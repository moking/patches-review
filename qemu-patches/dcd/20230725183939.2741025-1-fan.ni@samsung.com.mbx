From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 05CC7C001DE
	for <linux-cxl@archiver.kernel.org>; Tue, 25 Jul 2023 18:40:03 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S231808AbjGYSkB (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 25 Jul 2023 14:40:01 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:44740 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S231671AbjGYSkA (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 25 Jul 2023 14:40:00 -0400
Received: from mailout2.w2.samsung.com (mailout2.w2.samsung.com [211.189.100.12])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 812862116
        for <linux-cxl@vger.kernel.org>; Tue, 25 Jul 2023 11:39:58 -0700 (PDT)
Received: from uscas1p1.samsung.com (unknown [182.198.245.206])
        by mailout2.w2.samsung.com (KnoxPortal) with ESMTP id 20230725183957usoutp02992d3e7833220993797a76ffc7065698~1MFm_HMsM1493214932usoutp02K;
        Tue, 25 Jul 2023 18:39:57 +0000 (GMT)
DKIM-Filter: OpenDKIM Filter v2.11.0 mailout2.w2.samsung.com 20230725183957usoutp02992d3e7833220993797a76ffc7065698~1MFm_HMsM1493214932usoutp02K
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=samsung.com;
        s=mail20170921; t=1690310397;
        bh=C4aTzaNtGHKVgJ50XEww+sc4KO9zZq8bdfgSZbWIqXU=;
        h=From:To:CC:Subject:Date:In-Reply-To:References:From;
        b=qCWsGCcCps00iBHu+0uDI7lp9CdENBOf54X8Vz3bjQZSrZQzzjyAto1JA2TwPYKKt
         J3KcB84On9U6sm1lHeW0v7cNxQwWiXikUom5fMb1vx3YCT8TFWCqsOkSUSEqVoot0E
         tf13H0UoEOkq/ydkVWt/lTRULvt5B7BeecwnQiv0=
Received: from ussmges3new.samsung.com (u112.gpu85.samsung.co.kr
        [203.254.195.112]) by uscas1p2.samsung.com (KnoxPortal) with ESMTP id
        20230725183957uscas1p24667bdb00d268b3f78f7e2be57002365~1MFm2bFYY1972119721uscas1p2r;
        Tue, 25 Jul 2023 18:39:57 +0000 (GMT)
Received: from uscas1p2.samsung.com ( [182.198.245.207]) by
        ussmges3new.samsung.com (USCPEMTA) with SMTP id C7.4E.62237.CF610C46; Tue,
        25 Jul 2023 14:39:56 -0400 (EDT)
Received: from ussmgxs2new.samsung.com (u91.gpu85.samsung.co.kr
        [203.254.195.91]) by uscas1p1.samsung.com (KnoxPortal) with ESMTP id
        20230725183956uscas1p17a64ec512cdf5b9348451926d6f0b224~1MFmdxFht0903609036uscas1p1u;
        Tue, 25 Jul 2023 18:39:56 +0000 (GMT)
X-AuditID: cbfec370-823ff7000001f31d-90-64c016fc8161
Received: from SSI-EX1.ssi.samsung.com ( [105.128.2.145]) by
        ussmgxs2new.samsung.com (USCPEXMTA) with SMTP id A3.83.44215.CF610C46; Tue,
        25 Jul 2023 14:39:56 -0400 (EDT)
Received: from SSI-EX2.ssi.samsung.com (105.128.2.227) by
        SSI-EX1.ssi.samsung.com (105.128.2.226) with Microsoft SMTP Server
        (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384) id
        15.1.2375.24; Tue, 25 Jul 2023 11:39:55 -0700
Received: from SSI-EX2.ssi.samsung.com ([105.128.2.227]) by
        SSI-EX2.ssi.samsung.com ([105.128.2.227]) with mapi id 15.01.2375.024; Tue,
        25 Jul 2023 11:39:55 -0700
From: Fan Ni <fan.ni@samsung.com>
To: "qemu-devel@nongnu.org" <qemu-devel@nongnu.org>
CC: "jonathan.cameron@huawei.com" <jonathan.cameron@huawei.com>,
        "linux-cxl@vger.kernel.org" <linux-cxl@vger.kernel.org>,
        "gregory.price@memverge.com" <gregory.price@memverge.com>,
        "hchkuo@avery-design.com.tw" <hchkuo@avery-design.com.tw>,
        "cbrowy@avery-design.com" <cbrowy@avery-design.com>,
        "ira.weiny@intel.com" <ira.weiny@intel.com>,
        "dan.j.williams@intel.com" <dan.j.williams@intel.com>,
        Adam Manzanares <a.manzanares@samsung.com>,
        "dave@stgolabs.net" <dave@stgolabs.net>,
        "nmtadam.samsung@gmail.com" <nmtadam.samsung@gmail.com>,
        "nifan@outlook.com" <nifan@outlook.com>,
        Fan Ni <fan.ni@samsung.com>
Subject: [Qemu PATCH v2 1/9] hw/cxl/cxl-mailbox-utils: Add dc_event_log_size
 field to output payload of identify memory device command
Thread-Topic: [Qemu PATCH v2 1/9] hw/cxl/cxl-mailbox-utils: Add
        dc_event_log_size field to output payload of identify memory device command
Thread-Index: AQHZvydoRKWfeAB5G06EOZO9oxzjmQ==
Date: Tue, 25 Jul 2023 18:39:55 +0000
Message-ID: <20230725183939.2741025-2-fan.ni@samsung.com>
In-Reply-To: <20230725183939.2741025-1-fan.ni@samsung.com>
Accept-Language: en-US
Content-Language: en-US
X-MS-Has-Attach: 
X-MS-TNEF-Correlator: 
x-mailer: git-send-email 2.25.1
x-originating-ip: [105.128.2.176]
Content-Type: text/plain; charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable
MIME-Version: 1.0
X-CFilter-Loop: Reflected
X-Brightmail-Tracker: H4sIAAAAAAAAA+NgFjrLKsWRmVeSWpSXmKPExsWy7djX87p/xA6kGCzbbWHRfX4Do8X0qRcY
        LVbfXMNo0dD0iMWiZfd7Jov9T5+zWKxaeI3N4vysUywWzyc+Z7JYuuQRs8Xx3h0sDtweFyZP
        YPVY3ODqsXPWXXaPliNvgbw9L5k8Nn78z+7x5NpmJo/Nr18we0ydXe/xeZNcAFcUl01Kak5m
        WWqRvl0CV8b6Q7sYC27zVvT92s/ewNjL3cXIySEhYCKxY1kHaxcjF4eQwEpGiaX3prNDOK1M
        ElNb/rLBVE18P4MdxBYSWMsoMWlWFETRJ0aJrjN/WSCcZYwSra2nWUGq2AQUJfZ1bQfrFhEw
        ljh2eAkzSBGzwFsWiY9r3oB1CAt0MEoce/MVLCMi0MsosXDWG2aIFj2JeVPXs4DYLAKqEh0r
        dzCB2LwClhK/z20GO4RTwEri2ZfZYOsYBcQkvp9aA1bDLCAucevJfCaIwwUlFs3ewwxhi0n8
        2/UQ6iF5ick/ZkDZihL3v79kh+jVk7gxdQobhK0tsWzha2aIvYISJ2c+YYGol5Q4uOIG2AcS
        AtM5JSY2/INa5iLRsegJI4QtLfH37jKgOAeQnSyx6iMXRDhHYv6SLVBzrCUW/lnPNIFRZRaS
        s2chOWMWkjNmITljASPLKkbx0uLi3PTUYuO81HK94sTc4tK8dL3k/NxNjMAUd/rf4YIdjLdu
        fdQ7xMjEwXiIUYKDWUmE1zBmX4oQb0piZVVqUX58UWlOavEhRmkOFiVxXkPbk8lCAumJJanZ
        qakFqUUwWSYOTqkGpqztsjPeZs1jVxCcpT/rzYzqzzc1HJodBVX2nlhnVRC0LfNyWVlZ18QA
        m5//fHUqmF0ObIxs9/bcJfXt3OkVSn8+ndLPiJcU5j3ZKebaemNr5tZJlvNW9rSsNfB0ncma
        9OXpfRlX1rdZhVwB1+d67E9cvW/xxm1lqwQdWPMOhC6fMPeLNwvbi9qImZPOXNx9rejAgYQJ
        1Q2ykb3tIa4ZtwL1F4lZ87H/O8B4ub1tpuQ57wafOX9XbxTq3B931XaGkPDbkNtMbadll/ml
        VrR23vZ9/GB64TxTFvFfp7lTXT1En/8WSvb0Z7e9sG/K+oLlZ1NO+iwvv7NqJn/czlof+Ssh
        bv78/0x7+LpLPv9+pcRSnJFoqMVcVJwIAEdHWNPgAwAA
X-Brightmail-Tracker: H4sIAAAAAAAAA+NgFnrJIsWRmVeSWpSXmKPExsWS2cA0UfeP2IEUg+nPZC26z29gtJg+9QKj
        xeqbaxgtGpoesVi07H7PZLH/6XMWi1ULr7FZnJ91isXi+cTnTBZLlzxitjjeu4PFgdvjwuQJ
        rB6LG1w9ds66y+7RcuQtkLfnJZPHxo//2T2eXNvM5LH59Qtmj6mz6z0+b5IL4IrisklJzcks
        Sy3St0vgylh/aBdjwW3eir5f+9kbGHu5uxg5OSQETCQmvp/B3sXIxSEksJpRou/vcijnE6PE
        9fM/mCGcZYwSiw8vYAdpYRNQlNjXtZ0NxBYRMJY4dngJM4jNLPCaReLbRW6QBmGBDkaJY2++
        MkMU9TJKNF4whbD1JOZNXc8CYrMIqEp0rNzBBGLzClhK/D63GWgBB9A2S4mtE+NAwpwCVhLP
        vsxmBbEZBcQkvp9awwSxS1zi1pP5TBAvCEgs2XOeGcIWlXj5+B8rhC0vMfnHDDYIW1Hi/veX
        7BC9ehI3pk5hg7C1JZYtfM0McYKgxMmZT1gg6iUlDq64wTKBUWIWknWzkLTPQtI+C0n7AkaW
        VYzipcXFuekVxUZ5qeV6xYm5xaV56XrJ+bmbGIGp4fS/w9E7GG/f+qh3iJGJg/EQowQHs5II
        r2HMvhQh3pTEyqrUovz4otKc1OJDjNIcLErivC+jJsYLCaQnlqRmp6YWpBbBZJk4OKUamHgm
        fd9z7/+NZcxrfwSsNd3eorZ9gessoW8SHK0vG6LnzbUWFtlu7nPWS1cs4Mj60/cz3/c5zPVr
        OhRteXmPs9L+7Q4aUd6T01bNm5OfupLNOIBxS/yau44TBcxVAmdViaZyrbGYxu//rYv74J1b
        jHHc37gyK3QmGC+dnlBw6fWcrcbX/3X1z3mq5SAU9oSlveF8Q81Xs5fZl+c46l6tY42ecPPG
        5kl+/w7PvdEVs+dP8dqS571XnYw2eUpOyVu+8zbvJO9+o6Zpl4w39Fjvf2Nvynnsw5zlE/zZ
        N1Qddym+N6cm6emWF+afrvpdlPHSLEgz8k6TO2C06RWH2Y/vLrbla18d+XVJznpdoti+3f+U
        WIozEg21mIuKEwF9Cw0WfAMAAA==
X-CMS-MailID: 20230725183956uscas1p17a64ec512cdf5b9348451926d6f0b224
CMS-TYPE: 301P
X-CMS-RootMailID: 20230725183956uscas1p17a64ec512cdf5b9348451926d6f0b224
References: <20230725183939.2741025-1-fan.ni@samsung.com>
        <CGME20230725183956uscas1p17a64ec512cdf5b9348451926d6f0b224@uscas1p1.samsung.com>
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

From: Fan Ni <nifan@outlook.com>

Based on CXL spec 3.0 Table 8-94 (Identify Memory Device Output
Payload), dynamic capacity event log size should be part of
output of the Identify command.
Add dc_event_log_size to the output payload for the host to get the info.

Signed-off-by: Fan Ni <fan.ni@samsung.com>
---
 hw/cxl/cxl-mailbox-utils.c | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/hw/cxl/cxl-mailbox-utils.c b/hw/cxl/cxl-mailbox-utils.c
index ad7a6116e4..b013e30314 100644
--- a/hw/cxl/cxl-mailbox-utils.c
+++ b/hw/cxl/cxl-mailbox-utils.c
@@ -21,6 +21,8 @@
 #include "sysemu/hostmem.h"
=20
 #define CXL_CAPACITY_MULTIPLIER   (256 * MiB)
+/* Experimental value: dynamic capacity event log size */
+#define CXL_DC_EVENT_LOG_SIZE 8
=20
 /*
  * How to add a new command, example. The command set FOO, with cmd BAR.
@@ -519,8 +521,9 @@ static CXLRetCode cmd_identify_memory_device(struct cxl=
_cmd *cmd,
         uint16_t inject_poison_limit;
         uint8_t poison_caps;
         uint8_t qos_telemetry_caps;
+        uint16_t dc_event_log_size;
     } QEMU_PACKED *id;
-    QEMU_BUILD_BUG_ON(sizeof(*id) !=3D 0x43);
+    QEMU_BUILD_BUG_ON(sizeof(*id) !=3D 0x45);
=20
     CXLType3Dev *ct3d =3D container_of(cxl_dstate, CXLType3Dev, cxl_dstate=
);
     CXLType3Class *cvc =3D CXL_TYPE3_GET_CLASS(ct3d);
@@ -543,6 +546,7 @@ static CXLRetCode cmd_identify_memory_device(struct cxl=
_cmd *cmd,
     st24_le_p(id->poison_list_max_mer, 256);
     /* No limit - so limited by main poison record limit */
     stw_le_p(&id->inject_poison_limit, 0);
+    stw_le_p(&id->dc_event_log_size, CXL_DC_EVENT_LOG_SIZE);
=20
     *len =3D sizeof(*id);
     return CXL_MBOX_SUCCESS;
--=20
2.25.1

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 2E904C001DF
	for <linux-cxl@archiver.kernel.org>; Tue, 25 Jul 2023 18:40:04 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S231671AbjGYSkD (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 25 Jul 2023 14:40:03 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:44738 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S231691AbjGYSkA (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 25 Jul 2023 14:40:00 -0400
Received: from mailout2.w2.samsung.com (mailout2.w2.samsung.com [211.189.100.12])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 8097319BD
        for <linux-cxl@vger.kernel.org>; Tue, 25 Jul 2023 11:39:58 -0700 (PDT)
Received: from uscas1p1.samsung.com (unknown [182.198.245.206])
        by mailout2.w2.samsung.com (KnoxPortal) with ESMTP id 20230725183957usoutp027b4de56e6490a6180a47d3fd2584a026~1MFndHyew1430014300usoutp02k;
        Tue, 25 Jul 2023 18:39:57 +0000 (GMT)
DKIM-Filter: OpenDKIM Filter v2.11.0 mailout2.w2.samsung.com 20230725183957usoutp027b4de56e6490a6180a47d3fd2584a026~1MFndHyew1430014300usoutp02k
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=samsung.com;
        s=mail20170921; t=1690310397;
        bh=lBr/qyVNRvXVjZ/owLK3vUCLHdyi81JwmP39aawYy7E=;
        h=From:To:CC:Subject:Date:In-Reply-To:References:From;
        b=g4EYZf8CQj9bQ2nGOjltiuK92Sjs67JyCHJyajbJI+/ncJtzn1eHgAwTLw6GTUSuk
         uVfq64DdH3+6SVeBaFvYY6jzGqyZKLR8suC7qvquECxh598J8e/M8ze6DE6uvCRemB
         XipR+6tFKoyIa854tVJcsOKRa0MaI5CWZrdfg1mo=
Received: from ussmges1new.samsung.com (u109.gpu85.samsung.co.kr
        [203.254.195.109]) by uscas1p1.samsung.com (KnoxPortal) with ESMTP id
        20230725183957uscas1p19e9491c5c92badc2d2c8ffd5c5996421~1MFnUl-l00901509015uscas1p1g;
        Tue, 25 Jul 2023 18:39:57 +0000 (GMT)
Received: from uscas1p1.samsung.com ( [182.198.245.206]) by
        ussmges1new.samsung.com (USCPEMTA) with SMTP id 13.DD.51475.DF610C46; Tue,
        25 Jul 2023 14:39:57 -0400 (EDT)
Received: from ussmgxs1new.samsung.com (u89.gpu85.samsung.co.kr
        [203.254.195.89]) by uscas1p2.samsung.com (KnoxPortal) with ESMTP id
        20230725183957uscas1p28b38d294f90b97f99769466cc533b4de~1MFm_jFbK0167001670uscas1p2k;
        Tue, 25 Jul 2023 18:39:57 +0000 (GMT)
X-AuditID: cbfec36d-8a3ff7000001c913-42-64c016fd02fb
Received: from SSI-EX2.ssi.samsung.com ( [105.128.2.145]) by
        ussmgxs1new.samsung.com (USCPEXMTA) with SMTP id A3.54.38326.CF610C46; Tue,
        25 Jul 2023 14:39:57 -0400 (EDT)
Received: from SSI-EX2.ssi.samsung.com (105.128.2.227) by
        SSI-EX2.ssi.samsung.com (105.128.2.227) with Microsoft SMTP Server
        (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384) id
        15.1.2375.24; Tue, 25 Jul 2023 11:39:56 -0700
Received: from SSI-EX2.ssi.samsung.com ([105.128.2.227]) by
        SSI-EX2.ssi.samsung.com ([105.128.2.227]) with mapi id 15.01.2375.024; Tue,
        25 Jul 2023 11:39:56 -0700
From: Fan Ni <fan.ni@samsung.com>
To: "qemu-devel@nongnu.org" <qemu-devel@nongnu.org>
CC: "jonathan.cameron@huawei.com" <jonathan.cameron@huawei.com>,
        "linux-cxl@vger.kernel.org" <linux-cxl@vger.kernel.org>,
        "gregory.price@memverge.com" <gregory.price@memverge.com>,
        "hchkuo@avery-design.com.tw" <hchkuo@avery-design.com.tw>,
        "cbrowy@avery-design.com" <cbrowy@avery-design.com>,
        "ira.weiny@intel.com" <ira.weiny@intel.com>,
        "dan.j.williams@intel.com" <dan.j.williams@intel.com>,
        Adam Manzanares <a.manzanares@samsung.com>,
        "dave@stgolabs.net" <dave@stgolabs.net>,
        "nmtadam.samsung@gmail.com" <nmtadam.samsung@gmail.com>,
        "nifan@outlook.com" <nifan@outlook.com>,
        Fan Ni <fan.ni@samsung.com>
Subject: [Qemu PATCH v2 6/9] hw/mem/cxl_type3: Add DC extent list
 representative and get DC extent list mailbox support
Thread-Topic: [Qemu PATCH v2 6/9] hw/mem/cxl_type3: Add DC extent list
        representative and get DC extent list mailbox support
Thread-Index: AQHZvydobNJU5Smx1kW/FPcC4N6b9Q==
Date: Tue, 25 Jul 2023 18:39:56 +0000
Message-ID: <20230725183939.2741025-7-fan.ni@samsung.com>
In-Reply-To: <20230725183939.2741025-1-fan.ni@samsung.com>
Accept-Language: en-US
Content-Language: en-US
X-MS-Has-Attach: 
X-MS-TNEF-Correlator: 
x-mailer: git-send-email 2.25.1
x-originating-ip: [105.128.2.176]
Content-Type: text/plain; charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable
MIME-Version: 1.0
X-CFilter-Loop: Reflected
X-Brightmail-Tracker: H4sIAAAAAAAAA+NgFjrJKsWRmVeSWpSXmKPExsWy7djXc7p/xQ6kGGzdI2XRfX4Do8X0qRcY
        LVbfXMNo0dD0iMWiZfd7Jov9T5+zWKxaeI3N4vysUywWzyc+Z7JYuuQRs8Xx3h0sDtweFyZP
        YPVY3ODqsXPWXXaPliNvgbw9L5k8Nn78z+7x5NpmJo/Nr18we0ydXe/xeZNcAFcUl01Kak5m
        WWqRvl0CV0bD4/iCz1oV794fZWlgfKfQxcjJISFgItG19TNLFyMXh5DASkaJqZeWsEI4rUwS
        K99MBcpwgFW9nC0JEV/LKNF/cAkjhPOJUaLh9QMmCGcZo8Sb9l/MIHPZBBQl9nVtZwOxRQSM
        JY4dXsIMUsQs8JZF4uOaNywgCWGBSolDZ54yQRTVSVzt3cwIsk5EQE/i83kvkDCLgKrEjSNH
        GEFsXgFLic2LHoLN5xSwknj2ZTYriM0oICbx/dQasDHMAuISt57MZ4L4TVBi0ew9zBC2mMS/
        XQ/ZIGx5ick/ZkDZihL3v79kh+jVk7gxdQobhK0tsWzha2aIvYISJ2c+YYGol5Q4uOIGOLwk
        BKZzSjz9s48VIuEicX33GXYIW1ri6vWpzJCgS5ZY9ZELIpwjMX/JFqg51hIL/6xnmsCoMgvJ
        2bOQnDELyRmzkJyxgJFlFaN4aXFxbnpqsWFearlecWJucWleul5yfu4mRmBqO/3vcO4Oxh23
        PuodYmTiYDzEKMHBrCTCaxizL0WINyWxsiq1KD++qDQntfgQozQHi5I4r6HtyWQhgfTEktTs
        1NSC1CKYLBMHp1QD0wru4rDgB9tcD+841dp0bHrHIR2LpX+i2x4oblNetsPgzlbrpxPXPfu0
        Nf5NqFb5LQkP949Mv7yeMTd7Ovy10/tc9DJDbZG+00YPwyWeFx9XZqpcdXRpcuyrmJhw0GYX
        /zPrl50J6+N2HzjvNUfe+XGeyf9/M1b+iAhX80v+e1R0No/R3/m9du9Wmz9tNTT/s/z4uneH
        l/+yLJkrHKr7UDzAV2xFbdF95eVbl/w5Gp93ZY+zYuHSX22LN31haf77c8o67fnlNw7e4zgj
        O2v7pKSdBYeX3HFTOWCslu8ddaSQOaEhW45f5orODJu0tdudDkSqJE7S1f354dHXPbtbTaa0
        PdzQxTytWtnNyoRtjbYSS3FGoqEWc1FxIgCLUL5n3AMAAA==
X-Brightmail-Tracker: H4sIAAAAAAAAA02Se0hTYRjG+845Ho8T47Q0Pwu7DCq0Wo0sjiVhLOtYRhcCK0odeZoznWtH
        S4Ny1BCaWC5b1kRMnRZqWNrFzOu8rLw0s4tmSV62qUh5JRMzcx0C//s97/c87/P98RIo34ot
        J2TyWEYpl0QJcB4mUyHaTbPLasK3NJQiVLL5MaDSdW2AKvxcBCjV1T6MUr8aQahq6wBGFWR/
        wimzvgmjBrQDCJVn6EMpU0oZ5u9Mt6WlOtC5qgD6pb7bkVbXf59XFUMI/WRszpG2fCpF6NLh
        QZTWZSTSEyUrD/NO8vzCmSjZBUa5eVcYL0LVH6qY8I7/MdKAqcCP1RpAEJD0gUMZHhrAI/hk
        IYAPk+pwTowDmJTTjHIiH8Cs3EKgAU4ETq6BVZoXuJ1dya2wsc6A2hklhzH4852znZeSCdDY
        YkU4zxXYUdaI29tcSSGcMO+3jzFyLeysr/+30oX0haU5vajdwp/nZ9oQ+9iJ3AFtkxkOdgbk
        MjjVVIRwTe6wy5L1jyFJQkOFGeXYDQ71/3HgeBVM+3UX53gN/DY15MhlhbBTdxvneAPMzx5G
        uS8sgW/uWTDO7wFrH3ZiqQDqF9TpF8T1C+L6BfH7ACsA7nEsGy2NZ0Vy5qKQlUSzcXKp8ExM
        dAmYv4TmP3UnykBD15jQCBACGAEkUIGri+hUVTjfJVyScIlRxoQq46IY1ghWEJjA3YUfoA3l
        k1JJLHOOYRSM8v8rQjgtVyFwfaS3ZK5GIZ6LMbUqrIK3vq+vzXpaieKdjY7be9JL8kKCtp35
        6h/YU7X1dJLJ9mS38nNN+7EJdWumwuvm8yO5MnG8jRgvPho29qDNz1/aP/p4z9GCtGHPaXxy
        ClSVewUY2xUGdU/Jtpabi6RZeyvLT91LPGjyyxWd7S4u/3jnwHlxgGJgbZh544dxTXp+h0+K
        4Xp1YrvJMGsZGSW8+bKOjmA+LC7MieiTB/amVT71lIQS/Xcd9tmmL8cFqwOdT67LVuuTMw+J
        E48v1qXagr6II5nf2ket21NnvJpdsd9eg6o8UZNFHfECcXvuo/mY0pV8f6Y89tYoXXuD1c28
        F2BshETkjSpZyV/wthbdeAMAAA==
X-CMS-MailID: 20230725183957uscas1p28b38d294f90b97f99769466cc533b4de
CMS-TYPE: 301P
X-CMS-RootMailID: 20230725183957uscas1p28b38d294f90b97f99769466cc533b4de
References: <20230725183939.2741025-1-fan.ni@samsung.com>
        <CGME20230725183957uscas1p28b38d294f90b97f99769466cc533b4de@uscas1p2.samsung.com>
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

From: Fan Ni <nifan@outlook.com>

Add dynamic capacity extent list representative to the definition of
CXLType3Dev and add get DC extent list mailbox command per
CXL.spec.3.0:.8.2.9.8.9.2.

Signed-off-by: Fan Ni <fan.ni@samsung.com>
---
 hw/cxl/cxl-mailbox-utils.c  | 71 +++++++++++++++++++++++++++++++++++++
 hw/mem/cxl_type3.c          |  1 +
 include/hw/cxl/cxl_device.h | 23 ++++++++++++
 3 files changed, 95 insertions(+)

diff --git a/hw/cxl/cxl-mailbox-utils.c b/hw/cxl/cxl-mailbox-utils.c
index 0511b8e6f7..3d25a9697e 100644
--- a/hw/cxl/cxl-mailbox-utils.c
+++ b/hw/cxl/cxl-mailbox-utils.c
@@ -83,6 +83,7 @@ enum {
         #define CLEAR_POISON           0x2
     DCD_CONFIG  =3D 0x48, /*r3.0: 8.2.9.8.9*/
         #define GET_DC_CONFIG          0x0
+        #define GET_DYN_CAP_EXT_LIST   0x1
     PHYSICAL_SWITCH =3D 0x51
         #define IDENTIFY_SWITCH_DEVICE      0x0
 };
@@ -1018,6 +1019,73 @@ static CXLRetCode cmd_dcd_get_dyn_cap_config(struct =
cxl_cmd *cmd,
     return CXL_MBOX_SUCCESS;
 }
=20
+/*
+ * cxl spec 3.0: 8.2.9.8.9.2
+ * Get Dynamic Capacity Extent List (Opcode 4810h)
+ */
+static CXLRetCode cmd_dcd_get_dyn_cap_ext_list(struct cxl_cmd *cmd,
+        CXLDeviceState *cxl_dstate,
+        uint16_t *len)
+{
+    struct get_dyn_cap_ext_list_in_pl {
+        uint32_t extent_cnt;
+        uint32_t start_extent_id;
+    } QEMU_PACKED;
+
+    struct get_dyn_cap_ext_list_out_pl {
+        uint32_t count;
+        uint32_t total_extents;
+        uint32_t generation_num;
+        uint8_t rsvd[4];
+        CXLDCExtent_raw records[];
+    } QEMU_PACKED;
+
+    struct get_dyn_cap_ext_list_in_pl *in =3D (void *)cmd->payload;
+    struct get_dyn_cap_ext_list_out_pl *out =3D (void *)cmd->payload;
+    struct CXLType3Dev *ct3d =3D container_of(cxl_dstate, CXLType3Dev,
+            cxl_dstate);
+    uint16_t record_count =3D 0, i =3D 0, record_done =3D 0;
+    CXLDCDExtentList *extent_list =3D &ct3d->dc.extents;
+    CXLDCD_Extent *ent;
+    uint16_t out_pl_len;
+    uint32_t start_extent_id =3D in->start_extent_id;
+
+    if (start_extent_id > ct3d->dc.total_extent_count) {
+        return CXL_MBOX_INVALID_INPUT;
+    }
+
+    record_count =3D MIN(in->extent_cnt,
+            ct3d->dc.total_extent_count - start_extent_id);
+
+    out_pl_len =3D sizeof(*out) + record_count * sizeof(out->records[0]);
+    /* May need more processing here in the future */
+    assert(out_pl_len <=3D CXL_MAILBOX_MAX_PAYLOAD_SIZE);
+
+    memset(out, 0, out_pl_len);
+    stl_le_p(&out->count, record_count);
+    stl_le_p(&out->total_extents, ct3d->dc.total_extent_count);
+    stl_le_p(&out->generation_num, ct3d->dc.ext_list_gen_seq);
+
+    if (record_count > 0) {
+        QTAILQ_FOREACH(ent, extent_list, node) {
+            if (i++ < start_extent_id) {
+                continue;
+            }
+            stq_le_p(&out->records[record_done].start_dpa, ent->start_dpa)=
;
+            stq_le_p(&out->records[record_done].len, ent->len);
+            memcpy(&out->records[record_done].tag, ent->tag, 0x10);
+            stw_le_p(&out->records[record_done].shared_seq, ent->shared_se=
q);
+            record_done++;
+            if (record_done =3D=3D record_count) {
+                break;
+            }
+        }
+    }
+
+    *len =3D out_pl_len;
+    return CXL_MBOX_SUCCESS;
+}
+
 #define IMMEDIATE_CONFIG_CHANGE (1 << 1)
 #define IMMEDIATE_DATA_CHANGE (1 << 2)
 #define IMMEDIATE_POLICY_CHANGE (1 << 3)
@@ -1058,6 +1126,9 @@ static struct cxl_cmd cxl_cmd_set[256][256] =3D {
         cmd_media_clear_poison, 72, 0 },
     [DCD_CONFIG][GET_DC_CONFIG] =3D { "DCD_GET_DC_CONFIG",
         cmd_dcd_get_dyn_cap_config, 2, 0 },
+    [DCD_CONFIG][GET_DYN_CAP_EXT_LIST] =3D {
+        "DCD_GET_DYNAMIC_CAPACITY_EXTENT_LIST", cmd_dcd_get_dyn_cap_ext_li=
st,
+        8, 0 },
 };
=20
 static struct cxl_cmd cxl_cmd_set_sw[256][256] =3D {
diff --git a/hw/mem/cxl_type3.c b/hw/mem/cxl_type3.c
index 76bbd9f785..f1170b8047 100644
--- a/hw/mem/cxl_type3.c
+++ b/hw/mem/cxl_type3.c
@@ -789,6 +789,7 @@ static int cxl_create_dc_regions(CXLType3Dev *ct3d)
=20
         region_base +=3D region->len;
     }
+    QTAILQ_INIT(&ct3d->dc.extents);
=20
     return 0;
 }
diff --git a/include/hw/cxl/cxl_device.h b/include/hw/cxl/cxl_device.h
index 1c99b05a66..3a338b3b37 100644
--- a/include/hw/cxl/cxl_device.h
+++ b/include/hw/cxl/cxl_device.h
@@ -385,6 +385,25 @@ typedef QLIST_HEAD(, CXLPoison) CXLPoisonList;
=20
 #define DCD_MAX_REGION_NUM 8
=20
+typedef struct CXLDCD_Extent_raw {
+    uint64_t start_dpa;
+    uint64_t len;
+    uint8_t tag[0x10];
+    uint16_t shared_seq;
+    uint8_t rsvd[0x6];
+} QEMU_PACKED CXLDCExtent_raw;
+
+typedef struct CXLDCD_Extent {
+    uint64_t start_dpa;
+    uint64_t len;
+    uint8_t tag[0x10];
+    uint16_t shared_seq;
+    uint8_t rsvd[0x6];
+
+    QTAILQ_ENTRY(CXLDCD_Extent) node;
+} CXLDCD_Extent;
+typedef QTAILQ_HEAD(, CXLDCD_Extent) CXLDCDExtentList;
+
 typedef struct CXLDCD_Region {
     uint64_t base;
     uint64_t decode_len; /* in multiples of 256MB */
@@ -433,6 +452,10 @@ struct CXLType3Dev {
=20
         uint8_t num_regions; /* 0-8 regions */
         struct CXLDCD_Region regions[DCD_MAX_REGION_NUM];
+        CXLDCDExtentList extents;
+
+        uint32_t total_extent_count;
+        uint32_t ext_list_gen_seq;
     } dc;
 };
=20
--=20
2.25.1

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 57101C04A6A
	for <linux-cxl@archiver.kernel.org>; Tue, 25 Jul 2023 18:40:05 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S231691AbjGYSkD (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 25 Jul 2023 14:40:03 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:44742 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S231698AbjGYSkA (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 25 Jul 2023 14:40:00 -0400
Received: from mailout2.w2.samsung.com (mailout2.w2.samsung.com [211.189.100.12])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 811881FD2
        for <linux-cxl@vger.kernel.org>; Tue, 25 Jul 2023 11:39:58 -0700 (PDT)
Received: from uscas1p2.samsung.com (unknown [182.198.245.207])
        by mailout2.w2.samsung.com (KnoxPortal) with ESMTP id 20230725183957usoutp02b24c4a556f889ae031c04ff97bc50505~1MFm8ztg41412514125usoutp02g;
        Tue, 25 Jul 2023 18:39:57 +0000 (GMT)
DKIM-Filter: OpenDKIM Filter v2.11.0 mailout2.w2.samsung.com 20230725183957usoutp02b24c4a556f889ae031c04ff97bc50505~1MFm8ztg41412514125usoutp02g
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=samsung.com;
        s=mail20170921; t=1690310397;
        bh=ZRlzd8c3g2KsOYA3+M84nuNHo77atunwbmjFOddYgGk=;
        h=From:To:CC:Subject:Date:In-Reply-To:References:From;
        b=KKcOQYCq6PZhL5kUA+eItmSciDQmMebDT5+KSUYYQX/DvD0dyWNq8rFbL3s5hsf9I
         4N981wONc2a+zsjuwqad0oP0cRgUfZH+nzBogXx7+jnEz24ZJ5iUoWLf2hNuYYlMpi
         FC49pYlQsXO5hXc9Xe9xYYSor+IQs72IFhknvS9I=
Received: from ussmges3new.samsung.com (u112.gpu85.samsung.co.kr
        [203.254.195.112]) by uscas1p2.samsung.com (KnoxPortal) with ESMTP id
        20230725183956uscas1p2b3d33248e5971edd48e1fcad422a4b6c~1MFmz5tqs0167001670uscas1p2i;
        Tue, 25 Jul 2023 18:39:56 +0000 (GMT)
Received: from uscas1p1.samsung.com ( [182.198.245.206]) by
        ussmges3new.samsung.com (USCPEMTA) with SMTP id B7.4E.62237.CF610C46; Tue,
        25 Jul 2023 14:39:56 -0400 (EDT)
Received: from ussmgxs3new.samsung.com (u92.gpu85.samsung.co.kr
        [203.254.195.92]) by uscas1p2.samsung.com (KnoxPortal) with ESMTP id
        20230725183956uscas1p296403063c710f4b546d4fec7650915c4~1MFmgQ-Q62755227552uscas1p2B;
        Tue, 25 Jul 2023 18:39:56 +0000 (GMT)
X-AuditID: cbfec370-b17ff7000001f31d-8f-64c016fc55dc
Received: from SSI-EX3.ssi.samsung.com ( [105.128.2.146]) by
        ussmgxs3new.samsung.com (USCPEXMTA) with SMTP id 08.DA.64580.CF610C46; Tue,
        25 Jul 2023 14:39:56 -0400 (EDT)
Received: from SSI-EX2.ssi.samsung.com (105.128.2.227) by
        SSI-EX3.ssi.samsung.com (105.128.2.228) with Microsoft SMTP Server
        (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384) id
        15.1.2375.24; Tue, 25 Jul 2023 11:39:55 -0700
Received: from SSI-EX2.ssi.samsung.com ([105.128.2.227]) by
        SSI-EX2.ssi.samsung.com ([105.128.2.227]) with mapi id 15.01.2375.024; Tue,
        25 Jul 2023 11:39:55 -0700
From: Fan Ni <fan.ni@samsung.com>
To: "qemu-devel@nongnu.org" <qemu-devel@nongnu.org>
CC: "jonathan.cameron@huawei.com" <jonathan.cameron@huawei.com>,
        "linux-cxl@vger.kernel.org" <linux-cxl@vger.kernel.org>,
        "gregory.price@memverge.com" <gregory.price@memverge.com>,
        "hchkuo@avery-design.com.tw" <hchkuo@avery-design.com.tw>,
        "cbrowy@avery-design.com" <cbrowy@avery-design.com>,
        "ira.weiny@intel.com" <ira.weiny@intel.com>,
        "dan.j.williams@intel.com" <dan.j.williams@intel.com>,
        Adam Manzanares <a.manzanares@samsung.com>,
        "dave@stgolabs.net" <dave@stgolabs.net>,
        "nmtadam.samsung@gmail.com" <nmtadam.samsung@gmail.com>,
        "nifan@outlook.com" <nifan@outlook.com>,
        Fan Ni <fan.ni@samsung.com>
Subject: [Qemu PATCH v2 2/9] hw/cxl/cxl-mailbox-utils: Add dynamic capacity
 region representative and mailbox command support
Thread-Topic: [Qemu PATCH v2 2/9] hw/cxl/cxl-mailbox-utils: Add dynamic
        capacity region representative and mailbox command support
Thread-Index: AQHZvydoz7fRgsZIjkm5D4vXR5iWWg==
Date: Tue, 25 Jul 2023 18:39:55 +0000
Message-ID: <20230725183939.2741025-3-fan.ni@samsung.com>
In-Reply-To: <20230725183939.2741025-1-fan.ni@samsung.com>
Accept-Language: en-US
Content-Language: en-US
X-MS-Has-Attach: 
X-MS-TNEF-Correlator: 
x-mailer: git-send-email 2.25.1
x-originating-ip: [105.128.2.176]
Content-Type: text/plain; charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable
MIME-Version: 1.0
X-CFilter-Loop: Reflected
X-Brightmail-Tracker: H4sIAAAAAAAAA+NgFjrLKsWRmVeSWpSXmKPExsWy7djXc7p/xA6kGEz8ZmbRfX4Do8X0qRcY
        LVbfXMNo0dD0iMWiZfd7Jov9T5+zWKxaeI3N4vysUywWzyc+Z7JYuuQRs8Xx3h0sDtweFyZP
        YPVY3ODqsXPWXXaPliNvgbw9L5k8Nn78z+7x5NpmJo/Nr18we0ydXe/xeZNcAFcUl01Kak5m
        WWqRvl0CV8ar1XPYCnYbVSyYtZ+pgXGuWhcjJ4eEgIlE17ONrF2MXBxCAisZJfbdWM4I4bQy
        SZy5tZAJpmrC+RksEIm1jBJ/H/5ngnA+MUrM+7cTylnGKNHaepoVpIVNQFFiX9d2NhBbRMBY
        4tjhJcwgRcwCb1kkPq55wwKSEBaol2h89hWsW0SghVGi4/0fRogOPYmV8/eDFbEIqEp0rNwB
        dgivgKXE1I7LYDWcAlYSz77MBtvGKCAm8f3UGrAaZgFxiVtP5kMdLiixaPYeZghbTOLfrods
        ELa8xOQfM6BsRYn731+yQ/TqSdyYOoUNwtaWWLbwNTPEXkGJkzOfsEDUS0ocXHEDHBgSAtM5
        Jaas2cwIkXCR+N7dBLVYWmL6mstARRxAdrLEqo9cEOEciflLtkDNsZZY+Gc90wRGlVlIzp6F
        5IxZSM6YheSMBYwsqxjFS4uLc9NTi43zUsv1ihNzi0vz0vWS83M3MQJT3Ol/hwt2MN669VHv
        ECMTB+MhRgkOZiURXsOYfSlCvCmJlVWpRfnxRaU5qcWHGKU5WJTEeQ1tTyYLCaQnlqRmp6YW
        pBbBZJk4OKUamEx+nDv1gnvBR+W/PQK1zwzLbFnmplmGKH3o/ad/Vueu2KPYfX9XaywXL9yk
        EfP8xQIGhqAqRYGmgiyvnZO81gtsiwo558i8gK9Co3ez9sk3vFVKRzz6tt5LLfsdzHTpQPIU
        hWeVm2dYKOxXO6Fpz9N+VXlB+Hqv+M0Tn1nWrNpkkvHMOOjkkmzrb5r2k1++/H+Gc26NKO/v
        38bi//s14o5/4KqfuOx85C/+9QxvFshM3JFnsez1xXOCcxp+FGptN635LWl19tPfpS7iGWb3
        Q3Ii85PuSHRN0awTeigd4+spEJa4/cD0LfpWO5+uP7xr9US3DxqC/NYvPWe1frwz2Tj497PL
        V5i0v5w5u9Pl+jElluKMREMt5qLiRABR4GZy4AMAAA==
X-Brightmail-Tracker: H4sIAAAAAAAAA+NgFnrJIsWRmVeSWpSXmKPExsWS2cA0SfeP2IEUg+a98hbd5zcwWkyfeoHR
        YvXNNYwWDU2PWCxadr9nstj/9DmLxaqF19gszs86xWLxfOJzJoulSx4xWxzv3cHiwO1xYfIE
        Vo/FDa4eO2fdZfdoOfIWyNvzkslj48f/7B5Prm1m8tj8+gWzx9TZ9R6fN8kFcEVx2aSk5mSW
        pRbp2yVwZbxaPYetYLdRxYJZ+5kaGOeqdTFyckgImEhMOD+DpYuRi0NIYDWjROOmS0wQzidG
        iUv9DYwQzjJGicWHF7CDtLAJKErs69rOBmKLCBhLHDu8hBnEZhZ4zSLx7SI3iC0sUC/R+Owr
        2CQRgRZGiVfHJzBCNOhJrJy/nwXEZhFQlehYuYMJxOYVsJSY2nEZqIYDaJulxNaJcSBhTgEr
        iWdfZrOC2IwCYhLfT61hgtglLnHryXwmiBcEJJbsOc8MYYtKvHz8jxXClpeY/GMGG4StKHH/
        +0t2iF49iRtTp7BB2NoSyxa+ZoY4QVDi5MwnLBD1khIHV9xgmcAoMQvJullI2mchaZ+FpH0B
        I8sqRvHS4uLc9Ipi47zUcr3ixNzi0rx0veT83E2MwNRw+t/hmB2M92591DvEyMTBeIhRgoNZ
        SYTXMGZfihBvSmJlVWpRfnxRaU5q8SFGaQ4WJXFej9iJ8UIC6YklqdmpqQWpRTBZJg5OqQam
        CbcK4i8f8I/23rvTbZHKVg25yWziuX3aVevOf+6U5l4SOPGQpsHir5qnErJChUR8TQzLb8le
        SkpwPaQmNm2/V3KjwfPM2Bihcs2snL9e99otH897e/P05muHkg5Um625eKT0ghCT47R1LLXH
        fn1zeDH/3a7nK3PdzFbr959OC10dfnyP+6sIvaaAxZOVjSw3hj348b2vyDCl8dyfXUV5+oln
        9jbOmpP0MrX2S4xCy43DrSrp/Q/+d3r6Rc3+kS4p8KZeXvCgnKdKpqjpNaeKoxtSXXbY32w5
        ki11d+WHM5+eHmR6dmUnkyXHy8bg+F8uLxKCtijJOVmYfxcu5rRqFeouM/72fte1o4dfS55R
        YinOSDTUYi4qTgQAuFnZTHwDAAA=
X-CMS-MailID: 20230725183956uscas1p296403063c710f4b546d4fec7650915c4
CMS-TYPE: 301P
X-CMS-RootMailID: 20230725183956uscas1p296403063c710f4b546d4fec7650915c4
References: <20230725183939.2741025-1-fan.ni@samsung.com>
        <CGME20230725183956uscas1p296403063c710f4b546d4fec7650915c4@uscas1p2.samsung.com>
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

From: Fan Ni <nifan@outlook.com>

Per cxl spec 3.0, add dynamic capacity region representative based on
Table 8-126 and extend the cxl type3 device definition to include dc region
information. Also, based on info in 8.2.9.8.9.1, add 'Get Dynamic Capacity
Configuration' mailbox support.

Signed-off-by: Fan Ni <fan.ni@samsung.com>
---
 hw/cxl/cxl-mailbox-utils.c  | 72 +++++++++++++++++++++++++++++++++++++
 hw/mem/cxl_type3.c          |  6 ++++
 include/hw/cxl/cxl_device.h | 17 +++++++++
 3 files changed, 95 insertions(+)

diff --git a/hw/cxl/cxl-mailbox-utils.c b/hw/cxl/cxl-mailbox-utils.c
index b013e30314..0fe9f3eb5d 100644
--- a/hw/cxl/cxl-mailbox-utils.c
+++ b/hw/cxl/cxl-mailbox-utils.c
@@ -81,6 +81,8 @@ enum {
         #define GET_POISON_LIST        0x0
         #define INJECT_POISON          0x1
         #define CLEAR_POISON           0x2
+    DCD_CONFIG  =3D 0x48, /*r3.0: 8.2.9.8.9*/
+        #define GET_DC_CONFIG          0x0
     PHYSICAL_SWITCH =3D 0x51
         #define IDENTIFY_SWITCH_DEVICE      0x0
 };
@@ -939,6 +941,71 @@ static CXLRetCode cmd_media_clear_poison(struct cxl_cm=
d *cmd,
     return CXL_MBOX_SUCCESS;
 }
=20
+/*
+ * cxl spec 3.0: 8.2.9.8.9.1
+ * Get Dynamic Capacity Configuration
+ **/
+static CXLRetCode cmd_dcd_get_dyn_cap_config(struct cxl_cmd *cmd,
+        CXLDeviceState *cxl_dstate,
+        uint16_t *len)
+{
+    struct get_dyn_cap_config_in_pl {
+        uint8_t region_cnt;
+        uint8_t start_region_id;
+    } QEMU_PACKED;
+
+    struct get_dyn_cap_config_out_pl {
+        uint8_t num_regions;
+        uint8_t rsvd1[7];
+        struct {
+            uint64_t base;
+            uint64_t decode_len;
+            uint64_t region_len;
+            uint64_t block_size;
+            uint32_t dsmadhandle;
+            uint8_t flags;
+            uint8_t rsvd2[3];
+        } QEMU_PACKED records[];
+    } QEMU_PACKED;
+
+    struct get_dyn_cap_config_in_pl *in =3D (void *)cmd->payload;
+    struct get_dyn_cap_config_out_pl *out =3D (void *)cmd->payload;
+    struct CXLType3Dev *ct3d =3D container_of(cxl_dstate, CXLType3Dev,
+            cxl_dstate);
+    uint16_t record_count =3D 0, i;
+    uint16_t out_pl_len;
+    uint8_t start_region_id =3D in->start_region_id;
+
+    if (start_region_id >=3D ct3d->dc.num_regions) {
+        return CXL_MBOX_INVALID_INPUT;
+    }
+
+    record_count =3D MIN(ct3d->dc.num_regions - in->start_region_id,
+            in->region_cnt);
+
+    out_pl_len =3D sizeof(*out) + record_count * sizeof(out->records[0]);
+    assert(out_pl_len <=3D CXL_MAILBOX_MAX_PAYLOAD_SIZE);
+
+    memset(out, 0, out_pl_len);
+    out->num_regions =3D record_count;
+    for (i =3D 0; i < record_count; i++) {
+        stq_le_p(&out->records[i].base,
+                ct3d->dc.regions[start_region_id + i].base);
+        stq_le_p(&out->records[i].decode_len,
+                ct3d->dc.regions[start_region_id + i].decode_len);
+        stq_le_p(&out->records[i].region_len,
+                ct3d->dc.regions[start_region_id + i].len);
+        stq_le_p(&out->records[i].block_size,
+                ct3d->dc.regions[start_region_id + i].block_size);
+        stl_le_p(&out->records[i].dsmadhandle,
+                ct3d->dc.regions[start_region_id + i].dsmadhandle);
+        out->records[i].flags =3D ct3d->dc.regions[start_region_id + i].fl=
ags;
+    }
+
+    *len =3D out_pl_len;
+    return CXL_MBOX_SUCCESS;
+}
+
 #define IMMEDIATE_CONFIG_CHANGE (1 << 1)
 #define IMMEDIATE_DATA_CHANGE (1 << 2)
 #define IMMEDIATE_POLICY_CHANGE (1 << 3)
@@ -977,6 +1044,8 @@ static struct cxl_cmd cxl_cmd_set[256][256] =3D {
         cmd_media_inject_poison, 8, 0 },
     [MEDIA_AND_POISON][CLEAR_POISON] =3D { "MEDIA_AND_POISON_CLEAR_POISON"=
,
         cmd_media_clear_poison, 72, 0 },
+    [DCD_CONFIG][GET_DC_CONFIG] =3D { "DCD_GET_DC_CONFIG",
+        cmd_dcd_get_dyn_cap_config, 2, 0 },
 };
=20
 static struct cxl_cmd cxl_cmd_set_sw[256][256] =3D {
@@ -1164,6 +1233,9 @@ void cxl_initialize_mailbox(CXLDeviceState *cxl_dstat=
e, bool switch_cci)
     }
     for (int set =3D 0; set < 256; set++) {
         for (int cmd =3D 0; cmd < 256; cmd++) {
+            if (!cxl_dstate->is_dcd && set =3D=3D DCD_CONFIG) {
+                continue;
+            }
             if (cxl_dstate->cxl_cmd_set[set][cmd].handler) {
                 struct cxl_cmd *c =3D &cxl_dstate->cxl_cmd_set[set][cmd];
                 struct cel_log *log =3D
diff --git a/hw/mem/cxl_type3.c b/hw/mem/cxl_type3.c
index 862107c5ef..4d68824dfe 100644
--- a/hw/mem/cxl_type3.c
+++ b/hw/mem/cxl_type3.c
@@ -1046,6 +1046,12 @@ static void ct3d_reset(DeviceState *dev)
     uint32_t *reg_state =3D ct3d->cxl_cstate.crb.cache_mem_registers;
     uint32_t *write_msk =3D ct3d->cxl_cstate.crb.cache_mem_regs_write_mask=
;
=20
+    if (ct3d->dc.num_regions) {
+        ct3d->cxl_dstate.is_dcd =3D true;
+    } else {
+        ct3d->cxl_dstate.is_dcd =3D false;
+    }
+
     cxl_component_register_init_common(reg_state, write_msk, CXL2_TYPE3_DE=
VICE);
     cxl_device_register_init_common(&ct3d->cxl_dstate);
 }
diff --git a/include/hw/cxl/cxl_device.h b/include/hw/cxl/cxl_device.h
index cd7f28dba8..dae39da438 100644
--- a/include/hw/cxl/cxl_device.h
+++ b/include/hw/cxl/cxl_device.h
@@ -212,6 +212,7 @@ typedef struct cxl_device_state {
     uint64_t mem_size;
     uint64_t pmem_size;
     uint64_t vmem_size;
+    bool is_dcd;
=20
     struct cxl_cmd (*cxl_cmd_set)[256];
     CPMUState cpmu[CXL_NUM_CPMU_INSTANCES];
@@ -382,6 +383,17 @@ typedef struct CXLPoison {
 typedef QLIST_HEAD(, CXLPoison) CXLPoisonList;
 #define CXL_POISON_LIST_LIMIT 256
=20
+#define DCD_MAX_REGION_NUM 8
+
+typedef struct CXLDCD_Region {
+    uint64_t base;
+    uint64_t decode_len; /* in multiples of 256MB */
+    uint64_t len;
+    uint64_t block_size;
+    uint32_t dsmadhandle;
+    uint8_t flags;
+} CXLDCD_Region;
+
 struct CXLType3Dev {
     /* Private */
     PCIDevice parent_obj;
@@ -413,6 +425,11 @@ struct CXLType3Dev {
     unsigned int poison_list_cnt;
     bool poison_list_overflowed;
     uint64_t poison_list_overflow_ts;
+
+    struct dynamic_capacity {
+        uint8_t num_regions; /* 0-8 regions */
+        struct CXLDCD_Region regions[DCD_MAX_REGION_NUM];
+    } dc;
 };
=20
 #define TYPE_CXL_TYPE3 "cxl-type3"
--=20
2.25.1

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 834E0C001DE
	for <linux-cxl@archiver.kernel.org>; Tue, 25 Jul 2023 18:40:08 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S230504AbjGYSkG (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 25 Jul 2023 14:40:06 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:44744 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S231755AbjGYSkA (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 25 Jul 2023 14:40:00 -0400
Received: from mailout2.w2.samsung.com (mailout2.w2.samsung.com [211.189.100.12])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 8132B2126
        for <linux-cxl@vger.kernel.org>; Tue, 25 Jul 2023 11:39:58 -0700 (PDT)
Received: from uscas1p2.samsung.com (unknown [182.198.245.207])
        by mailout2.w2.samsung.com (KnoxPortal) with ESMTP id 20230725183957usoutp026402224fe014bd2558dcb703be77d9f2~1MFnGVPaO1493014930usoutp025;
        Tue, 25 Jul 2023 18:39:57 +0000 (GMT)
DKIM-Filter: OpenDKIM Filter v2.11.0 mailout2.w2.samsung.com 20230725183957usoutp026402224fe014bd2558dcb703be77d9f2~1MFnGVPaO1493014930usoutp025
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=samsung.com;
        s=mail20170921; t=1690310397;
        bh=4zHhiX+VKvsm4sZJl9tl93+G8ban/i2aXGty2+poNFg=;
        h=From:To:CC:Subject:Date:In-Reply-To:References:From;
        b=iVAx0/9RcpLhBXX+yfLPsDR5hbgcwVTBfCeDQw8InbD5RD0Qelkdgr+AvVe72F7TA
         NCXPOdABavQBm8U0OHYnLar+DUShPyei528+GXqQq/FOvS7K+XfOUHhFzmIAiISbwL
         gsow8v63EAXEII83HHtBoJXin/LSgjXVt9FMbJhM=
Received: from ussmges2new.samsung.com (u111.gpu85.samsung.co.kr
        [203.254.195.111]) by uscas1p1.samsung.com (KnoxPortal) with ESMTP id
        20230725183957uscas1p16fd7936ec77be6b2ccc8b60bc1f08eef~1MFm4GIwg0903709037uscas1p1X;
        Tue, 25 Jul 2023 18:39:57 +0000 (GMT)
Received: from uscas1p2.samsung.com ( [182.198.245.207]) by
        ussmges2new.samsung.com (USCPEMTA) with SMTP id A1.11.42611.CF610C46; Tue,
        25 Jul 2023 14:39:56 -0400 (EDT)
Received: from ussmgxs2new.samsung.com (u91.gpu85.samsung.co.kr
        [203.254.195.91]) by uscas1p1.samsung.com (KnoxPortal) with ESMTP id
        20230725183956uscas1p153242eb4b12cb9cb6529476b4e9058c4~1MFmiu1U-1453314533uscas1p14;
        Tue, 25 Jul 2023 18:39:56 +0000 (GMT)
X-AuditID: cbfec36f-fb1ff7000000a673-41-64c016fcb123
Received: from SSI-EX4.ssi.samsung.com ( [105.128.2.146]) by
        ussmgxs2new.samsung.com (USCPEXMTA) with SMTP id B3.83.44215.CF610C46; Tue,
        25 Jul 2023 14:39:56 -0400 (EDT)
Received: from SSI-EX2.ssi.samsung.com (105.128.2.227) by
        SSI-EX4.ssi.samsung.com (105.128.2.229) with Microsoft SMTP Server
        (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384) id
        15.1.2375.24; Tue, 25 Jul 2023 11:39:55 -0700
Received: from SSI-EX2.ssi.samsung.com ([105.128.2.227]) by
        SSI-EX2.ssi.samsung.com ([105.128.2.227]) with mapi id 15.01.2375.024; Tue,
        25 Jul 2023 11:39:55 -0700
From: Fan Ni <fan.ni@samsung.com>
To: "qemu-devel@nongnu.org" <qemu-devel@nongnu.org>
CC: "jonathan.cameron@huawei.com" <jonathan.cameron@huawei.com>,
        "linux-cxl@vger.kernel.org" <linux-cxl@vger.kernel.org>,
        "gregory.price@memverge.com" <gregory.price@memverge.com>,
        "hchkuo@avery-design.com.tw" <hchkuo@avery-design.com.tw>,
        "cbrowy@avery-design.com" <cbrowy@avery-design.com>,
        "ira.weiny@intel.com" <ira.weiny@intel.com>,
        "dan.j.williams@intel.com" <dan.j.williams@intel.com>,
        Adam Manzanares <a.manzanares@samsung.com>,
        "dave@stgolabs.net" <dave@stgolabs.net>,
        "nmtadam.samsung@gmail.com" <nmtadam.samsung@gmail.com>,
        "nifan@outlook.com" <nifan@outlook.com>,
        Fan Ni <fan.ni@samsung.com>
Subject: [Qemu PATCH v2 3/9] include/hw/cxl/cxl_device: Rename mem_size as
 static_mem_size for type3 memory devices
Thread-Topic: [Qemu PATCH v2 3/9] include/hw/cxl/cxl_device: Rename mem_size
        as static_mem_size for type3 memory devices
Thread-Index: AQHZvydogN6RnRodckK9r+0ZvWb2uQ==
Date: Tue, 25 Jul 2023 18:39:55 +0000
Message-ID: <20230725183939.2741025-4-fan.ni@samsung.com>
In-Reply-To: <20230725183939.2741025-1-fan.ni@samsung.com>
Accept-Language: en-US
Content-Language: en-US
X-MS-Has-Attach: 
X-MS-TNEF-Correlator: 
x-mailer: git-send-email 2.25.1
x-originating-ip: [105.128.2.176]
Content-Type: text/plain; charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable
MIME-Version: 1.0
X-CFilter-Loop: Reflected
X-Brightmail-Tracker: H4sIAAAAAAAAA+NgFjrJKsWRmVeSWpSXmKPExsWy7djX87p/xA6kGExqt7ToPr+B0WL61AuM
        FqtvrmG0aGh6xGLRsvs9k8X+p89ZLFYtvMZmcX7WKRaL5xOfM1ksXfKI2eJ47w4WB26PC5Mn
        sHosbnD12DnrLrtHy5G3QN6el0weGz/+Z/d4cm0zk8fm1y+YPabOrvf4vEkugCuKyyYlNSez
        LLVI3y6BK2NjXztzQbNMxbsHp1kaGDeJdTFycEgImEjMe6XXxcjFISSwklFi+/QNrF2MnEBO
        K5PE+WnKIDZIzfWXP9kgitYySvSu3cUEUfSJUWLRdDOIxDJGidbW02DdbAKKEvu6trOB2CIC
        xhLHDi9hBiliFnjLIvFxzRsWkISwQKnE/Bm7WSCKqiQurFsP1aAn8XfXBbA4i4CqRMfKHWDb
        eAUsJRYeWs0IYnMKWEk8+zIbbBmjgJjE91NrwGqYBcQlbj2ZzwRxtqDEotl7mCFsMYl/ux6y
        QdjyEpN/zICyFSXuf3/JDtGrJ3Fj6hQ2CFtbYtnC18wQewUlTs58wgJRLylxcMUNFpBnJAQm
        c0q0XzgNlXCRmLJ8MSOELS3x9+4yJkj4Jkus+sgFEc6RmL9kC1S5tcTCP+uZJjCqzEJy9iwk
        Z8xCcsYsJGcsYGRZxSheWlycm55abJSXWq5XnJhbXJqXrpecn7uJEZjaTv87nL+D8fqtj3qH
        GJk4GA8xSnAwK4nwGsbsSxHiTUmsrEotyo8vKs1JLT7EKM3BoiTOa2h7MllIID2xJDU7NbUg
        tQgmy8TBKdXAtOLTFusnLayvHBzceEwvKv/nnROs/C32gKteZPGbPaxT+l6n7Tleuyvp6yTW
        A9evs688eHH6jXDvLrkTWVqR1+U0mXx1D/l8mNvLnGZkqvLgYGa+BHvzgjdvBVy8HK41NO8R
        3bM0h1P4/78HbhatgdZm3K4uT0JX9TJ/mLwxgY119obYgx0Nk9jW3VphoFMU564b2tihEFit
        Hmpvu/6tf5bN3AfHLlz0LNxt07ho5e+Lfkl8McLpL27fcfK7ckL+tpqMyTqxQmUjsRX6TL5q
        516vM/9/86V/lMv/T45xB56ZMXjOWyt3h7nQr7Xzo+/8iYtXOGS67WD8PIste9aX2dOWVziH
        TgjMvqnDdlRaiaU4I9FQi7moOBEApGarQdwDAAA=
X-Brightmail-Tracker: H4sIAAAAAAAAA+NgFnrOIsWRmVeSWpSXmKPExsWS2cA0SfeP2IEUgy0TlSy6z29gtJg+9QKj
        xeqbaxgtGpoesVi07H7PZLH/6XMWi1ULr7FZnJ91isXi+cTnTBZLlzxitjjeu4PFgdvjwuQJ
        rB6LG1w9ds66y+7RcuQtkLfnJZPHxo//2T2eXNvM5LH59Qtmj6mz6z0+b5IL4IrisklJzcks
        Sy3St0vgytjY185c0CxT8e7BaZYGxk1iXYycHBICJhLXX/5k62Lk4hASWM0osezORjaQhJDA
        J0aJ7W0uEIlljBKLDy9gB0mwCShK7OvaDlYkImAscezwEmYQm1ngNYvEt4vcILawQKnE/Bm7
        WSBqqiRWdZ1jhrD1JP7uugAWZxFQlehYuYMJxOYVsJRYeGg1YxcjB9AyS4mtE+NAwpwCVhLP
        vsxmBbEZBcQkvp9awwSxSlzi1pP5TBAPCEgs2XOeGcIWlXj5+B8rhC0vMfnHDDYIW1Hi/veX
        7BC9ehI3pk5hg7C1JZYtfM0McYKgxMmZT1gg6iUlDq64wTKBUWIWknWzkLTPQtI+C0n7AkaW
        VYzipcXFuekVxUZ5qeV6xYm5xaV56XrJ+bmbGIFp4fS/w9E7GG/f+qh3iJGJg/EQowQHs5II
        r2HMvhQh3pTEyqrUovz4otKc1OJDjNIcLErivC+jJsYLCaQnlqRmp6YWpBbBZJk4OKUamKZ9
        Y3e5fdm9uTK/PHaeoOhLppwDU/2c74fMEf1h1XvdpHeFRIDT5RmT8rdrh21fukg399QP7flf
        7N7yScYtVL+5OvDSLc/X952UQxn7nlT52l4O7bdIlzumJymzcvmdwqLdpUF3A84uC11+s1W8
        3mJtY+1W52thdz/4GwVu33GkmHluY1n1DEUfmRPxacdSeebNUvRpu8qwy7Vgx6FinSkrFoXG
        BbCvfZWTsJtFTvWcnIpS03PO6HXrnPa/vrDX8Po95g27dr4UqRS6e49ZmPPRstqk1e3HbuUF
        +R3WaVv3q8OMbw2Xw1758vzySk41620Wi6PjTv4uUXlwtFgn38BRs3b+ss98Wb6eETFRSizF
        GYmGWsxFxYkA1BosnnoDAAA=
X-CMS-MailID: 20230725183956uscas1p153242eb4b12cb9cb6529476b4e9058c4
CMS-TYPE: 301P
X-CMS-RootMailID: 20230725183956uscas1p153242eb4b12cb9cb6529476b4e9058c4
References: <20230725183939.2741025-1-fan.ni@samsung.com>
        <CGME20230725183956uscas1p153242eb4b12cb9cb6529476b4e9058c4@uscas1p1.samsung.com>
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

From: Fan Ni <nifan@outlook.com>

Rename mem_size as static_mem_size for type3 memdev to cover static RAM and
pmem capacity, preparing for the introduction of dynamic capacity to suppor=
t
dynamic capacity devices.

Signed-off-by: Fan Ni <fan.ni@samsung.com>
---
 hw/cxl/cxl-mailbox-utils.c  | 5 +++--
 hw/mem/cxl_type3.c          | 8 ++++----
 include/hw/cxl/cxl_device.h | 2 +-
 3 files changed, 8 insertions(+), 7 deletions(-)

diff --git a/hw/cxl/cxl-mailbox-utils.c b/hw/cxl/cxl-mailbox-utils.c
index 0fe9f3eb5d..dd5ea95af8 100644
--- a/hw/cxl/cxl-mailbox-utils.c
+++ b/hw/cxl/cxl-mailbox-utils.c
@@ -540,7 +540,8 @@ static CXLRetCode cmd_identify_memory_device(struct cxl=
_cmd *cmd,
=20
     snprintf(id->fw_revision, 0x10, "BWFW VERSION %02d", 0);
=20
-    stq_le_p(&id->total_capacity, cxl_dstate->mem_size / CXL_CAPACITY_MULT=
IPLIER);
+    stq_le_p(&id->total_capacity,
+            cxl_dstate->static_mem_size / CXL_CAPACITY_MULTIPLIER);
     stq_le_p(&id->persistent_capacity, cxl_dstate->pmem_size / CXL_CAPACIT=
Y_MULTIPLIER);
     stq_le_p(&id->volatile_capacity, cxl_dstate->vmem_size / CXL_CAPACITY_=
MULTIPLIER);
     stl_le_p(&id->lsa_size, cvc->get_lsa_size(ct3d));
@@ -879,7 +880,7 @@ static CXLRetCode cmd_media_clear_poison(struct cxl_cmd=
 *cmd,
     struct clear_poison_pl *in =3D (void *)cmd->payload;
=20
     dpa =3D ldq_le_p(&in->dpa);
-    if (dpa + CXL_CACHE_LINE_SIZE > cxl_dstate->mem_size) {
+    if (dpa + CXL_CACHE_LINE_SIZE > cxl_dstate->static_mem_size) {
         return CXL_MBOX_INVALID_PA;
     }
=20
diff --git a/hw/mem/cxl_type3.c b/hw/mem/cxl_type3.c
index 4d68824dfe..3d7acffcb7 100644
--- a/hw/mem/cxl_type3.c
+++ b/hw/mem/cxl_type3.c
@@ -748,7 +748,7 @@ static bool cxl_setup_memory(CXLType3Dev *ct3d, Error *=
*errp)
         }
         address_space_init(&ct3d->hostvmem_as, vmr, v_name);
         ct3d->cxl_dstate.vmem_size =3D memory_region_size(vmr);
-        ct3d->cxl_dstate.mem_size +=3D memory_region_size(vmr);
+        ct3d->cxl_dstate.static_mem_size +=3D memory_region_size(vmr);
         g_free(v_name);
     }
=20
@@ -771,7 +771,7 @@ static bool cxl_setup_memory(CXLType3Dev *ct3d, Error *=
*errp)
         }
         address_space_init(&ct3d->hostpmem_as, pmr, p_name);
         ct3d->cxl_dstate.pmem_size =3D memory_region_size(pmr);
-        ct3d->cxl_dstate.mem_size +=3D memory_region_size(pmr);
+        ct3d->cxl_dstate.static_mem_size +=3D memory_region_size(pmr);
         g_free(p_name);
     }
=20
@@ -984,7 +984,7 @@ static int cxl_type3_hpa_to_as_and_dpa(CXLType3Dev *ct3=
d,
         return -EINVAL;
     }
=20
-    if (*dpa_offset > ct3d->cxl_dstate.mem_size) {
+    if (*dpa_offset > ct3d->cxl_dstate.static_mem_size) {
         return -EINVAL;
     }
=20
@@ -1148,7 +1148,7 @@ static bool set_cacheline(CXLType3Dev *ct3d, uint64_t=
 dpa_offset, uint8_t *data)
         return false;
     }
=20
-    if (dpa_offset + CXL_CACHE_LINE_SIZE > ct3d->cxl_dstate.mem_size) {
+    if (dpa_offset + CXL_CACHE_LINE_SIZE > ct3d->cxl_dstate.static_mem_siz=
e) {
         return false;
     }
=20
diff --git a/include/hw/cxl/cxl_device.h b/include/hw/cxl/cxl_device.h
index dae39da438..503c344326 100644
--- a/include/hw/cxl/cxl_device.h
+++ b/include/hw/cxl/cxl_device.h
@@ -209,7 +209,7 @@ typedef struct cxl_device_state {
     } timestamp;
=20
     /* memory region size, HDM */
-    uint64_t mem_size;
+    uint64_t static_mem_size;
     uint64_t pmem_size;
     uint64_t vmem_size;
     bool is_dcd;
--=20
2.25.1

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 0609EC001DF
	for <linux-cxl@archiver.kernel.org>; Tue, 25 Jul 2023 18:40:13 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S230432AbjGYSkK (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 25 Jul 2023 14:40:10 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:44766 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S231823AbjGYSkC (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 25 Jul 2023 14:40:02 -0400
Received: from mailout2.w2.samsung.com (mailout2.w2.samsung.com [211.189.100.12])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 5E2F7212C
        for <linux-cxl@vger.kernel.org>; Tue, 25 Jul 2023 11:39:59 -0700 (PDT)
Received: from uscas1p1.samsung.com (unknown [182.198.245.206])
        by mailout2.w2.samsung.com (KnoxPortal) with ESMTP id 20230725183958usoutp02098aa930577900300c3ab4b93eb6e5a4~1MFoCBLjD1412514125usoutp02i;
        Tue, 25 Jul 2023 18:39:58 +0000 (GMT)
DKIM-Filter: OpenDKIM Filter v2.11.0 mailout2.w2.samsung.com 20230725183958usoutp02098aa930577900300c3ab4b93eb6e5a4~1MFoCBLjD1412514125usoutp02i
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=samsung.com;
        s=mail20170921; t=1690310398;
        bh=xQl4UJjxwgWUuidcoMPZRlClhrcaaIQc0PdcqBYsE2k=;
        h=From:To:CC:Subject:Date:In-Reply-To:References:From;
        b=ukuhph5hvdbyKTCWldG/TijP1m8EwkSKbvcxIFN6QF+pmR5hxAceFTX1EanDitQxc
         Mgt2NG7Qid68aad5DAFGpC7d+gcci08TsE+S9avkOvBLbbRNOM0aM6agCX+lDsy8DO
         S4xFti5WhZHirG8gICJIpzsy5cNsitQFyTpfZx98=
Received: from ussmges2new.samsung.com (u111.gpu85.samsung.co.kr
        [203.254.195.111]) by uscas1p1.samsung.com (KnoxPortal) with ESMTP id
        20230725183958uscas1p1b4981dae3ea41805cd27d82396dd9135~1MFnz1S8O0414404144uscas1p15;
        Tue, 25 Jul 2023 18:39:58 +0000 (GMT)
Received: from uscas1p2.samsung.com ( [182.198.245.207]) by
        ussmges2new.samsung.com (USCPEMTA) with SMTP id 63.11.42611.DF610C46; Tue,
        25 Jul 2023 14:39:57 -0400 (EDT)
Received: from ussmgxs3new.samsung.com (u92.gpu85.samsung.co.kr
        [203.254.195.92]) by uscas1p2.samsung.com (KnoxPortal) with ESMTP id
        20230725183957uscas1p2ca5293c7229ab989ad1a2d95395436a6~1MFncI5Rb1972119721uscas1p2v;
        Tue, 25 Jul 2023 18:39:57 +0000 (GMT)
X-AuditID: cbfec36f-fb1ff7000000a673-45-64c016fd5afe
Received: from SSI-EX3.ssi.samsung.com ( [105.128.2.145]) by
        ussmgxs3new.samsung.com (USCPEXMTA) with SMTP id 89.DA.64580.DF610C46; Tue,
        25 Jul 2023 14:39:57 -0400 (EDT)
Received: from SSI-EX2.ssi.samsung.com (105.128.2.227) by
        SSI-EX3.ssi.samsung.com (105.128.2.228) with Microsoft SMTP Server
        (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384) id
        15.1.2375.24; Tue, 25 Jul 2023 11:39:56 -0700
Received: from SSI-EX2.ssi.samsung.com ([105.128.2.227]) by
        SSI-EX2.ssi.samsung.com ([105.128.2.227]) with mapi id 15.01.2375.024; Tue,
        25 Jul 2023 11:39:56 -0700
From: Fan Ni <fan.ni@samsung.com>
To: "qemu-devel@nongnu.org" <qemu-devel@nongnu.org>
CC: "jonathan.cameron@huawei.com" <jonathan.cameron@huawei.com>,
        "linux-cxl@vger.kernel.org" <linux-cxl@vger.kernel.org>,
        "gregory.price@memverge.com" <gregory.price@memverge.com>,
        "hchkuo@avery-design.com.tw" <hchkuo@avery-design.com.tw>,
        "cbrowy@avery-design.com" <cbrowy@avery-design.com>,
        "ira.weiny@intel.com" <ira.weiny@intel.com>,
        "dan.j.williams@intel.com" <dan.j.williams@intel.com>,
        Adam Manzanares <a.manzanares@samsung.com>,
        "dave@stgolabs.net" <dave@stgolabs.net>,
        "nmtadam.samsung@gmail.com" <nmtadam.samsung@gmail.com>,
        "nifan@outlook.com" <nifan@outlook.com>,
        Fan Ni <fan.ni@samsung.com>
Subject: [Qemu PATCH v2 9/9] hw/mem/cxl_type3: Add dpa range validation for
 accesses to dc regions
Thread-Topic: [Qemu PATCH v2 9/9] hw/mem/cxl_type3: Add dpa range validation
        for accesses to dc regions
Thread-Index: AQHZvydoZ/a421rE4EydfsE7dZC6xQ==
Date: Tue, 25 Jul 2023 18:39:56 +0000
Message-ID: <20230725183939.2741025-10-fan.ni@samsung.com>
In-Reply-To: <20230725183939.2741025-1-fan.ni@samsung.com>
Accept-Language: en-US
Content-Language: en-US
X-MS-Has-Attach: 
X-MS-TNEF-Correlator: 
x-mailer: git-send-email 2.25.1
x-originating-ip: [105.128.2.176]
Content-Type: text/plain; charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable
MIME-Version: 1.0
X-CFilter-Loop: Reflected
X-Brightmail-Tracker: H4sIAAAAAAAAA01SfVCLcRz3e55n27Nl7jHUT3k5qePEKOG5ZHXo7kGHc905ImZ7rFjFnhI5
        TJpeKKpFbZSojuSGXIlUJjH+mM5dKrlOV021Ysh7Y9uTu/77fD8v39/ne/fDUZGJ44nHxCXQ
        qjip0psrwKqbR8yLRt0b5Uu0mmDyjPk2IC/mvwLkzfZKQKpTujEy9eFHhGzotWBkRUkrlzTr
        XmCkJceCkGWl3Sj5LOs+FupGvco7z6GuqcOoWt07HpXaNOSY6voR6o7tL4/qaa1CqKrBDyiV
        rz9Bfbk7a7NguyBYTitjDtGqxZLdgujczj7sgDn4cOHXNJ4aZCzMBHwcEoGwtyCfmwkEuIi4
        AaA9tx+wgwaBP+3p3P+ugbdtY8ItAAc6P3Kcgoj4DKC1cx0rlDtw2i/UKXCJObA+s8aVnkos
        hc1PSlGnCSWGMGirtGJOYQohh9aUGow1xUBz6zMOi8Ww7luLi8cIX9jW1OR4GseFRBBsORvk
        pPkO2PdV77IDwh1+f1GJODFKeMCOnmKEbT0ZXtXXoSx2h/YH78eumQ3zfhSM4Tmw63s/j82K
        YVu+lstiP1heMujKCh17TIU9GOufDh9fb8Oct0Aijw/tKXZXN0isha8frWE9XvBi5WuMpWWw
        wiZgaSUsLr03tmYlLPljQM4DH9241rpxLXTjWujGtbgCsArgkcgwsQqaCYijk8SMNJZJjFOI
        ZfGxd4Hjt720P4m/D9502MRGgODACCCOek8V+u+ol4uEcumRZFoVv0uVqKQZI/DCMW8Pof8q
        k0xEKKQJ9H6aPkCr/qsIzvdUI8UjBh+9p/6ob+2oum9GHlN77eSjnIUjiqRcpdfp5aNb02ol
        UacsO7fI+VvClTn1WXONkiVFwzMV27TP0yfRy7IjTdpsrvXP24KG6nKFR+SKkCRNBJ087e/t
        li7PCWU5Bl/AZGQEDUfdLNq46GfawbpJjNZvaHi3IYbX8JSfuj7CPi/qEh4YGWopS86aGN0p
        O1e0fk82x0sSOn9f1V7gVhPqk04eEouPbAo0HXsc5aduHAgbVAZ+urXsXEhA44+EisZuk4w2
        ruLuiDi+QGMPkYV8SKxarW+/7N9uVWokmVeOb7AF/A5w64jt6qm+oOptDiP6Mh4eM8zVisJX
        /xaD694YEy31X4CqGOk/gPhra9wDAAA=
X-Brightmail-Tracker: H4sIAAAAAAAAA+NgFnrOIsWRmVeSWpSXmKPExsWS2cA0Ufev2IEUg5kHZSy6z29gtJg+9QKj
        xeqbaxgtGpoesVi07H7PZLH/6XMWi1ULr7FZnJ91isXi+cTnTBZLlzxitjjeu4PFgdvjwuQJ
        rB6LG1w9ds66y+7RcuQtkLfnJZPHxo//2T2eXNvM5LH59Qtmj6mz6z0+b5IL4IrisklJzcks
        Sy3St0vgyph05xlLwXmbiplf2tkbGDt1uhg5OSQETCRe3b7B2MXIxSEksJpRYtfGk6wQzidG
        iXOnXkE5yxgl5i9ezQjSwiagKLGvazsbiC0iYCxx7PASZhCbWeA1i8S3i9wgtrBAisSbpu0s
        EDWZElen72aGsPUk9ny7CBZnEVCVuHHkCNBMDg5eASuJiz1WIKaQgKXE1olxIBWcQNFnX2az
        gtiMAmIS30+tYYLYJC5x68l8JogHBCSW7DnPDGGLSrx8/I8VwpaXmPxjBhuErShx//tLdohe
        PYkbU6ewQdjaEssWvgbr5RUQlDg58wkLRL2kxMEVN1gmMErMQrJuFpL2WUjaZyFpX8DIsopR
        vLS4ODe9otg4L7Vcrzgxt7g0L10vOT93EyMwLZz+dzhmB+O9Wx/1DjEycTAeYpTgYFYS4TWM
        2ZcixJuSWFmVWpQfX1Sak1p8iFGag0VJnNcjdmK8kEB6YklqdmpqQWoRTJaJg1OqgSlOZX25
        lECk6fkzJ/QTXB2qF+2Jmav+zcr6pODh5eoWBzMSeAUf8Zbxb53U9OVDskjcuWDulSW/Vk0p
        Pj7Di+etupV6n0jKdav9T7+IrTxZvuXr2+SgLfbJyQeeTF6jdmzFgcPHH+r0da67IxNf+f29
        C/eDpp6JV1K0q/iqzjwIivui+ZTpyJLCIn/GJ2nS3PuNrWfYXpQx7j7boTeJwSfJzHJe9Mzz
        m20OLp4bvlafp71eYV7XxG8rJZnKHtuvzvd7aHSOK3lzB++JGW8ijiWvCGt+1TfhMZNA5p2J
        a1wD7koyht53DpfoeecXe/DJ26n7Q92NXx/nvuF41KKc4ZK+0s9H5tq6XDtSeJ+cPK/EUpyR
        aKjFXFScCADcXZpwegMAAA==
X-CMS-MailID: 20230725183957uscas1p2ca5293c7229ab989ad1a2d95395436a6
CMS-TYPE: 301P
X-CMS-RootMailID: 20230725183957uscas1p2ca5293c7229ab989ad1a2d95395436a6
References: <20230725183939.2741025-1-fan.ni@samsung.com>
        <CGME20230725183957uscas1p2ca5293c7229ab989ad1a2d95395436a6@uscas1p2.samsung.com>
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

From: Fan Ni <nifan@outlook.com>

Not all dpa range in the dc regions is valid to access until an extent
covering the range has been added. Add a bitmap for each region to
record whether a dc block in the region has been backed by dc extent.
For the bitmap, a bit in the bitmap represents a dc block. When a dc
extent is added, all the bits of the blocks in the extent will be set,
which will be cleared when the extent is released.

Signed-off-by: Fan Ni <fan.ni@samsung.com>
---
 hw/mem/cxl_type3.c          | 155 ++++++++++++++++++++++++++++++++++++
 include/hw/cxl/cxl_device.h |   1 +
 2 files changed, 156 insertions(+)

diff --git a/hw/mem/cxl_type3.c b/hw/mem/cxl_type3.c
index 41a828598a..51943a36fc 100644
--- a/hw/mem/cxl_type3.c
+++ b/hw/mem/cxl_type3.c
@@ -787,13 +787,37 @@ static int cxl_create_dc_regions(CXLType3Dev *ct3d)
         /* dsmad_handle is set when creating cdat table entries */
         region->flags =3D 0;
=20
+        region->blk_bitmap =3D bitmap_new(region->len / region->block_size=
);
+        if (!region->blk_bitmap) {
+            break;
+        }
+
         region_base +=3D region->len;
     }
+
+    if (i < ct3d->dc.num_regions) {
+        while (--i >=3D 0) {
+            g_free(ct3d->dc.regions[i].blk_bitmap);
+        }
+        return -1;
+    }
+
     QTAILQ_INIT(&ct3d->dc.extents);
=20
     return 0;
 }
=20
+static void cxl_destroy_dc_regions(CXLType3Dev *ct3d)
+{
+    int i;
+    struct CXLDCD_Region *region;
+
+    for (i =3D 0; i < ct3d->dc.num_regions; i++) {
+        region =3D &ct3d->dc.regions[i];
+        g_free(region->blk_bitmap);
+    }
+}
+
 static bool cxl_setup_memory(CXLType3Dev *ct3d, Error **errp)
 {
     DeviceState *ds =3D DEVICE(ct3d);
@@ -1021,6 +1045,7 @@ err_free_special_ops:
     g_free(regs->special_ops);
 err_address_space_free:
     if (ct3d->dc.host_dc) {
+        cxl_destroy_dc_regions(ct3d);
         address_space_destroy(&ct3d->dc.host_dc_as);
     }
     if (ct3d->hostpmem) {
@@ -1043,6 +1068,7 @@ static void ct3_exit(PCIDevice *pci_dev)
     spdm_sock_fini(ct3d->doe_spdm.socket);
     g_free(regs->special_ops);
     if (ct3d->dc.host_dc) {
+        cxl_destroy_dc_regions(ct3d);
         address_space_destroy(&ct3d->dc.host_dc_as);
     }
     if (ct3d->hostpmem) {
@@ -1053,6 +1079,110 @@ static void ct3_exit(PCIDevice *pci_dev)
     }
 }
=20
+/*
+ * This function will marked the dpa range [dpa, dap + len) to be backed a=
nd
+ * accessible, this happens when a dc extent is added and accepted by the
+ * host.
+ */
+static void set_region_block_backed(CXLType3Dev *ct3d, uint64_t dpa,
+        uint64_t len)
+{
+    int i;
+    CXLDCD_Region *region =3D &ct3d->dc.regions[0];
+
+    if (dpa < region->base
+            || dpa >=3D region->base + ct3d->dc.total_capacity)
+        return;
+
+    /*
+     * spec 3.0 9.13.3: Regions are used in increasing-DPA order, with
+     * Region 0 being used for the lowest DPA of Dynamic Capacity and
+     * Region 7 for the highest DPA.
+     * So we check from the last region to find where the dpa belongs.
+     * access across multiple regions is not allowed.
+     **/
+    for (i =3D ct3d->dc.num_regions - 1; i >=3D 0; i--) {
+        region =3D &ct3d->dc.regions[i];
+        if (dpa >=3D region->base) {
+            break;
+        }
+    }
+
+    bitmap_set(region->blk_bitmap, (dpa - region->base) / region->block_si=
ze,
+            len / region->block_size);
+}
+
+/*
+ * This function check whether a dpa range [dpa, dpa + len) has been backe=
d
+ * with dc extents, used when validating read/write to dc regions
+ */
+static bool test_region_block_backed(CXLType3Dev *ct3d, uint64_t dpa,
+        uint64_t len)
+{
+    int i;
+    CXLDCD_Region *region =3D &ct3d->dc.regions[0];
+    uint64_t nbits;
+    long nr;
+
+    if (dpa < region->base
+            || dpa >=3D region->base + ct3d->dc.total_capacity)
+        return false;
+
+    /*
+     * spec 3.0 9.13.3: Regions are used in increasing-DPA order, with
+     * Region 0 being used for the lowest DPA of Dynamic Capacity and
+     * Region 7 for the highest DPA.
+     * So we check from the last region to find where the dpa belongs.
+     * access across multiple regions is not allowed.
+     */
+    for (i =3D ct3d->dc.num_regions - 1; i >=3D 0; i--) {
+        region =3D &ct3d->dc.regions[i];
+        if (dpa >=3D region->base) {
+            break;
+        }
+    }
+
+    nr =3D (dpa - region->base) / region->block_size;
+    nbits =3D len / region->block_size;
+    return find_next_zero_bit(region->blk_bitmap, nbits, nr) >=3D nr + nbi=
ts;
+}
+
+/*
+ * This function will marked the dpa range [dpa, dap + len) to be unbacked=
 and
+ * inaccessible, this happens when a dc extent is added and accepted by th=
e
+ * host.
+ */
+static void clear_region_block_backed(CXLType3Dev *ct3d, uint64_t dpa,
+        uint64_t len)
+{
+    int i;
+    CXLDCD_Region *region =3D &ct3d->dc.regions[0];
+    uint64_t nbits;
+    long nr;
+
+    if (dpa < region->base
+            || dpa >=3D region->base + ct3d->dc.total_capacity)
+        return;
+
+    /*
+     * spec 3.0 9.13.3: Regions are used in increasing-DPA order, with
+     * Region 0 being used for the lowest DPA of Dynamic Capacity and
+     * Region 7 for the highest DPA.
+     * So we check from the last region to find where the dpa belongs.
+     * access across multiple regions is not allowed.
+     */
+    for (i =3D ct3d->dc.num_regions - 1; i >=3D 0; i--) {
+        region =3D &ct3d->dc.regions[i];
+        if (dpa >=3D region->base) {
+            break;
+        }
+    }
+
+    nr =3D (dpa - region->base) / region->block_size;
+    nbits =3D len / region->block_size;
+    bitmap_clear(region->blk_bitmap, nr, nbits);
+}
+
 static bool cxl_type3_dpa(CXLType3Dev *ct3d, hwaddr host_addr, uint64_t *d=
pa)
 {
     uint32_t *cache_mem =3D ct3d->cxl_cstate.crb.cache_mem_registers;
@@ -1145,6 +1275,10 @@ static int cxl_type3_hpa_to_as_and_dpa(CXLType3Dev *=
ct3d,
         *as =3D &ct3d->hostpmem_as;
         *dpa_offset -=3D vmr_size;
     } else {
+        if (!test_region_block_backed(ct3d, *dpa_offset, size)) {
+            return -ENODEV;
+        }
+
         *as =3D &ct3d->dc.host_dc_as;
         *dpa_offset -=3D (vmr_size + pmr_size);
     }
@@ -1944,6 +2078,27 @@ static void qmp_cxl_process_dynamic_capacity_event(c=
onst char *path,
     }
=20
     g_free(extents);
+
+    /* Another choice is to do the set/clear after getting mailbox respons=
e*/
+    list =3D records;
+    while (list) {
+        dpa =3D list->value->dpa * 1024 * 1024;
+        len =3D list->value->len * 1024 * 1024;
+        rid =3D list->value->region_id;
+
+        switch (type) {
+        case DC_EVENT_ADD_CAPACITY:
+            set_region_block_backed(dcd, dpa, len);
+            break;
+        case DC_EVENT_RELEASE_CAPACITY:
+            clear_region_block_backed(dcd, dpa, len);
+            break;
+        default:
+            error_setg(errp, "DC event type not handled yet");
+            break;
+        }
+        list =3D list->next;
+    }
 }
=20
 void qmp_cxl_add_dynamic_capacity_event(const char *path,
diff --git a/include/hw/cxl/cxl_device.h b/include/hw/cxl/cxl_device.h
index 01a5eaca48..1f85c88017 100644
--- a/include/hw/cxl/cxl_device.h
+++ b/include/hw/cxl/cxl_device.h
@@ -412,6 +412,7 @@ typedef struct CXLDCD_Region {
     uint64_t block_size;
     uint32_t dsmadhandle;
     uint8_t flags;
+    unsigned long *blk_bitmap;
 } CXLDCD_Region;
=20
 struct CXLType3Dev {
--=20
2.25.1

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id C2A99EB64DD
	for <linux-cxl@archiver.kernel.org>; Tue, 25 Jul 2023 18:40:13 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S229780AbjGYSkN (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 25 Jul 2023 14:40:13 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:44754 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S231703AbjGYSkH (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 25 Jul 2023 14:40:07 -0400
Received: from mailout1.w2.samsung.com (mailout1.w2.samsung.com [211.189.100.11])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 012102135
        for <linux-cxl@vger.kernel.org>; Tue, 25 Jul 2023 11:39:59 -0700 (PDT)
Received: from uscas1p2.samsung.com (unknown [182.198.245.207])
        by mailout1.w2.samsung.com (KnoxPortal) with ESMTP id 20230725183958usoutp010c978e34254344b55caf1b3bb61edc49~1MFn1eQt51059910599usoutp01E;
        Tue, 25 Jul 2023 18:39:58 +0000 (GMT)
DKIM-Filter: OpenDKIM Filter v2.11.0 mailout1.w2.samsung.com 20230725183958usoutp010c978e34254344b55caf1b3bb61edc49~1MFn1eQt51059910599usoutp01E
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=samsung.com;
        s=mail20170921; t=1690310398;
        bh=CIC36SxZn+TjeOeeE9nzntOUDOaaeK63Kru21bJOxSI=;
        h=From:To:CC:Subject:Date:In-Reply-To:References:From;
        b=bKmNuMJAjrTSVZVtUoyuapUjDFvMQIXjJbZje6OyXNXiWQJAT+MqhQaP+DJLhsy5s
         V+cyPsMgnpqlIdQLnaYH7TMZuJYbfnckMXXCNGDYRriSw0JtwhBPRnBa7z+hifDh7q
         a+aOuOGr3ULgknB5VhzDfkvjIJxkdQzvbIAh4PBQ=
Received: from ussmges3new.samsung.com (u112.gpu85.samsung.co.kr
        [203.254.195.112]) by uscas1p2.samsung.com (KnoxPortal) with ESMTP id
        20230725183957uscas1p2392a7252cb4b8139ef782dc4e3fd0365~1MFnqGJYV1580715807uscas1p2R;
        Tue, 25 Jul 2023 18:39:57 +0000 (GMT)
Received: from uscas1p1.samsung.com ( [182.198.245.206]) by
        ussmges3new.samsung.com (USCPEMTA) with SMTP id 7A.4E.62237.DF610C46; Tue,
        25 Jul 2023 14:39:57 -0400 (EDT)
Received: from ussmgxs1new.samsung.com (u89.gpu85.samsung.co.kr
        [203.254.195.89]) by uscas1p2.samsung.com (KnoxPortal) with ESMTP id
        20230725183957uscas1p2a076b6f7b694d2e632a0b8025ec331d7~1MFnT2UFB1972119721uscas1p2u;
        Tue, 25 Jul 2023 18:39:57 +0000 (GMT)
X-AuditID: cbfec370-b17ff7000001f31d-95-64c016fd5f19
Received: from SSI-EX2.ssi.samsung.com ( [105.128.2.145]) by
        ussmgxs1new.samsung.com (USCPEXMTA) with SMTP id 74.54.38326.DF610C46; Tue,
        25 Jul 2023 14:39:57 -0400 (EDT)
Received: from SSI-EX2.ssi.samsung.com (105.128.2.227) by
        SSI-EX2.ssi.samsung.com (105.128.2.227) with Microsoft SMTP Server
        (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384) id
        15.1.2375.24; Tue, 25 Jul 2023 11:39:56 -0700
Received: from SSI-EX2.ssi.samsung.com ([105.128.2.227]) by
        SSI-EX2.ssi.samsung.com ([105.128.2.227]) with mapi id 15.01.2375.024; Tue,
        25 Jul 2023 11:39:56 -0700
From: Fan Ni <fan.ni@samsung.com>
To: "qemu-devel@nongnu.org" <qemu-devel@nongnu.org>
CC: "jonathan.cameron@huawei.com" <jonathan.cameron@huawei.com>,
        "linux-cxl@vger.kernel.org" <linux-cxl@vger.kernel.org>,
        "gregory.price@memverge.com" <gregory.price@memverge.com>,
        "hchkuo@avery-design.com.tw" <hchkuo@avery-design.com.tw>,
        "cbrowy@avery-design.com" <cbrowy@avery-design.com>,
        "ira.weiny@intel.com" <ira.weiny@intel.com>,
        "dan.j.williams@intel.com" <dan.j.williams@intel.com>,
        Adam Manzanares <a.manzanares@samsung.com>,
        "dave@stgolabs.net" <dave@stgolabs.net>,
        "nmtadam.samsung@gmail.com" <nmtadam.samsung@gmail.com>,
        "nifan@outlook.com" <nifan@outlook.com>,
        Fan Ni <fan.ni@samsung.com>
Subject: [Qemu PATCH v2 7/9] hw/cxl/cxl-mailbox-utils: Add mailbox commands
 to support add/release dynamic capacity response
Thread-Topic: [Qemu PATCH v2 7/9] hw/cxl/cxl-mailbox-utils: Add mailbox
        commands to support add/release dynamic capacity response
Thread-Index: AQHZvydoEWnb5qMfxEi9SRoRqte0zA==
Date: Tue, 25 Jul 2023 18:39:56 +0000
Message-ID: <20230725183939.2741025-8-fan.ni@samsung.com>
In-Reply-To: <20230725183939.2741025-1-fan.ni@samsung.com>
Accept-Language: en-US
Content-Language: en-US
X-MS-Has-Attach: 
X-MS-TNEF-Correlator: 
x-mailer: git-send-email 2.25.1
x-originating-ip: [105.128.2.176]
Content-Type: text/plain; charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable
MIME-Version: 1.0
X-CFilter-Loop: Reflected
X-Brightmail-Tracker: H4sIAAAAAAAAA+NgFjrNKsWRmVeSWpSXmKPExsWy7djXc7p/xQ6kGEydoWfRfX4Do8X0qRcY
        LVbfXMNo0dD0iMWiZfd7Jov9T5+zWKxaeI3N4vysUywWzyc+Z7JYuuQRs8Xx3h0sDtweFyZP
        YPVY3ODqsXPWXXaPliNvgbw9L5k8Nn78z+7x5NpmJo/Nr18we0ydXe/xeZNcAFcUl01Kak5m
        WWqRvl0CV8behS2MBQsCK27uqG9g3GrZxcjJISFgIjFp2jmWLkYuDiGBlYwSl29OZYVwWpkk
        Hs7oZIOp6plylREisRaoqvE9VNUnRomG1w+YIJxljBJv2n8xg7SwCShK7OvaDtYuImAscezw
        EmaQImaBtywSH9e8YQFJCAvUSfy7+w8sISLQzCgxa+EiVogOPYlrG9+wg9gsAqoSN44cAVrO
        wcErYClxfI8VSJhTwEri2ZfZYOWMAmIS30+tYQKxmQXEJW49mc8EcbegxKLZe5ghbDGJf7se
        Qv0jLzH5xwwoW1Hi/veX7BC9ehI3pk5hg7C1JZYtfA3Wyws05+TMJywQ9ZISB1fcAIeYhMBk
        TontTz+xQiRcJO7e+QlVJC1x9fpUZpCbJQSSJVZ95III50jMX7IFqsRaYuGf9UwTGFVmITl7
        FpIzZiE5YxaSMxYwsqxiFC8tLs5NTy02zkst1ytOzC0uzUvXS87P3cQITG+n/x0u2MF469ZH
        vUOMTByMhxglOJiVRHgNY/alCPGmJFZWpRblxxeV5qQWH2KU5mBREuc1tD2ZLCSQnliSmp2a
        WpBaBJNl4uCUamCSX/3E3iJkyukn/srJGVJc0erm2158mxCxyWJ/64QQr/um0W4tMitClj8R
        r4hS3eN0+MSrgN1H7zDNULPdo1WcO7uZ5d19IdGU20ueTj+i98F9LfuCP7+u6zD+3xYrNaVi
        4V6ztW2JS6/4v9nWlD/v23wvg7XrIx0t+D7fcjtvf8SS9/ty52DPaxWZT79P9V5knnpV54bC
        Nt715nPyao8o/TgmJ2564NnLaSuX2psxpNyR0zi25tTd56L3dnEEftn30fqiXuav/Zkq3KcN
        RFkLX7fMDWGxPJ16vTmn1DHuMsPLxztu6rs8WpxX8rhFPuLdKpcMvvn7j+tcfJ4uv/NHgVE8
        U96bavGETu23E/yPKrEUZyQaajEXFScCABc2v7TeAwAA
X-Brightmail-Tracker: H4sIAAAAAAAAA+NgFnrOIsWRmVeSWpSXmKPExsWS2cA0Ufev2IEUg6YzEhbd5zcwWkyfeoHR
        YvXNNYwWDU2PWCxadr9nstj/9DmLxaqF19gszs86xWLxfOJzJoulSx4xWxzv3cHiwO1xYfIE
        Vo/FDa4eO2fdZfdoOfIWyNvzkslj48f/7B5Prm1m8tj8+gWzx9TZ9R6fN8kFcEVx2aSk5mSW
        pRbp2yVwZexd2MJYsCCw4uaO+gbGrZZdjJwcEgImEj1TrjJ2MXJxCAmsZpRoPrydBcL5xCjR
        tug0M4SzjFFi/uLVjCAtbAKKEvu6trOB2CICxhLHDi9hBrGZBV6zSHy7yA1iCwvUSRx+O50N
        pFlEoJlR4vLck0wQDXoS1za+YQexWQRUJW4cOQI0lIODV8BS4vgeKxBTCMjcOjEOpIJTwEri
        2ZfZrCA2o4CYxPdTa5ggVolL3HoynwniAwGJJXvOM0PYohIvH/9jhbDlJSb/mMEGYStK3P/+
        kh2iV0/ixtQpbBC2tsSyha/BenkFBCVOznzCAlEvKXFwxQ2WCYwSs5Csm4WkfRaS9llI2hcw
        sqxiFC8tLs5Nryg2zEst1ytOzC0uzUvXS87P3cQITAun/x2O3MF49NZHvUOMTByMhxglOJiV
        RHgNY/alCPGmJFZWpRblxxeV5qQWH2KU5mBREucVcp0YLySQnliSmp2aWpBaBJNl4uCUamDS
        eLqKuUw053qmxkNhm7R/zVUqXtt2ztxyNZh1h03ehgLLxeFbRc6pVPXOzxLw1LwqdmHi/q+d
        Rlcli5n9r26pfWaUvYDf+FPjqvR/zq//KxlHnPPeZfs4U+rC5ru68gKnZlmsb/0ml/j/ynyf
        mDWzbAtjO468SVpZf3u30i3LdisXNsU4nkVKPXuPFHU9yWCZ8cav1yB5mZWEdq5EieDavvgn
        LVvzHs0OlTtcJCz3Vf7AbsGrLfOlLjAzLQ8r3Fhqbl5g3RhjW3Np7WQ1kwzPoNinZouFHA84
        WNX98W82qz3VuszRuFW6cu3F+7xHIqpjAxMn/FtZVpH9zvCgtfOqrTpzzKuv9gj+Y4ubrMRS
        nJFoqMVcVJwIAA+iSr96AwAA
X-CMS-MailID: 20230725183957uscas1p2a076b6f7b694d2e632a0b8025ec331d7
CMS-TYPE: 301P
X-CMS-RootMailID: 20230725183957uscas1p2a076b6f7b694d2e632a0b8025ec331d7
References: <20230725183939.2741025-1-fan.ni@samsung.com>
        <CGME20230725183957uscas1p2a076b6f7b694d2e632a0b8025ec331d7@uscas1p2.samsung.com>
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

From: Fan Ni <nifan@outlook.com>

Per CXL spec 3.0, two mailbox commands are implemented:
Add Dynamic Capacity Response (Opcode 4802h) 8.2.9.8.9.3, and
Release Dynamic Capacity (Opcode 4803h) 8.2.9.8.9.4.

Signed-off-by: Fan Ni <fan.ni@samsung.com>
---
 hw/cxl/cxl-mailbox-utils.c  | 253 ++++++++++++++++++++++++++++++++++++
 include/hw/cxl/cxl_device.h |   3 +-
 2 files changed, 255 insertions(+), 1 deletion(-)

diff --git a/hw/cxl/cxl-mailbox-utils.c b/hw/cxl/cxl-mailbox-utils.c
index 3d25a9697e..1e4944da95 100644
--- a/hw/cxl/cxl-mailbox-utils.c
+++ b/hw/cxl/cxl-mailbox-utils.c
@@ -84,6 +84,8 @@ enum {
     DCD_CONFIG  =3D 0x48, /*r3.0: 8.2.9.8.9*/
         #define GET_DC_CONFIG          0x0
         #define GET_DYN_CAP_EXT_LIST   0x1
+        #define ADD_DYN_CAP_RSP        0x2
+        #define RELEASE_DYN_CAP        0x3
     PHYSICAL_SWITCH =3D 0x51
         #define IDENTIFY_SWITCH_DEVICE      0x0
 };
@@ -1086,6 +1088,251 @@ static CXLRetCode cmd_dcd_get_dyn_cap_ext_list(stru=
ct cxl_cmd *cmd,
     return CXL_MBOX_SUCCESS;
 }
=20
+/*
+ * Check whether the bits at addr between [nr, nr+size) are all set,
+ * return 1 if all 1s, else return 0
+ */
+static inline int test_bits(const unsigned long *addr, int nr, int size)
+{
+    unsigned long res =3D find_next_zero_bit(addr, size + nr, nr);
+
+    return (res >=3D nr + size) ? 1 : 0;
+}
+
+/*
+ * Find dynamic capacity region id based on dpa range [dpa, dpa+len)
+ */
+static uint8_t find_region_id(struct CXLType3Dev *dev, uint64_t dpa,
+        uint64_t len)
+{
+    int8_t i =3D dev->dc.num_regions - 1;
+
+    while (i > 0 && dpa < dev->dc.regions[i].base) {
+        i--;
+    }
+
+    if (dpa < dev->dc.regions[i].base
+            || dpa + len > dev->dc.regions[i].base + dev->dc.regions[i].le=
n) {
+        return dev->dc.num_regions;
+    }
+
+    return i;
+}
+
+static void insert_extent_to_extent_list(CXLDCDExtentList *list, uint64_t =
dpa,
+        uint64_t len, uint8_t *tag, uint16_t shared_seq)
+{
+    CXLDCD_Extent *extent;
+    extent =3D g_new0(CXLDCD_Extent, 1);
+    extent->start_dpa =3D dpa;
+    extent->len =3D len;
+    if (tag) {
+        memcpy(extent->tag, tag, 0x10);
+    } else {
+        memset(extent->tag, 0, 0x10);
+    }
+    extent->shared_seq =3D shared_seq;
+
+    QTAILQ_INSERT_TAIL(list, extent, node);
+}
+
+typedef struct updated_dc_extent_list_in_pl {
+    uint32_t num_entries_updated;
+    uint8_t rsvd[4];
+    struct { /* r3.0: Table 8-130 */
+        uint64_t start_dpa;
+        uint64_t len;
+        uint8_t rsvd[8];
+    } QEMU_PACKED updated_entries[];
+} QEMU_PACKED updated_dc_extent_list_in_pl;
+
+/*
+ * The function only check the input extent list against itself.
+ */
+static CXLRetCode detect_malformed_extent_list(CXLType3Dev *dev,
+        const updated_dc_extent_list_in_pl *in)
+{
+    unsigned long *blk_bitmap;
+    uint64_t min_block_size =3D dev->dc.regions[0].block_size;
+    struct CXLDCD_Region *region =3D &dev->dc.regions[0];
+    uint32_t i;
+    uint64_t dpa, len;
+    uint8_t rid;
+    CXLRetCode ret;
+
+    for (i =3D 1; i < dev->dc.num_regions; i++) {
+        region =3D &dev->dc.regions[i];
+        if (min_block_size > region->block_size) {
+            min_block_size =3D region->block_size;
+        }
+    }
+
+    blk_bitmap =3D bitmap_new((region->len + region->base
+                - dev->dc.regions[0].base) / min_block_size);
+
+    for (i =3D 0; i < in->num_entries_updated; i++) {
+        dpa =3D in->updated_entries[i].start_dpa;
+        len =3D in->updated_entries[i].len;
+
+        rid =3D find_region_id(dev, dpa, len);
+        if (rid =3D=3D dev->dc.num_regions) {
+            ret =3D CXL_MBOX_INVALID_PA;
+            goto out;
+        }
+
+        region =3D &dev->dc.regions[rid];
+        if (dpa % region->block_size || len % region->block_size) {
+            ret =3D CXL_MBOX_INVALID_EXTENT_LIST;
+            goto out;
+        }
+        /* the dpa range already covered by some other extents in the list=
 */
+        if (test_bits(blk_bitmap, dpa / min_block_size, len / min_block_si=
ze)) {
+            ret =3D CXL_MBOX_INVALID_EXTENT_LIST;
+            goto out;
+        }
+        bitmap_set(blk_bitmap, dpa / min_block_size, len / min_block_size)=
;
+   }
+
+    ret =3D CXL_MBOX_SUCCESS;
+
+out:
+    g_free(blk_bitmap);
+    return ret;
+}
+
+/*
+ * cxl spec 3.0: 8.2.9.8.9.3
+ * Add Dynamic Capacity Response (opcode 4802h)
+ * Assume an extent is added only after the response is processed successf=
ully
+ * TODO: for better extent list validation, a better solution would be
+ * maintaining a pending extent list and use it to verify the extent list =
in
+ * the response.
+ */
+static CXLRetCode cmd_dcd_add_dyn_cap_rsp(struct cxl_cmd *cmd,
+        CXLDeviceState *cxl_dstate, uint16_t *len_unused)
+{
+    updated_dc_extent_list_in_pl *in =3D (void *)cmd->payload;
+    struct CXLType3Dev *ct3d =3D container_of(cxl_dstate, CXLType3Dev,
+            cxl_dstate);
+    CXLDCDExtentList *extent_list =3D &ct3d->dc.extents;
+    CXLDCD_Extent *ent;
+    uint32_t i;
+    uint64_t dpa, len;
+    CXLRetCode ret;
+=20
+    if (in->num_entries_updated =3D=3D 0) {
+        ret =3D CXL_MBOX_SUCCESS;
+        goto out;
+    }
+
+    ret =3D detect_malformed_extent_list(ct3d, in);
+    if (ret !=3D CXL_MBOX_SUCCESS) {
+        goto out;
+    }
+
+    for (i =3D 0; i < in->num_entries_updated; i++) {
+        dpa =3D in->updated_entries[i].start_dpa;
+        len =3D in->updated_entries[i].len;
+
+        /*
+         * Check if the DPA range of the to-be-added extent overlaps with
+         * existing extent list maintained by the device.
+         */
+        QTAILQ_FOREACH(ent, extent_list, node) {
+            if (ent->start_dpa =3D=3D dpa && ent->len =3D=3D len) {
+                ret =3D CXL_MBOX_INVALID_PA;
+                goto out;
+            } else if (ent->start_dpa <=3D dpa
+                    && dpa + len <=3D ent->start_dpa + ent->len) {
+                ret =3D CXL_MBOX_INVALID_PA;
+                goto out;
+            } else if ((dpa < ent->start_dpa + ent->len
+                        && dpa + len > ent->start_dpa + ent->len)
+                    || (dpa < ent->start_dpa && dpa + len > ent->start_dpa=
)) {
+                ret =3D CXL_MBOX_INVALID_PA;
+                goto out;
+            }
+        }
+
+        /*
+         * TODO: add a pending extent list based on event log record and v=
erify
+         * the input response
+         */
+
+        insert_extent_to_extent_list(extent_list, dpa, len, NULL, 0);
+    }
+    ret =3D CXL_MBOX_SUCCESS;
+
+out:
+    return ret;
+}
+
+/*
+ * Spec 3.0: 8.2.9.8.9.4
+ * Release Dynamic Capacity (opcode 4803h)
+ **/
+static CXLRetCode cmd_dcd_release_dyn_cap(struct cxl_cmd *cmd,
+        CXLDeviceState *cxl_dstate,
+        uint16_t *len_unused)
+{
+    updated_dc_extent_list_in_pl *in =3D (void *)cmd->payload;
+    struct CXLType3Dev *ct3d =3D container_of(cxl_dstate, CXLType3Dev,
+            cxl_dstate);
+    CXLDCDExtentList *extent_list =3D &ct3d->dc.extents;
+    CXLDCD_Extent *ent;
+    uint32_t i;
+    uint64_t dpa, len;
+    CXLRetCode ret;
+
+    if (in->num_entries_updated =3D=3D 0) {
+        return CXL_MBOX_INVALID_INPUT;
+    }
+
+    ret =3D detect_malformed_extent_list(ct3d, in);
+    if (ret !=3D CXL_MBOX_SUCCESS) {
+        return ret;
+    }
+
+    for (i =3D 0; i < in->num_entries_updated; i++) {
+        dpa =3D in->updated_entries[i].start_dpa;
+        len =3D in->updated_entries[i].len;
+
+        QTAILQ_FOREACH(ent, extent_list, node) {
+            if (ent->start_dpa =3D=3D dpa && ent->len =3D=3D len) {
+                break;
+            } else if (ent->start_dpa < dpa
+                    && dpa + len <=3D ent->start_dpa + ent->len) {
+                /* remove partial extent */
+                uint64_t len1 =3D dpa - ent->start_dpa;
+                uint64_t len2 =3D ent->start_dpa + ent->len - dpa - len;
+
+                if (len1) {
+                    insert_extent_to_extent_list(extent_list, ent->start_d=
pa,
+                            len1, NULL, 0);
+                }
+                if (len2) {
+                    insert_extent_to_extent_list(extent_list, dpa + len, l=
en2,
+                            NULL, 0);
+                }
+                break;
+            } else if ((dpa < ent->start_dpa + ent->len
+                        && dpa + len > ent->start_dpa + ent->len)
+                    || (dpa < ent->start_dpa && dpa + len > ent->start_dpa=
))
+                return CXL_MBOX_INVALID_EXTENT_LIST;
+        }
+
+        if (ent) {
+            QTAILQ_REMOVE(extent_list, ent, node);
+            g_free(ent);
+        } else {
+            /* Try to remove a non-existing extent */
+            return CXL_MBOX_INVALID_PA;
+        }
+    }
+
+    return CXL_MBOX_SUCCESS;
+}
+=20
 #define IMMEDIATE_CONFIG_CHANGE (1 << 1)
 #define IMMEDIATE_DATA_CHANGE (1 << 2)
 #define IMMEDIATE_POLICY_CHANGE (1 << 3)
@@ -1129,6 +1376,12 @@ static struct cxl_cmd cxl_cmd_set[256][256] =3D {
     [DCD_CONFIG][GET_DYN_CAP_EXT_LIST] =3D {
         "DCD_GET_DYNAMIC_CAPACITY_EXTENT_LIST", cmd_dcd_get_dyn_cap_ext_li=
st,
         8, 0 },
+    [DCD_CONFIG][ADD_DYN_CAP_RSP] =3D {
+        "ADD_DCD_DYNAMIC_CAPACITY_RESPONSE", cmd_dcd_add_dyn_cap_rsp,
+        ~0, IMMEDIATE_DATA_CHANGE },
+    [DCD_CONFIG][RELEASE_DYN_CAP] =3D {
+        "RELEASE_DCD_DYNAMIC_CAPACITY", cmd_dcd_release_dyn_cap,
+        ~0, IMMEDIATE_DATA_CHANGE },
 };
=20
 static struct cxl_cmd cxl_cmd_set_sw[256][256] =3D {
diff --git a/include/hw/cxl/cxl_device.h b/include/hw/cxl/cxl_device.h
index 3a338b3b37..01a5eaca48 100644
--- a/include/hw/cxl/cxl_device.h
+++ b/include/hw/cxl/cxl_device.h
@@ -130,7 +130,8 @@ typedef enum {
     CXL_MBOX_INCORRECT_PASSPHRASE =3D 0x14,
     CXL_MBOX_UNSUPPORTED_MAILBOX =3D 0x15,
     CXL_MBOX_INVALID_PAYLOAD_LENGTH =3D 0x16,
-    CXL_MBOX_MAX =3D 0x17
+    CXL_MBOX_INVALID_EXTENT_LIST =3D 0x1E, /* cxl r3.0: Table 8-34*/
+    CXL_MBOX_MAX =3D 0x1F
 } CXLRetCode;
=20
 struct cxl_cmd;
--=20
2.25.1

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id AC5A1C04E69
	for <linux-cxl@archiver.kernel.org>; Tue, 25 Jul 2023 18:40:16 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S231824AbjGYSkP (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 25 Jul 2023 14:40:15 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:44790 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S231698AbjGYSkE (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 25 Jul 2023 14:40:04 -0400
Received: from mailout1.w2.samsung.com (mailout1.w2.samsung.com [211.189.100.11])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id A8D9E212A
        for <linux-cxl@vger.kernel.org>; Tue, 25 Jul 2023 11:39:59 -0700 (PDT)
Received: from uscas1p2.samsung.com (unknown [182.198.245.207])
        by mailout1.w2.samsung.com (KnoxPortal) with ESMTP id 20230725183957usoutp01cb0ac2b7d0945f87dcc750325c3c5dca~1MFm2x1Ci1107711077usoutp01t;
        Tue, 25 Jul 2023 18:39:57 +0000 (GMT)
DKIM-Filter: OpenDKIM Filter v2.11.0 mailout1.w2.samsung.com 20230725183957usoutp01cb0ac2b7d0945f87dcc750325c3c5dca~1MFm2x1Ci1107711077usoutp01t
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=samsung.com;
        s=mail20170921; t=1690310397;
        bh=B1j67K7Wo9LB7R3854Ms8sUmfcxuACxDq7d7l8I3jpQ=;
        h=From:To:CC:Subject:Date:References:From;
        b=WNtt5pMK94OK6Vmm6bWyFrK35uvZryYfkPY6w+NqxRPFAyw4n3Vg5zGOkC6jHJibQ
         SIv7dJkyymB5p5c/biYQWLSuQ+UQXgZlni5Lzitv6N4OSXtuZT6MHVuQ+pgljaqwpq
         7WNNX1YY5Txn/iqwR2lY6sLrleyBRCVXpQ91hPDM=
Received: from ussmges1new.samsung.com (u109.gpu85.samsung.co.kr
        [203.254.195.109]) by uscas1p1.samsung.com (KnoxPortal) with ESMTP id
        20230725183956uscas1p19e375d2106e3399f7a8036e23a16153f~1MFmr36MM2195121951uscas1p1m;
        Tue, 25 Jul 2023 18:39:56 +0000 (GMT)
Received: from uscas1p1.samsung.com ( [182.198.245.206]) by
        ussmges1new.samsung.com (USCPEMTA) with SMTP id 42.DD.51475.CF610C46; Tue,
        25 Jul 2023 14:39:56 -0400 (EDT)
Received: from ussmgxs2new.samsung.com (u91.gpu85.samsung.co.kr
        [203.254.195.91]) by uscas1p1.samsung.com (KnoxPortal) with ESMTP id
        20230725183956uscas1p154e945516c2a4091479f4906d7652648~1MFmIgDjd1452314523uscas1p1B;
        Tue, 25 Jul 2023 18:39:56 +0000 (GMT)
X-AuditID: cbfec36d-8a3ff7000001c913-3e-64c016fc5d02
Received: from SSI-EX1.ssi.samsung.com ( [105.128.2.145]) by
        ussmgxs2new.samsung.com (USCPEXMTA) with SMTP id E2.83.44215.BF610C46; Tue,
        25 Jul 2023 14:39:56 -0400 (EDT)
Received: from SSI-EX2.ssi.samsung.com (105.128.2.227) by
        SSI-EX1.ssi.samsung.com (105.128.2.226) with Microsoft SMTP Server
        (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384) id
        15.1.2375.24; Tue, 25 Jul 2023 11:39:55 -0700
Received: from SSI-EX2.ssi.samsung.com ([105.128.2.227]) by
        SSI-EX2.ssi.samsung.com ([105.128.2.227]) with mapi id 15.01.2375.024; Tue,
        25 Jul 2023 11:39:55 -0700
From: Fan Ni <fan.ni@samsung.com>
To: "qemu-devel@nongnu.org" <qemu-devel@nongnu.org>
CC: "jonathan.cameron@huawei.com" <jonathan.cameron@huawei.com>,
        "linux-cxl@vger.kernel.org" <linux-cxl@vger.kernel.org>,
        "gregory.price@memverge.com" <gregory.price@memverge.com>,
        "hchkuo@avery-design.com.tw" <hchkuo@avery-design.com.tw>,
        "cbrowy@avery-design.com" <cbrowy@avery-design.com>,
        "ira.weiny@intel.com" <ira.weiny@intel.com>,
        "dan.j.williams@intel.com" <dan.j.williams@intel.com>,
        Adam Manzanares <a.manzanares@samsung.com>,
        "dave@stgolabs.net" <dave@stgolabs.net>,
        "nmtadam.samsung@gmail.com" <nmtadam.samsung@gmail.com>,
        "nifan@outlook.com" <nifan@outlook.com>,
        Fan Ni <fan.ni@samsung.com>
Subject: [Qemu PATCH v2 0/9] Enabling DCD emulation support in Qemu
Thread-Topic: [Qemu PATCH v2 0/9] Enabling DCD emulation support in Qemu
Thread-Index: AQHZvydn8pbwbQd4g0ikjj4shw3FGw==
Date: Tue, 25 Jul 2023 18:39:55 +0000
Message-ID: <20230725183939.2741025-1-fan.ni@samsung.com>
Accept-Language: en-US
Content-Language: en-US
X-MS-Has-Attach: 
X-MS-TNEF-Correlator: 
x-mailer: git-send-email 2.25.1
x-originating-ip: [105.128.2.176]
Content-Type: text/plain; charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable
MIME-Version: 1.0
X-CFilter-Loop: Reflected
X-Brightmail-Tracker: H4sIAAAAAAAAA+NgFjrDKsWRmVeSWpSXmKPExsWy7djXc7p/xA6kGDxeoG3RfX4Do8X0qRcY
        LVbfXMNo0dD0iMWiZfd7Jov9T5+zWKxaeI3N4vysUywWzyc+Z7JYuuQRs8Xx3h0sDtweFyZP
        YPVY3ODqsXPWXXaPliNvgbw9L5k8Nn78z+7x5NpmJo/Nr18we0ydXe/xeZNcAFcUl01Kak5m
        WWqRvl0CV8bl/rVsBXt5Kq696GJrYJzK1cXIySEhYCLxZnc3SxcjF4eQwEpGiQvvnjFBOK1M
        EqfP/2aEqXq5ZyI7RGIto8Tqy41QVZ8YJbrO/IXqX8Yo0dp6mhWkhU1AUWJf13Y2EFtEwFji
        2OElzCBFzAJvWSQ+rnnDApIQFnCWWNrxigWiyENi6YH9rBC2nsSyZTeZQWwWAVWJjpU7mEBs
        XgFLif2LZ4LVMAqISXw/tQYsziwgLnHryXwmiFsFJRbN3sMMYYtJ/Nv1kA3ClpeY/GMGlK0o
        cf/7S3aIXj2JG1OnsEHY2hLLFr5mhtglKHFy5hMWiHpJiYMrboB9KSHwhUPizMWjrBAJF4kt
        i1ugFktL/L27DMjmALKTJVZ9hIZwjsT8JVug5lhLLPyzHupmPom/vx4xTmBUnoXkhVlITpqF
        5KRZSE5awMiyilG8tLg4Nz212DAvtVyvODG3uDQvXS85P3cTIzDBnf53OHcH445bH/UOMTJx
        MB5ilOBgVhLhNYzZlyLEm5JYWZValB9fVJqTWnyIUZqDRUmc19D2ZLKQQHpiSWp2ampBahFM
        lomDU6qBaQLX/Po1k3cfz6/aFJKgtH3WBp1pa/ceKJ5+m020YN+W6Lv7+SYmm3zdsMhvf/Rl
        taATH1wLJaz1p0ZejNCTr/ZTt/Fr7lTl3coumK932H4ee5RzfZWK2Nvj2c9XanSGeSvouRjz
        WPz4by/14FxsSm0Zr9dlxUNKxpcezw1zPsPjx/H/uo2nn6XdaxU31SzzHdySn668yxKP5uJ/
        Kv7F12z6pnU32qa7l5y9pWW7y3j6nnvn+5InWH5zOBApqxq99m6k6ITepLkq004WivOsyF9Q
        PCPPw+6fmk+o7ESjTWzv3n3Z/NL4RciDZ8IK+3tFZvlfX7awYmeLXSRXp/KmD4ffqVR+u6Br
        v5/Z5O5MJZbijERDLeai4kQA+lsPat8DAAA=
X-Brightmail-Tracker: H4sIAAAAAAAAA+NgFrrIIsWRmVeSWpSXmKPExsWS2cA0UfeP2IEUg4/rOC26z29gtJg+9QKj
        xeqbaxgtGpoesVi07H7PZLH/6XMWi1ULr7FZnJ91isXi+cTnTBZLlzxitjjeu4PFgdvjwuQJ
        rB6LG1w9ds66y+7RcuQtkLfnJZPHxo//2T2eXNvM5LH59Qtmj6mz6z0+b5IL4IrisklJzcks
        Sy3St0vgyrjcv5atYC9PxbUXXWwNjFO5uhg5OSQETCRe7pnI3sXIxSEksJpR4sTeZhYI5xOj
        xPXzP5ghnGWMEosPL2AHaWETUJTY17WdDcQWETCWOHZ4CTOIzSzwmkXi20VuEFtYwFliaccr
        FogaD4mlB/azQth6EsuW3QSrZxFQlehYuYMJxOYVsJTYv3gmWA2jgJjE91NrmCBmikvcejKf
        CeJUAYkle84zQ9iiEi8f/2OFsOUlJv+YwQZhK0rc//6SHaJXT+LG1ClsELa2xLKFr5khdglK
        nJz5hAWiXlLi4IobLBMYxWYhWTcLSfssJO2zkLQvYGRZxSheWlycm15RbJSXWq5XnJhbXJqX
        rpecn7uJERjrp/8djt7BePvWR71DjEwcjIcYJTiYlUR4DWP2pQjxpiRWVqUW5ccXleakFh9i
        lOZgURLnfRk1MV5IID2xJDU7NbUgtQgmy8TBKdXAFO6XmZf79vZCU5POyxVXN5w8oL5Lynzy
        konPqt+ftlgjz229MeBTx4Le2ET1wOneMczmYqu4pA7ELmr++Heq+FyWKstqA5MZGaV7NBuV
        7wbxSi0780fZa2Z+AsfDrUV//s/VCQ5eInDx+F6Re4v9XjwP5gvU9Ph5x32BDvOeu2V+6fVb
        9paIub+y35yxxiHro99kVcVi3+lxdmkctkcKd3JPfsRlqiscsqw0YUHcgppljutVzVz5xGW/
        Bh/4Y1ReyTRpmfvWae9yXLO7v8XPm2auVbngUZ1tiH1pMuvujLf/HNLt2/c1PbztkrShJlFQ
        +UThSbM8HQepjNx65Z3dst5yvyTXl/VmsZtOFVNiKc5INNRiLipOBADZ1pLiZAMAAA==
X-CMS-MailID: 20230725183956uscas1p154e945516c2a4091479f4906d7652648
CMS-TYPE: 301P
X-CMS-RootMailID: 20230725183956uscas1p154e945516c2a4091479f4906d7652648
References: <CGME20230725183956uscas1p154e945516c2a4091479f4906d7652648@uscas1p1.samsung.com>
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

v1[1]->v2:

1. fix a regression issue reported by Ira[2]:
2. fix a compile warning due to uninitialized 'rip' in qmp processing funct=
ion.


[1] https://lore.kernel.org/linux-cxl/20230724162313.34196-1-fan.ni@samsung=
.com/T/#t
[2] https://lore.kernel.org/linux-cxl/64bfe7b090843_12757b2945b@iweiny-mobl=
.notmuch/T/#m09983a3dbaa9135a850e345d86714bf2ab957ef6

Fan Ni (9):
  hw/cxl/cxl-mailbox-utils: Add dc_event_log_size field to output
    payload of identify memory device command
  hw/cxl/cxl-mailbox-utils: Add dynamic capacity region representative
    and mailbox command support
  include/hw/cxl/cxl_device: Rename mem_size as static_mem_size for
    type3 memory devices
  hw/mem/cxl_type3: Add support to create DC regions to type3 memory
    devices
  hw/mem/cxl_type3: Add host backend and address space handling for DC
    regions
  hw/mem/cxl_type3: Add DC extent list representative and get DC extent
    list mailbox support
  hw/cxl/cxl-mailbox-utils: Add mailbox commands to support add/release
    dynamic capacity response
  hw/cxl/events: Add qmp interfaces to add/release dynamic capacity
    extents
  hw/mem/cxl_type3: Add dpa range validation for accesses to dc regions

 hw/cxl/cxl-mailbox-utils.c  | 424 +++++++++++++++++++++++++++-
 hw/mem/cxl_type3.c          | 545 +++++++++++++++++++++++++++++++++---
 hw/mem/cxl_type3_stubs.c    |   6 +
 include/hw/cxl/cxl_device.h |  50 +++-
 include/hw/cxl/cxl_events.h |  16 ++
 qapi/cxl.json               |  49 ++++
 6 files changed, 1044 insertions(+), 46 deletions(-)

--=20
2.25.1

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 24437C04A6A
	for <linux-cxl@archiver.kernel.org>; Tue, 25 Jul 2023 18:40:15 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S229995AbjGYSkN (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 25 Jul 2023 14:40:13 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:44798 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S231840AbjGYSkF (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 25 Jul 2023 14:40:05 -0400
Received: from mailout1.w2.samsung.com (mailout1.w2.samsung.com [211.189.100.11])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id A9036212E
        for <linux-cxl@vger.kernel.org>; Tue, 25 Jul 2023 11:39:59 -0700 (PDT)
Received: from uscas1p1.samsung.com (unknown [182.198.245.206])
        by mailout1.w2.samsung.com (KnoxPortal) with ESMTP id 20230725183957usoutp01386a59245c416eb4887c2a2ab995ff0d~1MFnKlaFM1107111071usoutp01t;
        Tue, 25 Jul 2023 18:39:57 +0000 (GMT)
DKIM-Filter: OpenDKIM Filter v2.11.0 mailout1.w2.samsung.com 20230725183957usoutp01386a59245c416eb4887c2a2ab995ff0d~1MFnKlaFM1107111071usoutp01t
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=samsung.com;
        s=mail20170921; t=1690310397;
        bh=378aU1/0ie9wyBAWxyGSYcYy2mOtEBM2RX8oNqSnjj4=;
        h=From:To:CC:Subject:Date:In-Reply-To:References:From;
        b=BpOYCvsYNGSfflipjLoaWrzqRrbHpIfIj/sw4BNgJ4nYioGESaJNyj3ipzAgqhnp0
         VCMfgiYdgnKYlxfr3ZoIJSypbyoyLJmnwVlUsQmNLdrxp/B8WycmkJYTLNJQot2EAQ
         BR0YUHmXctqRD8aXKk9+y78FKb9Tpjv8bzD5L1iI=
Received: from ussmges3new.samsung.com (u112.gpu85.samsung.co.kr
        [203.254.195.112]) by uscas1p2.samsung.com (KnoxPortal) with ESMTP id
        20230725183957uscas1p29cab1dc7eab27d69683f931aa08285e5~1MFnAQJZs1580215802uscas1p24;
        Tue, 25 Jul 2023 18:39:57 +0000 (GMT)
Received: from uscas1p1.samsung.com ( [182.198.245.206]) by
        ussmges3new.samsung.com (USCPEMTA) with SMTP id 39.4E.62237.DF610C46; Tue,
        25 Jul 2023 14:39:57 -0400 (EDT)
Received: from ussmgxs1new.samsung.com (u89.gpu85.samsung.co.kr
        [203.254.195.89]) by uscas1p2.samsung.com (KnoxPortal) with ESMTP id
        20230725183956uscas1p2008fba59779b70405c74d28a30e4fbaa~1MFmrSVuy1580215802uscas1p23;
        Tue, 25 Jul 2023 18:39:56 +0000 (GMT)
X-AuditID: cbfec370-b17ff7000001f31d-91-64c016fd67ca
Received: from SSI-EX2.ssi.samsung.com ( [105.128.2.145]) by
        ussmgxs1new.samsung.com (USCPEXMTA) with SMTP id E2.54.38326.CF610C46; Tue,
        25 Jul 2023 14:39:56 -0400 (EDT)
Received: from SSI-EX2.ssi.samsung.com (105.128.2.227) by
        SSI-EX2.ssi.samsung.com (105.128.2.227) with Microsoft SMTP Server
        (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384) id
        15.1.2375.24; Tue, 25 Jul 2023 11:39:56 -0700
Received: from SSI-EX2.ssi.samsung.com ([105.128.2.227]) by
        SSI-EX2.ssi.samsung.com ([105.128.2.227]) with mapi id 15.01.2375.024; Tue,
        25 Jul 2023 11:39:56 -0700
From: Fan Ni <fan.ni@samsung.com>
To: "qemu-devel@nongnu.org" <qemu-devel@nongnu.org>
CC: "jonathan.cameron@huawei.com" <jonathan.cameron@huawei.com>,
        "linux-cxl@vger.kernel.org" <linux-cxl@vger.kernel.org>,
        "gregory.price@memverge.com" <gregory.price@memverge.com>,
        "hchkuo@avery-design.com.tw" <hchkuo@avery-design.com.tw>,
        "cbrowy@avery-design.com" <cbrowy@avery-design.com>,
        "ira.weiny@intel.com" <ira.weiny@intel.com>,
        "dan.j.williams@intel.com" <dan.j.williams@intel.com>,
        Adam Manzanares <a.manzanares@samsung.com>,
        "dave@stgolabs.net" <dave@stgolabs.net>,
        "nmtadam.samsung@gmail.com" <nmtadam.samsung@gmail.com>,
        "nifan@outlook.com" <nifan@outlook.com>,
        Fan Ni <fan.ni@samsung.com>
Subject: [Qemu PATCH v2 4/9] hw/mem/cxl_type3: Add support to create DC
 regions to type3 memory devices
Thread-Topic: [Qemu PATCH v2 4/9] hw/mem/cxl_type3: Add support to create DC
        regions to type3 memory devices
Thread-Index: AQHZvydoCwFjnM0gJE6KDcVANjM/Og==
Date: Tue, 25 Jul 2023 18:39:55 +0000
Message-ID: <20230725183939.2741025-5-fan.ni@samsung.com>
In-Reply-To: <20230725183939.2741025-1-fan.ni@samsung.com>
Accept-Language: en-US
Content-Language: en-US
X-MS-Has-Attach: 
X-MS-TNEF-Correlator: 
x-mailer: git-send-email 2.25.1
x-originating-ip: [105.128.2.176]
Content-Type: text/plain; charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable
MIME-Version: 1.0
X-CFilter-Loop: Reflected
X-Brightmail-Tracker: H4sIAAAAAAAAA+NgFjrJKsWRmVeSWpSXmKPExsWy7djXc7p/xQ6kGCzayWLRfX4Do8X0qRcY
        LVbfXMNo0dD0iMWiZfd7Jov9T5+zWKxaeI3N4vysUywWzyc+Z7JYuuQRs8Xx3h0sDtweFyZP
        YPVY3ODqsXPWXXaPliNvgbw9L5k8Nn78z+7x5NpmJo/Nr18we0ydXe/xeZNcAFcUl01Kak5m
        WWqRvl0CV8ad5v9MBSskKhY1XGNsYNwt3MXIySEhYCLxa/N+dhBbSGAlo8SKpbxdjFxAdiuT
        xPIpv9lhik5f+8QOkVjLKLHxxwYWCOcTo0TD6wdMEM4yRok37b+YQVrYBBQl9nVtZwOxRQSM
        JY4dXsIMUsQs8JZF4uOaNywgCWGBTIl9246zQBTlSdz5uRzK1pO43r0HzGYRUJXoWLmDCcTm
        FbCUmPVkE9hQTgEriWdfZrOC2IwCYhLfT60Bq2EWEJe49WQ+E8TdghKLZu9hhrDFJP7tesgG
        YctLTP4xA8pWlLj//SU7RK+exI2pU9ggbG2JZQtfM0PsFZQ4OfMJC0S9pMTBFTeg7MmcEs/P
        23QxcgDZLhL7/qpAhKUlrl6fygwRTpZY9ZELIpwjMX/JFqhOa4mFf9YzTWBUmYXk6FlIjpiF
        5IhZSI5YwMiyilG8tLg4Nz212DgvtVyvODG3uDQvXS85P3cTIzC1nf53uGAH461bH/UOMTJx
        MB5ilOBgVhLhNYzZlyLEm5JYWZValB9fVJqTWnyIUZqDRUmc19D2ZLKQQHpiSWp2ampBahFM
        lomDU6qBacL8qHIrz7oZ3FcFWQLXenA+/LXnwJ7psjsndhp+uuckHLbx79aPtUFvXkjtcNFY
        v25u6sXfF9wPKS6dGNO3PWGXl0U529YrDOJRsyet+6e3Zff5Y2tF7Nl4J9VzXV4wYcv2VUl6
        19aesV3rb6R2g2lK3rNQ0Vj/s1qGK5ckGUQwPVAzLjLc1jrjKnORhMC/7AMru2P3uF/p3d8k
        2ni6/Yna6ZwkdtN7Sz5srfZvY9fcXflgnebPE61PNvPPyb7yqFLuRu7rO+cCnncbtP10rPp1
        SqdmXu/mYrWHYTHyGj61iT9X5AS+P8CQPq2KL/rk439Lf+SVHFdYmPJVeP+UnxvqJ/tkPJ5c
        nMH202fag5tKLMUZiYZazEXFiQDh7ToF3AMAAA==
X-Brightmail-Tracker: H4sIAAAAAAAAA+NgFnrOIsWRmVeSWpSXmKPExsWS2cA0UfeP2IEUg+ZbWhbd5zcwWkyfeoHR
        YvXNNYwWDU2PWCxadr9nstj/9DmLxaqF19gszs86xWLxfOJzJoulSx4xWxzv3cHiwO1xYfIE
        Vo/FDa4eO2fdZfdoOfIWyNvzkslj48f/7B5Prm1m8tj8+gWzx9TZ9R6fN8kFcEVx2aSk5mSW
        pRbp2yVwZdxp/s9UsEKiYlHDNcYGxt3CXYycHBICJhKnr31i72Lk4hASWM0ocXF3BxOE84lR
        om3RaWYIZxmjxPzFqxlBWtgEFCX2dW1nA7FFBIwljh1ewgxiMwu8ZpH4dpEbxBYWyJTYt+04
        SxcjB1BNnsT36/IQ5XoS17v3sIDYLAKqEh0rdzCB2LwClhKznmxiAykXArK3TowDCXMKWEk8
        +zKbFcRmFBCT+H5qDRPEJnGJW0/mM0E8ICCxZM95ZghbVOLl43+sELa8xOQfM9ggbEWJ+99f
        skP06kncmDqFDcLWlli28DUzxAmCEidnPmGBqJeUOLjiBssERolZSNbNQtI+C0n7LCTtCxhZ
        VjGKlxYX56ZXFBvmpZbrFSfmFpfmpesl5+duYgSmhdP/DkfuYDx666PeIUYmDsZDjBIczEoi
        vIYx+1KEeFMSK6tSi/Lji0pzUosPMUpzsCiJ8wq5TowXEkhPLEnNTk0tSC2CyTJxcEo1MImu
        a/q+c11zlr5K8+Poitnr9s2Uyr5sJf9iSXTPNsVSz8qF09SP8Uc9ei4ufXOjYvJlibxOXpGi
        l7u3+hTZKLot/bZZ+QnH5XNmqrNDvnQ7GHzLTm6wen5rj/f88h4zw8fzVq7fXjG3XvdrVPNs
        vpIaeU431onCr4TZq6auCYsO+fPEyF3U3MOap2fzPo/y5A/d872uyn14eucIZ5exFe9tCaZr
        OoWnzq1Z8f1UzAEfntWXlcLKu+VPhsdxH246W3CQq/65Sk1cpvt0prrUpL+VaTyhB/zXLo0P
        37bwTbiI86yGL90fBV5m7d7Eey9OsTJHKvjfLu/jm2zjeh+9Kde7WsnmcfW9pkl1kfNMJZbi
        jERDLeai4kQAM1kx7HoDAAA=
X-CMS-MailID: 20230725183956uscas1p2008fba59779b70405c74d28a30e4fbaa
CMS-TYPE: 301P
X-CMS-RootMailID: 20230725183956uscas1p2008fba59779b70405c74d28a30e4fbaa
References: <20230725183939.2741025-1-fan.ni@samsung.com>
        <CGME20230725183956uscas1p2008fba59779b70405c74d28a30e4fbaa@uscas1p2.samsung.com>
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

From: Fan Ni <nifan@outlook.com>

With the change, when setting up memory for type3 memory device, we can
create DC regions
A property 'num-dc-regions' is added to ct3_props to allow users to pass th=
e
number of DC regions to create. To make it easier, other region parameters
like region base, length, and block size are hard coded. If needed,
these parameters can be added easily.

With the change, we can create DC regions with proper kernel side
support as below:

region=3D$(cat /sys/bus/cxl/devices/decoder0.0/create_dc_region)
echo $region> /sys/bus/cxl/devices/decoder0.0/create_dc_region
echo 256 > /sys/bus/cxl/devices/$region/interleave_granularity
echo 1 > /sys/bus/cxl/devices/$region/interleave_ways

echo "dc0" >/sys/bus/cxl/devices/decoder2.0/mode
echo 0x40000000 >/sys/bus/cxl/devices/decoder2.0/dpa_size

echo 0x40000000 > /sys/bus/cxl/devices/$region/size
echo  "decoder2.0" > /sys/bus/cxl/devices/$region/target0
echo 1 > /sys/bus/cxl/devices/$region/commit
echo $region > /sys/bus/cxl/drivers/cxl_region/bind

Signed-off-by: Fan Ni <fan.ni@samsung.com>
---
 hw/mem/cxl_type3.c | 33 +++++++++++++++++++++++++++++++++
 1 file changed, 33 insertions(+)

diff --git a/hw/mem/cxl_type3.c b/hw/mem/cxl_type3.c
index 3d7acffcb7..b29bb2309a 100644
--- a/hw/mem/cxl_type3.c
+++ b/hw/mem/cxl_type3.c
@@ -707,6 +707,34 @@ static void ct3d_reg_write(void *opaque, hwaddr offset=
, uint64_t value,
     }
 }
=20
+/*
+ * Create a dc region to test "Get Dynamic Capacity Configuration" command=
.
+ */
+static int cxl_create_dc_regions(CXLType3Dev *ct3d)
+{
+    int i;
+    uint64_t region_base =3D (ct3d->hostvmem ? ct3d->hostvmem->size : 0)
+        + (ct3d->hostpmem ? ct3d->hostpmem->size : 0);
+    uint64_t region_len =3D (uint64_t)2 * 1024 * 1024 * 1024;
+    uint64_t decode_len =3D 4; /* 4*256MB */
+    uint64_t blk_size =3D 2 * 1024 * 1024;
+    struct CXLDCD_Region *region;
+
+    for (i =3D 0; i < ct3d->dc.num_regions; i++) {
+        region =3D &ct3d->dc.regions[i];
+        region->base =3D region_base;
+        region->decode_len =3D decode_len;
+        region->len =3D region_len;
+        region->block_size =3D blk_size;
+        /* dsmad_handle is set when creating cdat table entries */
+        region->flags =3D 0;
+
+        region_base +=3D region->len;
+    }
+
+    return 0;
+}
+
 static bool cxl_setup_memory(CXLType3Dev *ct3d, Error **errp)
 {
     DeviceState *ds =3D DEVICE(ct3d);
@@ -775,6 +803,10 @@ static bool cxl_setup_memory(CXLType3Dev *ct3d, Error =
**errp)
         g_free(p_name);
     }
=20
+    if (cxl_create_dc_regions(ct3d)) {
+        return false;
+    }
+
     return true;
 }
=20
@@ -1068,6 +1100,7 @@ static Property ct3_props[] =3D {
     DEFINE_PROP_UINT64("sn", CXLType3Dev, sn, UI64_NULL),
     DEFINE_PROP_STRING("cdat", CXLType3Dev, cxl_cstate.cdat.filename),
     DEFINE_PROP_UINT16("spdm", CXLType3Dev, spdm_port, 0),
+    DEFINE_PROP_UINT8("num-dc-regions", CXLType3Dev, dc.num_regions, 0),
     DEFINE_PROP_END_OF_LIST(),
 };
=20
--=20
2.25.1

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id D3833C00528
	for <linux-cxl@archiver.kernel.org>; Tue, 25 Jul 2023 18:40:15 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S231506AbjGYSkP (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 25 Jul 2023 14:40:15 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:44800 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S231853AbjGYSkF (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 25 Jul 2023 14:40:05 -0400
Received: from mailout1.w2.samsung.com (mailout1.w2.samsung.com [211.189.100.11])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 5E3F6212D
        for <linux-cxl@vger.kernel.org>; Tue, 25 Jul 2023 11:39:59 -0700 (PDT)
Received: from uscas1p2.samsung.com (unknown [182.198.245.207])
        by mailout1.w2.samsung.com (KnoxPortal) with ESMTP id 20230725183957usoutp0181b63791b8fd5bcf0241df45cedcc66c~1MFniA3Zc1034510345usoutp01W;
        Tue, 25 Jul 2023 18:39:57 +0000 (GMT)
DKIM-Filter: OpenDKIM Filter v2.11.0 mailout1.w2.samsung.com 20230725183957usoutp0181b63791b8fd5bcf0241df45cedcc66c~1MFniA3Zc1034510345usoutp01W
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=samsung.com;
        s=mail20170921; t=1690310397;
        bh=QeyB8uxIUqjoxKrMmz+AjPCe1zFk9SF+BxXjnc8gHjU=;
        h=From:To:CC:Subject:Date:In-Reply-To:References:From;
        b=bORs5KVhSsnK4ddXVm1eFZbY7p3gRCsFeHCEaK3hlIN9qvkQ1HFrxBjJ8yMpADVbs
         Jh1prTo5+BhU8AXgf82Cc+K42qn5e2wQTza7vUDLQUXH4EBytmxLkPoejZDoihF4df
         ycasaZas144BrqRHr5pqbMxze/KyL1z7W4srUZRM=
Received: from ussmges2new.samsung.com (u111.gpu85.samsung.co.kr
        [203.254.195.111]) by uscas1p1.samsung.com (KnoxPortal) with ESMTP id
        20230725183957uscas1p1dfc3e7525e765eff3555a8bed5c38df2~1MFnV-LlP1453314533uscas1p16;
        Tue, 25 Jul 2023 18:39:57 +0000 (GMT)
Received: from uscas1p1.samsung.com ( [182.198.245.206]) by
        ussmges2new.samsung.com (USCPEMTA) with SMTP id 82.11.42611.DF610C46; Tue,
        25 Jul 2023 14:39:57 -0400 (EDT)
Received: from ussmgxs3new.samsung.com (u92.gpu85.samsung.co.kr
        [203.254.195.92]) by uscas1p1.samsung.com (KnoxPortal) with ESMTP id
        20230725183957uscas1p1eeb8e8eccc6c00b460d183027642374b~1MFm4O7XX0903609036uscas1p1v;
        Tue, 25 Jul 2023 18:39:57 +0000 (GMT)
X-AuditID: cbfec36f-fb1ff7000000a673-43-64c016fd47e9
Received: from SSI-EX3.ssi.samsung.com ( [105.128.2.146]) by
        ussmgxs3new.samsung.com (USCPEXMTA) with SMTP id C8.DA.64580.CF610C46; Tue,
        25 Jul 2023 14:39:56 -0400 (EDT)
Received: from SSI-EX2.ssi.samsung.com (105.128.2.227) by
        SSI-EX3.ssi.samsung.com (105.128.2.228) with Microsoft SMTP Server
        (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384) id
        15.1.2375.24; Tue, 25 Jul 2023 11:39:56 -0700
Received: from SSI-EX2.ssi.samsung.com ([105.128.2.227]) by
        SSI-EX2.ssi.samsung.com ([105.128.2.227]) with mapi id 15.01.2375.024; Tue,
        25 Jul 2023 11:39:56 -0700
From: Fan Ni <fan.ni@samsung.com>
To: "qemu-devel@nongnu.org" <qemu-devel@nongnu.org>
CC: "jonathan.cameron@huawei.com" <jonathan.cameron@huawei.com>,
        "linux-cxl@vger.kernel.org" <linux-cxl@vger.kernel.org>,
        "gregory.price@memverge.com" <gregory.price@memverge.com>,
        "hchkuo@avery-design.com.tw" <hchkuo@avery-design.com.tw>,
        "cbrowy@avery-design.com" <cbrowy@avery-design.com>,
        "ira.weiny@intel.com" <ira.weiny@intel.com>,
        "dan.j.williams@intel.com" <dan.j.williams@intel.com>,
        Adam Manzanares <a.manzanares@samsung.com>,
        "dave@stgolabs.net" <dave@stgolabs.net>,
        "nmtadam.samsung@gmail.com" <nmtadam.samsung@gmail.com>,
        "nifan@outlook.com" <nifan@outlook.com>,
        Fan Ni <fan.ni@samsung.com>
Subject: [Qemu PATCH v2 5/9] hw/mem/cxl_type3: Add host backend and address
 space handling for DC regions
Thread-Topic: [Qemu PATCH v2 5/9] hw/mem/cxl_type3: Add host backend and
        address space handling for DC regions
Thread-Index: AQHZvydo9CDYVoLKukCzVG4QTwqoCg==
Date: Tue, 25 Jul 2023 18:39:56 +0000
Message-ID: <20230725183939.2741025-6-fan.ni@samsung.com>
In-Reply-To: <20230725183939.2741025-1-fan.ni@samsung.com>
Accept-Language: en-US
Content-Language: en-US
X-MS-Has-Attach: 
X-MS-TNEF-Correlator: 
x-mailer: git-send-email 2.25.1
x-originating-ip: [105.128.2.176]
Content-Type: text/plain; charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable
MIME-Version: 1.0
X-CFilter-Loop: Reflected
X-Brightmail-Tracker: H4sIAAAAAAAAA+NgFjrFKsWRmVeSWpSXmKPExsWy7djXc7p/xQ6kGDzaJ2HRfX4Do8X0qRcY
        LVbfXMNo0dD0iMWiZfd7Jov9T5+zWKxaeI3N4vysUywWzyc+Z7JYuuQRs8Xx3h0sDtweFyZP
        YPVY3ODqsXPWXXaPliNvgbw9L5k8Nn78z+7x5NpmJo/Nr18we0ydXe/xeZNcAFcUl01Kak5m
        WWqRvl0CV8bGtZ2MBQ0TGCuezr/D2sC4Ka2LkZNDQsBE4sz550xdjFwcQgIrGSXOtZ1nh3Ba
        mSSWLXnODFO15F4nVNVaRondPR1sIAkhgU+MEm/ueEIklgHZ7b/AOtgEFCX2dW0HKxIRMJY4
        dngJM0gRs8BbFomPa96wdDFycAgLZEvcvMoLUVMg0fTiHFS9nkRHF8QCFgFViRtHjjCClPMK
        WEpMPmQJEuYUsJJ49mU2K4jNKCAm8f3UGiYQm1lAXOLWk/lMEEcLSiyavQfqATGJf7seskHY
        8hKTf8yAshUl7n9/yQ7RqydxY+oUNghbW2LZwtdgvbxAc07OfMICUS8pcXDFDRaQVyQEJnNK
        LF7cDpVwkTi8ZysrhC0tMX3NZbAXJQSSJVZ95III50jMX7IFqtxaYuGf9UwTGFVmITl7FpIz
        ZiE5YxaSMxYwsqxiFC8tLs5NTy02ykst1ytOzC0uzUvXS87P3cQITG6n/x3O38F4/dZHvUOM
        TByMhxglOJiVRHgNY/alCPGmJFZWpRblxxeV5qQWH2KU5mBREuc1tD2ZLCSQnliSmp2aWpBa
        BJNl4uCUamCKX5DE6lQ6w+V+2sKqrY0Xmso3N870LP0Wv0T/7F21d/8/+puZCpyRkLrKtspv
        8YnQJx1aEw/efrvr3X7JK3Hv/NcKftdWj+metnnJm/Zw+3cWnadXWFyukOD7+u3l8bbAoLPV
        82L2+93Qr7E1aTdewdYQfPF5O9PZc7VndpkaLXDJ3rEzUlu1vUbZ8yCTotKJlRfZX3jLpTVV
        iYqrrfj4UsG45PT88CzWWM1wIzuDP7brfN1XyyX58sbNy1vHXN4iUHnSpaz15aw/p7L+vf48
        p2kGT/PNKYv+urf8m7B1+ZrFt+Z2heTPuMhVqOVTXXzogOOEl9Mvyih2WQcuPTGRzVZq7bNH
        /9uXSeZ3Z3xUYinOSDTUYi4qTgQA+m51Xd0DAAA=
X-Brightmail-Tracker: H4sIAAAAAAAAA+NgFnrOIsWRmVeSWpSXmKPExsWS2cA0SfeP2IEUg08bTC26z29gtJg+9QKj
        xeqbaxgtGpoesVi07H7PZLH/6XMWi1ULr7FZnJ91isXi+cTnTBZLlzxitjjeu4PFgdvjwuQJ
        rB6LG1w9ds66y+7RcuQtkLfnJZPHxo//2T2eXNvM5LH59Qtmj6mz6z0+b5IL4IrisklJzcks
        Sy3St0vgyti4tpOxoGECY8XT+XdYGxg3pXUxcnJICJhILLnXydTFyMUhJLCaUeLGhH2sEM4n
        Rolzp15BOcsYJeYvXs0I0sImoCixr2s7G4gtImAscezwEmYQm1ngNYvEt4vcXYwcHMIC2RI3
        r/JClBRI/Nv3jwnC1pPo6OoAa2URUJW4ceQII0g5r4ClxORDliCmEJC5dWIcSAWngJXEsy+z
        WUFsRgExie+n1jBBLBKXuPVkPhPE/QISS/acZ4awRSVePv7HCmHLS0z+MYMNwlaUuP/9JTtE
        r57EjalT2CBsbYllC1+D9fIKCEqcnPmEBaJeUuLgihssExglZiFZNwtJ+ywk7bOQtC9gZFnF
        KF5aXJybXlFsnJdarlecmFtcmpeul5yfu4kRmBZO/zscs4Px3q2PeocYmTgYDzFKcDArifAa
        xuxLEeJNSaysSi3Kjy8qzUktPsQozcGiJM7rETsxXkggPbEkNTs1tSC1CCbLxMEp1cBUKvL0
        3uH1OQecOuSmFGvP/Xjt9rW7m25vODHt9rK1de9r/TmF2oxLrd/LX31UoaPnlVcZ+u28qsQ9
        0xmTeJiM+c7+7BXN3n71QPki8bbU6ogS4TciNTJct64mie6PttafFr0m93fvh943SalX7h9f
        feKsBkeR3yPbOcuWrRaqz+VRyckL+ifmmMl7nktmfdMlcdOMI5HKR8JdjinarHvJsfLo9sZ6
        3gDT3Z/uhBRum/brdPUaFVs1ns1RhzKNPYRm8i8uPi/zr2rmNqW1z6ZsFp/yO/vkjG2fjzPN
        PjT1gTPzNQ7bpRlfrOsWNZ/OOdCUH/P794mWxYuqH5gZ/Y3oOWFYr2lnrcEjay/4w/qpEktx
        RqKhFnNRcSIAFCKCiXoDAAA=
X-CMS-MailID: 20230725183957uscas1p1eeb8e8eccc6c00b460d183027642374b
CMS-TYPE: 301P
X-CMS-RootMailID: 20230725183957uscas1p1eeb8e8eccc6c00b460d183027642374b
References: <20230725183939.2741025-1-fan.ni@samsung.com>
        <CGME20230725183957uscas1p1eeb8e8eccc6c00b460d183027642374b@uscas1p1.samsung.com>
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

From: Fan Ni <nifan@outlook.com>

Add (file/memory backed) host backend, all the dynamic capacity regions
will share a single, large enough host backend. Set up address space for
DC regions to support read/write operations to dynamic capacity for DCD.

With the change, following supports are added:
1. add a new property to type3 device "nonvolatile-dc-memdev" to point to h=
ost
   memory backend for dynamic capacity;
2. add namespace for dynamic capacity for read/write support;
3. create cdat entries for each dynamic capacity region;
4. fix dvsec range registers to include DC regions.

Signed-off-by: Fan Ni <fan.ni@samsung.com>
---
 hw/cxl/cxl-mailbox-utils.c  |  19 +++-
 hw/mem/cxl_type3.c          | 203 +++++++++++++++++++++++++++++-------
 include/hw/cxl/cxl_device.h |   4 +
 3 files changed, 185 insertions(+), 41 deletions(-)

diff --git a/hw/cxl/cxl-mailbox-utils.c b/hw/cxl/cxl-mailbox-utils.c
index dd5ea95af8..0511b8e6f7 100644
--- a/hw/cxl/cxl-mailbox-utils.c
+++ b/hw/cxl/cxl-mailbox-utils.c
@@ -388,9 +388,11 @@ static CXLRetCode cmd_firmware_update_get_info(struct =
cxl_cmd *cmd,
         char fw_rev4[0x10];
     } QEMU_PACKED *fw_info;
     QEMU_BUILD_BUG_ON(sizeof(*fw_info) !=3D 0x50);
+    CXLType3Dev *ct3d =3D container_of(cxl_dstate, CXLType3Dev, cxl_dstate=
);
=20
     if ((cxl_dstate->vmem_size < CXL_CAPACITY_MULTIPLIER) ||
-        (cxl_dstate->pmem_size < CXL_CAPACITY_MULTIPLIER)) {
+        (cxl_dstate->pmem_size < CXL_CAPACITY_MULTIPLIER) ||
+        (ct3d->dc.total_capacity < CXL_CAPACITY_MULTIPLIER)) {
         return CXL_MBOX_INTERNAL_ERROR;
     }
=20
@@ -531,7 +533,8 @@ static CXLRetCode cmd_identify_memory_device(struct cxl=
_cmd *cmd,
     CXLType3Class *cvc =3D CXL_TYPE3_GET_CLASS(ct3d);
=20
     if ((!QEMU_IS_ALIGNED(cxl_dstate->vmem_size, CXL_CAPACITY_MULTIPLIER))=
 ||
-        (!QEMU_IS_ALIGNED(cxl_dstate->pmem_size, CXL_CAPACITY_MULTIPLIER))=
) {
+        (!QEMU_IS_ALIGNED(cxl_dstate->pmem_size, CXL_CAPACITY_MULTIPLIER))=
 ||
+        (!QEMU_IS_ALIGNED(ct3d->dc.total_capacity, CXL_CAPACITY_MULTIPLIER=
))) {
         return CXL_MBOX_INTERNAL_ERROR;
     }
=20
@@ -566,9 +569,11 @@ static CXLRetCode cmd_ccls_get_partition_info(struct c=
xl_cmd *cmd,
         uint64_t next_pmem;
     } QEMU_PACKED *part_info =3D (void *)cmd->payload;
     QEMU_BUILD_BUG_ON(sizeof(*part_info) !=3D 0x20);
+    CXLType3Dev *ct3d =3D container_of(cxl_dstate, CXLType3Dev, cxl_dstate=
);
=20
     if ((!QEMU_IS_ALIGNED(cxl_dstate->vmem_size, CXL_CAPACITY_MULTIPLIER))=
 ||
-        (!QEMU_IS_ALIGNED(cxl_dstate->pmem_size, CXL_CAPACITY_MULTIPLIER))=
) {
+        (!QEMU_IS_ALIGNED(cxl_dstate->pmem_size, CXL_CAPACITY_MULTIPLIER))=
 ||
+        (!QEMU_IS_ALIGNED(ct3d->dc.total_capacity, CXL_CAPACITY_MULTIPLIER=
))) {
         return CXL_MBOX_INTERNAL_ERROR;
     }
=20
@@ -880,7 +885,13 @@ static CXLRetCode cmd_media_clear_poison(struct cxl_cm=
d *cmd,
     struct clear_poison_pl *in =3D (void *)cmd->payload;
=20
     dpa =3D ldq_le_p(&in->dpa);
-    if (dpa + CXL_CACHE_LINE_SIZE > cxl_dstate->static_mem_size) {
+    if (dpa + CXL_CACHE_LINE_SIZE >=3D cxl_dstate->static_mem_size
+            && ct3d->dc.num_regions =3D=3D 0) {
+        return CXL_MBOX_INVALID_PA;
+    }
+
+    if (ct3d->dc.num_regions && dpa + CXL_CACHE_LINE_SIZE >=3D
+            cxl_dstate->static_mem_size + ct3d->dc.total_capacity) {
         return CXL_MBOX_INVALID_PA;
     }
=20
diff --git a/hw/mem/cxl_type3.c b/hw/mem/cxl_type3.c
index b29bb2309a..76bbd9f785 100644
--- a/hw/mem/cxl_type3.c
+++ b/hw/mem/cxl_type3.c
@@ -20,6 +20,7 @@
 #include "hw/pci/spdm.h"
=20
 #define DWORD_BYTE 4
+#define CXL_CAPACITY_MULTIPLIER   (256 * MiB)
=20
 /* Default CDAT entries for a memory region */
 enum {
@@ -33,8 +34,8 @@ enum {
 };
=20
 static int ct3_build_cdat_entries_for_mr(CDATSubHeader **cdat_table,
-                                         int dsmad_handle, MemoryRegion *m=
r,
-                                         bool is_pmem, uint64_t dpa_base)
+        int dsmad_handle, uint8_t flags,
+        uint64_t dpa_base, uint64_t size)
 {
     g_autofree CDATDsmas *dsmas =3D NULL;
     g_autofree CDATDslbis *dslbis0 =3D NULL;
@@ -53,9 +54,9 @@ static int ct3_build_cdat_entries_for_mr(CDATSubHeader **=
cdat_table,
             .length =3D sizeof(*dsmas),
         },
         .DSMADhandle =3D dsmad_handle,
-        .flags =3D is_pmem ? CDAT_DSMAS_FLAG_NV : 0,
+        .flags =3D flags,
         .DPA_base =3D dpa_base,
-        .DPA_length =3D memory_region_size(mr),
+        .DPA_length =3D size,
     };
=20
     /* For now, no memory side cache, plausiblish numbers */
@@ -137,9 +138,9 @@ static int ct3_build_cdat_entries_for_mr(CDATSubHeader =
**cdat_table,
          * NV: Reserved - the non volatile from DSMAS matters
          * V: EFI_MEMORY_SP
          */
-        .EFI_memory_type_attr =3D is_pmem ? 2 : 1,
+        .EFI_memory_type_attr =3D flags ? 2 : 1,
         .DPA_offset =3D 0,
-        .DPA_length =3D memory_region_size(mr),
+        .DPA_length =3D size,
     };
=20
     /* Header always at start of structure */
@@ -158,21 +159,28 @@ static int ct3_build_cdat_table(CDATSubHeader ***cdat=
_table, void *priv)
     g_autofree CDATSubHeader **table =3D NULL;
     CXLType3Dev *ct3d =3D priv;
     MemoryRegion *volatile_mr =3D NULL, *nonvolatile_mr =3D NULL;
+    MemoryRegion *dc_mr =3D NULL;
     int dsmad_handle =3D 0;
     int cur_ent =3D 0;
     int len =3D 0;
     int rc, i;
+    uint64_t vmr_size =3D 0, pmr_size =3D 0;
=20
-    if (!ct3d->hostpmem && !ct3d->hostvmem) {
+    if (!ct3d->hostpmem && !ct3d->hostvmem && !ct3d->dc.num_regions) {
         return 0;
     }
=20
+    if (ct3d->hostpmem && ct3d->hostvmem && ct3d->dc.host_dc) {
+        warn_report("The device has static ram and pmem and dynamic capaci=
ty");
+    }
+
     if (ct3d->hostvmem) {
         volatile_mr =3D host_memory_backend_get_memory(ct3d->hostvmem);
         if (!volatile_mr) {
             return -EINVAL;
         }
         len +=3D CT3_CDAT_NUM_ENTRIES;
+        vmr_size =3D volatile_mr->size;
     }
=20
     if (ct3d->hostpmem) {
@@ -181,6 +189,19 @@ static int ct3_build_cdat_table(CDATSubHeader ***cdat_=
table, void *priv)
             return -EINVAL;
         }
         len +=3D CT3_CDAT_NUM_ENTRIES;
+        pmr_size =3D nonvolatile_mr->size;
+    }
+
+    if (ct3d->dc.num_regions) {
+        if (ct3d->dc.host_dc) {
+            dc_mr =3D host_memory_backend_get_memory(ct3d->dc.host_dc);
+            if (!dc_mr) {
+                return -EINVAL;
+            }
+            len +=3D CT3_CDAT_NUM_ENTRIES * ct3d->dc.num_regions;
+        } else {
+            return -EINVAL;
+        }
     }
=20
     table =3D g_malloc0(len * sizeof(*table));
@@ -190,8 +211,8 @@ static int ct3_build_cdat_table(CDATSubHeader ***cdat_t=
able, void *priv)
=20
     /* Now fill them in */
     if (volatile_mr) {
-        rc =3D ct3_build_cdat_entries_for_mr(table, dsmad_handle++, volati=
le_mr,
-                                           false, 0);
+        rc =3D ct3_build_cdat_entries_for_mr(table, dsmad_handle++,
+                0, 0, vmr_size);
         if (rc < 0) {
             return rc;
         }
@@ -200,14 +221,37 @@ static int ct3_build_cdat_table(CDATSubHeader ***cdat=
_table, void *priv)
=20
     if (nonvolatile_mr) {
         rc =3D ct3_build_cdat_entries_for_mr(&(table[cur_ent]), dsmad_hand=
le++,
-                                           nonvolatile_mr, true,
-                                           (volatile_mr ?
-                                            memory_region_size(volatile_mr=
) : 0));
+                CDAT_DSMAS_FLAG_NV, vmr_size, pmr_size);
         if (rc < 0) {
             goto error_cleanup;
         }
         cur_ent +=3D CT3_CDAT_NUM_ENTRIES;
     }
+
+    if (dc_mr) {
+        uint64_t region_base =3D vmr_size + pmr_size;
+
+        /*
+         * Currently we create cdat entries for each region, should we onl=
y
+         * create dsmas table instead??
+         * We assume all dc regions are non-volatile for now.
+         *
+         */
+        for (i =3D 0; i < ct3d->dc.num_regions; i++) {
+            rc =3D ct3_build_cdat_entries_for_mr(&(table[cur_ent])
+                    , dsmad_handle++
+                    , CDAT_DSMAS_FLAG_NV | CDAT_DSMAS_FLAG_DYNAMIC_CAP
+                    , region_base, ct3d->dc.regions[i].len);
+            if (rc < 0) {
+                goto error_cleanup;
+            }
+            ct3d->dc.regions[i].dsmadhandle =3D dsmad_handle - 1;
+
+            cur_ent +=3D CT3_CDAT_NUM_ENTRIES;
+            region_base +=3D ct3d->dc.regions[i].len;
+        }
+    }
+
     assert(len =3D=3D cur_ent);
=20
     *cdat_table =3D g_steal_pointer(&table);
@@ -435,11 +479,24 @@ static void build_dvsecs(CXLType3Dev *ct3d)
             range2_size_hi =3D ct3d->hostpmem->size >> 32;
             range2_size_lo =3D (2 << 5) | (2 << 2) | 0x3 |
                              (ct3d->hostpmem->size & 0xF0000000);
+        } else if (ct3d->dc.host_dc) {
+            range2_size_hi =3D ct3d->dc.host_dc->size >> 32;
+            range2_size_lo =3D (2 << 5) | (2 << 2) | 0x3 |
+                             (ct3d->dc.host_dc->size & 0xF0000000);
         }
-    } else {
+    } else if (ct3d->hostpmem) {
         range1_size_hi =3D ct3d->hostpmem->size >> 32;
         range1_size_lo =3D (2 << 5) | (2 << 2) | 0x3 |
                          (ct3d->hostpmem->size & 0xF0000000);
+        if (ct3d->dc.host_dc) {
+            range2_size_hi =3D ct3d->dc.host_dc->size >> 32;
+            range2_size_lo =3D (2 << 5) | (2 << 2) | 0x3 |
+                             (ct3d->dc.host_dc->size & 0xF0000000);
+        }
+    } else {
+        range1_size_hi =3D ct3d->dc.host_dc->size >> 32;
+        range1_size_lo =3D (2 << 5) | (2 << 2) | 0x3 |
+            (ct3d->dc.host_dc->size & 0xF0000000);
     }
=20
     dvsec =3D (uint8_t *)&(CXLDVSECDevice){
@@ -708,7 +765,8 @@ static void ct3d_reg_write(void *opaque, hwaddr offset,=
 uint64_t value,
 }
=20
 /*
- * Create a dc region to test "Get Dynamic Capacity Configuration" command=
.
+ * Create dc regions.
+ * TODO: region parameters are hard coded, may need to change in the futur=
e.
  */
 static int cxl_create_dc_regions(CXLType3Dev *ct3d)
 {
@@ -739,7 +797,8 @@ static bool cxl_setup_memory(CXLType3Dev *ct3d, Error *=
*errp)
 {
     DeviceState *ds =3D DEVICE(ct3d);
=20
-    if (!ct3d->hostmem && !ct3d->hostvmem && !ct3d->hostpmem) {
+    if (!ct3d->hostmem && !ct3d->hostvmem && !ct3d->hostpmem
+            && !ct3d->dc.num_regions) {
         error_setg(errp, "at least one memdev property must be set");
         return false;
     } else if (ct3d->hostmem && ct3d->hostpmem) {
@@ -807,6 +866,50 @@ static bool cxl_setup_memory(CXLType3Dev *ct3d, Error =
**errp)
         return false;
     }
=20
+    ct3d->dc.total_capacity =3D 0;
+    if (ct3d->dc.host_dc) {
+        MemoryRegion *dc_mr;
+        char *dc_name;
+        uint64_t total_region_size =3D 0;
+        int i;
+
+        dc_mr =3D host_memory_backend_get_memory(ct3d->dc.host_dc);
+        if (!dc_mr) {
+            error_setg(errp, "dynamic capacity must have backing device");
+            return false;
+        }
+        /* FIXME: set dc as nonvolatile for now */
+        memory_region_set_nonvolatile(dc_mr, true);
+        memory_region_set_enabled(dc_mr, true);
+        host_memory_backend_set_mapped(ct3d->dc.host_dc, true);
+        if (ds->id) {
+            dc_name =3D g_strdup_printf("cxl-dcd-dpa-dc-space:%s", ds->id)=
;
+        } else {
+            dc_name =3D g_strdup("cxl-dcd-dpa-dc-space");
+        }
+        address_space_init(&ct3d->dc.host_dc_as, dc_mr, dc_name);
+
+        for (i =3D 0; i < ct3d->dc.num_regions; i++) {
+            total_region_size +=3D ct3d->dc.regions[i].len;
+        }
+        /* Make sure the host backend is large enough to cover all dc rang=
e */
+        if (total_region_size > memory_region_size(dc_mr)) {
+            error_setg(errp,
+                "too small host backend size, increase to %lu MiB or more"=
,
+                total_region_size / 1024 / 1024);
+            return false;
+        }
+
+        if (dc_mr->size % CXL_CAPACITY_MULTIPLIER !=3D 0) {
+            error_setg(errp, "DC region size is unaligned to %lx",
+                    CXL_CAPACITY_MULTIPLIER);
+            return false;
+        }
+
+        ct3d->dc.total_capacity =3D total_region_size;
+        g_free(dc_name);
+    }
+
     return true;
 }
=20
@@ -916,6 +1019,9 @@ err_release_cdat:
 err_free_special_ops:
     g_free(regs->special_ops);
 err_address_space_free:
+    if (ct3d->dc.host_dc) {
+        address_space_destroy(&ct3d->dc.host_dc_as);
+    }
     if (ct3d->hostpmem) {
         address_space_destroy(&ct3d->hostpmem_as);
     }
@@ -935,6 +1041,9 @@ static void ct3_exit(PCIDevice *pci_dev)
     cxl_doe_cdat_release(cxl_cstate);
     spdm_sock_fini(ct3d->doe_spdm.socket);
     g_free(regs->special_ops);
+    if (ct3d->dc.host_dc) {
+        address_space_destroy(&ct3d->dc.host_dc_as);
+    }
     if (ct3d->hostpmem) {
         address_space_destroy(&ct3d->hostpmem_as);
     }
@@ -999,16 +1108,24 @@ static int cxl_type3_hpa_to_as_and_dpa(CXLType3Dev *=
ct3d,
                                        AddressSpace **as,
                                        uint64_t *dpa_offset)
 {
-    MemoryRegion *vmr =3D NULL, *pmr =3D NULL;
+    MemoryRegion *vmr =3D NULL, *pmr =3D NULL, *dc_mr =3D NULL;
+    uint64_t vmr_size =3D 0, pmr_size =3D 0, dc_size =3D 0;
=20
     if (ct3d->hostvmem) {
         vmr =3D host_memory_backend_get_memory(ct3d->hostvmem);
+        vmr_size =3D memory_region_size(vmr);
     }
     if (ct3d->hostpmem) {
         pmr =3D host_memory_backend_get_memory(ct3d->hostpmem);
+        pmr_size =3D memory_region_size(pmr);
+    }
+    if (ct3d->dc.host_dc) {
+        dc_mr =3D host_memory_backend_get_memory(ct3d->dc.host_dc);
+        /* Do we want dc_size to be dc_mr->size or not?? */
+        dc_size =3D ct3d->dc.total_capacity;
     }
=20
-    if (!vmr && !pmr) {
+    if (!vmr && !pmr && !dc_mr) {
         return -ENODEV;
     }
=20
@@ -1016,19 +1133,19 @@ static int cxl_type3_hpa_to_as_and_dpa(CXLType3Dev =
*ct3d,
         return -EINVAL;
     }
=20
-    if (*dpa_offset > ct3d->cxl_dstate.static_mem_size) {
+    if ((*dpa_offset >=3D vmr_size + pmr_size + dc_size) ||
+       (*dpa_offset >=3D vmr_size + pmr_size && ct3d->dc.num_regions =3D=
=3D 0)) {
         return -EINVAL;
     }
=20
-    if (vmr) {
-        if (*dpa_offset < memory_region_size(vmr)) {
-            *as =3D &ct3d->hostvmem_as;
-        } else {
-            *as =3D &ct3d->hostpmem_as;
-            *dpa_offset -=3D memory_region_size(vmr);
-        }
-    } else {
+    if (*dpa_offset < vmr_size) {
+        *as =3D &ct3d->hostvmem_as;
+    } else if (*dpa_offset < vmr_size + pmr_size) {
         *as =3D &ct3d->hostpmem_as;
+        *dpa_offset -=3D vmr_size;
+    } else {
+        *as =3D &ct3d->dc.host_dc_as;
+        *dpa_offset -=3D (vmr_size + pmr_size);
     }
=20
     return 0;
@@ -1101,6 +1218,8 @@ static Property ct3_props[] =3D {
     DEFINE_PROP_STRING("cdat", CXLType3Dev, cxl_cstate.cdat.filename),
     DEFINE_PROP_UINT16("spdm", CXLType3Dev, spdm_port, 0),
     DEFINE_PROP_UINT8("num-dc-regions", CXLType3Dev, dc.num_regions, 0),
+    DEFINE_PROP_LINK("nonvolatile-dc-memdev", CXLType3Dev, dc.host_dc,
+                    TYPE_MEMORY_BACKEND, HostMemoryBackend *),
     DEFINE_PROP_END_OF_LIST(),
 };
=20
@@ -1167,33 +1286,43 @@ static void set_lsa(CXLType3Dev *ct3d, const void *=
buf, uint64_t size,
=20
 static bool set_cacheline(CXLType3Dev *ct3d, uint64_t dpa_offset, uint8_t =
*data)
 {
-    MemoryRegion *vmr =3D NULL, *pmr =3D NULL;
+    MemoryRegion *vmr =3D NULL, *pmr =3D NULL, *dc_mr =3D NULL;
     AddressSpace *as;
+    uint64_t vmr_size =3D 0, pmr_size =3D 0, dc_size =3D 0;
=20
     if (ct3d->hostvmem) {
         vmr =3D host_memory_backend_get_memory(ct3d->hostvmem);
+        vmr_size =3D memory_region_size(vmr);
     }
     if (ct3d->hostpmem) {
         pmr =3D host_memory_backend_get_memory(ct3d->hostpmem);
+        pmr_size =3D memory_region_size(pmr);
     }
+    if (ct3d->dc.host_dc) {
+        dc_mr =3D host_memory_backend_get_memory(ct3d->dc.host_dc);
+        dc_size =3D ct3d->dc.total_capacity;
+     }
=20
-    if (!vmr && !pmr) {
+    if (!vmr && !pmr && !dc_mr) {
         return false;
     }
=20
-    if (dpa_offset + CXL_CACHE_LINE_SIZE > ct3d->cxl_dstate.static_mem_siz=
e) {
+    if (dpa_offset >=3D vmr_size + pmr_size + dc_size) {
+        return false;
+    }
+    if (dpa_offset + CXL_CACHE_LINE_SIZE >=3D vmr_size + pmr_size
+            && ct3d->dc.num_regions =3D=3D 0) {
         return false;
     }
=20
-    if (vmr) {
-        if (dpa_offset < memory_region_size(vmr)) {
-            as =3D &ct3d->hostvmem_as;
-        } else {
-            as =3D &ct3d->hostpmem_as;
-            dpa_offset -=3D memory_region_size(vmr);
-        }
-    } else {
+    if (dpa_offset < vmr_size) {
+        as =3D &ct3d->hostvmem_as;
+    } else if (dpa_offset < vmr_size + pmr_size) {
         as =3D &ct3d->hostpmem_as;
+        dpa_offset -=3D vmr->size;
+    } else {
+        as =3D &ct3d->dc.host_dc_as;
+        dpa_offset -=3D (vmr_size + pmr_size);
     }
=20
     address_space_write(as, dpa_offset, MEMTXATTRS_UNSPECIFIED, &data,
diff --git a/include/hw/cxl/cxl_device.h b/include/hw/cxl/cxl_device.h
index 503c344326..1c99b05a66 100644
--- a/include/hw/cxl/cxl_device.h
+++ b/include/hw/cxl/cxl_device.h
@@ -427,6 +427,10 @@ struct CXLType3Dev {
     uint64_t poison_list_overflow_ts;
=20
     struct dynamic_capacity {
+        HostMemoryBackend *host_dc;
+        AddressSpace host_dc_as;
+        uint64_t total_capacity; /* 256M aligned */
+
         uint8_t num_regions; /* 0-8 regions */
         struct CXLDCD_Region regions[DCD_MAX_REGION_NUM];
     } dc;
--=20
2.25.1

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id A6E2FEB64DD
	for <linux-cxl@archiver.kernel.org>; Tue, 25 Jul 2023 18:40:17 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S231853AbjGYSkQ (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 25 Jul 2023 14:40:16 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:44844 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S231867AbjGYSkI (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 25 Jul 2023 14:40:08 -0400
Received: from mailout1.w2.samsung.com (mailout1.w2.samsung.com [211.189.100.11])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 1BD7D199A
        for <linux-cxl@vger.kernel.org>; Tue, 25 Jul 2023 11:39:59 -0700 (PDT)
Received: from uscas1p1.samsung.com (unknown [182.198.245.206])
        by mailout1.w2.samsung.com (KnoxPortal) with ESMTP id 20230725183958usoutp01ca4219ae688b3d67582e7d7dfbddb25f~1MFoViZvN1010010100usoutp01b;
        Tue, 25 Jul 2023 18:39:58 +0000 (GMT)
DKIM-Filter: OpenDKIM Filter v2.11.0 mailout1.w2.samsung.com 20230725183958usoutp01ca4219ae688b3d67582e7d7dfbddb25f~1MFoViZvN1010010100usoutp01b
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=samsung.com;
        s=mail20170921; t=1690310398;
        bh=oq8OuyNlcK46NtOYiH/dkrYZOBLYrhi5/Gt4g5ls/rw=;
        h=From:To:CC:Subject:Date:In-Reply-To:References:From;
        b=aYqCab9nFQZddCJW7mBY795lZJXuB0laTYmuIoIvCnHmBi+LpoEQTk6+vGrbXYblS
         re5zCazI6uz+S0On4ZFONpdMxwnFzNTuAA1tL0ySvf++B+xjvdBBvRwDvlMJnyhNoh
         v8kaNx3GmeSi0N1IS0w+/3CMCm1grKwqyInRcqtI=
Received: from ussmges2new.samsung.com (u111.gpu85.samsung.co.kr
        [203.254.195.111]) by uscas1p1.samsung.com (KnoxPortal) with ESMTP id
        20230725183958uscas1p13a01ccdf75fc954ec0c4d28f21e96544~1MFn-v4Eo1453314533uscas1p1_;
        Tue, 25 Jul 2023 18:39:58 +0000 (GMT)
Received: from uscas1p2.samsung.com ( [182.198.245.207]) by
        ussmges2new.samsung.com (USCPEMTA) with SMTP id 24.11.42611.EF610C46; Tue,
        25 Jul 2023 14:39:58 -0400 (EDT)
Received: from ussmgxs1new.samsung.com (u89.gpu85.samsung.co.kr
        [203.254.195.89]) by uscas1p1.samsung.com (KnoxPortal) with ESMTP id
        20230725183957uscas1p1ebf676c30d21896d1fd7f9b652250449~1MFnpsX0j0317903179uscas1p1x;
        Tue, 25 Jul 2023 18:39:57 +0000 (GMT)
X-AuditID: cbfec36f-fb1ff7000000a673-47-64c016fec26d
Received: from SSI-EX4.ssi.samsung.com ( [105.128.2.145]) by
        ussmgxs1new.samsung.com (USCPEXMTA) with SMTP id D4.54.38326.DF610C46; Tue,
        25 Jul 2023 14:39:57 -0400 (EDT)
Received: from SSI-EX2.ssi.samsung.com (105.128.2.227) by
        SSI-EX4.ssi.samsung.com (105.128.2.229) with Microsoft SMTP Server
        (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384) id
        15.1.2375.24; Tue, 25 Jul 2023 11:39:56 -0700
Received: from SSI-EX2.ssi.samsung.com ([105.128.2.227]) by
        SSI-EX2.ssi.samsung.com ([105.128.2.227]) with mapi id 15.01.2375.024; Tue,
        25 Jul 2023 11:39:56 -0700
From: Fan Ni <fan.ni@samsung.com>
To: "qemu-devel@nongnu.org" <qemu-devel@nongnu.org>
CC: "jonathan.cameron@huawei.com" <jonathan.cameron@huawei.com>,
        "linux-cxl@vger.kernel.org" <linux-cxl@vger.kernel.org>,
        "gregory.price@memverge.com" <gregory.price@memverge.com>,
        "hchkuo@avery-design.com.tw" <hchkuo@avery-design.com.tw>,
        "cbrowy@avery-design.com" <cbrowy@avery-design.com>,
        "ira.weiny@intel.com" <ira.weiny@intel.com>,
        "dan.j.williams@intel.com" <dan.j.williams@intel.com>,
        Adam Manzanares <a.manzanares@samsung.com>,
        "dave@stgolabs.net" <dave@stgolabs.net>,
        "nmtadam.samsung@gmail.com" <nmtadam.samsung@gmail.com>,
        "nifan@outlook.com" <nifan@outlook.com>,
        Fan Ni <fan.ni@samsung.com>
Subject: [Qemu PATCH v2 8/9] hw/cxl/events: Add qmp interfaces to
 add/release dynamic capacity extents
Thread-Topic: [Qemu PATCH v2 8/9] hw/cxl/events: Add qmp interfaces to
        add/release dynamic capacity extents
Thread-Index: AQHZvydoteAcJguFu0q3LwS06vqHoA==
Date: Tue, 25 Jul 2023 18:39:56 +0000
Message-ID: <20230725183939.2741025-9-fan.ni@samsung.com>
In-Reply-To: <20230725183939.2741025-1-fan.ni@samsung.com>
Accept-Language: en-US
Content-Language: en-US
X-MS-Has-Attach: 
X-MS-TNEF-Correlator: 
x-mailer: git-send-email 2.25.1
x-originating-ip: [105.128.2.176]
Content-Type: text/plain; charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable
MIME-Version: 1.0
X-CFilter-Loop: Reflected
X-Brightmail-Tracker: H4sIAAAAAAAAA+NgFjrDKsWRmVeSWpSXmKPExsWy7djX87r/xA6kGNzaw2HRfX4Do8X0qRcY
        LVbfXMNo0dD0iMWiZfd7Jov9T5+zWKxaeI3N4vysUywWzyc+Z7JYuuQRs8Xx3h0sDtweFyZP
        YPVY3ODqsXPWXXaPliNvgbw9L5k8Nn78z+7x5NpmJo/Nr18we0ydXe/xeZNcAFcUl01Kak5m
        WWqRvl0CV8bbxjlMBU0eFZfOvWRpYHxp2sXIySEhYCJx6+Aaxi5GLg4hgZWMEj8bjjFDOK1M
        Ev/eLGeHqzq1E6pqLaPEyveX2CCcT4wS95a+hHKWMUq8af/FDNLCJqAosa9rOxuILSJgLHHs
        8BKwucwCb1kkPq55wwKSEBbIkDg16xMLRFGuxMr99xkhbD2J/gtLmEBsFgFViRtHjoDFeQUs
        JQ7O/swKYnMKWEk8+zIbzGYUEJP4fmoNWD2zgLjErSfzmSDuFpRYNHsPM4QtJvFv10M2CFte
        YvKPGVC2osT97y/ZIXr1JG5MncIGYWtLLFv4mhlir6DEyZlPWCDqJSUOrrjBAvKMhMBkTomu
        D5ehlrlIfJrzDKpIWuLq9alAzRxAdrLEqo9cEOEciflLtkCVWEss/LOeaQKjyiwkZ89CcsYs
        JGfMQnLGAkaWVYzipcXFuempxUZ5qeV6xYm5xaV56XrJ+bmbGIEJ7vS/w/k7GK/f+qh3iJGJ
        g/EQowQHs5IIr2HMvhQh3pTEyqrUovz4otKc1OJDjNIcLErivIa2J5OFBNITS1KzU1MLUotg
        skwcnFINTI2SG+p2nrv9aXJy07Z6E32j6Wv5S6/0CZxlejk9JvafVgDbqn/nPi5oLdyw0+GT
        hdDrhTvSoxVORMTFKOlXrr0deLvLa+rVAs43vbsSsuMF566MWHJlLn/Qi9uKh3799s5wrCjJ
        PcBYMGPRM+aA569vCMxnfcgnN2dH9oE6W3fPVw5zFRPZs6XbP/vNu/+W9XgDk6ic5GfJP5xc
        K08pvn/02PD//OALWmuW6FxNl9ureLY6LGL6211OnQxz72xYflx1T1+O/Nd9ztdDpMKW//oQ
        3yVjb7q/ztTIb23P50avlmeX+ZaGmpSLCD5z8lw7/ZuxiU70h4m7X6d9OPvkW0ab4/d1ndwt
        FRcfbLS5YajEUpyRaKjFXFScCACL3ZRu3wMAAA==
X-Brightmail-Tracker: H4sIAAAAAAAAA02Sf0gTYRjHee9u2zkbXMv01ULTstBotiw6V1SUxlX/jCDKsmy1wy23ZTst
        S6glq0Cz3FTSWz9xpalEaVmSVOqy1GibyJhDK5Y1x4ooy/WDrK0j8L/P93m+3/d5HnhxVOzD
        4nC1rpDW6xSaJL4QUxsQ05Lf0U+US++a0shy+21AXqhxALJ5uAWQhlIvRhoffkLIx+98GNl0
        zcUn7Ww/RvpMPoS8bvWi5LOKB9i6SMpRVcmj6g1ZVAc7KqCMto8h1elHqDuf/wioMVcbQrUF
        xlGqxnKCmmiNlwt3ClcraY36MK1PW7NXqPp48iJSUEoVD770YwbgX1EGInBILIee/g5QBoS4
        mGgG0D5qRDjxBcA+6ycBJ24AeKW+GYQjfCIRPiq7zw9zFJEOe3usaJhRIoDBSWdkmGcRKhio
        bgrV8ZBHCxt75ZxdAs87rEiYMSIZum22f0+KiAzYZZnghe3iEN8z7QmXIwgZfP/VwgszIKJh
        sL8F4SbFQM/YFYQ7gIDWTjvK8WzofzvF4zgBVn2v5XOcCF8H/QIuK4Hummo+x4vhjWsBlFth
        JuyrG8M4fyzsanRjlQCy08ax0+LstDg7LX4VYE0gpohhtHnFjFRHH5EwCi1TpMuT7D+obQWh
        vzAw1ZP9ADz1fJZ0AwQH3QDiaFKUSJrzSCkWKRVHj9H6g7n6Ig3NdIM5OJYUIxJnmXLFRJ6i
        kM6n6QJa/7+L4BFxBqR8pHzr5Rf+b9K8eT9Hbjr7XzWIfiwcv7R6frbl1njdyj+42yqjzHxT
        aoW48tAydIXcdrwhRebadDM5Mz2dYBuPREm63p7+1TmYWMfOT840Lw6smTn0zGXR9KROVp0o
        N3qlwoSJA6c3xFtaneeYd7t6sWKHswRkD9h41wMt7rQU+Y7j+84Y5wTb1fkF8rNTNbe2bR/b
        uHn9h82ZZscHMzA/yUXa9BVbGmqDA+3VmqgO8pXdiZ0zSLLMZV3m3dHKRWlvVgli8zPavHOD
        rZdK1m4smWVeamv3LCkYqWf75hl86ycWeJc3xsq0z+sT+NF1qpOnZoiGzgzvSFR5InMkSRij
        UkhTUT2j+AviSwS6egMAAA==
X-CMS-MailID: 20230725183957uscas1p1ebf676c30d21896d1fd7f9b652250449
CMS-TYPE: 301P
X-CMS-RootMailID: 20230725183957uscas1p1ebf676c30d21896d1fd7f9b652250449
References: <20230725183939.2741025-1-fan.ni@samsung.com>
        <CGME20230725183957uscas1p1ebf676c30d21896d1fd7f9b652250449@uscas1p1.samsung.com>
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

From: Fan Ni <nifan@outlook.com>

Since fabric manager emulation is not supported yet, the change implements
the functions to add/release dynamic capacity extents as QMP interfaces.

1. Add dynamic capacity extents:

For example, the command to add two continuous extents (each is 128MB long)
to region 0 (starting at dpa offset 0 and 128MB) looks like below:

{ "execute": "qmp_capabilities" }

{ "execute": "cxl-add-dynamic-capacity-event",
  "arguments": {
      "path": "/machine/peripheral/cxl-dcd0",
      "extents": [
      {
          "region-id": 0,
          "dpa": 0,
          "len": 128
      },
      {
          "region-id": 0,
          "dpa": 128,
          "len": 128
      }
      ]
  }
}

2. Release dynamic capacity extents:

For example, the command to release an extent of size 128MB from region 0
(starting at dpa offset 128MB) look like below:

{ "execute": "cxl-release-dynamic-capacity-event",
  "arguments": {
      "path": "/machine/peripheral/cxl-dcd0",
      "extents": [
      {
          "region-id": 0,
          "dpa": 128,
          "len": 128
      }
      ]
  }
}

Signed-off-by: Fan Ni <fan.ni@samsung.com>
---
 hw/mem/cxl_type3.c          | 145 ++++++++++++++++++++++++++++++++++++
 hw/mem/cxl_type3_stubs.c    |   6 ++
 include/hw/cxl/cxl_events.h |  16 ++++
 qapi/cxl.json               |  49 ++++++++++++
 4 files changed, 216 insertions(+)

diff --git a/hw/mem/cxl_type3.c b/hw/mem/cxl_type3.c
index f1170b8047..41a828598a 100644
--- a/hw/mem/cxl_type3.c
+++ b/hw/mem/cxl_type3.c
@@ -1817,6 +1817,151 @@ void qmp_cxl_inject_memory_module_event(const char =
*path, CxlEventLog log,
     }
 }
=20
+static const QemuUUID dynamic_capacity_uuid =3D {
+    .data =3D UUID(0xca95afa7, 0xf183, 0x4018, 0x8c, 0x2f,
+            0x95, 0x26, 0x8e, 0x10, 0x1a, 0x2a),
+};
+
+/*
+ * cxl r3.0: Table 8-47
+ * 00h: add capacity
+ * 01h: release capacity
+ * 02h: forced capacity release
+ * 03h: region configuration updated
+ * 04h: Add capacity response
+ * 05h: capacity released
+ */
+enum DC_Event_Type {
+    DC_EVENT_ADD_CAPACITY,
+    DC_EVENT_RELEASE_CAPACITY,
+    DC_EVENT_FORCED_RELEASE_CAPACITY,
+    DC_EVENT_REGION_CONFIG_UPDATED,
+    DC_EVENT_ADD_CAPACITY_RSP,
+    DC_EVENT_CAPACITY_RELEASED,
+    DC_EVENT_NUM
+};
+
+#define MEM_BLK_SIZE_MB 128
+static void qmp_cxl_process_dynamic_capacity_event(const char *path,
+        CxlEventLog log, enum DC_Event_Type type,
+        uint16_t hid, CXLDCExtentRecordList *records, Error **errp)
+{
+    Object *obj =3D object_resolve_path(path, NULL);
+    CXLEventDynamicCapacity dCap;
+    CXLEventRecordHdr *hdr =3D &dCap.hdr;
+    CXLDeviceState *cxlds;
+    CXLType3Dev *dcd;
+    uint8_t flags =3D 1 << CXL_EVENT_TYPE_INFO;
+    uint32_t num_extents =3D 0;
+    CXLDCExtentRecordList *list =3D records;
+    CXLDCExtent_raw *extents;
+    uint64_t dpa, len;
+    uint8_t rid =3D 0;
+    int i;
+
+    if (!obj) {
+        error_setg(errp, "Unable to resolve path");
+        return;
+    }
+    if (!object_dynamic_cast(obj, TYPE_CXL_TYPE3)) {
+        error_setg(errp, "Path not point to a valid CXL type3 device");
+        return;
+    }
+
+    dcd =3D CXL_TYPE3(obj);
+    cxlds =3D &dcd->cxl_dstate;
+    memset(&dCap, 0, sizeof(dCap));
+
+    if (!dcd->dc.num_regions) {
+        error_setg(errp, "No dynamic capacity support from the device");
+        return;
+    }
+
+    while (list) {
+        dpa =3D list->value->dpa * 1024 * 1024;
+        len =3D list->value->len * 1024 * 1024;
+        rid =3D list->value->region_id;
+
+        if (rid >=3D dcd->dc.num_regions) {
+            error_setg(errp, "region id is too large");
+            return;
+        }
+
+        if (dpa % dcd->dc.regions[rid].block_size
+                || len % dcd->dc.regions[rid].block_size) {
+            error_setg(errp, "dpa or len is not aligned to region block si=
ze");
+            return;
+        }
+
+        if (dpa + len > dcd->dc.regions[rid].decode_len * 256 * 1024 * 102=
4) {
+            error_setg(errp, "extent range is beyond the region end");
+            return;
+        }
+
+        num_extents++;
+        list =3D list->next;
+    }
+
+    i =3D 0;
+    list =3D records;
+    extents =3D g_new0(CXLDCExtent_raw, num_extents);
+    while (list) {
+        dpa =3D list->value->dpa * 1024 * 1024;
+        len =3D list->value->len * 1024 * 1024;
+        rid =3D list->value->region_id;
+
+        extents[i].start_dpa =3D dpa + dcd->dc.regions[rid].base;
+        extents[i].len =3D len;
+        memset(extents[i].tag, 0, 0x10);
+        extents[i].shared_seq =3D 0;
+
+        list =3D list->next;
+        i++;
+    }
+
+    /*
+     * 8.2.9.1.5
+     * All Dynamic Capacity event records shall set the Event Record
+     * Severity field in the Common Event Record Format to Informational
+     * Event. All Dynamic Capacity related events shall be logged in the
+     * Dynamic Capacity Event Log.
+     */
+    cxl_assign_event_header(hdr, &dynamic_capacity_uuid, flags, sizeof(dCa=
p),
+            cxl_device_get_timestamp(&dcd->cxl_dstate));
+
+    dCap.type =3D type;
+    stw_le_p(&dCap.host_id, hid);
+    /* only valid for DC_REGION_CONFIG_UPDATED event */
+    dCap.updated_region_id =3D rid;
+    for (i =3D 0; i < num_extents; i++) {
+        memcpy(&dCap.dynamic_capacity_extent, &extents[i]
+                , sizeof(CXLDCExtent_raw));
+
+        if (cxl_event_insert(cxlds, CXL_EVENT_TYPE_DYNAMIC_CAP,
+                    (CXLEventRecordRaw *)&dCap)) {
+            cxl_event_irq_assert(dcd);
+        }
+    }
+
+    g_free(extents);
+}
+
+void qmp_cxl_add_dynamic_capacity_event(const char *path,
+        struct CXLDCExtentRecordList  *records,
+        Error **errp)
+{
+   qmp_cxl_process_dynamic_capacity_event(path, CXL_EVENT_LOG_INFORMATIONA=
L,
+           DC_EVENT_ADD_CAPACITY, 0, records, errp);
+}
+
+void qmp_cxl_release_dynamic_capacity_event(const char *path,
+        struct CXLDCExtentRecordList  *records,
+        Error **errp)
+{
+    qmp_cxl_process_dynamic_capacity_event(path, CXL_EVENT_LOG_INFORMATION=
AL,
+            DC_EVENT_RELEASE_CAPACITY, 0, records, errp);
+}
+
 static void ct3_class_init(ObjectClass *oc, void *data)
 {
     DeviceClass *dc =3D DEVICE_CLASS(oc);
diff --git a/hw/mem/cxl_type3_stubs.c b/hw/mem/cxl_type3_stubs.c
index f3e4a9fa72..482229f3bd 100644
--- a/hw/mem/cxl_type3_stubs.c
+++ b/hw/mem/cxl_type3_stubs.c
@@ -56,3 +56,9 @@ void qmp_cxl_inject_correctable_error(const char *path, C=
xlCorErrorType type,
 {
     error_setg(errp, "CXL Type 3 support is not compiled in");
 }
+
+void qmp_cxl_add_dynamic_capacity_event(const char *path,
+        struct CXLDCExtentRecordList  *records, Error **errp) {}
+
+void qmp_cxl_release_dynamic_capacity_event(const char *path,
+        struct CXLDCExtentRecordList  *records, Error **errp) {}
diff --git a/include/hw/cxl/cxl_events.h b/include/hw/cxl/cxl_events.h
index 089ba2091f..3baf745f8d 100644
--- a/include/hw/cxl/cxl_events.h
+++ b/include/hw/cxl/cxl_events.h
@@ -165,4 +165,20 @@ typedef struct CXLEventMemoryModule {
     uint8_t reserved[0x3d];
 } QEMU_PACKED CXLEventMemoryModule;
=20
+/*
+ * Dynamic Capacity Event Record
+ * CXL Rev 3.0 Section 8.2.9.2.1.5: Table 8-47
+ * All fields little endian.
+ */
+typedef struct CXLEventDynamicCapacity {
+    CXLEventRecordHdr hdr;
+    uint8_t type;
+    uint8_t reserved1;
+    uint16_t host_id;
+    uint8_t updated_region_id;
+    uint8_t reserved2[3];
+    uint8_t dynamic_capacity_extent[0x28]; /* defined in cxl_device.h */
+    uint8_t reserved[0x20];
+} QEMU_PACKED CXLEventDynamicCapacity;
+
 #endif /* CXL_EVENTS_H */
diff --git a/qapi/cxl.json b/qapi/cxl.json
index 05c560cfe5..fb04ec4c41 100644
--- a/qapi/cxl.json
+++ b/qapi/cxl.json
@@ -369,3 +369,52 @@
 ##
 {'command': 'cxl-inject-correctable-error',
  'data': {'path': 'str', 'type': 'CxlCorErrorType'}}
+
+##
+# @CXLDCExtentRecord:
+#
+# Record of a single extent to add/release
+#
+# @region-id: id of the region where the extent to add/release
+# @dpa: start dpa (in MiB) of the extent, related to region base address
+# @len: extent size (in MiB)
+#
+# Since: 8.0
+##
+{ 'struct': 'CXLDCExtentRecord',
+  'data': {
+      'region-id': 'uint8',
+      'dpa':'uint64',
+      'len': 'uint64'
+  }
+}
+
+##
+# @cxl-add-dynamic-capacity-event:
+#
+# Command to add dynamic capacity extent event
+#
+# @path: CXL DCD canonical QOM path
+# @extents: Extents to add
+#
+##
+{ 'command': 'cxl-add-dynamic-capacity-event',
+  'data': { 'path': 'str',
+            'extents': [ 'CXLDCExtentRecord' ]
+           }
+}
+
+##
+# @cxl-release-dynamic-capacity-event:
+#
+# Command to release dynamic capacity extent event
+#
+# @path: CXL DCD canonical QOM path
+# @extents: Extents to release
+#
+##
+{ 'command': 'cxl-release-dynamic-capacity-event',
+  'data': { 'path': 'str',
+            'extents': [ 'CXLDCExtentRecord' ]
+           }
+}
--=20
2.25.1

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 2CF28C0015E
	for <linux-cxl@archiver.kernel.org>; Wed, 26 Jul 2023 12:53:32 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S231674AbjGZMxb (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Wed, 26 Jul 2023 08:53:31 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:55940 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S231370AbjGZMxa (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Wed, 26 Jul 2023 08:53:30 -0400
Received: from NAM12-MW2-obe.outbound.protection.outlook.com (mail-mw2nam12on2075.outbound.protection.outlook.com [40.107.244.75])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 297AB1BD6
        for <linux-cxl@vger.kernel.org>; Wed, 26 Jul 2023 05:53:27 -0700 (PDT)
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=AR+AAFzpqnYsjsWLPHk2/tgHVv37TSCx9FK936hclDwi2JE1CHgII1t7ob0ikBvMeIDfuRN7QjTSyiRWQGg81gpv0rCHt92QMG6If1w60eRPtT9AcPuzGz7oc7HleIzkOarzIQA/pKNGt1VUlTApmb9w2FoSXFKWM+lmkj+hEArxU3IDOjsZJvKIyLsFWyRS9QRLc+Dka8I4mPt0d+BbConR2pNBmkXTQBQzyA8IFNSJqhAC1QSjyz+W8xDJII8FBf+SUqJCMPEH1GrQcauRMd3Y78tudmbM8h0hGnIiS1lEr5VE6ygw55P1tYxki6Ft9sDJp3ZaVEhyFUFk0+BJ0w==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=UxeO7gdwMIubkFpzqQO7K+RrLubfF+UM9xIxwzZrppM=;
 b=J+PihbtbgYnEtLudSJHW4VplMtYsG03JkJ+uuWBe/T+VcF8xxI3iaS+vuXF8OgZBlEsbfVeO0RloyPizEcr2YiR/6FK4hsKOUQ03V/yC8uJpN5mTeMBUvLa8uck62xqQTsrO805XrX+pJTVbAWPH1+xrhyfgueEO/U23qzq3KJT8xZyOBKptxmHMYJ5i6fHtbVsytpKXm/GJ3XXclm/wXeBzklje7qvSRRXM/I9Wo/+2CVvA2P+AawOXRgl/x1VXFmlVUceMnXOKY7eV14H/iG3L+AbzGbP5qUpZaujqcNILhgbSbcGshOXMUhuyPp/DAJHMCV6YL1bpd8sCM/d4wA==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=amd.com; dmarc=pass action=none header.from=amd.com; dkim=pass
 header.d=amd.com; arc=none
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=amd.com; s=selector1;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-SenderADCheck;
 bh=UxeO7gdwMIubkFpzqQO7K+RrLubfF+UM9xIxwzZrppM=;
 b=paeQKHt1DW980Lc0/3GqeTMKryftNP1lYgb12bbzeMELJoRra0e7EF5qwBr93LYtDrVBuW0YosADWVmrlJIOX+SGvEYHn5J7u0pQskEMngjWD/etuF/rbZY2yZaeLjH+FmM3/LOpQyBh6tchujlVXLK923XdIQ3g2TCymGmfMGY=
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=amd.com;
Received: from MN0PR12MB6222.namprd12.prod.outlook.com (2603:10b6:208:3c2::19)
 by DM4PR12MB5914.namprd12.prod.outlook.com (2603:10b6:8:67::21) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.6609.28; Wed, 26 Jul
 2023 12:53:23 +0000
Received: from MN0PR12MB6222.namprd12.prod.outlook.com
 ([fe80::9b81:467f:8267:9891]) by MN0PR12MB6222.namprd12.prod.outlook.com
 ([fe80::9b81:467f:8267:9891%6]) with mapi id 15.20.6631.026; Wed, 26 Jul 2023
 12:53:23 +0000
Message-ID: <1773a964-3597-434e-ca15-5ca1afdc116a@amd.com>
Date: Wed, 26 Jul 2023 07:53:21 -0500
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101
 Thunderbird/102.13.0
Subject: Re: [Qemu PATCH v2 5/9] hw/mem/cxl_type3: Add host backend and
 address space handling for DC regions
Content-Language: en-US
To: Fan Ni <fan.ni@samsung.com>,
        "qemu-devel@nongnu.org" <qemu-devel@nongnu.org>
Cc: "jonathan.cameron@huawei.com" <jonathan.cameron@huawei.com>,
        "linux-cxl@vger.kernel.org" <linux-cxl@vger.kernel.org>,
        "gregory.price@memverge.com" <gregory.price@memverge.com>,
        "hchkuo@avery-design.com.tw" <hchkuo@avery-design.com.tw>,
        "cbrowy@avery-design.com" <cbrowy@avery-design.com>,
        "ira.weiny@intel.com" <ira.weiny@intel.com>,
        "dan.j.williams@intel.com" <dan.j.williams@intel.com>,
        Adam Manzanares <a.manzanares@samsung.com>,
        "dave@stgolabs.net" <dave@stgolabs.net>,
        "nmtadam.samsung@gmail.com" <nmtadam.samsung@gmail.com>,
        "nifan@outlook.com" <nifan@outlook.com>
References: <20230725183939.2741025-1-fan.ni@samsung.com>
 <CGME20230725183957uscas1p1eeb8e8eccc6c00b460d183027642374b@uscas1p1.samsung.com>
 <20230725183939.2741025-6-fan.ni@samsung.com>
From: Nathan Fontenot <nafonten@amd.com>
In-Reply-To: <20230725183939.2741025-6-fan.ni@samsung.com>
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 7bit
X-ClientProxiedBy: SN6PR05CA0001.namprd05.prod.outlook.com
 (2603:10b6:805:de::14) To MN0PR12MB6222.namprd12.prod.outlook.com
 (2603:10b6:208:3c2::19)
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: MN0PR12MB6222:EE_|DM4PR12MB5914:EE_
X-MS-Office365-Filtering-Correlation-Id: 7238f7cf-cba5-4b1c-b842-08db8dd74c0a
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;
X-Microsoft-Antispam-Message-Info: KQ7bNmOauME+y21zcp5qjjxvNMKyROilPG3uKXChwlyuYjtlh2AwpqhZoyBLS+fb1VUKBl3e6Y6w7iXxiClbdj6SnWPYB0gJ/Pmqx1FuLcF+vvEugOX2jzE6+HRHm5u48uujtedT3JhT//5tmxSMvaVPQ3/vp0P7YMku0E0hnT+vVAjjLJOhFyi5ku66Q3Wo32qLf5XiblvLRep25Dsvsh7siApKJipHH4Jy0vjX2dzggnu911XcOdO0k/GXBZHpMVT6eoLptMWeW+9/rb8v1tDvOVH/1DXqyNsZ2vCWy+fuBExX7iQLk/8dtMAASM/6aitLkAUttPqJAbyiYdAA7RAOquYJYWm+oTwYqNIMt+vkwnOD6DSEc23kYDPFRz9oZF11qbSTbSvqWmBGEcuz2kl2bq0JWSN1ckxXV0cIuy3mz+CxXsMgcx4ciVmdwvB7brhgRYAVU0cTS3CrtV2wBV1Yif3w7kOZSQxmBhmD5Kl3/e//90WpoEgyiLEHQPzbosa/R/vTn6pVELyoo9xBI9PxdOXcZEyem/PD0fd+T7hOfNCtCWNLHVnR0ESz61CrurySkGElXVOwNzJMzqi3w5PJwv80r6cGfhzOVasFup7mFaHy+oWPo5HuOjk5nJ6Q912OWseQPvAi4pS2te6K8A==
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:MN0PR12MB6222.namprd12.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230028)(4636009)(376002)(396003)(39860400002)(346002)(366004)(136003)(451199021)(6506007)(26005)(186003)(2616005)(53546011)(66556008)(316002)(4326008)(36756003)(30864003)(66476007)(54906003)(2906002)(8936002)(5660300002)(66946007)(45080400002)(478600001)(6512007)(41300700001)(7416002)(8676002)(6486002)(110136005)(83380400001)(38100700002)(31696002)(31686004)(43740500002)(45980500001);DIR:OUT;SFP:1101;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?utf-8?B?V3JsbU15clVzU3hWVnl5K3hKa0JpOE5lMGtHWVkrZUtRQU1NaUQzZEtqTjNM?=
 =?utf-8?B?cWlIL0h5YThmdEVCcU1PZ252UTVmSWdONHNPYjBORmhsZ1FQdm8wcTRhRGc3?=
 =?utf-8?B?OEoySGJic0pmWWd4Q3pDWUlZWnFtY1E0WFQrWXdHSkNIQk9YRUh2YVpBMElY?=
 =?utf-8?B?WUxUcDE2NTV0Rjg1dnJOQ1c1NHBML1VLS2hacEZlK3Rub1VIQlFhdmkyUS92?=
 =?utf-8?B?WmhHZ1VMbFFNSkdudS9hcUV4M2Y0YVg4MDdEMHhpT0ZZUXQzU2Z0WTlXSncx?=
 =?utf-8?B?QUV5K2N0bEJqZ2FpYW9zRllmeTRPSzVTOWsyTXE2SjJnYSt2V25mK2RuTTl3?=
 =?utf-8?B?R0QvQ1Mxb25wTkZETVBJczRQRG5CK2pBRUxuR0pEbW5DY05VSUVPTXY3ck51?=
 =?utf-8?B?RHJ5YmFJbUZSdkhzTVFFR3cra0tBaThQZ3FpaThPUFpQMmxWYUk2R0pWMnhq?=
 =?utf-8?B?N1pZeVJwMGRBZEcxZy8xbTJ4VXdjc0FHYmNoOUhRR2xlZWV2QXhWcDZtUmtQ?=
 =?utf-8?B?TEwwQUlqS3VkZFpEdG9DVXNCTzQraWZWNUlaTGNCUUsvSi82aldRYnlEVEFI?=
 =?utf-8?B?Y3lsMzdKZXE1RzJYZUU2Um4rTXBnK0RvRHBWT2laOGlDSGFvajNlTDVNTjRD?=
 =?utf-8?B?dkczTmZYWFN5M2hMUE1CeFFXNTd4UmtPUHYyMVhZSGVqT1V5MEJUQnR3L3RO?=
 =?utf-8?B?MHdBQTRHRU9CcVFpenNpbkFTdVA2U3Z4YTMreHBiYnE2VXZRajFhWW5yZmJj?=
 =?utf-8?B?dGs2clYzNjVrdnJGdFJucGNHU2tXblpNRE1mZlFFa1krS0J0SUVFUUI0Lytj?=
 =?utf-8?B?NFdHaDA2WFplU0R4Qk1GWmJYTEY2WkI5OVViYkpIT1BBb0JQZHpPcFY2REEv?=
 =?utf-8?B?Nmhjb0JDbnByeHJkejdyTDk4eEVJY1lLcUNhNVBGU09oUm5EbUtUSGpZZnVP?=
 =?utf-8?B?bzk1Z1ZzNVJwU1NsYzJBZzN0ckVKRVJFa1FCZzJERk90QXFRMm4xNCt5N0t4?=
 =?utf-8?B?VVFBWlgwU2h6WHcrV2g1dWw1amVENndudi9HVWV1bWNUZWt1bkpYZk92L2Zr?=
 =?utf-8?B?Tkcra1NXcnpFSUFmc3NXM2VhN2pKcTM2bjRtV1NuZTNYdjVoc1dpOVQ2VkVr?=
 =?utf-8?B?amhiRnUvQmRFSnBtaTdaZk1GSTJiR1U2SURRdnRndlJZUk4vaWkwTGpYcUFV?=
 =?utf-8?B?NHQ4ekVDTWNvSDNVL0hqcTlWZmJ0TjRzL2x4UVFPWDZLOFp6SGI0SS9Zakhx?=
 =?utf-8?B?TXgrODdFMlpRTkJ4dkVGWGpPZDY4VTJYUm1Dd2NMc0dRRHdwdldMV1FxY0Z0?=
 =?utf-8?B?RjAyY25zMGVicUpWNTF3SjJDSWNLRkFNSkdTWEdDTWFCTVlBRHpFd09NYlNT?=
 =?utf-8?B?VjRnMHgzSS9yNnJOQld1OXJ2NFh3YXk3N1Q3THpxNmh3WUJ1ZlRTNzMxVmsx?=
 =?utf-8?B?bFhLUTZKWGx6Q1FXcUxQeVZVNm9Lb0s2b05ySmNzWU9BdUN2K2RyZ3hBcitt?=
 =?utf-8?B?TU1Md1hHb3IwYzR0NFZLT2NKSlY1Vk1uWVRGL2VEdExxMzN2Z2xZQVpackMv?=
 =?utf-8?B?TGZuVEFEVnJ4bUd4VWhBbXBmZFRjVDY5N1RHTWs2R0Zza1B4TVJFWDZYUys3?=
 =?utf-8?B?bWNGOVBlcHg5TlJEbDl2cVFSOGNhcHBwU01hQkFyazVxSmlBbU0xMzFwRGhp?=
 =?utf-8?B?SHh5aHkxYStHUlNSYlFTbVdOZGJxVzl1cWdTSlFZVUdwZmRZRVdLdFRpTS9U?=
 =?utf-8?B?Uy9nNEJFcmdBdDlqdU9iVnpSY05RaU51TDNkcE43THB0VlVOYjYrMytQNGFv?=
 =?utf-8?B?eGVMQXFyTkJSOThDUllvQlJWL2VhWk1SK2J0RW9VSnc3YkN6SWpJc0grL2d6?=
 =?utf-8?B?dWYrZ2NjbkpSbzQxM2pWR3pySnFsYjZudXZheDJxTXZGL2QraG56UU1jc1Jr?=
 =?utf-8?B?NWNzK2tJWGFBNWh3N0NCeDJ1a2lGTEZSUnFHb1JCRFNLRGJvLzdEYUkySHg1?=
 =?utf-8?B?UFhNOWRnNEpjeUpIcU15b2p1UFNRTERPVWFMem5DdS9vQnhmQityK20zaWJ6?=
 =?utf-8?B?SDVXQTJ0UkpvMWhuRFl2ajJkVjd2TEpGNVQyQTFIQS9tTDN0TUpoYnNxNTBq?=
 =?utf-8?Q?YZMO8iaEEDu562hPDyYSlQaSV?=
X-OriginatorOrg: amd.com
X-MS-Exchange-CrossTenant-Network-Message-Id: 7238f7cf-cba5-4b1c-b842-08db8dd74c0a
X-MS-Exchange-CrossTenant-AuthSource: MN0PR12MB6222.namprd12.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 26 Jul 2023 12:53:23.7848
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 3dd8961f-e488-4e60-8e11-a82d994e183d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: j0mos/lnRDJ67OHQI6yZ1cfqHquuNVx3SFZRDx5T/LcQgTdCWomPAmF/BhgfXj11bU6CFfJdwVGQJ+4s3CYFeQ==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: DM4PR12MB5914
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

On 7/25/23 13:39, Fan Ni wrote:
> From: Fan Ni <nifan@outlook.com>
> 
> Add (file/memory backed) host backend, all the dynamic capacity regions
> will share a single, large enough host backend. Set up address space for
> DC regions to support read/write operations to dynamic capacity for DCD.
> 
> With the change, following supports are added:
> 1. add a new property to type3 device "nonvolatile-dc-memdev" to point to host
>    memory backend for dynamic capacity;
> 2. add namespace for dynamic capacity for read/write support;
> 3. create cdat entries for each dynamic capacity region;
> 4. fix dvsec range registers to include DC regions.
> 
> Signed-off-by: Fan Ni <fan.ni@samsung.com>
> ---
>  hw/cxl/cxl-mailbox-utils.c  |  19 +++-
>  hw/mem/cxl_type3.c          | 203 +++++++++++++++++++++++++++++-------
>  include/hw/cxl/cxl_device.h |   4 +
>  3 files changed, 185 insertions(+), 41 deletions(-)
> 
> diff --git a/hw/cxl/cxl-mailbox-utils.c b/hw/cxl/cxl-mailbox-utils.c
> index dd5ea95af8..0511b8e6f7 100644
> --- a/hw/cxl/cxl-mailbox-utils.c
> +++ b/hw/cxl/cxl-mailbox-utils.c
> @@ -388,9 +388,11 @@ static CXLRetCode cmd_firmware_update_get_info(struct cxl_cmd *cmd,
>          char fw_rev4[0x10];
>      } QEMU_PACKED *fw_info;
>      QEMU_BUILD_BUG_ON(sizeof(*fw_info) != 0x50);
> +    CXLType3Dev *ct3d = container_of(cxl_dstate, CXLType3Dev, cxl_dstate);
>  
>      if ((cxl_dstate->vmem_size < CXL_CAPACITY_MULTIPLIER) ||
> -        (cxl_dstate->pmem_size < CXL_CAPACITY_MULTIPLIER)) {
> +        (cxl_dstate->pmem_size < CXL_CAPACITY_MULTIPLIER) ||
> +        (ct3d->dc.total_capacity < CXL_CAPACITY_MULTIPLIER)) {
>          return CXL_MBOX_INTERNAL_ERROR;
>      }
>  
> @@ -531,7 +533,8 @@ static CXLRetCode cmd_identify_memory_device(struct cxl_cmd *cmd,
>      CXLType3Class *cvc = CXL_TYPE3_GET_CLASS(ct3d);
>  
>      if ((!QEMU_IS_ALIGNED(cxl_dstate->vmem_size, CXL_CAPACITY_MULTIPLIER)) ||
> -        (!QEMU_IS_ALIGNED(cxl_dstate->pmem_size, CXL_CAPACITY_MULTIPLIER))) {
> +        (!QEMU_IS_ALIGNED(cxl_dstate->pmem_size, CXL_CAPACITY_MULTIPLIER)) ||
> +        (!QEMU_IS_ALIGNED(ct3d->dc.total_capacity, CXL_CAPACITY_MULTIPLIER))) {
>          return CXL_MBOX_INTERNAL_ERROR;
>      }
>  
> @@ -566,9 +569,11 @@ static CXLRetCode cmd_ccls_get_partition_info(struct cxl_cmd *cmd,
>          uint64_t next_pmem;
>      } QEMU_PACKED *part_info = (void *)cmd->payload;
>      QEMU_BUILD_BUG_ON(sizeof(*part_info) != 0x20);
> +    CXLType3Dev *ct3d = container_of(cxl_dstate, CXLType3Dev, cxl_dstate);
>  
>      if ((!QEMU_IS_ALIGNED(cxl_dstate->vmem_size, CXL_CAPACITY_MULTIPLIER)) ||
> -        (!QEMU_IS_ALIGNED(cxl_dstate->pmem_size, CXL_CAPACITY_MULTIPLIER))) {
> +        (!QEMU_IS_ALIGNED(cxl_dstate->pmem_size, CXL_CAPACITY_MULTIPLIER)) ||
> +        (!QEMU_IS_ALIGNED(ct3d->dc.total_capacity, CXL_CAPACITY_MULTIPLIER))) {
>          return CXL_MBOX_INTERNAL_ERROR;
>      }
>  
> @@ -880,7 +885,13 @@ static CXLRetCode cmd_media_clear_poison(struct cxl_cmd *cmd,
>      struct clear_poison_pl *in = (void *)cmd->payload;
>  
>      dpa = ldq_le_p(&in->dpa);
> -    if (dpa + CXL_CACHE_LINE_SIZE > cxl_dstate->static_mem_size) {
> +    if (dpa + CXL_CACHE_LINE_SIZE >= cxl_dstate->static_mem_size
> +            && ct3d->dc.num_regions == 0) {
> +        return CXL_MBOX_INVALID_PA;
> +    }
> +
> +    if (ct3d->dc.num_regions && dpa + CXL_CACHE_LINE_SIZE >=
> +            cxl_dstate->static_mem_size + ct3d->dc.total_capacity) {
>          return CXL_MBOX_INVALID_PA;
>      }
>  
> diff --git a/hw/mem/cxl_type3.c b/hw/mem/cxl_type3.c
> index b29bb2309a..76bbd9f785 100644
> --- a/hw/mem/cxl_type3.c
> +++ b/hw/mem/cxl_type3.c
> @@ -20,6 +20,7 @@
>  #include "hw/pci/spdm.h"
>  
>  #define DWORD_BYTE 4
> +#define CXL_CAPACITY_MULTIPLIER   (256 * MiB)
>  
>  /* Default CDAT entries for a memory region */
>  enum {
> @@ -33,8 +34,8 @@ enum {
>  };
>  
>  static int ct3_build_cdat_entries_for_mr(CDATSubHeader **cdat_table,
> -                                         int dsmad_handle, MemoryRegion *mr,
> -                                         bool is_pmem, uint64_t dpa_base)
> +        int dsmad_handle, uint8_t flags,
> +        uint64_t dpa_base, uint64_t size)
>  {
>      g_autofree CDATDsmas *dsmas = NULL;
>      g_autofree CDATDslbis *dslbis0 = NULL;
> @@ -53,9 +54,9 @@ static int ct3_build_cdat_entries_for_mr(CDATSubHeader **cdat_table,
>              .length = sizeof(*dsmas),
>          },
>          .DSMADhandle = dsmad_handle,
> -        .flags = is_pmem ? CDAT_DSMAS_FLAG_NV : 0,
> +        .flags = flags,
>          .DPA_base = dpa_base,
> -        .DPA_length = memory_region_size(mr),
> +        .DPA_length = size,
>      };
>  
>      /* For now, no memory side cache, plausiblish numbers */
> @@ -137,9 +138,9 @@ static int ct3_build_cdat_entries_for_mr(CDATSubHeader **cdat_table,
>           * NV: Reserved - the non volatile from DSMAS matters
>           * V: EFI_MEMORY_SP
>           */
> -        .EFI_memory_type_attr = is_pmem ? 2 : 1,
> +        .EFI_memory_type_attr = flags ? 2 : 1,
>          .DPA_offset = 0,
> -        .DPA_length = memory_region_size(mr),
> +        .DPA_length = size,
>      };
>  
>      /* Header always at start of structure */
> @@ -158,21 +159,28 @@ static int ct3_build_cdat_table(CDATSubHeader ***cdat_table, void *priv)
>      g_autofree CDATSubHeader **table = NULL;
>      CXLType3Dev *ct3d = priv;
>      MemoryRegion *volatile_mr = NULL, *nonvolatile_mr = NULL;
> +    MemoryRegion *dc_mr = NULL;
>      int dsmad_handle = 0;
>      int cur_ent = 0;
>      int len = 0;
>      int rc, i;
> +    uint64_t vmr_size = 0, pmr_size = 0;
>  
> -    if (!ct3d->hostpmem && !ct3d->hostvmem) {
> +    if (!ct3d->hostpmem && !ct3d->hostvmem && !ct3d->dc.num_regions) {
>          return 0;
>      }
>  
> +    if (ct3d->hostpmem && ct3d->hostvmem && ct3d->dc.host_dc) {
> +        warn_report("The device has static ram and pmem and dynamic capacity");
> +    }
> +
>      if (ct3d->hostvmem) {
>          volatile_mr = host_memory_backend_get_memory(ct3d->hostvmem);
>          if (!volatile_mr) {
>              return -EINVAL;
>          }
>          len += CT3_CDAT_NUM_ENTRIES;
> +        vmr_size = volatile_mr->size;
>      }
>  
>      if (ct3d->hostpmem) {
> @@ -181,6 +189,19 @@ static int ct3_build_cdat_table(CDATSubHeader ***cdat_table, void *priv)
>              return -EINVAL;
>          }
>          len += CT3_CDAT_NUM_ENTRIES;
> +        pmr_size = nonvolatile_mr->size;
> +    }
> +
> +    if (ct3d->dc.num_regions) {
> +        if (ct3d->dc.host_dc) {
> +            dc_mr = host_memory_backend_get_memory(ct3d->dc.host_dc);
> +            if (!dc_mr) {
> +                return -EINVAL;
> +            }
> +            len += CT3_CDAT_NUM_ENTRIES * ct3d->dc.num_regions;
> +        } else {
> +            return -EINVAL;
> +        }
>      }
>  
>      table = g_malloc0(len * sizeof(*table));
> @@ -190,8 +211,8 @@ static int ct3_build_cdat_table(CDATSubHeader ***cdat_table, void *priv)
>  
>      /* Now fill them in */
>      if (volatile_mr) {
> -        rc = ct3_build_cdat_entries_for_mr(table, dsmad_handle++, volatile_mr,
> -                                           false, 0);
> +        rc = ct3_build_cdat_entries_for_mr(table, dsmad_handle++,
> +                0, 0, vmr_size);
>          if (rc < 0) {
>              return rc;
>          }
> @@ -200,14 +221,37 @@ static int ct3_build_cdat_table(CDATSubHeader ***cdat_table, void *priv)
>  
>      if (nonvolatile_mr) {
>          rc = ct3_build_cdat_entries_for_mr(&(table[cur_ent]), dsmad_handle++,
> -                                           nonvolatile_mr, true,
> -                                           (volatile_mr ?
> -                                            memory_region_size(volatile_mr) : 0));
> +                CDAT_DSMAS_FLAG_NV, vmr_size, pmr_size);
>          if (rc < 0) {
>              goto error_cleanup;
>          }
>          cur_ent += CT3_CDAT_NUM_ENTRIES;
>      }
> +
> +    if (dc_mr) {
> +        uint64_t region_base = vmr_size + pmr_size;
> +
> +        /*
> +         * Currently we create cdat entries for each region, should we only
> +         * create dsmas table instead??
> +         * We assume all dc regions are non-volatile for now.
> +         *
> +         */
> +        for (i = 0; i < ct3d->dc.num_regions; i++) {
> +            rc = ct3_build_cdat_entries_for_mr(&(table[cur_ent])
> +                    , dsmad_handle++
> +                    , CDAT_DSMAS_FLAG_NV | CDAT_DSMAS_FLAG_DYNAMIC_CAP
> +                    , region_base, ct3d->dc.regions[i].len);
> +            if (rc < 0) {
> +                goto error_cleanup;
> +            }
> +            ct3d->dc.regions[i].dsmadhandle = dsmad_handle - 1;
> +
> +            cur_ent += CT3_CDAT_NUM_ENTRIES;
> +            region_base += ct3d->dc.regions[i].len;
> +        }
> +    }
> +
>      assert(len == cur_ent);
>  
>      *cdat_table = g_steal_pointer(&table);
> @@ -435,11 +479,24 @@ static void build_dvsecs(CXLType3Dev *ct3d)
>              range2_size_hi = ct3d->hostpmem->size >> 32;
>              range2_size_lo = (2 << 5) | (2 << 2) | 0x3 |
>                               (ct3d->hostpmem->size & 0xF0000000);
> +        } else if (ct3d->dc.host_dc) {
> +            range2_size_hi = ct3d->dc.host_dc->size >> 32;
> +            range2_size_lo = (2 << 5) | (2 << 2) | 0x3 |
> +                             (ct3d->dc.host_dc->size & 0xF0000000);
>          }
> -    } else {
> +    } else if (ct3d->hostpmem) {
>          range1_size_hi = ct3d->hostpmem->size >> 32;
>          range1_size_lo = (2 << 5) | (2 << 2) | 0x3 |
>                           (ct3d->hostpmem->size & 0xF0000000);
> +        if (ct3d->dc.host_dc) {
> +            range2_size_hi = ct3d->dc.host_dc->size >> 32;
> +            range2_size_lo = (2 << 5) | (2 << 2) | 0x3 |
> +                             (ct3d->dc.host_dc->size & 0xF0000000);
> +        }
> +    } else {
> +        range1_size_hi = ct3d->dc.host_dc->size >> 32;
> +        range1_size_lo = (2 << 5) | (2 << 2) | 0x3 |
> +            (ct3d->dc.host_dc->size & 0xF0000000);
>      }
>  
>      dvsec = (uint8_t *)&(CXLDVSECDevice){
> @@ -708,7 +765,8 @@ static void ct3d_reg_write(void *opaque, hwaddr offset, uint64_t value,
>  }
>  
>  /*
> - * Create a dc region to test "Get Dynamic Capacity Configuration" command.
> + * Create dc regions.
> + * TODO: region parameters are hard coded, may need to change in the future.
>   */
>  static int cxl_create_dc_regions(CXLType3Dev *ct3d)
>  {
> @@ -739,7 +797,8 @@ static bool cxl_setup_memory(CXLType3Dev *ct3d, Error **errp)
>  {
>      DeviceState *ds = DEVICE(ct3d);
>  
> -    if (!ct3d->hostmem && !ct3d->hostvmem && !ct3d->hostpmem) {
> +    if (!ct3d->hostmem && !ct3d->hostvmem && !ct3d->hostpmem
> +            && !ct3d->dc.num_regions) {
>          error_setg(errp, "at least one memdev property must be set");
>          return false;
>      } else if (ct3d->hostmem && ct3d->hostpmem) {
> @@ -807,6 +866,50 @@ static bool cxl_setup_memory(CXLType3Dev *ct3d, Error **errp)
>          return false;
>      }
>  
> +    ct3d->dc.total_capacity = 0;
> +    if (ct3d->dc.host_dc) {
> +        MemoryRegion *dc_mr;
> +        char *dc_name;
> +        uint64_t total_region_size = 0;
> +        int i;
> +
> +        dc_mr = host_memory_backend_get_memory(ct3d->dc.host_dc);
> +        if (!dc_mr) {
> +            error_setg(errp, "dynamic capacity must have backing device");
> +            return false;
> +        }
> +        /* FIXME: set dc as nonvolatile for now */
> +        memory_region_set_nonvolatile(dc_mr, true);
> +        memory_region_set_enabled(dc_mr, true);
> +        host_memory_backend_set_mapped(ct3d->dc.host_dc, true);
> +        if (ds->id) {
> +            dc_name = g_strdup_printf("cxl-dcd-dpa-dc-space:%s", ds->id);
> +        } else {
> +            dc_name = g_strdup("cxl-dcd-dpa-dc-space");
> +        }
> +        address_space_init(&ct3d->dc.host_dc_as, dc_mr, dc_name);
> +
> +        for (i = 0; i < ct3d->dc.num_regions; i++) {
> +            total_region_size += ct3d->dc.regions[i].len;
> +        }
> +        /* Make sure the host backend is large enough to cover all dc range */
> +        if (total_region_size > memory_region_size(dc_mr)) {
> +            error_setg(errp,
> +                "too small host backend size, increase to %lu MiB or more",
> +                total_region_size / 1024 / 1024);
> +            return false;
> +        }
> +
> +        if (dc_mr->size % CXL_CAPACITY_MULTIPLIER != 0) {
> +            error_setg(errp, "DC region size is unaligned to %lx",
> +                    CXL_CAPACITY_MULTIPLIER);
> +            return false;
> +        }
> +
> +        ct3d->dc.total_capacity = total_region_size;
> +        g_free(dc_name);

Shouldn't dc_name also be free'ed in the two places above where you return 
false?

I think you could just free it after the call address_space_init().

-Nathan

> +    }
> +
>      return true;
>  }
>  
> @@ -916,6 +1019,9 @@ err_release_cdat:
>  err_free_special_ops:
>      g_free(regs->special_ops);
>  err_address_space_free:
> +    if (ct3d->dc.host_dc) {
> +        address_space_destroy(&ct3d->dc.host_dc_as);
> +    }
>      if (ct3d->hostpmem) {
>          address_space_destroy(&ct3d->hostpmem_as);
>      }
> @@ -935,6 +1041,9 @@ static void ct3_exit(PCIDevice *pci_dev)
>      cxl_doe_cdat_release(cxl_cstate);
>      spdm_sock_fini(ct3d->doe_spdm.socket);
>      g_free(regs->special_ops);
> +    if (ct3d->dc.host_dc) {
> +        address_space_destroy(&ct3d->dc.host_dc_as);
> +    }
>      if (ct3d->hostpmem) {
>          address_space_destroy(&ct3d->hostpmem_as);
>      }
> @@ -999,16 +1108,24 @@ static int cxl_type3_hpa_to_as_and_dpa(CXLType3Dev *ct3d,
>                                         AddressSpace **as,
>                                         uint64_t *dpa_offset)
>  {
> -    MemoryRegion *vmr = NULL, *pmr = NULL;
> +    MemoryRegion *vmr = NULL, *pmr = NULL, *dc_mr = NULL;
> +    uint64_t vmr_size = 0, pmr_size = 0, dc_size = 0;
>  
>      if (ct3d->hostvmem) {
>          vmr = host_memory_backend_get_memory(ct3d->hostvmem);
> +        vmr_size = memory_region_size(vmr);
>      }
>      if (ct3d->hostpmem) {
>          pmr = host_memory_backend_get_memory(ct3d->hostpmem);
> +        pmr_size = memory_region_size(pmr);
> +    }
> +    if (ct3d->dc.host_dc) {
> +        dc_mr = host_memory_backend_get_memory(ct3d->dc.host_dc);
> +        /* Do we want dc_size to be dc_mr->size or not?? */
> +        dc_size = ct3d->dc.total_capacity;
>      }
>  
> -    if (!vmr && !pmr) {
> +    if (!vmr && !pmr && !dc_mr) {
>          return -ENODEV;
>      }
>  
> @@ -1016,19 +1133,19 @@ static int cxl_type3_hpa_to_as_and_dpa(CXLType3Dev *ct3d,
>          return -EINVAL;
>      }
>  
> -    if (*dpa_offset > ct3d->cxl_dstate.static_mem_size) {
> +    if ((*dpa_offset >= vmr_size + pmr_size + dc_size) ||
> +       (*dpa_offset >= vmr_size + pmr_size && ct3d->dc.num_regions == 0)) {
>          return -EINVAL;
>      }
>  
> -    if (vmr) {
> -        if (*dpa_offset < memory_region_size(vmr)) {
> -            *as = &ct3d->hostvmem_as;
> -        } else {
> -            *as = &ct3d->hostpmem_as;
> -            *dpa_offset -= memory_region_size(vmr);
> -        }
> -    } else {
> +    if (*dpa_offset < vmr_size) {
> +        *as = &ct3d->hostvmem_as;
> +    } else if (*dpa_offset < vmr_size + pmr_size) {
>          *as = &ct3d->hostpmem_as;
> +        *dpa_offset -= vmr_size;
> +    } else {
> +        *as = &ct3d->dc.host_dc_as;
> +        *dpa_offset -= (vmr_size + pmr_size);
>      }
>  
>      return 0;
> @@ -1101,6 +1218,8 @@ static Property ct3_props[] = {
>      DEFINE_PROP_STRING("cdat", CXLType3Dev, cxl_cstate.cdat.filename),
>      DEFINE_PROP_UINT16("spdm", CXLType3Dev, spdm_port, 0),
>      DEFINE_PROP_UINT8("num-dc-regions", CXLType3Dev, dc.num_regions, 0),
> +    DEFINE_PROP_LINK("nonvolatile-dc-memdev", CXLType3Dev, dc.host_dc,
> +                    TYPE_MEMORY_BACKEND, HostMemoryBackend *),
>      DEFINE_PROP_END_OF_LIST(),
>  };
>  
> @@ -1167,33 +1286,43 @@ static void set_lsa(CXLType3Dev *ct3d, const void *buf, uint64_t size,
>  
>  static bool set_cacheline(CXLType3Dev *ct3d, uint64_t dpa_offset, uint8_t *data)
>  {
> -    MemoryRegion *vmr = NULL, *pmr = NULL;
> +    MemoryRegion *vmr = NULL, *pmr = NULL, *dc_mr = NULL;
>      AddressSpace *as;
> +    uint64_t vmr_size = 0, pmr_size = 0, dc_size = 0;
>  
>      if (ct3d->hostvmem) {
>          vmr = host_memory_backend_get_memory(ct3d->hostvmem);
> +        vmr_size = memory_region_size(vmr);
>      }
>      if (ct3d->hostpmem) {
>          pmr = host_memory_backend_get_memory(ct3d->hostpmem);
> +        pmr_size = memory_region_size(pmr);
>      }
> +    if (ct3d->dc.host_dc) {
> +        dc_mr = host_memory_backend_get_memory(ct3d->dc.host_dc);
> +        dc_size = ct3d->dc.total_capacity;
> +     }
>  
> -    if (!vmr && !pmr) {
> +    if (!vmr && !pmr && !dc_mr) {
>          return false;
>      }
>  
> -    if (dpa_offset + CXL_CACHE_LINE_SIZE > ct3d->cxl_dstate.static_mem_size) {
> +    if (dpa_offset >= vmr_size + pmr_size + dc_size) {
> +        return false;
> +    }
> +    if (dpa_offset + CXL_CACHE_LINE_SIZE >= vmr_size + pmr_size
> +            && ct3d->dc.num_regions == 0) {
>          return false;
>      }
>  
> -    if (vmr) {
> -        if (dpa_offset < memory_region_size(vmr)) {
> -            as = &ct3d->hostvmem_as;
> -        } else {
> -            as = &ct3d->hostpmem_as;
> -            dpa_offset -= memory_region_size(vmr);
> -        }
> -    } else {
> +    if (dpa_offset < vmr_size) {
> +        as = &ct3d->hostvmem_as;
> +    } else if (dpa_offset < vmr_size + pmr_size) {
>          as = &ct3d->hostpmem_as;
> +        dpa_offset -= vmr->size;
> +    } else {
> +        as = &ct3d->dc.host_dc_as;
> +        dpa_offset -= (vmr_size + pmr_size);
>      }
>  
>      address_space_write(as, dpa_offset, MEMTXATTRS_UNSPECIFIED, &data,
> diff --git a/include/hw/cxl/cxl_device.h b/include/hw/cxl/cxl_device.h
> index 503c344326..1c99b05a66 100644
> --- a/include/hw/cxl/cxl_device.h
> +++ b/include/hw/cxl/cxl_device.h
> @@ -427,6 +427,10 @@ struct CXLType3Dev {
>      uint64_t poison_list_overflow_ts;
>  
>      struct dynamic_capacity {
> +        HostMemoryBackend *host_dc;
> +        AddressSpace host_dc_as;
> +        uint64_t total_capacity; /* 256M aligned */
> +
>          uint8_t num_regions; /* 0-8 regions */
>          struct CXLDCD_Region regions[DCD_MAX_REGION_NUM];
>      } dc;

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id AA386C001DF
	for <linux-cxl@archiver.kernel.org>; Wed, 26 Jul 2023 16:18:30 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S233015AbjGZQS3 (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Wed, 26 Jul 2023 12:18:29 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:42648 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S229963AbjGZQS1 (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Wed, 26 Jul 2023 12:18:27 -0400
Received: from APC01-SG2-obe.outbound.protection.outlook.com (mail-sgaapc01olkn2057.outbound.protection.outlook.com [40.92.53.57])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 327A61BDA
        for <linux-cxl@vger.kernel.org>; Wed, 26 Jul 2023 09:18:25 -0700 (PDT)
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=mn+zdbmdLkwUx/N20O9tVJQFQw4qO7X7YHhs6V35tqKfsy1tqzTeTOv3OKdNgvk2qbXdtcUbE+ZtY7+bCj4GgppdIQ4j1U79mnvDuK+QCfwg03sulv5ACZXtzW/Qa9d6MNX8FW41S58Vks46OTe2UTAMnzQf8K6KYlbU2orZ2z8HbCAqBXFHj9FhMS4hmMDoe7kmON7x7s8iTxvD5d22yNh4x43ghL2hLNUOj1N2oQ79CX662G4+YK4sR5pUy9bRrmKH8QrgsExkdqr6fXsquo4MM1Ac0sDDxz9bo/yQWZDH58CiPKXS3Srfep68de2cuEX+dzH91rcQ7CSm/d7nsw==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=aIQ6KFkbQBIvScUJ+fn0dzaJXE+6dyTLkdqHwCBkeno=;
 b=TNsy08bvUms/Jtn98x44in5C3n6iWLspIKoq1v42QSnK22dPNmSMPHa7A2lCYnWwTmojWpSvx9t5HIXqgTaakGya5EN4X6tz7AblV5U8aUMxG9WxizHSl8U7pwkLHf2DSoNzR6JpxG3tefBFyc3Emlu8XFsGt+paAlqApYCLJI6PlRWwhMwflADRpx9f+DccFVp9flkCoyOJlN889BZjMy/R+hKAa6eUjCr197bl84Vf5Pc/L1c6fsQBjUYcL1q5WyEODaRjVvFJGa6zUIc6BNigdL/fguIFNSru95/BAfQzFCe4S4O6N0HGZts8x58XG6O2XP9CvacMWQ+ejVyMMQ==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=none; dmarc=none;
 dkim=none; arc=none
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=outlook.com;
 s=selector1;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-SenderADCheck;
 bh=aIQ6KFkbQBIvScUJ+fn0dzaJXE+6dyTLkdqHwCBkeno=;
 b=lLaSVzkadUzfOSiW2Ilu50zfQKE43ESpwY4SquSML08Olesb7oA/WeAiimlY5VQKpONmYWD0HaJg9Gs8BYA7Lr2weo6IMUeBz36RDy+dUG2A+9WNS/9Cb5KMsObSPzVYeMk0dlfkkYbZ0RXF4N3diETqzZKZCpDsogD/BHjlDzIRDX14XdauQfEIjKP6tWUMv9WmI7PtZHu1dJuV1v9MWf5Ry/5y0bH0YUcAjlvIMGZ9cFwcI+lapV9RBM/C5IEMvT1HC717lbMDQHjpMb/A4K4wHYxCE5vJz6Vr2OajbmMsRnlFKtmub/hsvtZ2DQyD99Ix5K4FspyGKb013ZeiZQ==
Received: from SG2PR06MB3397.apcprd06.prod.outlook.com (2603:1096:4:7a::17) by
 TY0PR06MB5356.apcprd06.prod.outlook.com (2603:1096:400:216::8) with Microsoft
 SMTP Server (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.20.6609.33; Wed, 26 Jul 2023 16:18:19 +0000
Received: from SG2PR06MB3397.apcprd06.prod.outlook.com
 ([fe80::450:9c8c:9058:c94c]) by SG2PR06MB3397.apcprd06.prod.outlook.com
 ([fe80::450:9c8c:9058:c94c%5]) with mapi id 15.20.6609.032; Wed, 26 Jul 2023
 16:18:07 +0000
Date: Wed, 26 Jul 2023 09:17:45 -0700
From: "nifan@outlook.com" <nifan@outlook.com>
To: Nathan Fontenot <nafonten@amd.com>
Cc: Fan Ni <fan.ni@samsung.com>,
        "qemu-devel@nongnu.org" <qemu-devel@nongnu.org>,
        "jonathan.cameron@huawei.com" <jonathan.cameron@huawei.com>,
        "linux-cxl@vger.kernel.org" <linux-cxl@vger.kernel.org>,
        "gregory.price@memverge.com" <gregory.price@memverge.com>,
        "hchkuo@avery-design.com.tw" <hchkuo@avery-design.com.tw>,
        "cbrowy@avery-design.com" <cbrowy@avery-design.com>,
        "ira.weiny@intel.com" <ira.weiny@intel.com>,
        "dan.j.williams@intel.com" <dan.j.williams@intel.com>,
        Adam Manzanares <a.manzanares@samsung.com>,
        "dave@stgolabs.net" <dave@stgolabs.net>,
        "nmtadam.samsung@gmail.com" <nmtadam.samsung@gmail.com>
Subject: Re: [Qemu PATCH v2 5/9] hw/mem/cxl_type3: Add host backend and
 address space handling for DC regions
Message-ID: <SG2PR06MB3397E7869AE20F7E892E174CB200A@SG2PR06MB3397.apcprd06.prod.outlook.com>
References: <20230725183939.2741025-1-fan.ni@samsung.com>
 <CGME20230725183957uscas1p1eeb8e8eccc6c00b460d183027642374b@uscas1p1.samsung.com>
 <20230725183939.2741025-6-fan.ni@samsung.com>
 <1773a964-3597-434e-ca15-5ca1afdc116a@amd.com>
Content-Type: text/plain; charset=utf-8
Content-Disposition: inline
In-Reply-To: <1773a964-3597-434e-ca15-5ca1afdc116a@amd.com>
X-TMN: [06MWhy6vVW9LRmlyuoH+Yr8WdNIahm0qGxPa88HBiBAvpV+gX+mJr1Ynh5CJSpGt]
X-ClientProxiedBy: CH0PR13CA0056.namprd13.prod.outlook.com
 (2603:10b6:610:b2::31) To SG2PR06MB3397.apcprd06.prod.outlook.com
 (2603:1096:4:7a::17)
X-Microsoft-Original-Message-ID: <ZMFHKXXL0308YG9m@outlook.com>
MIME-Version: 1.0
X-MS-Exchange-MessageSentRepresentingType: 1
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: SG2PR06MB3397:EE_|TY0PR06MB5356:EE_
X-MS-Office365-Filtering-Correlation-Id: 8f3b9a66-4123-4ed0-1e5b-08db8df3e53d
X-Microsoft-Antispam: BCL:0;
X-Microsoft-Antispam-Message-Info: UbKpaxPT7/qoTf9hCZ4EEuTtEMgrfyCf2gUZ+6oulweBl8vd9DuAwjO8cN9qI3wsCe1zogBZmEMUy6YAJCMZN0cE/byz/Tkfitfj+TSyP17fYNHS57p2fdhW/YVqMZqj/slptMXc7nQKu+2GZt5Kqx/Dbjy9LrpDFWKBiAJzQnafrbkRd+/3wAx237N87dNqekz8oDt+AYNxVWM/64z8rxXFW0XqzptSrJcda78Hzums+btHYyJCVw5UWYivfHs2zFpn+D4dSO/CEw7JCX4Expq/3NKHGvE8rJw5etWXRZzuNhOkFvlAgJ1A2oES4w4TseGe7mG0iXiGWcWYSfdoSGKVyk5AZ/goycJ5tbmIZfs1GKGiqLsSZyDAfO5N7Z4+dyQxQZs8kNuHJ8Uvx4q8VPUJxIYWb12kiEjOSkyvsyqso0dNMLO7a2tjQ4BSEdmoU0d6UAv9iwbr0UqFC4mRy+b4/q0bK2G1W4+QNk+eDnrBMieT+d11uGbluDt4/cqp6OXlHL0VfQyW2N09ot1subO1+fxWc9GKS9oHBrsJoupA7HwWtPxYVJe9lYSdYUNU
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?utf-8?B?bXFZT2lYQUluSnFwUDRSMGdHR0xMMjQ3cWg2TTdLcWdFNGFkR0IwUHVGeUJD?=
 =?utf-8?B?bWRXNHdwdUZsTWhLT014RzgvYWYvZXRRcjJKUExyOGgyRXNDNTVWMWdkSjV4?=
 =?utf-8?B?SDNVQlQwQ01PWUR6YmJzVXIxR0NCZlUvRkFPb3lKUUpMQi9hdnJnOHRTekNt?=
 =?utf-8?B?NUNwb000eUZia0ZrdFNIb2hxNzhmdDc2K0lySVZnOXcvMkhYSm9BOFNvR21v?=
 =?utf-8?B?NkltVGpMRlhoUGZ1N3dqUHFiRU4wWGlzUExpY3QzQ1d4QmJkWFNybVhXTFZT?=
 =?utf-8?B?QmQ3ekVJckFNYWY4TXhEWktKQ1FZb0phQW1DeE90aTNBNnYzWjZpeHBoaUc3?=
 =?utf-8?B?OWw1ZUJzd1MyQnpZdWx0M0taRkZ3aE9LZm1Wc2IzeGhub2xidTQwNko5Zmxl?=
 =?utf-8?B?UHZXSkRBWUZSWFlrbjNyOUNFQ2VreTZZaSs2dEdiU3FENzQyNmpxU2FUNTZ6?=
 =?utf-8?B?RlEyM1NhandNT2lLeFVoTlJBV1dSanY1ZjhHMGJyVk9LNWFqT2tHR2VwdEt4?=
 =?utf-8?B?emREODJpS0d2WjRrRUpkclcvR3FqangzUlkwKzZwSldqR0lqQlZqU3lVa3pa?=
 =?utf-8?B?aUdSMFpPc3lUR2xNMlpXdFBFOXcxTnFDYTF0QUZFVThXdVhTbDg5M1RVRjV0?=
 =?utf-8?B?cU5DakFvblovYklDM29Od2xXZjJWdE9VZW8yZ0JDcDlBeEtHbDNRQVIvcDJy?=
 =?utf-8?B?Wmp1d0FpamdubWc5UERmNlc3OE5GcUIzSVNHNkdzbGFFaWhuemphZ1dGRmxV?=
 =?utf-8?B?VUpvcUdJK1ZKL0dTbEE2RjcvaUtCamZZNlUwVTl1WXhxQTRHUWwyOU1YeHBP?=
 =?utf-8?B?YlBBenN3My9jbHF3amg5bWg0OTVFZzJPMDRGVDcrWE93ODNkZ3FEZGQwaDZj?=
 =?utf-8?B?ai92NkZjMHZ4bklSNDgyY0Nra1JFQ3RXQWFKd0d4QzBQNytmRC9TVHU0SWdm?=
 =?utf-8?B?Tk0yNVh4c0pkSFFuVkgrdlJqanlPNCs4OEQ4eSt2aTBXMG4vV2JmWjZFYXNQ?=
 =?utf-8?B?ZVlsK2NteW5mc2RUVnptWDlMcmh4N1NpNWZmNi96eS9LSzcxR1hEcmpnaGFJ?=
 =?utf-8?B?SDBWazFwVC9YOFNvMFN5WnFGMGFIV0h1dE9FSnErbnpmL0pUb05MRXRSQVJj?=
 =?utf-8?B?QmJoZGp1dm5oVzZXR0lLRVl2eFJDU1Y4dWhaT2hESTlYNnVZSGRUMm5ia2Rn?=
 =?utf-8?B?N1RrbEFsNEtaaDA5LzlEanFybDJsTXNqM3g1SEVrOVBDVXhraENhKzB6WERv?=
 =?utf-8?B?bERBdWxSVWhlVHdCQjgzUHpnWGx5ZXNvcHhTTTc5cmFOeUFWS1RSWFJFbXRr?=
 =?utf-8?B?TTJPTWl3b2RBeEtJajhOaXdEN0xOL2Myb2xFZUowVEtITVMwdkdtYVRvMzJX?=
 =?utf-8?B?YUpCYkNVUWhtV0libmJIeWM0RjVWY2RrVlhQejMwZStuODRacTIyNVJDWlc1?=
 =?utf-8?B?KzFXZHh5T2xPVmszdVJobVJmWGwzZ1FhU3pMZVlQcUFTZldNT0NSSHJsUmxy?=
 =?utf-8?B?TUZ6aHJPR2IwWTdRa3ROMWR3RU5iRTlEWjJ5d3FNRitoUzZLcktTbmMrWkpP?=
 =?utf-8?B?UnMvSTlGM2k3QitOSGs3K1plc3ZpTWNZcU5DUzRoRW12T0NGWExmSHdEcEpY?=
 =?utf-8?B?U0RPUGMwMzhFVjJoNmw4M0FRcEFQNHdxYmRyTStxK1BoNEt1Q1RGYWpRZjJa?=
 =?utf-8?B?NDluQS9nZko5YmZIdVlBYXdoUnZjc2MzaXY1ak5YRHlaR09XY2lGVlR3PT0=?=
X-OriginatorOrg: outlook.com
X-MS-Exchange-CrossTenant-Network-Message-Id: 8f3b9a66-4123-4ed0-1e5b-08db8df3e53d
X-MS-Exchange-CrossTenant-AuthSource: SG2PR06MB3397.apcprd06.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 26 Jul 2023 16:18:07.3455
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 84df9e7f-e9f6-40af-b435-aaaaaaaaaaaa
X-MS-Exchange-CrossTenant-RMS-PersistedConsumerOrg: 00000000-0000-0000-0000-000000000000
X-MS-Exchange-Transport-CrossTenantHeadersStamped: TY0PR06MB5356
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

The 07/26/2023 07:53, Nathan Fontenot wrote:
> On 7/25/23 13:39, Fan Ni wrote:
> > From: Fan Ni <nifan@outlook.com>
> > 
> > Add (file/memory backed) host backend, all the dynamic capacity regions
> > will share a single, large enough host backend. Set up address space for
> > DC regions to support read/write operations to dynamic capacity for DCD.
> > 
> > With the change, following supports are added:
> > 1. add a new property to type3 device "nonvolatile-dc-memdev" to point to host
> >    memory backend for dynamic capacity;
> > 2. add namespace for dynamic capacity for read/write support;
> > 3. create cdat entries for each dynamic capacity region;
> > 4. fix dvsec range registers to include DC regions.
> > 
> > Signed-off-by: Fan Ni <fan.ni@samsung.com>
> > ---
> >  hw/cxl/cxl-mailbox-utils.c  |  19 +++-
> >  hw/mem/cxl_type3.c          | 203 +++++++++++++++++++++++++++++-------
> >  include/hw/cxl/cxl_device.h |   4 +
> >  3 files changed, 185 insertions(+), 41 deletions(-)
> > 
> > diff --git a/hw/cxl/cxl-mailbox-utils.c b/hw/cxl/cxl-mailbox-utils.c
> > index dd5ea95af8..0511b8e6f7 100644
> > --- a/hw/cxl/cxl-mailbox-utils.c
> > +++ b/hw/cxl/cxl-mailbox-utils.c
> > @@ -388,9 +388,11 @@ static CXLRetCode cmd_firmware_update_get_info(struct cxl_cmd *cmd,
> >          char fw_rev4[0x10];
> >      } QEMU_PACKED *fw_info;
> >      QEMU_BUILD_BUG_ON(sizeof(*fw_info) != 0x50);
> > +    CXLType3Dev *ct3d = container_of(cxl_dstate, CXLType3Dev, cxl_dstate);
> >  
> >      if ((cxl_dstate->vmem_size < CXL_CAPACITY_MULTIPLIER) ||
> > -        (cxl_dstate->pmem_size < CXL_CAPACITY_MULTIPLIER)) {
> > +        (cxl_dstate->pmem_size < CXL_CAPACITY_MULTIPLIER) ||
> > +        (ct3d->dc.total_capacity < CXL_CAPACITY_MULTIPLIER)) {
> >          return CXL_MBOX_INTERNAL_ERROR;
> >      }
> >  
> > @@ -531,7 +533,8 @@ static CXLRetCode cmd_identify_memory_device(struct cxl_cmd *cmd,
> >      CXLType3Class *cvc = CXL_TYPE3_GET_CLASS(ct3d);
> >  
> >      if ((!QEMU_IS_ALIGNED(cxl_dstate->vmem_size, CXL_CAPACITY_MULTIPLIER)) ||
> > -        (!QEMU_IS_ALIGNED(cxl_dstate->pmem_size, CXL_CAPACITY_MULTIPLIER))) {
> > +        (!QEMU_IS_ALIGNED(cxl_dstate->pmem_size, CXL_CAPACITY_MULTIPLIER)) ||
> > +        (!QEMU_IS_ALIGNED(ct3d->dc.total_capacity, CXL_CAPACITY_MULTIPLIER))) {
> >          return CXL_MBOX_INTERNAL_ERROR;
> >      }
> >  
> > @@ -566,9 +569,11 @@ static CXLRetCode cmd_ccls_get_partition_info(struct cxl_cmd *cmd,
> >          uint64_t next_pmem;
> >      } QEMU_PACKED *part_info = (void *)cmd->payload;
> >      QEMU_BUILD_BUG_ON(sizeof(*part_info) != 0x20);
> > +    CXLType3Dev *ct3d = container_of(cxl_dstate, CXLType3Dev, cxl_dstate);
> >  
> >      if ((!QEMU_IS_ALIGNED(cxl_dstate->vmem_size, CXL_CAPACITY_MULTIPLIER)) ||
> > -        (!QEMU_IS_ALIGNED(cxl_dstate->pmem_size, CXL_CAPACITY_MULTIPLIER))) {
> > +        (!QEMU_IS_ALIGNED(cxl_dstate->pmem_size, CXL_CAPACITY_MULTIPLIER)) ||
> > +        (!QEMU_IS_ALIGNED(ct3d->dc.total_capacity, CXL_CAPACITY_MULTIPLIER))) {
> >          return CXL_MBOX_INTERNAL_ERROR;
> >      }
> >  
> > @@ -880,7 +885,13 @@ static CXLRetCode cmd_media_clear_poison(struct cxl_cmd *cmd,
> >      struct clear_poison_pl *in = (void *)cmd->payload;
> >  
> >      dpa = ldq_le_p(&in->dpa);
> > -    if (dpa + CXL_CACHE_LINE_SIZE > cxl_dstate->static_mem_size) {
> > +    if (dpa + CXL_CACHE_LINE_SIZE >= cxl_dstate->static_mem_size
> > +            && ct3d->dc.num_regions == 0) {
> > +        return CXL_MBOX_INVALID_PA;
> > +    }
> > +
> > +    if (ct3d->dc.num_regions && dpa + CXL_CACHE_LINE_SIZE >=
> > +            cxl_dstate->static_mem_size + ct3d->dc.total_capacity) {
> >          return CXL_MBOX_INVALID_PA;
> >      }
> >  
> > diff --git a/hw/mem/cxl_type3.c b/hw/mem/cxl_type3.c
> > index b29bb2309a..76bbd9f785 100644
> > --- a/hw/mem/cxl_type3.c
> > +++ b/hw/mem/cxl_type3.c
> > @@ -20,6 +20,7 @@
> >  #include "hw/pci/spdm.h"
> >  
> >  #define DWORD_BYTE 4
> > +#define CXL_CAPACITY_MULTIPLIER   (256 * MiB)
> >  
> >  /* Default CDAT entries for a memory region */
> >  enum {
> > @@ -33,8 +34,8 @@ enum {
> >  };
> >  
> >  static int ct3_build_cdat_entries_for_mr(CDATSubHeader **cdat_table,
> > -                                         int dsmad_handle, MemoryRegion *mr,
> > -                                         bool is_pmem, uint64_t dpa_base)
> > +        int dsmad_handle, uint8_t flags,
> > +        uint64_t dpa_base, uint64_t size)
> >  {
> >      g_autofree CDATDsmas *dsmas = NULL;
> >      g_autofree CDATDslbis *dslbis0 = NULL;
> > @@ -53,9 +54,9 @@ static int ct3_build_cdat_entries_for_mr(CDATSubHeader **cdat_table,
> >              .length = sizeof(*dsmas),
> >          },
> >          .DSMADhandle = dsmad_handle,
> > -        .flags = is_pmem ? CDAT_DSMAS_FLAG_NV : 0,
> > +        .flags = flags,
> >          .DPA_base = dpa_base,
> > -        .DPA_length = memory_region_size(mr),
> > +        .DPA_length = size,
> >      };
> >  
> >      /* For now, no memory side cache, plausiblish numbers */
> > @@ -137,9 +138,9 @@ static int ct3_build_cdat_entries_for_mr(CDATSubHeader **cdat_table,
> >           * NV: Reserved - the non volatile from DSMAS matters
> >           * V: EFI_MEMORY_SP
> >           */
> > -        .EFI_memory_type_attr = is_pmem ? 2 : 1,
> > +        .EFI_memory_type_attr = flags ? 2 : 1,
> >          .DPA_offset = 0,
> > -        .DPA_length = memory_region_size(mr),
> > +        .DPA_length = size,
> >      };
> >  
> >      /* Header always at start of structure */
> > @@ -158,21 +159,28 @@ static int ct3_build_cdat_table(CDATSubHeader ***cdat_table, void *priv)
> >      g_autofree CDATSubHeader **table = NULL;
> >      CXLType3Dev *ct3d = priv;
> >      MemoryRegion *volatile_mr = NULL, *nonvolatile_mr = NULL;
> > +    MemoryRegion *dc_mr = NULL;
> >      int dsmad_handle = 0;
> >      int cur_ent = 0;
> >      int len = 0;
> >      int rc, i;
> > +    uint64_t vmr_size = 0, pmr_size = 0;
> >  
> > -    if (!ct3d->hostpmem && !ct3d->hostvmem) {
> > +    if (!ct3d->hostpmem && !ct3d->hostvmem && !ct3d->dc.num_regions) {
> >          return 0;
> >      }
> >  
> > +    if (ct3d->hostpmem && ct3d->hostvmem && ct3d->dc.host_dc) {
> > +        warn_report("The device has static ram and pmem and dynamic capacity");
> > +    }
> > +
> >      if (ct3d->hostvmem) {
> >          volatile_mr = host_memory_backend_get_memory(ct3d->hostvmem);
> >          if (!volatile_mr) {
> >              return -EINVAL;
> >          }
> >          len += CT3_CDAT_NUM_ENTRIES;
> > +        vmr_size = volatile_mr->size;
> >      }
> >  
> >      if (ct3d->hostpmem) {
> > @@ -181,6 +189,19 @@ static int ct3_build_cdat_table(CDATSubHeader ***cdat_table, void *priv)
> >              return -EINVAL;
> >          }
> >          len += CT3_CDAT_NUM_ENTRIES;
> > +        pmr_size = nonvolatile_mr->size;
> > +    }
> > +
> > +    if (ct3d->dc.num_regions) {
> > +        if (ct3d->dc.host_dc) {
> > +            dc_mr = host_memory_backend_get_memory(ct3d->dc.host_dc);
> > +            if (!dc_mr) {
> > +                return -EINVAL;
> > +            }
> > +            len += CT3_CDAT_NUM_ENTRIES * ct3d->dc.num_regions;
> > +        } else {
> > +            return -EINVAL;
> > +        }
> >      }
> >  
> >      table = g_malloc0(len * sizeof(*table));
> > @@ -190,8 +211,8 @@ static int ct3_build_cdat_table(CDATSubHeader ***cdat_table, void *priv)
> >  
> >      /* Now fill them in */
> >      if (volatile_mr) {
> > -        rc = ct3_build_cdat_entries_for_mr(table, dsmad_handle++, volatile_mr,
> > -                                           false, 0);
> > +        rc = ct3_build_cdat_entries_for_mr(table, dsmad_handle++,
> > +                0, 0, vmr_size);
> >          if (rc < 0) {
> >              return rc;
> >          }
> > @@ -200,14 +221,37 @@ static int ct3_build_cdat_table(CDATSubHeader ***cdat_table, void *priv)
> >  
> >      if (nonvolatile_mr) {
> >          rc = ct3_build_cdat_entries_for_mr(&(table[cur_ent]), dsmad_handle++,
> > -                                           nonvolatile_mr, true,
> > -                                           (volatile_mr ?
> > -                                            memory_region_size(volatile_mr) : 0));
> > +                CDAT_DSMAS_FLAG_NV, vmr_size, pmr_size);
> >          if (rc < 0) {
> >              goto error_cleanup;
> >          }
> >          cur_ent += CT3_CDAT_NUM_ENTRIES;
> >      }
> > +
> > +    if (dc_mr) {
> > +        uint64_t region_base = vmr_size + pmr_size;
> > +
> > +        /*
> > +         * Currently we create cdat entries for each region, should we only
> > +         * create dsmas table instead??
> > +         * We assume all dc regions are non-volatile for now.
> > +         *
> > +         */
> > +        for (i = 0; i < ct3d->dc.num_regions; i++) {
> > +            rc = ct3_build_cdat_entries_for_mr(&(table[cur_ent])
> > +                    , dsmad_handle++
> > +                    , CDAT_DSMAS_FLAG_NV | CDAT_DSMAS_FLAG_DYNAMIC_CAP
> > +                    , region_base, ct3d->dc.regions[i].len);
> > +            if (rc < 0) {
> > +                goto error_cleanup;
> > +            }
> > +            ct3d->dc.regions[i].dsmadhandle = dsmad_handle - 1;
> > +
> > +            cur_ent += CT3_CDAT_NUM_ENTRIES;
> > +            region_base += ct3d->dc.regions[i].len;
> > +        }
> > +    }
> > +
> >      assert(len == cur_ent);
> >  
> >      *cdat_table = g_steal_pointer(&table);
> > @@ -435,11 +479,24 @@ static void build_dvsecs(CXLType3Dev *ct3d)
> >              range2_size_hi = ct3d->hostpmem->size >> 32;
> >              range2_size_lo = (2 << 5) | (2 << 2) | 0x3 |
> >                               (ct3d->hostpmem->size & 0xF0000000);
> > +        } else if (ct3d->dc.host_dc) {
> > +            range2_size_hi = ct3d->dc.host_dc->size >> 32;
> > +            range2_size_lo = (2 << 5) | (2 << 2) | 0x3 |
> > +                             (ct3d->dc.host_dc->size & 0xF0000000);
> >          }
> > -    } else {
> > +    } else if (ct3d->hostpmem) {
> >          range1_size_hi = ct3d->hostpmem->size >> 32;
> >          range1_size_lo = (2 << 5) | (2 << 2) | 0x3 |
> >                           (ct3d->hostpmem->size & 0xF0000000);
> > +        if (ct3d->dc.host_dc) {
> > +            range2_size_hi = ct3d->dc.host_dc->size >> 32;
> > +            range2_size_lo = (2 << 5) | (2 << 2) | 0x3 |
> > +                             (ct3d->dc.host_dc->size & 0xF0000000);
> > +        }
> > +    } else {
> > +        range1_size_hi = ct3d->dc.host_dc->size >> 32;
> > +        range1_size_lo = (2 << 5) | (2 << 2) | 0x3 |
> > +            (ct3d->dc.host_dc->size & 0xF0000000);
> >      }
> >  
> >      dvsec = (uint8_t *)&(CXLDVSECDevice){
> > @@ -708,7 +765,8 @@ static void ct3d_reg_write(void *opaque, hwaddr offset, uint64_t value,
> >  }
> >  
> >  /*
> > - * Create a dc region to test "Get Dynamic Capacity Configuration" command.
> > + * Create dc regions.
> > + * TODO: region parameters are hard coded, may need to change in the future.
> >   */
> >  static int cxl_create_dc_regions(CXLType3Dev *ct3d)
> >  {
> > @@ -739,7 +797,8 @@ static bool cxl_setup_memory(CXLType3Dev *ct3d, Error **errp)
> >  {
> >      DeviceState *ds = DEVICE(ct3d);
> >  
> > -    if (!ct3d->hostmem && !ct3d->hostvmem && !ct3d->hostpmem) {
> > +    if (!ct3d->hostmem && !ct3d->hostvmem && !ct3d->hostpmem
> > +            && !ct3d->dc.num_regions) {
> >          error_setg(errp, "at least one memdev property must be set");
> >          return false;
> >      } else if (ct3d->hostmem && ct3d->hostpmem) {
> > @@ -807,6 +866,50 @@ static bool cxl_setup_memory(CXLType3Dev *ct3d, Error **errp)
> >          return false;
> >      }
> >  
> > +    ct3d->dc.total_capacity = 0;
> > +    if (ct3d->dc.host_dc) {
> > +        MemoryRegion *dc_mr;
> > +        char *dc_name;
> > +        uint64_t total_region_size = 0;
> > +        int i;
> > +
> > +        dc_mr = host_memory_backend_get_memory(ct3d->dc.host_dc);
> > +        if (!dc_mr) {
> > +            error_setg(errp, "dynamic capacity must have backing device");
> > +            return false;
> > +        }
> > +        /* FIXME: set dc as nonvolatile for now */
> > +        memory_region_set_nonvolatile(dc_mr, true);
> > +        memory_region_set_enabled(dc_mr, true);
> > +        host_memory_backend_set_mapped(ct3d->dc.host_dc, true);
> > +        if (ds->id) {
> > +            dc_name = g_strdup_printf("cxl-dcd-dpa-dc-space:%s", ds->id);
> > +        } else {
> > +            dc_name = g_strdup("cxl-dcd-dpa-dc-space");
> > +        }
> > +        address_space_init(&ct3d->dc.host_dc_as, dc_mr, dc_name);
> > +
> > +        for (i = 0; i < ct3d->dc.num_regions; i++) {
> > +            total_region_size += ct3d->dc.regions[i].len;
> > +        }
> > +        /* Make sure the host backend is large enough to cover all dc range */
> > +        if (total_region_size > memory_region_size(dc_mr)) {
> > +            error_setg(errp,
> > +                "too small host backend size, increase to %lu MiB or more",
> > +                total_region_size / 1024 / 1024);
> > +            return false;
> > +        }
> > +
> > +        if (dc_mr->size % CXL_CAPACITY_MULTIPLIER != 0) {
> > +            error_setg(errp, "DC region size is unaligned to %lx",
> > +                    CXL_CAPACITY_MULTIPLIER);
> > +            return false;
> > +        }
> > +
> > +        ct3d->dc.total_capacity = total_region_size;
> > +        g_free(dc_name);
> 
> Shouldn't dc_name also be free'ed in the two places above where you return 
> false?
> 
> I think you could just free it after the call address_space_init().
> 
> -Nathan

Make sense. Will fix in the next version. Thanks.

-Fan

> 
> > +    }
> > +
> >      return true;
> >  }
> >  
> > @@ -916,6 +1019,9 @@ err_release_cdat:
> >  err_free_special_ops:
> >      g_free(regs->special_ops);
> >  err_address_space_free:
> > +    if (ct3d->dc.host_dc) {
> > +        address_space_destroy(&ct3d->dc.host_dc_as);
> > +    }
> >      if (ct3d->hostpmem) {
> >          address_space_destroy(&ct3d->hostpmem_as);
> >      }
> > @@ -935,6 +1041,9 @@ static void ct3_exit(PCIDevice *pci_dev)
> >      cxl_doe_cdat_release(cxl_cstate);
> >      spdm_sock_fini(ct3d->doe_spdm.socket);
> >      g_free(regs->special_ops);
> > +    if (ct3d->dc.host_dc) {
> > +        address_space_destroy(&ct3d->dc.host_dc_as);
> > +    }
> >      if (ct3d->hostpmem) {
> >          address_space_destroy(&ct3d->hostpmem_as);
> >      }
> > @@ -999,16 +1108,24 @@ static int cxl_type3_hpa_to_as_and_dpa(CXLType3Dev *ct3d,
> >                                         AddressSpace **as,
> >                                         uint64_t *dpa_offset)
> >  {
> > -    MemoryRegion *vmr = NULL, *pmr = NULL;
> > +    MemoryRegion *vmr = NULL, *pmr = NULL, *dc_mr = NULL;
> > +    uint64_t vmr_size = 0, pmr_size = 0, dc_size = 0;
> >  
> >      if (ct3d->hostvmem) {
> >          vmr = host_memory_backend_get_memory(ct3d->hostvmem);
> > +        vmr_size = memory_region_size(vmr);
> >      }
> >      if (ct3d->hostpmem) {
> >          pmr = host_memory_backend_get_memory(ct3d->hostpmem);
> > +        pmr_size = memory_region_size(pmr);
> > +    }
> > +    if (ct3d->dc.host_dc) {
> > +        dc_mr = host_memory_backend_get_memory(ct3d->dc.host_dc);
> > +        /* Do we want dc_size to be dc_mr->size or not?? */
> > +        dc_size = ct3d->dc.total_capacity;
> >      }
> >  
> > -    if (!vmr && !pmr) {
> > +    if (!vmr && !pmr && !dc_mr) {
> >          return -ENODEV;
> >      }
> >  
> > @@ -1016,19 +1133,19 @@ static int cxl_type3_hpa_to_as_and_dpa(CXLType3Dev *ct3d,
> >          return -EINVAL;
> >      }
> >  
> > -    if (*dpa_offset > ct3d->cxl_dstate.static_mem_size) {
> > +    if ((*dpa_offset >= vmr_size + pmr_size + dc_size) ||
> > +       (*dpa_offset >= vmr_size + pmr_size && ct3d->dc.num_regions == 0)) {
> >          return -EINVAL;
> >      }
> >  
> > -    if (vmr) {
> > -        if (*dpa_offset < memory_region_size(vmr)) {
> > -            *as = &ct3d->hostvmem_as;
> > -        } else {
> > -            *as = &ct3d->hostpmem_as;
> > -            *dpa_offset -= memory_region_size(vmr);
> > -        }
> > -    } else {
> > +    if (*dpa_offset < vmr_size) {
> > +        *as = &ct3d->hostvmem_as;
> > +    } else if (*dpa_offset < vmr_size + pmr_size) {
> >          *as = &ct3d->hostpmem_as;
> > +        *dpa_offset -= vmr_size;
> > +    } else {
> > +        *as = &ct3d->dc.host_dc_as;
> > +        *dpa_offset -= (vmr_size + pmr_size);
> >      }
> >  
> >      return 0;
> > @@ -1101,6 +1218,8 @@ static Property ct3_props[] = {
> >      DEFINE_PROP_STRING("cdat", CXLType3Dev, cxl_cstate.cdat.filename),
> >      DEFINE_PROP_UINT16("spdm", CXLType3Dev, spdm_port, 0),
> >      DEFINE_PROP_UINT8("num-dc-regions", CXLType3Dev, dc.num_regions, 0),
> > +    DEFINE_PROP_LINK("nonvolatile-dc-memdev", CXLType3Dev, dc.host_dc,
> > +                    TYPE_MEMORY_BACKEND, HostMemoryBackend *),
> >      DEFINE_PROP_END_OF_LIST(),
> >  };
> >  
> > @@ -1167,33 +1286,43 @@ static void set_lsa(CXLType3Dev *ct3d, const void *buf, uint64_t size,
> >  
> >  static bool set_cacheline(CXLType3Dev *ct3d, uint64_t dpa_offset, uint8_t *data)
> >  {
> > -    MemoryRegion *vmr = NULL, *pmr = NULL;
> > +    MemoryRegion *vmr = NULL, *pmr = NULL, *dc_mr = NULL;
> >      AddressSpace *as;
> > +    uint64_t vmr_size = 0, pmr_size = 0, dc_size = 0;
> >  
> >      if (ct3d->hostvmem) {
> >          vmr = host_memory_backend_get_memory(ct3d->hostvmem);
> > +        vmr_size = memory_region_size(vmr);
> >      }
> >      if (ct3d->hostpmem) {
> >          pmr = host_memory_backend_get_memory(ct3d->hostpmem);
> > +        pmr_size = memory_region_size(pmr);
> >      }
> > +    if (ct3d->dc.host_dc) {
> > +        dc_mr = host_memory_backend_get_memory(ct3d->dc.host_dc);
> > +        dc_size = ct3d->dc.total_capacity;
> > +     }
> >  
> > -    if (!vmr && !pmr) {
> > +    if (!vmr && !pmr && !dc_mr) {
> >          return false;
> >      }
> >  
> > -    if (dpa_offset + CXL_CACHE_LINE_SIZE > ct3d->cxl_dstate.static_mem_size) {
> > +    if (dpa_offset >= vmr_size + pmr_size + dc_size) {
> > +        return false;
> > +    }
> > +    if (dpa_offset + CXL_CACHE_LINE_SIZE >= vmr_size + pmr_size
> > +            && ct3d->dc.num_regions == 0) {
> >          return false;
> >      }
> >  
> > -    if (vmr) {
> > -        if (dpa_offset < memory_region_size(vmr)) {
> > -            as = &ct3d->hostvmem_as;
> > -        } else {
> > -            as = &ct3d->hostpmem_as;
> > -            dpa_offset -= memory_region_size(vmr);
> > -        }
> > -    } else {
> > +    if (dpa_offset < vmr_size) {
> > +        as = &ct3d->hostvmem_as;
> > +    } else if (dpa_offset < vmr_size + pmr_size) {
> >          as = &ct3d->hostpmem_as;
> > +        dpa_offset -= vmr->size;
> > +    } else {
> > +        as = &ct3d->dc.host_dc_as;
> > +        dpa_offset -= (vmr_size + pmr_size);
> >      }
> >  
> >      address_space_write(as, dpa_offset, MEMTXATTRS_UNSPECIFIED, &data,
> > diff --git a/include/hw/cxl/cxl_device.h b/include/hw/cxl/cxl_device.h
> > index 503c344326..1c99b05a66 100644
> > --- a/include/hw/cxl/cxl_device.h
> > +++ b/include/hw/cxl/cxl_device.h
> > @@ -427,6 +427,10 @@ struct CXLType3Dev {
> >      uint64_t poison_list_overflow_ts;
> >  
> >      struct dynamic_capacity {
> > +        HostMemoryBackend *host_dc;
> > +        AddressSpace host_dc_as;
> > +        uint64_t total_capacity; /* 256M aligned */
> > +
> >          uint8_t num_regions; /* 0-8 regions */
> >          struct CXLDCD_Region regions[DCD_MAX_REGION_NUM];
> >      } dc;

-- 
Fan Ni <nifan@outlook.com>

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 37303C001DB
	for <linux-cxl@archiver.kernel.org>; Fri,  4 Aug 2023 14:20:03 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S229612AbjHDOUC (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Fri, 4 Aug 2023 10:20:02 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:48742 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S231468AbjHDOUB (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Fri, 4 Aug 2023 10:20:01 -0400
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 3F00B1990
        for <linux-cxl@vger.kernel.org>; Fri,  4 Aug 2023 07:20:00 -0700 (PDT)
Received: from lhrpeml500005.china.huawei.com (unknown [172.18.147.200])
        by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4RHSSJ4M8hz67lKK;
        Fri,  4 Aug 2023 22:16:16 +0800 (CST)
Received: from localhost (10.202.227.76) by lhrpeml500005.china.huawei.com
 (7.191.163.240) with Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id 15.1.2507.27; Fri, 4 Aug
 2023 15:19:57 +0100
Date: Fri, 4 Aug 2023 15:19:57 +0100
From: Jonathan Cameron <Jonathan.Cameron@Huawei.com>
To: Fan Ni <fan.ni@samsung.com>
CC: "qemu-devel@nongnu.org" <qemu-devel@nongnu.org>,
        "linux-cxl@vger.kernel.org" <linux-cxl@vger.kernel.org>,
        "gregory.price@memverge.com" <gregory.price@memverge.com>,
        "hchkuo@avery-design.com.tw" <hchkuo@avery-design.com.tw>,
        "cbrowy@avery-design.com" <cbrowy@avery-design.com>,
        "ira.weiny@intel.com" <ira.weiny@intel.com>,
        "dan.j.williams@intel.com" <dan.j.williams@intel.com>,
        Adam Manzanares <a.manzanares@samsung.com>,
        "dave@stgolabs.net" <dave@stgolabs.net>,
        "nmtadam.samsung@gmail.com" <nmtadam.samsung@gmail.com>,
        "nifan@outlook.com" <nifan@outlook.com>
Subject: Re: [Qemu PATCH v2 1/9] hw/cxl/cxl-mailbox-utils: Add
 dc_event_log_size field to output payload of identify memory device command
Message-ID: <20230804151957.00006ac1@Huawei.com>
In-Reply-To: <20230725183939.2741025-2-fan.ni@samsung.com>
References: <20230725183939.2741025-1-fan.ni@samsung.com>
        <CGME20230725183956uscas1p17a64ec512cdf5b9348451926d6f0b224@uscas1p1.samsung.com>
        <20230725183939.2741025-2-fan.ni@samsung.com>
Organization: Huawei Technologies Research and Development (UK) Ltd.
X-Mailer: Claws Mail 4.1.0 (GTK 3.24.33; x86_64-w64-mingw32)
MIME-Version: 1.0
Content-Type: text/plain; charset="US-ASCII"
Content-Transfer-Encoding: 7bit
X-Originating-IP: [10.202.227.76]
X-ClientProxiedBy: lhrpeml500003.china.huawei.com (7.191.162.67) To
 lhrpeml500005.china.huawei.com (7.191.163.240)
X-CFilter-Loop: Reflected
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

On Tue, 25 Jul 2023 18:39:55 +0000
Fan Ni <fan.ni@samsung.com> wrote:

> From: Fan Ni <nifan@outlook.com>
> 
> Based on CXL spec 3.0 Table 8-94 (Identify Memory Device Output
> Payload), dynamic capacity event log size should be part of
> output of the Identify command.
> Add dc_event_log_size to the output payload for the host to get the info.
> 
> Signed-off-by: Fan Ni <fan.ni@samsung.com>
> ---
>  hw/cxl/cxl-mailbox-utils.c | 6 +++++-
>  1 file changed, 5 insertions(+), 1 deletion(-)
> 
> diff --git a/hw/cxl/cxl-mailbox-utils.c b/hw/cxl/cxl-mailbox-utils.c
> index ad7a6116e4..b013e30314 100644
> --- a/hw/cxl/cxl-mailbox-utils.c
> +++ b/hw/cxl/cxl-mailbox-utils.c
> @@ -21,6 +21,8 @@
>  #include "sysemu/hostmem.h"
>  
>  #define CXL_CAPACITY_MULTIPLIER   (256 * MiB)
> +/* Experimental value: dynamic capacity event log size */

It's got to have some value.  Not sure why this is 'experimental'.
As such I would drop the comment as not helpful.

> +#define CXL_DC_EVENT_LOG_SIZE 8
>  
>  /*
>   * How to add a new command, example. The command set FOO, with cmd BAR.
> @@ -519,8 +521,9 @@ static CXLRetCode cmd_identify_memory_device(struct cxl_cmd *cmd,
>          uint16_t inject_poison_limit;
>          uint8_t poison_caps;
>          uint8_t qos_telemetry_caps;
> +        uint16_t dc_event_log_size;
>      } QEMU_PACKED *id;
> -    QEMU_BUILD_BUG_ON(sizeof(*id) != 0x43);
> +    QEMU_BUILD_BUG_ON(sizeof(*id) != 0x45);
>  
>      CXLType3Dev *ct3d = container_of(cxl_dstate, CXLType3Dev, cxl_dstate);
>      CXLType3Class *cvc = CXL_TYPE3_GET_CLASS(ct3d);
> @@ -543,6 +546,7 @@ static CXLRetCode cmd_identify_memory_device(struct cxl_cmd *cmd,
>      st24_le_p(id->poison_list_max_mer, 256);
>      /* No limit - so limited by main poison record limit */
>      stw_le_p(&id->inject_poison_limit, 0);
> +    stw_le_p(&id->dc_event_log_size, CXL_DC_EVENT_LOG_SIZE);
>  
>      *len = sizeof(*id);
>      return CXL_MBOX_SUCCESS;


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 3B46AC001DF
	for <linux-cxl@archiver.kernel.org>; Fri,  4 Aug 2023 15:26:20 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S232129AbjHDP0S (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Fri, 4 Aug 2023 11:26:18 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:57532 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S231490AbjHDP0B (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Fri, 4 Aug 2023 11:26:01 -0400
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id EFDDA49F0
        for <linux-cxl@vger.kernel.org>; Fri,  4 Aug 2023 08:25:25 -0700 (PDT)
Received: from lhrpeml500005.china.huawei.com (unknown [172.18.147.206])
        by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4RHTvZ0jjFz6J67F;
        Fri,  4 Aug 2023 23:21:30 +0800 (CST)
Received: from localhost (10.202.227.76) by lhrpeml500005.china.huawei.com
 (7.191.163.240) with Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id 15.1.2507.27; Fri, 4 Aug
 2023 16:24:55 +0100
Date: Fri, 4 Aug 2023 16:24:54 +0100
From: Jonathan Cameron <Jonathan.Cameron@Huawei.com>
To: Fan Ni <fan.ni@samsung.com>
CC: "qemu-devel@nongnu.org" <qemu-devel@nongnu.org>,
        "linux-cxl@vger.kernel.org" <linux-cxl@vger.kernel.org>,
        "gregory.price@memverge.com" <gregory.price@memverge.com>,
        "hchkuo@avery-design.com.tw" <hchkuo@avery-design.com.tw>,
        "cbrowy@avery-design.com" <cbrowy@avery-design.com>,
        "ira.weiny@intel.com" <ira.weiny@intel.com>,
        "dan.j.williams@intel.com" <dan.j.williams@intel.com>,
        Adam Manzanares <a.manzanares@samsung.com>,
        "dave@stgolabs.net" <dave@stgolabs.net>,
        "nmtadam.samsung@gmail.com" <nmtadam.samsung@gmail.com>,
        "nifan@outlook.com" <nifan@outlook.com>
Subject: Re: [Qemu PATCH v2 2/9] hw/cxl/cxl-mailbox-utils: Add dynamic
 capacity region representative and mailbox command support
Message-ID: <20230804162454.000052ae@Huawei.com>
In-Reply-To: <20230725183939.2741025-3-fan.ni@samsung.com>
References: <20230725183939.2741025-1-fan.ni@samsung.com>
        <CGME20230725183956uscas1p296403063c710f4b546d4fec7650915c4@uscas1p2.samsung.com>
        <20230725183939.2741025-3-fan.ni@samsung.com>
Organization: Huawei Technologies Research and Development (UK) Ltd.
X-Mailer: Claws Mail 4.1.0 (GTK 3.24.33; x86_64-w64-mingw32)
MIME-Version: 1.0
Content-Type: text/plain; charset="US-ASCII"
Content-Transfer-Encoding: 7bit
X-Originating-IP: [10.202.227.76]
X-ClientProxiedBy: lhrpeml100004.china.huawei.com (7.191.162.219) To
 lhrpeml500005.china.huawei.com (7.191.163.240)
X-CFilter-Loop: Reflected
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

On Tue, 25 Jul 2023 18:39:55 +0000
Fan Ni <fan.ni@samsung.com> wrote:

> From: Fan Ni <nifan@outlook.com>
You should fix the author on these to match the SoB

git commit --amend --author="Fan Ni <fan.ni@samsung.com>" fixes them.

I'm trying to pick these up for my tree as I review them (where they aren't
invasive).  So I'll fix this stuff whilst doing so.

I'm applying on top of the mailbox rework.  Whilst some of that
may take a while to land I think we can move the generalization code
forwards fairly soon and that changes the command functions etc to not
assume as much.

> 
> Per cxl spec 3.0, add dynamic capacity region representative based on
> Table 8-126 and extend the cxl type3 device definition to include dc region
> information. Also, based on info in 8.2.9.8.9.1, add 'Get Dynamic Capacity
> Configuration' mailbox support.
> 
> Signed-off-by: Fan Ni <fan.ni@samsung.com>
> ---
>  hw/cxl/cxl-mailbox-utils.c  | 72 +++++++++++++++++++++++++++++++++++++
>  hw/mem/cxl_type3.c          |  6 ++++
>  include/hw/cxl/cxl_device.h | 17 +++++++++
>  3 files changed, 95 insertions(+)
> 
> diff --git a/hw/cxl/cxl-mailbox-utils.c b/hw/cxl/cxl-mailbox-utils.c
> index b013e30314..0fe9f3eb5d 100644
> --- a/hw/cxl/cxl-mailbox-utils.c
> +++ b/hw/cxl/cxl-mailbox-utils.c
> @@ -81,6 +81,8 @@ enum {
>          #define GET_POISON_LIST        0x0
>          #define INJECT_POISON          0x1
>          #define CLEAR_POISON           0x2
> +    DCD_CONFIG  = 0x48, /*r3.0: 8.2.9.8.9*/

I'd not document the section here (As otherwise this list will get very messy).

> +        #define GET_DC_CONFIG          0x0
>      PHYSICAL_SWITCH = 0x51
>          #define IDENTIFY_SWITCH_DEVICE      0x0
>  };
> @@ -939,6 +941,71 @@ static CXLRetCode cmd_media_clear_poison(struct cxl_cmd *cmd,
>      return CXL_MBOX_SUCCESS;
>  }
>  
> +/*
> + * cxl spec 3.0: 8.2.9.8.9.1
> + * Get Dynamic Capacity Configuration

Here is a good place for documentation.  I'm trying to slowly standardize these
references though (might do a blanket fixup if I get time next week).
My current preference is:

 * CXL r3.0 section 8.2.9.8.9.1: Get Dynamic Capacity Configuration
 * (Opcode 4800h)

Long winded but should avoid us being forced to update this for CXL.next when
it's released (and it becomes hard to get old specs)

> + **/
> +static CXLRetCode cmd_dcd_get_dyn_cap_config(struct cxl_cmd *cmd,
> +        CXLDeviceState *cxl_dstate,
> +        uint16_t *len)
> +{
> +    struct get_dyn_cap_config_in_pl {
> +        uint8_t region_cnt;
> +        uint8_t start_region_id;
> +    } QEMU_PACKED;
> +
> +    struct get_dyn_cap_config_out_pl {
> +        uint8_t num_regions;
> +        uint8_t rsvd1[7];
> +        struct {
> +            uint64_t base;
> +            uint64_t decode_len;
> +            uint64_t region_len;
> +            uint64_t block_size;
> +            uint32_t dsmadhandle;
> +            uint8_t flags;
> +            uint8_t rsvd2[3];
> +        } QEMU_PACKED records[];
> +    } QEMU_PACKED;
> +
> +    struct get_dyn_cap_config_in_pl *in = (void *)cmd->payload;
> +    struct get_dyn_cap_config_out_pl *out = (void *)cmd->payload;

I've reworked this stuff to take into account the changes in the cci
reworking patch set. Changes the parameter etc but not too hard to 
rebase this.

> +    struct CXLType3Dev *ct3d = container_of(cxl_dstate, CXLType3Dev,
> +            cxl_dstate);
> +    uint16_t record_count = 0, i;
> +    uint16_t out_pl_len;
> +    uint8_t start_region_id = in->start_region_id;
> +
> +    if (start_region_id >= ct3d->dc.num_regions) {
> +        return CXL_MBOX_INVALID_INPUT;
> +    }
> +
> +    record_count = MIN(ct3d->dc.num_regions - in->start_region_id,
> +            in->region_cnt);
> +
> +    out_pl_len = sizeof(*out) + record_count * sizeof(out->records[0]);
> +    assert(out_pl_len <= CXL_MAILBOX_MAX_PAYLOAD_SIZE);
> +
> +    memset(out, 0, out_pl_len);
> +    out->num_regions = record_count;
> +    for (i = 0; i < record_count; i++) {
> +        stq_le_p(&out->records[i].base,
> +                ct3d->dc.regions[start_region_id + i].base);
> +        stq_le_p(&out->records[i].decode_len,
> +                ct3d->dc.regions[start_region_id + i].decode_len);
> +        stq_le_p(&out->records[i].region_len,
> +                ct3d->dc.regions[start_region_id + i].len);
> +        stq_le_p(&out->records[i].block_size,
> +                ct3d->dc.regions[start_region_id + i].block_size);
> +        stl_le_p(&out->records[i].dsmadhandle,
> +                ct3d->dc.regions[start_region_id + i].dsmadhandle);
> +        out->records[i].flags = ct3d->dc.regions[start_region_id + i].flags;
> +    }
> +
> +    *len = out_pl_len;
> +    return CXL_MBOX_SUCCESS;
> +}
> +
>  #define IMMEDIATE_CONFIG_CHANGE (1 << 1)
>  #define IMMEDIATE_DATA_CHANGE (1 << 2)
>  #define IMMEDIATE_POLICY_CHANGE (1 << 3)
> @@ -977,6 +1044,8 @@ static struct cxl_cmd cxl_cmd_set[256][256] = {
>          cmd_media_inject_poison, 8, 0 },
>      [MEDIA_AND_POISON][CLEAR_POISON] = { "MEDIA_AND_POISON_CLEAR_POISON",
>          cmd_media_clear_poison, 72, 0 },
> +    [DCD_CONFIG][GET_DC_CONFIG] = { "DCD_GET_DC_CONFIG",
> +        cmd_dcd_get_dyn_cap_config, 2, 0 },
>  };
>  
>  static struct cxl_cmd cxl_cmd_set_sw[256][256] = {
> @@ -1164,6 +1233,9 @@ void cxl_initialize_mailbox(CXLDeviceState *cxl_dstate, bool switch_cci)
>      }
>      for (int set = 0; set < 256; set++) {
>          for (int cmd = 0; cmd < 256; cmd++) {
> +            if (!cxl_dstate->is_dcd && set == DCD_CONFIG) {
> +                continue;
> +            }
Hmm. This doesn't work any more as at the level of this function we now have
a cci rather that the device state.

I've tried dropping in a version of Gregory's dynamic command registration
so we only register the DCD commands if we have enabled them.

>              if (cxl_dstate->cxl_cmd_set[set][cmd].handler) {
>                  struct cxl_cmd *c = &cxl_dstate->cxl_cmd_set[set][cmd];
>                  struct cel_log *log =
> diff --git a/hw/mem/cxl_type3.c b/hw/mem/cxl_type3.c
> index 862107c5ef..4d68824dfe 100644
> --- a/hw/mem/cxl_type3.c
> +++ b/hw/mem/cxl_type3.c
> @@ -1046,6 +1046,12 @@ static void ct3d_reset(DeviceState *dev)
>      uint32_t *reg_state = ct3d->cxl_cstate.crb.cache_mem_registers;
>      uint32_t *write_msk = ct3d->cxl_cstate.crb.cache_mem_regs_write_mask;
>  
> +    if (ct3d->dc.num_regions) {
> +        ct3d->cxl_dstate.is_dcd = true;
> +    } else {
> +        ct3d->cxl_dstate.is_dcd = false;
> +    }
> +
>      cxl_component_register_init_common(reg_state, write_msk, CXL2_TYPE3_DEVICE);
>      cxl_device_register_init_common(&ct3d->cxl_dstate);
>  }
> diff --git a/include/hw/cxl/cxl_device.h b/include/hw/cxl/cxl_device.h
> index cd7f28dba8..dae39da438 100644
> --- a/include/hw/cxl/cxl_device.h
> +++ b/include/hw/cxl/cxl_device.h
> @@ -212,6 +212,7 @@ typedef struct cxl_device_state {
>      uint64_t mem_size;
>      uint64_t pmem_size;
>      uint64_t vmem_size;
> +    bool is_dcd;
>  
>      struct cxl_cmd (*cxl_cmd_set)[256];
>      CPMUState cpmu[CXL_NUM_CPMU_INSTANCES];
> @@ -382,6 +383,17 @@ typedef struct CXLPoison {
>  typedef QLIST_HEAD(, CXLPoison) CXLPoisonList;
>  #define CXL_POISON_LIST_LIMIT 256
>  
> +#define DCD_MAX_REGION_NUM 8
> +
> +typedef struct CXLDCD_Region {
> +    uint64_t base;
> +    uint64_t decode_len; /* in multiples of 256MB */
> +    uint64_t len;
> +    uint64_t block_size;
> +    uint32_t dsmadhandle;
> +    uint8_t flags;
> +} CXLDCD_Region;

whilst we aren't always strictly inline with QEMU naming conventions
to match local style at least we should have CXLDCDRegion

> +
>  struct CXLType3Dev {
>      /* Private */
>      PCIDevice parent_obj;
> @@ -413,6 +425,11 @@ struct CXLType3Dev {
>      unsigned int poison_list_cnt;
>      bool poison_list_overflowed;
>      uint64_t poison_list_overflow_ts;
> +
> +    struct dynamic_capacity {
> +        uint8_t num_regions; /* 0-8 regions */
> +        struct CXLDCD_Region regions[DCD_MAX_REGION_NUM];
Typedef above, so
	   CXLDCDRegion regions[...]

> +    } dc;
>  };
>  
>  #define TYPE_CXL_TYPE3 "cxl-type3"


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 8E194C001DB
	for <linux-cxl@archiver.kernel.org>; Fri,  4 Aug 2023 15:29:01 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S232126AbjHDP3A (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Fri, 4 Aug 2023 11:29:00 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:34082 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S232151AbjHDP20 (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Fri, 4 Aug 2023 11:28:26 -0400
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 877294EE6
        for <linux-cxl@vger.kernel.org>; Fri,  4 Aug 2023 08:28:01 -0700 (PDT)
Received: from lhrpeml500005.china.huawei.com (unknown [172.18.147.201])
        by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4RHTz55JGTz6J6cL;
        Fri,  4 Aug 2023 23:24:33 +0800 (CST)
Received: from localhost (10.202.227.76) by lhrpeml500005.china.huawei.com
 (7.191.163.240) with Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id 15.1.2507.27; Fri, 4 Aug
 2023 16:27:59 +0100
Date: Fri, 4 Aug 2023 16:27:58 +0100
From: Jonathan Cameron <Jonathan.Cameron@Huawei.com>
To: Fan Ni <fan.ni@samsung.com>
CC: "qemu-devel@nongnu.org" <qemu-devel@nongnu.org>,
        "linux-cxl@vger.kernel.org" <linux-cxl@vger.kernel.org>,
        "gregory.price@memverge.com" <gregory.price@memverge.com>,
        "hchkuo@avery-design.com.tw" <hchkuo@avery-design.com.tw>,
        "cbrowy@avery-design.com" <cbrowy@avery-design.com>,
        "ira.weiny@intel.com" <ira.weiny@intel.com>,
        "dan.j.williams@intel.com" <dan.j.williams@intel.com>,
        Adam Manzanares <a.manzanares@samsung.com>,
        "dave@stgolabs.net" <dave@stgolabs.net>,
        "nmtadam.samsung@gmail.com" <nmtadam.samsung@gmail.com>,
        "nifan@outlook.com" <nifan@outlook.com>
Subject: Re: [Qemu PATCH v2 3/9] include/hw/cxl/cxl_device: Rename mem_size
 as static_mem_size for type3 memory devices
Message-ID: <20230804162758.000041ae@Huawei.com>
In-Reply-To: <20230725183939.2741025-4-fan.ni@samsung.com>
References: <20230725183939.2741025-1-fan.ni@samsung.com>
        <CGME20230725183956uscas1p153242eb4b12cb9cb6529476b4e9058c4@uscas1p1.samsung.com>
        <20230725183939.2741025-4-fan.ni@samsung.com>
Organization: Huawei Technologies Research and Development (UK) Ltd.
X-Mailer: Claws Mail 4.1.0 (GTK 3.24.33; x86_64-w64-mingw32)
MIME-Version: 1.0
Content-Type: text/plain; charset="US-ASCII"
Content-Transfer-Encoding: 7bit
X-Originating-IP: [10.202.227.76]
X-ClientProxiedBy: lhrpeml500001.china.huawei.com (7.191.163.213) To
 lhrpeml500005.china.huawei.com (7.191.163.240)
X-CFilter-Loop: Reflected
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

On Tue, 25 Jul 2023 18:39:55 +0000
Fan Ni <fan.ni@samsung.com> wrote:

> From: Fan Ni <nifan@outlook.com>
> 
> Rename mem_size as static_mem_size for type3 memdev to cover static RAM and
> pmem capacity, preparing for the introduction of dynamic capacity to support
> dynamic capacity devices.
> 
> Signed-off-by: Fan Ni <fan.ni@samsung.com>
Looks good.  I've picked this up with the author change.

Note that just because I've starting picking these up, doesn't
mean you can't keep changing them, but if you start from where my
gitlab.com/jic23/qemu tree is that will make life easier given
we have a lot of stuff in flight.

Jonathan

p.s. that assumes I've actually pushed the result of this out before
you get back to it!


> ---
>  hw/cxl/cxl-mailbox-utils.c  | 5 +++--
>  hw/mem/cxl_type3.c          | 8 ++++----
>  include/hw/cxl/cxl_device.h | 2 +-
>  3 files changed, 8 insertions(+), 7 deletions(-)
> 
> diff --git a/hw/cxl/cxl-mailbox-utils.c b/hw/cxl/cxl-mailbox-utils.c
> index 0fe9f3eb5d..dd5ea95af8 100644
> --- a/hw/cxl/cxl-mailbox-utils.c
> +++ b/hw/cxl/cxl-mailbox-utils.c
> @@ -540,7 +540,8 @@ static CXLRetCode cmd_identify_memory_device(struct cxl_cmd *cmd,
>  
>      snprintf(id->fw_revision, 0x10, "BWFW VERSION %02d", 0);
>  
> -    stq_le_p(&id->total_capacity, cxl_dstate->mem_size / CXL_CAPACITY_MULTIPLIER);
> +    stq_le_p(&id->total_capacity,
> +            cxl_dstate->static_mem_size / CXL_CAPACITY_MULTIPLIER);
>      stq_le_p(&id->persistent_capacity, cxl_dstate->pmem_size / CXL_CAPACITY_MULTIPLIER);
>      stq_le_p(&id->volatile_capacity, cxl_dstate->vmem_size / CXL_CAPACITY_MULTIPLIER);
>      stl_le_p(&id->lsa_size, cvc->get_lsa_size(ct3d));
> @@ -879,7 +880,7 @@ static CXLRetCode cmd_media_clear_poison(struct cxl_cmd *cmd,
>      struct clear_poison_pl *in = (void *)cmd->payload;
>  
>      dpa = ldq_le_p(&in->dpa);
> -    if (dpa + CXL_CACHE_LINE_SIZE > cxl_dstate->mem_size) {
> +    if (dpa + CXL_CACHE_LINE_SIZE > cxl_dstate->static_mem_size) {
>          return CXL_MBOX_INVALID_PA;
>      }
>  
> diff --git a/hw/mem/cxl_type3.c b/hw/mem/cxl_type3.c
> index 4d68824dfe..3d7acffcb7 100644
> --- a/hw/mem/cxl_type3.c
> +++ b/hw/mem/cxl_type3.c
> @@ -748,7 +748,7 @@ static bool cxl_setup_memory(CXLType3Dev *ct3d, Error **errp)
>          }
>          address_space_init(&ct3d->hostvmem_as, vmr, v_name);
>          ct3d->cxl_dstate.vmem_size = memory_region_size(vmr);
> -        ct3d->cxl_dstate.mem_size += memory_region_size(vmr);
> +        ct3d->cxl_dstate.static_mem_size += memory_region_size(vmr);
>          g_free(v_name);
>      }
>  
> @@ -771,7 +771,7 @@ static bool cxl_setup_memory(CXLType3Dev *ct3d, Error **errp)
>          }
>          address_space_init(&ct3d->hostpmem_as, pmr, p_name);
>          ct3d->cxl_dstate.pmem_size = memory_region_size(pmr);
> -        ct3d->cxl_dstate.mem_size += memory_region_size(pmr);
> +        ct3d->cxl_dstate.static_mem_size += memory_region_size(pmr);
>          g_free(p_name);
>      }
>  
> @@ -984,7 +984,7 @@ static int cxl_type3_hpa_to_as_and_dpa(CXLType3Dev *ct3d,
>          return -EINVAL;
>      }
>  
> -    if (*dpa_offset > ct3d->cxl_dstate.mem_size) {
> +    if (*dpa_offset > ct3d->cxl_dstate.static_mem_size) {
>          return -EINVAL;
>      }
>  
> @@ -1148,7 +1148,7 @@ static bool set_cacheline(CXLType3Dev *ct3d, uint64_t dpa_offset, uint8_t *data)
>          return false;
>      }
>  
> -    if (dpa_offset + CXL_CACHE_LINE_SIZE > ct3d->cxl_dstate.mem_size) {
> +    if (dpa_offset + CXL_CACHE_LINE_SIZE > ct3d->cxl_dstate.static_mem_size) {
>          return false;
>      }
>  
> diff --git a/include/hw/cxl/cxl_device.h b/include/hw/cxl/cxl_device.h
> index dae39da438..503c344326 100644
> --- a/include/hw/cxl/cxl_device.h
> +++ b/include/hw/cxl/cxl_device.h
> @@ -209,7 +209,7 @@ typedef struct cxl_device_state {
>      } timestamp;
>  
>      /* memory region size, HDM */
> -    uint64_t mem_size;
> +    uint64_t static_mem_size;
>      uint64_t pmem_size;
>      uint64_t vmem_size;
>      bool is_dcd;


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 96DFAC04A6A
	for <linux-cxl@archiver.kernel.org>; Fri,  4 Aug 2023 15:55:10 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S231598AbjHDPzJ (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Fri, 4 Aug 2023 11:55:09 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:50172 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S232213AbjHDPzH (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Fri, 4 Aug 2023 11:55:07 -0400
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 1CB39B2
        for <linux-cxl@vger.kernel.org>; Fri,  4 Aug 2023 08:55:06 -0700 (PDT)
Received: from lhrpeml500005.china.huawei.com (unknown [172.18.147.206])
        by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4RHVZ15Ylkz67R01;
        Fri,  4 Aug 2023 23:51:21 +0800 (CST)
Received: from localhost (10.202.227.76) by lhrpeml500005.china.huawei.com
 (7.191.163.240) with Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id 15.1.2507.27; Fri, 4 Aug
 2023 16:55:03 +0100
Date: Fri, 4 Aug 2023 16:55:02 +0100
From: Jonathan Cameron <Jonathan.Cameron@Huawei.com>
To: Fan Ni <fan.ni@samsung.com>
CC: "qemu-devel@nongnu.org" <qemu-devel@nongnu.org>,
        "linux-cxl@vger.kernel.org" <linux-cxl@vger.kernel.org>,
        "gregory.price@memverge.com" <gregory.price@memverge.com>,
        "hchkuo@avery-design.com.tw" <hchkuo@avery-design.com.tw>,
        "cbrowy@avery-design.com" <cbrowy@avery-design.com>,
        "ira.weiny@intel.com" <ira.weiny@intel.com>,
        "dan.j.williams@intel.com" <dan.j.williams@intel.com>,
        Adam Manzanares <a.manzanares@samsung.com>,
        "dave@stgolabs.net" <dave@stgolabs.net>,
        "nmtadam.samsung@gmail.com" <nmtadam.samsung@gmail.com>,
        "nifan@outlook.com" <nifan@outlook.com>
Subject: Re: [Qemu PATCH v2 4/9] hw/mem/cxl_type3: Add support to create DC
 regions to type3 memory devices
Message-ID: <20230804165502.00000ed6@Huawei.com>
In-Reply-To: <20230725183939.2741025-5-fan.ni@samsung.com>
References: <20230725183939.2741025-1-fan.ni@samsung.com>
        <CGME20230725183956uscas1p2008fba59779b70405c74d28a30e4fbaa@uscas1p2.samsung.com>
        <20230725183939.2741025-5-fan.ni@samsung.com>
Organization: Huawei Technologies Research and Development (UK) Ltd.
X-Mailer: Claws Mail 4.1.0 (GTK 3.24.33; x86_64-w64-mingw32)
MIME-Version: 1.0
Content-Type: text/plain; charset="US-ASCII"
Content-Transfer-Encoding: 7bit
X-Originating-IP: [10.202.227.76]
X-ClientProxiedBy: lhrpeml100001.china.huawei.com (7.191.160.183) To
 lhrpeml500005.china.huawei.com (7.191.163.240)
X-CFilter-Loop: Reflected
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

On Tue, 25 Jul 2023 18:39:55 +0000
Fan Ni <fan.ni@samsung.com> wrote:

> From: Fan Ni <nifan@outlook.com>
> 
> With the change, when setting up memory for type3 memory device, we can
> create DC regions
> A property 'num-dc-regions' is added to ct3_props to allow users to pass the
> number of DC regions to create. To make it easier, other region parameters
> like region base, length, and block size are hard coded. If needed,
> these parameters can be added easily.

Longer term I think we need to have an interface based on one or more
memory backends.  Gets fiddly if we allow live configuration of the regions
but for static regions it should be easy and look like the vmem and pmem
already in place.

This is good for testing in the meantime.

> 
> With the change, we can create DC regions with proper kernel side
> support as below:
> 
> region=$(cat /sys/bus/cxl/devices/decoder0.0/create_dc_region)
> echo $region> /sys/bus/cxl/devices/decoder0.0/create_dc_region
> echo 256 > /sys/bus/cxl/devices/$region/interleave_granularity
> echo 1 > /sys/bus/cxl/devices/$region/interleave_ways
> 
> echo "dc0" >/sys/bus/cxl/devices/decoder2.0/mode
> echo 0x40000000 >/sys/bus/cxl/devices/decoder2.0/dpa_size
> 
> echo 0x40000000 > /sys/bus/cxl/devices/$region/size
> echo  "decoder2.0" > /sys/bus/cxl/devices/$region/target0
> echo 1 > /sys/bus/cxl/devices/$region/commit
> echo $region > /sys/bus/cxl/drivers/cxl_region/bind
> 
> Signed-off-by: Fan Ni <fan.ni@samsung.com>
> ---
>  hw/mem/cxl_type3.c | 33 +++++++++++++++++++++++++++++++++
>  1 file changed, 33 insertions(+)
> 
> diff --git a/hw/mem/cxl_type3.c b/hw/mem/cxl_type3.c
> index 3d7acffcb7..b29bb2309a 100644
> --- a/hw/mem/cxl_type3.c
> +++ b/hw/mem/cxl_type3.c
> @@ -707,6 +707,34 @@ static void ct3d_reg_write(void *opaque, hwaddr offset, uint64_t value,
>      }
>  }
>  
> +/*
> + * Create a dc region to test "Get Dynamic Capacity Configuration" command.
> + */
> +static int cxl_create_dc_regions(CXLType3Dev *ct3d)
> +{
> +    int i;
> +    uint64_t region_base = (ct3d->hostvmem ? ct3d->hostvmem->size : 0)
> +        + (ct3d->hostpmem ? ct3d->hostpmem->size : 0);

This is getting hard to read. Perhaps long hand version with if statements is easier?

	uint64_t region_base = 0;

	if (ct3d->hostvmem) {
		region_base += ct3d->hostvmem->size;
	}
etc.


> +    uint64_t region_len = (uint64_t)2 * 1024 * 1024 * 1024;

include/qemu/units.h GiB and MiB as appropraite.

> +    uint64_t decode_len = 4; /* 4*256MB */
> +    uint64_t blk_size = 2 * 1024 * 1024;
> +    struct CXLDCD_Region *region;
> +
> +    for (i = 0; i < ct3d->dc.num_regions; i++) {
> +        region = &ct3d->dc.regions[i];
> +        region->base = region_base;
> +        region->decode_len = decode_len;
> +        region->len = region_len;
> +        region->block_size = blk_size;
> +        /* dsmad_handle is set when creating cdat table entries */
> +        region->flags = 0;
> +
> +        region_base += region->len;
> +    }
> +
> +    return 0;
> +}
> +
>  static bool cxl_setup_memory(CXLType3Dev *ct3d, Error **errp)
>  {
>      DeviceState *ds = DEVICE(ct3d);
> @@ -775,6 +803,10 @@ static bool cxl_setup_memory(CXLType3Dev *ct3d, Error **errp)
>          g_free(p_name);
>      }
>  
> +    if (cxl_create_dc_regions(ct3d)) {
> +        return false;
> +    }
> +
>      return true;
>  }
>  
> @@ -1068,6 +1100,7 @@ static Property ct3_props[] = {
>      DEFINE_PROP_UINT64("sn", CXLType3Dev, sn, UI64_NULL),
>      DEFINE_PROP_STRING("cdat", CXLType3Dev, cxl_cstate.cdat.filename),
>      DEFINE_PROP_UINT16("spdm", CXLType3Dev, spdm_port, 0),
> +    DEFINE_PROP_UINT8("num-dc-regions", CXLType3Dev, dc.num_regions, 0),
>      DEFINE_PROP_END_OF_LIST(),
>  };
>  


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 476DDC001DB
	for <linux-cxl@archiver.kernel.org>; Fri,  4 Aug 2023 16:36:32 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S229607AbjHDQgb (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Fri, 4 Aug 2023 12:36:31 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:48630 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S229504AbjHDQga (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Fri, 4 Aug 2023 12:36:30 -0400
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id ABFCCB2
        for <linux-cxl@vger.kernel.org>; Fri,  4 Aug 2023 09:36:27 -0700 (PDT)
Received: from lhrpeml500005.china.huawei.com (unknown [172.18.147.201])
        by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4RHWTk6pC3z688hZ;
        Sat,  5 Aug 2023 00:32:42 +0800 (CST)
Received: from localhost (10.202.227.76) by lhrpeml500005.china.huawei.com
 (7.191.163.240) with Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id 15.1.2507.27; Fri, 4 Aug
 2023 17:36:24 +0100
Date: Fri, 4 Aug 2023 17:36:23 +0100
From: Jonathan Cameron <Jonathan.Cameron@Huawei.com>
To: Fan Ni <fan.ni@samsung.com>
CC: "qemu-devel@nongnu.org" <qemu-devel@nongnu.org>,
        "linux-cxl@vger.kernel.org" <linux-cxl@vger.kernel.org>,
        "gregory.price@memverge.com" <gregory.price@memverge.com>,
        "hchkuo@avery-design.com.tw" <hchkuo@avery-design.com.tw>,
        "cbrowy@avery-design.com" <cbrowy@avery-design.com>,
        "ira.weiny@intel.com" <ira.weiny@intel.com>,
        "dan.j.williams@intel.com" <dan.j.williams@intel.com>,
        Adam Manzanares <a.manzanares@samsung.com>,
        "dave@stgolabs.net" <dave@stgolabs.net>,
        "nmtadam.samsung@gmail.com" <nmtadam.samsung@gmail.com>,
        "nifan@outlook.com" <nifan@outlook.com>
Subject: Re: [Qemu PATCH v2 5/9] hw/mem/cxl_type3: Add host backend and
 address space handling for DC regions
Message-ID: <20230804173623.00007707@Huawei.com>
In-Reply-To: <20230725183939.2741025-6-fan.ni@samsung.com>
References: <20230725183939.2741025-1-fan.ni@samsung.com>
        <CGME20230725183957uscas1p1eeb8e8eccc6c00b460d183027642374b@uscas1p1.samsung.com>
        <20230725183939.2741025-6-fan.ni@samsung.com>
Organization: Huawei Technologies Research and Development (UK) Ltd.
X-Mailer: Claws Mail 4.1.0 (GTK 3.24.33; x86_64-w64-mingw32)
MIME-Version: 1.0
Content-Type: text/plain; charset="US-ASCII"
Content-Transfer-Encoding: 7bit
X-Originating-IP: [10.202.227.76]
X-ClientProxiedBy: lhrpeml500004.china.huawei.com (7.191.163.9) To
 lhrpeml500005.china.huawei.com (7.191.163.240)
X-CFilter-Loop: Reflected
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

On Tue, 25 Jul 2023 18:39:56 +0000
Fan Ni <fan.ni@samsung.com> wrote:

> From: Fan Ni <nifan@outlook.com>
> 
> Add (file/memory backed) host backend, all the dynamic capacity regions
> will share a single, large enough host backend. Set up address space for
> DC regions to support read/write operations to dynamic capacity for DCD.
> 
> With the change, following supports are added:
> 1. add a new property to type3 device "nonvolatile-dc-memdev" to point to host
>    memory backend for dynamic capacity;
> 2. add namespace for dynamic capacity for read/write support;
> 3. create cdat entries for each dynamic capacity region;
> 4. fix dvsec range registers to include DC regions.
> 
> Signed-off-by: Fan Ni <fan.ni@samsung.com>
Hi Fan,

I'm not sure if we want to do all regions backed by one memory backend
or one backend each.  It will become complex when some are shared
(e.g. what Gregory is working on).

A few questions inline.  In particular there are subtle changes to
existing handling that are either bug fixes (in which case they need
to be sent first) or bugs / have no effect and shouldn't be in here.


> ---
>  hw/cxl/cxl-mailbox-utils.c  |  19 +++-
>  hw/mem/cxl_type3.c          | 203 +++++++++++++++++++++++++++++-------
>  include/hw/cxl/cxl_device.h |   4 +
>  3 files changed, 185 insertions(+), 41 deletions(-)
> 
> diff --git a/hw/cxl/cxl-mailbox-utils.c b/hw/cxl/cxl-mailbox-utils.c
> index dd5ea95af8..0511b8e6f7 100644
> --- a/hw/cxl/cxl-mailbox-utils.c
> +++ b/hw/cxl/cxl-mailbox-utils.c
> @@ -388,9 +388,11 @@ static CXLRetCode cmd_firmware_update_get_info(struct cxl_cmd *cmd,
>          char fw_rev4[0x10];
>      } QEMU_PACKED *fw_info;
>      QEMU_BUILD_BUG_ON(sizeof(*fw_info) != 0x50);
> +    CXLType3Dev *ct3d = container_of(cxl_dstate, CXLType3Dev, cxl_dstate);
>  
>      if ((cxl_dstate->vmem_size < CXL_CAPACITY_MULTIPLIER) ||
> -        (cxl_dstate->pmem_size < CXL_CAPACITY_MULTIPLIER)) {
> +        (cxl_dstate->pmem_size < CXL_CAPACITY_MULTIPLIER) ||
> +        (ct3d->dc.total_capacity < CXL_CAPACITY_MULTIPLIER)) {
>          return CXL_MBOX_INTERNAL_ERROR;
>      }
>  
> @@ -531,7 +533,8 @@ static CXLRetCode cmd_identify_memory_device(struct cxl_cmd *cmd,
>      CXLType3Class *cvc = CXL_TYPE3_GET_CLASS(ct3d);
>  
>      if ((!QEMU_IS_ALIGNED(cxl_dstate->vmem_size, CXL_CAPACITY_MULTIPLIER)) ||
> -        (!QEMU_IS_ALIGNED(cxl_dstate->pmem_size, CXL_CAPACITY_MULTIPLIER))) {
> +        (!QEMU_IS_ALIGNED(cxl_dstate->pmem_size, CXL_CAPACITY_MULTIPLIER)) ||
> +        (!QEMU_IS_ALIGNED(ct3d->dc.total_capacity, CXL_CAPACITY_MULTIPLIER))) {
>          return CXL_MBOX_INTERNAL_ERROR;
>      }
>  
> @@ -566,9 +569,11 @@ static CXLRetCode cmd_ccls_get_partition_info(struct cxl_cmd *cmd,
>          uint64_t next_pmem;
>      } QEMU_PACKED *part_info = (void *)cmd->payload;
>      QEMU_BUILD_BUG_ON(sizeof(*part_info) != 0x20);
> +    CXLType3Dev *ct3d = container_of(cxl_dstate, CXLType3Dev, cxl_dstate);
>  
>      if ((!QEMU_IS_ALIGNED(cxl_dstate->vmem_size, CXL_CAPACITY_MULTIPLIER)) ||
> -        (!QEMU_IS_ALIGNED(cxl_dstate->pmem_size, CXL_CAPACITY_MULTIPLIER))) {
> +        (!QEMU_IS_ALIGNED(cxl_dstate->pmem_size, CXL_CAPACITY_MULTIPLIER)) ||
> +        (!QEMU_IS_ALIGNED(ct3d->dc.total_capacity, CXL_CAPACITY_MULTIPLIER))) {
>          return CXL_MBOX_INTERNAL_ERROR;
>      }
>  
> @@ -880,7 +885,13 @@ static CXLRetCode cmd_media_clear_poison(struct cxl_cmd *cmd,
>      struct clear_poison_pl *in = (void *)cmd->payload;
>  
>      dpa = ldq_le_p(&in->dpa);
> -    if (dpa + CXL_CACHE_LINE_SIZE > cxl_dstate->static_mem_size) {
> +    if (dpa + CXL_CACHE_LINE_SIZE >= cxl_dstate->static_mem_size

If there is already a bug here we should pull it out. If not I can't
see why the >= change is here.  

> +            && ct3d->dc.num_regions == 0) {
> +        return CXL_MBOX_INVALID_PA;
> +    }
> +
> +    if (ct3d->dc.num_regions && dpa + CXL_CACHE_LINE_SIZE >=
> +            cxl_dstate->static_mem_size + ct3d->dc.total_capacity) {
>          return CXL_MBOX_INVALID_PA;
>      }
>  
> diff --git a/hw/mem/cxl_type3.c b/hw/mem/cxl_type3.c
> index b29bb2309a..76bbd9f785 100644
> --- a/hw/mem/cxl_type3.c
> +++ b/hw/mem/cxl_type3.c
> @@ -20,6 +20,7 @@
>  #include "hw/pci/spdm.h"
>  
>  #define DWORD_BYTE 4
> +#define CXL_CAPACITY_MULTIPLIER   (256 * MiB)
>  
>  /* Default CDAT entries for a memory region */
>  enum {
> @@ -33,8 +34,8 @@ enum {
>  };
>  
>  static int ct3_build_cdat_entries_for_mr(CDATSubHeader **cdat_table,
> -                                         int dsmad_handle, MemoryRegion *mr,
> -                                         bool is_pmem, uint64_t dpa_base)
> +        int dsmad_handle, uint8_t flags,
> +        uint64_t dpa_base, uint64_t size)
>  {
>      g_autofree CDATDsmas *dsmas = NULL;
>      g_autofree CDATDslbis *dslbis0 = NULL;
> @@ -53,9 +54,9 @@ static int ct3_build_cdat_entries_for_mr(CDATSubHeader **cdat_table,
>              .length = sizeof(*dsmas),
>          },
>          .DSMADhandle = dsmad_handle,
> -        .flags = is_pmem ? CDAT_DSMAS_FLAG_NV : 0,
> +        .flags = flags,
>          .DPA_base = dpa_base,
> -        .DPA_length = memory_region_size(mr),
> +        .DPA_length = size,
>      };
>  
>      /* For now, no memory side cache, plausiblish numbers */
> @@ -137,9 +138,9 @@ static int ct3_build_cdat_entries_for_mr(CDATSubHeader **cdat_table,
>           * NV: Reserved - the non volatile from DSMAS matters
>           * V: EFI_MEMORY_SP
>           */
> -        .EFI_memory_type_attr = is_pmem ? 2 : 1,
> +        .EFI_memory_type_attr = flags ? 2 : 1,

This doesn't look good.  Previously we used a boolean to control
this now you are using flags which contains other things?

I don't see the flags expanding that much more, so instead of
this I'd just change the function to take two booleans.
is_pmem, is_dynamic

>          .DPA_offset = 0,
> -        .DPA_length = memory_region_size(mr),
> +        .DPA_length = size,
>      };
>  
>      /* Header always at start of structure */
> @@ -158,21 +159,28 @@ static int ct3_build_cdat_table(CDATSubHeader ***cdat_table, void *priv)
>      g_autofree CDATSubHeader **table = NULL;
>      CXLType3Dev *ct3d = priv;
>      MemoryRegion *volatile_mr = NULL, *nonvolatile_mr = NULL;
> +    MemoryRegion *dc_mr = NULL;
>      int dsmad_handle = 0;
>      int cur_ent = 0;
>      int len = 0;
>      int rc, i;
> +    uint64_t vmr_size = 0, pmr_size = 0;
>  
> -    if (!ct3d->hostpmem && !ct3d->hostvmem) {
> +    if (!ct3d->hostpmem && !ct3d->hostvmem && !ct3d->dc.num_regions) {
>          return 0;
>      }
>  
> +    if (ct3d->hostpmem && ct3d->hostvmem && ct3d->dc.host_dc) {
> +        warn_report("The device has static ram and pmem and dynamic capacity");
> +    }
> +
>      if (ct3d->hostvmem) {
>          volatile_mr = host_memory_backend_get_memory(ct3d->hostvmem);
>          if (!volatile_mr) {
>              return -EINVAL;
>          }
>          len += CT3_CDAT_NUM_ENTRIES;
> +        vmr_size = volatile_mr->size;
>      }
>  
>      if (ct3d->hostpmem) {
> @@ -181,6 +189,19 @@ static int ct3_build_cdat_table(CDATSubHeader ***cdat_table, void *priv)
>              return -EINVAL;
>          }
>          len += CT3_CDAT_NUM_ENTRIES;
> +        pmr_size = nonvolatile_mr->size;
> +    }
> +
> +    if (ct3d->dc.num_regions) {
> +        if (ct3d->dc.host_dc) {
> +            dc_mr = host_memory_backend_get_memory(ct3d->dc.host_dc);
> +            if (!dc_mr) {
> +                return -EINVAL;
> +            }
> +            len += CT3_CDAT_NUM_ENTRIES * ct3d->dc.num_regions;
> +        } else {
> +            return -EINVAL;
> +        }
>      }
>  
>      table = g_malloc0(len * sizeof(*table));
> @@ -190,8 +211,8 @@ static int ct3_build_cdat_table(CDATSubHeader ***cdat_table, void *priv)
>  
>      /* Now fill them in */
>      if (volatile_mr) {
> -        rc = ct3_build_cdat_entries_for_mr(table, dsmad_handle++, volatile_mr,
> -                                           false, 0);
> +        rc = ct3_build_cdat_entries_for_mr(table, dsmad_handle++,
> +                0, 0, vmr_size);
>          if (rc < 0) {
>              return rc;
>          }
> @@ -200,14 +221,37 @@ static int ct3_build_cdat_table(CDATSubHeader ***cdat_table, void *priv)
>  
>      if (nonvolatile_mr) {
>          rc = ct3_build_cdat_entries_for_mr(&(table[cur_ent]), dsmad_handle++,
> -                                           nonvolatile_mr, true,
> -                                           (volatile_mr ?
> -                                            memory_region_size(volatile_mr) : 0));
> +                CDAT_DSMAS_FLAG_NV, vmr_size, pmr_size);

These lines don't end up that long, so I'd prefer to keep aligned 
with the brackets where we can do so and stay under 80 chars.

>          if (rc < 0) {
>              goto error_cleanup;
>          }
>          cur_ent += CT3_CDAT_NUM_ENTRIES;
>      }
> +
> +    if (dc_mr) {
> +        uint64_t region_base = vmr_size + pmr_size;
> +
> +        /*
> +         * Currently we create cdat entries for each region, should we only
> +         * create dsmas table instead??
> +         * We assume all dc regions are non-volatile for now.
> +         *
> +         */
> +        for (i = 0; i < ct3d->dc.num_regions; i++) {
> +            rc = ct3_build_cdat_entries_for_mr(&(table[cur_ent])
> +                    , dsmad_handle++
> +                    , CDAT_DSMAS_FLAG_NV | CDAT_DSMAS_FLAG_DYNAMIC_CAP
> +                    , region_base, ct3d->dc.regions[i].len);

Formatting should have those , on the end of lines, not start of next ones.

> +            if (rc < 0) {
> +                goto error_cleanup;
> +            }
> +            ct3d->dc.regions[i].dsmadhandle = dsmad_handle - 1;
> +
> +            cur_ent += CT3_CDAT_NUM_ENTRIES;
> +            region_base += ct3d->dc.regions[i].len;
> +        }
> +    }
> +
>      assert(len == cur_ent);
>  
>      *cdat_table = g_steal_pointer(&table);
> @@ -435,11 +479,24 @@ static void build_dvsecs(CXLType3Dev *ct3d)
>              range2_size_hi = ct3d->hostpmem->size >> 32;
>              range2_size_lo = (2 << 5) | (2 << 2) | 0x3 |
>                               (ct3d->hostpmem->size & 0xF0000000);
> +        } else if (ct3d->dc.host_dc) {
> +            range2_size_hi = ct3d->dc.host_dc->size >> 32;
> +            range2_size_lo = (2 << 5) | (2 << 2) | 0x3 |
> +                             (ct3d->dc.host_dc->size & 0xF0000000);
>          }
> -    } else {
> +    } else if (ct3d->hostpmem) {
>          range1_size_hi = ct3d->hostpmem->size >> 32;
>          range1_size_lo = (2 << 5) | (2 << 2) | 0x3 |
>                           (ct3d->hostpmem->size & 0xF0000000);
> +        if (ct3d->dc.host_dc) {
> +            range2_size_hi = ct3d->dc.host_dc->size >> 32;
> +            range2_size_lo = (2 << 5) | (2 << 2) | 0x3 |
> +                             (ct3d->dc.host_dc->size & 0xF0000000);
> +        }
> +    } else {
> +        range1_size_hi = ct3d->dc.host_dc->size >> 32;
> +        range1_size_lo = (2 << 5) | (2 << 2) | 0x3 |
> +            (ct3d->dc.host_dc->size & 0xF0000000);
>      }
I think we concluded in that other thread that DCD doesn't belong in here
at all?  I'll leave it for now though.

>  
>      dvsec = (uint8_t *)&(CXLDVSECDevice){
> @@ -708,7 +765,8 @@ static void ct3d_reg_write(void *opaque, hwaddr offset, uint64_t value,
>  }
>  
>  /*
> - * Create a dc region to test "Get Dynamic Capacity Configuration" command.
> + * Create dc regions.
> + * TODO: region parameters are hard coded, may need to change in the future.
>   */
>  static int cxl_create_dc_regions(CXLType3Dev *ct3d)
>  {
> @@ -739,7 +797,8 @@ static bool cxl_setup_memory(CXLType3Dev *ct3d, Error **errp)
>  {
>      DeviceState *ds = DEVICE(ct3d);
>  
> -    if (!ct3d->hostmem && !ct3d->hostvmem && !ct3d->hostpmem) {
> +    if (!ct3d->hostmem && !ct3d->hostvmem && !ct3d->hostpmem
> +            && !ct3d->dc.num_regions) {
>          error_setg(errp, "at least one memdev property must be set");
>          return false;
>      } else if (ct3d->hostmem && ct3d->hostpmem) {
> @@ -807,6 +866,50 @@ static bool cxl_setup_memory(CXLType3Dev *ct3d, Error **errp)
>          return false;
>      }
>  
> +    ct3d->dc.total_capacity = 0;
> +    if (ct3d->dc.host_dc) {
> +        MemoryRegion *dc_mr;
> +        char *dc_name;
> +        uint64_t total_region_size = 0;
> +        int i;
> +
> +        dc_mr = host_memory_backend_get_memory(ct3d->dc.host_dc);
> +        if (!dc_mr) {
> +            error_setg(errp, "dynamic capacity must have backing device");
> +            return false;
> +        }
> +        /* FIXME: set dc as nonvolatile for now */

Yup. This is where we need to think about interface, or decide
that no one cares about PMEM DCD on basis it's a pain to deal with
and I think some stuff is still not well defined in the spec.

> +        memory_region_set_nonvolatile(dc_mr, true);
> +        memory_region_set_enabled(dc_mr, true);
> +        host_memory_backend_set_mapped(ct3d->dc.host_dc, true);
> +        if (ds->id) {
> +            dc_name = g_strdup_printf("cxl-dcd-dpa-dc-space:%s", ds->id);
> +        } else {
> +            dc_name = g_strdup("cxl-dcd-dpa-dc-space");
> +        }
> +        address_space_init(&ct3d->dc.host_dc_as, dc_mr, dc_name);
> +
> +        for (i = 0; i < ct3d->dc.num_regions; i++) {
> +            total_region_size += ct3d->dc.regions[i].len;
> +        }
> +        /* Make sure the host backend is large enough to cover all dc range */
> +        if (total_region_size > memory_region_size(dc_mr)) {
> +            error_setg(errp,
> +                "too small host backend size, increase to %lu MiB or more",
> +                total_region_size / 1024 / 1024);

/ MiB

> +            return false;
> +        }
> +
> +        if (dc_mr->size % CXL_CAPACITY_MULTIPLIER != 0) {
> +            error_setg(errp, "DC region size is unaligned to %lx",
> +                    CXL_CAPACITY_MULTIPLIER);
> +            return false;
> +        }
> +
> +        ct3d->dc.total_capacity = total_region_size;
> +        g_free(dc_name);
> +    }
> +
>      return true;
>  }
>  
> @@ -916,6 +1019,9 @@ err_release_cdat:
>  err_free_special_ops:
>      g_free(regs->special_ops);
>  err_address_space_free:
> +    if (ct3d->dc.host_dc) {
> +        address_space_destroy(&ct3d->dc.host_dc_as);
> +    }
>      if (ct3d->hostpmem) {
>          address_space_destroy(&ct3d->hostpmem_as);
>      }
> @@ -935,6 +1041,9 @@ static void ct3_exit(PCIDevice *pci_dev)
>      cxl_doe_cdat_release(cxl_cstate);
>      spdm_sock_fini(ct3d->doe_spdm.socket);
>      g_free(regs->special_ops);
> +    if (ct3d->dc.host_dc) {
> +        address_space_destroy(&ct3d->dc.host_dc_as);
> +    }
>      if (ct3d->hostpmem) {
>          address_space_destroy(&ct3d->hostpmem_as);
>      }
> @@ -999,16 +1108,24 @@ static int cxl_type3_hpa_to_as_and_dpa(CXLType3Dev *ct3d,
>                                         AddressSpace **as,
>                                         uint64_t *dpa_offset)
>  {
> -    MemoryRegion *vmr = NULL, *pmr = NULL;
> +    MemoryRegion *vmr = NULL, *pmr = NULL, *dc_mr = NULL;
> +    uint64_t vmr_size = 0, pmr_size = 0, dc_size = 0;
>  
>      if (ct3d->hostvmem) {
>          vmr = host_memory_backend_get_memory(ct3d->hostvmem);
> +        vmr_size = memory_region_size(vmr);
>      }
>      if (ct3d->hostpmem) {
>          pmr = host_memory_backend_get_memory(ct3d->hostpmem);
> +        pmr_size = memory_region_size(pmr);
> +    }
> +    if (ct3d->dc.host_dc) {
> +        dc_mr = host_memory_backend_get_memory(ct3d->dc.host_dc);
> +        /* Do we want dc_size to be dc_mr->size or not?? */

yes, I think we do. No need for qemu to care about remapping and complex
allocation strategies.  The host can't tell if we are doing that or not
anyway.

> +        dc_size = ct3d->dc.total_capacity;
>      }
>  
> -    if (!vmr && !pmr) {
> +    if (!vmr && !pmr && !dc_mr) {
>          return -ENODEV;
>      }
>  
> @@ -1016,19 +1133,19 @@ static int cxl_type3_hpa_to_as_and_dpa(CXLType3Dev *ct3d,
>          return -EINVAL;
>      }
>  
> -    if (*dpa_offset > ct3d->cxl_dstate.static_mem_size) {
> +    if ((*dpa_offset >= vmr_size + pmr_size + dc_size) ||
> +       (*dpa_offset >= vmr_size + pmr_size && ct3d->dc.num_regions == 0)) {
>          return -EINVAL;
>      }
>  
> -    if (vmr) {
> -        if (*dpa_offset < memory_region_size(vmr)) {
> -            *as = &ct3d->hostvmem_as;
> -        } else {
> -            *as = &ct3d->hostpmem_as;
> -            *dpa_offset -= memory_region_size(vmr);
> -        }
> -    } else {
> +    if (*dpa_offset < vmr_size) {
> +        *as = &ct3d->hostvmem_as;
> +    } else if (*dpa_offset < vmr_size + pmr_size) {
>          *as = &ct3d->hostpmem_as;
> +        *dpa_offset -= vmr_size;
> +    } else {
> +        *as = &ct3d->dc.host_dc_as;
> +        *dpa_offset -= (vmr_size + pmr_size);
>      }
>  
>      return 0;
> @@ -1101,6 +1218,8 @@ static Property ct3_props[] = {
>      DEFINE_PROP_STRING("cdat", CXLType3Dev, cxl_cstate.cdat.filename),
>      DEFINE_PROP_UINT16("spdm", CXLType3Dev, spdm_port, 0),
>      DEFINE_PROP_UINT8("num-dc-regions", CXLType3Dev, dc.num_regions, 0),
> +    DEFINE_PROP_LINK("nonvolatile-dc-memdev", CXLType3Dev, dc.host_dc,
> +                    TYPE_MEMORY_BACKEND, HostMemoryBackend *),

I think we will want a more adaptable interface for this, but I'll apply with this for now
so we have something to iterate on.

>      DEFINE_PROP_END_OF_LIST(),
>  };
>  
> @@ -1167,33 +1286,43 @@ static void set_lsa(CXLType3Dev *ct3d, const void *buf, uint64_t size,
>  
>  static bool set_cacheline(CXLType3Dev *ct3d, uint64_t dpa_offset, uint8_t *data)
>  {
> -    MemoryRegion *vmr = NULL, *pmr = NULL;
> +    MemoryRegion *vmr = NULL, *pmr = NULL, *dc_mr = NULL;
>      AddressSpace *as;
> +    uint64_t vmr_size = 0, pmr_size = 0, dc_size = 0;
>  
>      if (ct3d->hostvmem) {
>          vmr = host_memory_backend_get_memory(ct3d->hostvmem);
> +        vmr_size = memory_region_size(vmr);
>      }
>      if (ct3d->hostpmem) {
>          pmr = host_memory_backend_get_memory(ct3d->hostpmem);
> +        pmr_size = memory_region_size(pmr);
>      }
> +    if (ct3d->dc.host_dc) {
> +        dc_mr = host_memory_backend_get_memory(ct3d->dc.host_dc);
> +        dc_size = ct3d->dc.total_capacity;
> +     }
>  
> -    if (!vmr && !pmr) {
> +    if (!vmr && !pmr && !dc_mr) {
>          return false;
>      }
>  
> -    if (dpa_offset + CXL_CACHE_LINE_SIZE > ct3d->cxl_dstate.static_mem_size) {
> +    if (dpa_offset >= vmr_size + pmr_size + dc_size) {

What is reasoning behind not having offset + cacheline size here?
DC blocks are multiples of CXL_CACHE_LINE_SIZE anyway.


> +        return false;
> +    }
> +    if (dpa_offset + CXL_CACHE_LINE_SIZE >= vmr_size + pmr_size
> +            && ct3d->dc.num_regions == 0) {

This is getting messy - we have the dc_size set above on basis
of one condition and this checked on num_regions.

Need to only allow backed regions to keep this simpler.

>          return false;
>      }


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id CFCCDC04FDF
	for <linux-cxl@archiver.kernel.org>; Fri,  4 Aug 2023 18:08:36 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S230020AbjHDSIf (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Fri, 4 Aug 2023 14:08:35 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:44302 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S230249AbjHDSId (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Fri, 4 Aug 2023 14:08:33 -0400
Received: from NAM10-MW2-obe.outbound.protection.outlook.com (mail-mw2nam10on2088.outbound.protection.outlook.com [40.107.94.88])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id EA56B4ED3
        for <linux-cxl@vger.kernel.org>; Fri,  4 Aug 2023 11:08:08 -0700 (PDT)
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=bd+IXgEWF0BY6AiKDuOB55L0dl6mPtubokO+JQDTqldTvQZmTmuLxbUYI55PkTQUuJX13+grR9Hpa9w1DPJBJhb12WQuAVw8GzxT+UUAewYXsnBIh4y1ZirVbmvSwHBMlgQHkLUdiXJ/5DA3ZStPMTxZiTO1ya59dHCxe9g9OAgRosAIm1b1f2ZDmZRrTPkOpODDe5tl/IE/xZ3Kd+XCybQjw/dnUUnGNC4y6Er83Ydcua1qEegNKq9ZWr2rOvoC9HQX2jNcHFv7rhcV002JWW6G88/VRkHZBOLFO9X0956V8ErXlejX284T8cE8V3TOujlYH4bnc1hIMahNq5GKKA==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=424i07vjtmK/mEVisWXFR0HRWSgY1E4IRFnFAmqONeA=;
 b=KGeBE/ssg4aH9IFQbJttyIAaPhQNt6RBqGSPXzy0/QAGVvQD4QKsuT3bJHZxApHIgAoQ3GWZa6hsWcoZ3r/5iNipL9MWo0AWlag1ilUE1sQnEBTJTo4fCp9xF2fa43EcZ/HwRdZRNpU71hbsVBFMmv+wdQuo6nAyO11DrBiDD/tmP1gSEQ246g/hMjFh0TUPUE25fTQXV1YkpaylCYcd5maW1OqjQwCVaxlO0My6NVXTsrgWq6ADhpXuE0lQMqxGZxFVr/oFPmIPZqZ29eeD10r51i3hNZlRIxPgJxPyRF26iKNVIGoGN+U0TDW7xhZcnzoqELuTBuk9/Vi0/7aYrw==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=memverge.com; dmarc=pass action=none header.from=memverge.com;
 dkim=pass header.d=memverge.com; arc=none
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=memverge.com;
 s=selector2;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-SenderADCheck;
 bh=424i07vjtmK/mEVisWXFR0HRWSgY1E4IRFnFAmqONeA=;
 b=gS+RtwUDux+yDqdsUZGO1gQGYLoy8q74/65Vkg0FaK0yAfvX+vxxqrWEat0DhkRarhU4jJYH+/833yHZPS22bn5LkSeO8ngc4LFXHAPfRjHGC/7X4mKf7R5lhAbZc+PaF16QjhUb56jk3DB0BEaQplTyzxMQN2Wy93v8vjRpjJg=
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=memverge.com;
Received: from SJ0PR17MB5512.namprd17.prod.outlook.com (2603:10b6:a03:394::19)
 by PH0PR17MB5755.namprd17.prod.outlook.com (2603:10b6:510:112::12) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.6652.20; Fri, 4 Aug
 2023 18:08:04 +0000
Received: from SJ0PR17MB5512.namprd17.prod.outlook.com
 ([fe80::28b3:ad85:6a11:3872]) by SJ0PR17MB5512.namprd17.prod.outlook.com
 ([fe80::28b3:ad85:6a11:3872%6]) with mapi id 15.20.6652.020; Fri, 4 Aug 2023
 18:08:04 +0000
Date: Fri, 4 Aug 2023 14:07:55 -0400
From: Gregory Price <gregory.price@memverge.com>
To: Jonathan Cameron <Jonathan.Cameron@huawei.com>
Cc: Fan Ni <fan.ni@samsung.com>,
        "qemu-devel@nongnu.org" <qemu-devel@nongnu.org>,
        "linux-cxl@vger.kernel.org" <linux-cxl@vger.kernel.org>,
        "hchkuo@avery-design.com.tw" <hchkuo@avery-design.com.tw>,
        "cbrowy@avery-design.com" <cbrowy@avery-design.com>,
        "ira.weiny@intel.com" <ira.weiny@intel.com>,
        "dan.j.williams@intel.com" <dan.j.williams@intel.com>,
        Adam Manzanares <a.manzanares@samsung.com>,
        "dave@stgolabs.net" <dave@stgolabs.net>,
        "nmtadam.samsung@gmail.com" <nmtadam.samsung@gmail.com>,
        "nifan@outlook.com" <nifan@outlook.com>
Subject: Re: [Qemu PATCH v2 5/9] hw/mem/cxl_type3: Add host backend and
 address space handling for DC regions
Message-ID: <ZM0+ewZtknlOrGMl@memverge.com>
References: <20230725183939.2741025-1-fan.ni@samsung.com>
 <CGME20230725183957uscas1p1eeb8e8eccc6c00b460d183027642374b@uscas1p1.samsung.com>
 <20230725183939.2741025-6-fan.ni@samsung.com>
 <20230804173623.00007707@Huawei.com>
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: <20230804173623.00007707@Huawei.com>
X-ClientProxiedBy: SJ0PR13CA0166.namprd13.prod.outlook.com
 (2603:10b6:a03:2c7::21) To SJ0PR17MB5512.namprd17.prod.outlook.com
 (2603:10b6:a03:394::19)
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: SJ0PR17MB5512:EE_|PH0PR17MB5755:EE_
X-MS-Office365-Filtering-Correlation-Id: 7a772df8-18c2-45b0-412c-08db9515bef9
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;
X-Microsoft-Antispam-Message-Info: wUZZCcp89U7QlxJ8dcmy3+atc/OlFtxdW445N0zcVX/yxcd5bdBO+UWPFMdT2yJVsEPW6ha9mHVPA3Qka+sTceRJU5axnk2CIE8yA6OJCyqvvjmiD1zVDDsVIcn/9mOKVT1g/mH469E7icHZlFdCC3E9mZ2qngbF9Yiv+up8Wr3+xRJOOua6osl57FV7awlLbXv8fAB0Ej9DlO6rUXlLc4OMOUHGuot3l4v0EZ9xtYh3BzyJmwBe4Z/f2BrIID08+43jt4VgpA0Ja9+AkC4qI3uI7flq5AoAckUqS0lnfyaBQhUkqruFoAIXBCSifMAxtiwyVRlM5fj9vbRP0FtHsTNVloVx7TsaqImDiMYf8gSCIU+QNrUcfPb0TT0ekq1aLDN8haNtaiPFdxpq59sdhBcIw7K4gzdOuZWZqJfgc1xtLGv2CpEupT4DuINsTe22CIe4ZrxRHBVxT3q9HEI/QfcHNXhErhybx6gaDf3ecJy5HyncQf+wXGvme5GOEdg4xr1P3LDyfaLfhq42ck8vy+nYk01JGK7BZ9zViYLQvyj9LtI8vYc6LQH20WFHwINr2hA+OF19YYSWPlsr8AFTBtx+z16aXykxCrS/KOxnfq0=
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:SJ0PR17MB5512.namprd17.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230028)(376002)(346002)(366004)(396003)(136003)(39830400003)(451199021)(1800799003)(186006)(45080400002)(478600001)(86362001)(36756003)(6486002)(6512007)(6666004)(316002)(8936002)(8676002)(41300700001)(5660300002)(6916009)(4326008)(66556008)(44832011)(66476007)(83380400001)(7416002)(54906003)(2906002)(38100700002)(66946007)(6506007)(26005)(2616005)(67856001);DIR:OUT;SFP:1101;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?us-ascii?Q?DVLeacuQr2AomBcB6uwjb2lMbXk/2mYSObaMsdnOGZo5nI+FCt5Mx7P6RBqY?=
 =?us-ascii?Q?VKKrjMQugu0un2lAGwva2zeAnRuQBsUKEJzH6n7JweVUOGvVmUVnG1zBMK/V?=
 =?us-ascii?Q?nwxlgOOOtFIWXv+nFiYPY0HxSIjziEIvN1+uRPE8oIatWBhtyrTyM1eJPLMn?=
 =?us-ascii?Q?ndb/WlhmWhpcjtp3hKxJO+Fs7gQDMW1AqLZ8AjuqKefwYuDbL6aSG12kePBc?=
 =?us-ascii?Q?kOBWZNAyRnI8h61NA2D4eMVbo3M97hynTzuEdRJbHHbkEcFoPixXxoGk38hd?=
 =?us-ascii?Q?pnF/BrdRDn/HxZWieKRN5cJLXxgsVp1Y9WyFXPHBVR2YNnZfLH5NhjHLAziA?=
 =?us-ascii?Q?o07n9JMSuXVPqrMfpO5NJ+rjqwezoLkGScrg6BwgZs/OQjv1MmKc9ZZmGLUq?=
 =?us-ascii?Q?Riwo6MppmygdjyaUUtOigW2ulHT0g6ChUnIxK09GoBB/QwuQP+ogosoMHhDS?=
 =?us-ascii?Q?DDyeCBMrP9TzjCRN5rNdZQvISzTvktN2PA3a6QbtRkQv4XwluKoYDz0HgXav?=
 =?us-ascii?Q?Ndw6PzpZm2pc6eqzkqML4oNYDKchNpU89xvbxCUY+YXicFECw2pfVwdkxcED?=
 =?us-ascii?Q?xfApXLA52/lJmjNFKmj6OnLjbeBwYrILB3tJ9HZ+CHy/fkiYs89BkVPKXJM8?=
 =?us-ascii?Q?Llg/Ngy6d+XgD+38sc0saOzKBOzZyN66eFCN48ztwXCG0bz9LdCeQlqDuBbl?=
 =?us-ascii?Q?5cOKp693zmxe10bgTK8Cu3V2uR3xRjuTIr1xv9OKmKVHDwvQizzz90YNIWhh?=
 =?us-ascii?Q?EEfHzPBzwhnywMjM61+Lyo/ZQ1dp/EFskbPYWXdv4vxZlVzChUaQipFGk5Eb?=
 =?us-ascii?Q?uwnLS9z+aWh2viz+gR255cW/hiVSkYiYsGRNThzmsSNLEtSOLOxLnVKrUYYT?=
 =?us-ascii?Q?Ujr/BL3W4xuPZY36BkiTwtymwGM04HSx4kdT+ob2OtTXdguBvLMEyR5ghhx/?=
 =?us-ascii?Q?HIR7Owz3/Z7vhP7xF3BeFFwJIc51dR2i5OXHQNQMLSR7j1/Y8VghDboIylLW?=
 =?us-ascii?Q?DLRLSVuOdX17NX69A0+IfjwWijo8KTyA6B7okrnIvboag/TYTlbxqfHaGe2L?=
 =?us-ascii?Q?/XRhbJ0attgj44882uDCbY+5u2wbWjx5VmI+DX8nFyQvMd2bHLXA2iIf8R5R?=
 =?us-ascii?Q?GOG2Tya0giNM5eJQHBIIarn8cgzHw1hJZiAigvt280PW8OmALUf1XLMl2dvV?=
 =?us-ascii?Q?dvhhJ6/E90aclbmXPndktuppTrnIMOvOFnt98kCRM88y/QqwKdkRJ8MieWbI?=
 =?us-ascii?Q?tojoFSPBzPHv9KsqZz4TLHT1BBQfJZYyI3TKfpxMQmTupvwm0FH26Wu72iY0?=
 =?us-ascii?Q?lZcMt6RRw9fhtAI/tCQYCnkFm4wPc4Q9WnYWi7txopmbqGYHJITiE9s6rkim?=
 =?us-ascii?Q?W/CPsNeIU5/s9gn12PKmxD8YglDVrg6GJ7LL9e7FmR9dh9h7tJQTtJpgaWKb?=
 =?us-ascii?Q?BVlFRp2ysyd+0HU+Ua4ns8KbYwslm9lIObc7BF6QUPTm5qgbZHUfs9a7fcNX?=
 =?us-ascii?Q?GJZM0VzQpPYZj0lylVZRiNyQE1BCbGEcirpdYY6kvYC5kyF8GKsI0C1zHYEj?=
 =?us-ascii?Q?qu+x8c1H76uJFMukpdS/JOw9E4ZK1SL3mZm2DrzvLjr7TT6lZXdg+WimDLYi?=
 =?us-ascii?Q?ZQ=3D=3D?=
X-OriginatorOrg: memverge.com
X-MS-Exchange-CrossTenant-Network-Message-Id: 7a772df8-18c2-45b0-412c-08db9515bef9
X-MS-Exchange-CrossTenant-AuthSource: SJ0PR17MB5512.namprd17.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 04 Aug 2023 18:08:03.6390
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 5c90cb59-37e7-4c81-9c07-00473d5fb682
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: cj2nxqda2eNaQi7Zgy7Ctl2QERnayKIgYJIclLssK7RijvOF+bwCOYAlVBk8IQz7LBAI31Rd+9Qe5hKayKQSoYi+vdTuPdJKv31RAETqgVY=
X-MS-Exchange-Transport-CrossTenantHeadersStamped: PH0PR17MB5755
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

On Fri, Aug 04, 2023 at 05:36:23PM +0100, Jonathan Cameron wrote:
> On Tue, 25 Jul 2023 18:39:56 +0000
> Fan Ni <fan.ni@samsung.com> wrote:
> 
> > From: Fan Ni <nifan@outlook.com>
> > 
> > Add (file/memory backed) host backend, all the dynamic capacity regions
> > will share a single, large enough host backend. Set up address space for
> > DC regions to support read/write operations to dynamic capacity for DCD.
> > 
> > With the change, following supports are added:
> > 1. add a new property to type3 device "nonvolatile-dc-memdev" to point to host
> >    memory backend for dynamic capacity;
> > 2. add namespace for dynamic capacity for read/write support;
> > 3. create cdat entries for each dynamic capacity region;
> > 4. fix dvsec range registers to include DC regions.
> > 
> > Signed-off-by: Fan Ni <fan.ni@samsung.com>
> Hi Fan,
> 
> I'm not sure if we want to do all regions backed by one memory backend
> or one backend each.  It will become complex when some are shared
> (e.g. what Gregory is working on).

I thought about this briefly when i implemented the original volatile
support due to the potential for partitioning. We landed on, iirc, 
2 backends (1 for volatile, 1 for non-volatile).

The reality, though, is the driver (presently) does not have a good way
to create more than 1 dax per memdev, and in practice with real devices
we see that this just tends to be the case: 1 dax per device.  So unless
that's going to change, ever having more than 1 backend will just be
unused complexity.

To me, this is a good example of "maybe piling everything into the core
ct3d is going to get ugly fast".  Maybe it would be better to do
something similar to the CCI interface and allow for overriding the
other functions as well.

just a thought.  I apologize for not engaging with the DCD patch set,
conferences have been keeping me busier than expected.  I plan on
putting it through the grinder this month.

> 
> A few questions inline.  In particular there are subtle changes to
> existing handling that are either bug fixes (in which case they need
> to be sent first) or bugs / have no effect and shouldn't be in here.
> 
> 
> > ---
> >  hw/cxl/cxl-mailbox-utils.c  |  19 +++-
> >  hw/mem/cxl_type3.c          | 203 +++++++++++++++++++++++++++++-------
> >  include/hw/cxl/cxl_device.h |   4 +
> >  3 files changed, 185 insertions(+), 41 deletions(-)
> > 

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id ACC4EC001B0
	for <linux-cxl@archiver.kernel.org>; Mon,  7 Aug 2023 08:54:51 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S231199AbjHGIyS (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Mon, 7 Aug 2023 04:54:18 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:39886 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S230382AbjHGIxt (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Mon, 7 Aug 2023 04:53:49 -0400
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 4AD4710FD
        for <linux-cxl@vger.kernel.org>; Mon,  7 Aug 2023 01:53:46 -0700 (PDT)
Received: from lhrpeml500005.china.huawei.com (unknown [172.18.147.206])
        by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4RK94d2TMfz67sgR;
        Mon,  7 Aug 2023 16:50:09 +0800 (CST)
Received: from localhost (10.202.227.76) by lhrpeml500005.china.huawei.com
 (7.191.163.240) with Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id 15.1.2507.27; Mon, 7 Aug
 2023 09:53:43 +0100
Date: Mon, 7 Aug 2023 09:53:42 +0100
From: Jonathan Cameron <Jonathan.Cameron@Huawei.com>
To: Fan Ni <fan.ni@samsung.com>
CC: "qemu-devel@nongnu.org" <qemu-devel@nongnu.org>,
        "linux-cxl@vger.kernel.org" <linux-cxl@vger.kernel.org>,
        "gregory.price@memverge.com" <gregory.price@memverge.com>,
        "hchkuo@avery-design.com.tw" <hchkuo@avery-design.com.tw>,
        "cbrowy@avery-design.com" <cbrowy@avery-design.com>,
        "ira.weiny@intel.com" <ira.weiny@intel.com>,
        "dan.j.williams@intel.com" <dan.j.williams@intel.com>,
        Adam Manzanares <a.manzanares@samsung.com>,
        "dave@stgolabs.net" <dave@stgolabs.net>,
        "nmtadam.samsung@gmail.com" <nmtadam.samsung@gmail.com>,
        "nifan@outlook.com" <nifan@outlook.com>
Subject: Re: [Qemu PATCH v2 9/9] hw/mem/cxl_type3: Add dpa range validation
 for accesses to dc regions
Message-ID: <20230807095342.00006f88@Huawei.com>
In-Reply-To: <20230725183939.2741025-10-fan.ni@samsung.com>
References: <20230725183939.2741025-1-fan.ni@samsung.com>
        <CGME20230725183957uscas1p2ca5293c7229ab989ad1a2d95395436a6@uscas1p2.samsung.com>
        <20230725183939.2741025-10-fan.ni@samsung.com>
Organization: Huawei Technologies Research and Development (UK) Ltd.
X-Mailer: Claws Mail 4.1.0 (GTK 3.24.33; x86_64-w64-mingw32)
MIME-Version: 1.0
Content-Type: text/plain; charset="US-ASCII"
Content-Transfer-Encoding: 7bit
X-Originating-IP: [10.202.227.76]
X-ClientProxiedBy: lhrpeml500005.china.huawei.com (7.191.163.240) To
 lhrpeml500005.china.huawei.com (7.191.163.240)
X-CFilter-Loop: Reflected
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

On Tue, 25 Jul 2023 18:39:56 +0000
Fan Ni <fan.ni@samsung.com> wrote:

> From: Fan Ni <nifan@outlook.com>
> 
> Not all dpa range in the dc regions is valid to access until an extent
> covering the range has been added. Add a bitmap for each region to
> record whether a dc block in the region has been backed by dc extent.
> For the bitmap, a bit in the bitmap represents a dc block. When a dc
> extent is added, all the bits of the blocks in the extent will be set,
> which will be cleared when the extent is released.
> 
> Signed-off-by: Fan Ni <fan.ni@samsung.com>
Hi Fan,

A few of the bits of feedback apply broadly across the series.  Given I'm
rebasing this anyway to give myself something to test I'll tidy things up
(feel free to disagree with and revert any changes !) 
and push a tree out in next day or two.  I'll message when I've done so.

Jonathan

> ---
>  hw/mem/cxl_type3.c          | 155 ++++++++++++++++++++++++++++++++++++
>  include/hw/cxl/cxl_device.h |   1 +
>  2 files changed, 156 insertions(+)
> 
> diff --git a/hw/mem/cxl_type3.c b/hw/mem/cxl_type3.c
> index 41a828598a..51943a36fc 100644
> --- a/hw/mem/cxl_type3.c
> +++ b/hw/mem/cxl_type3.c
> @@ -787,13 +787,37 @@ static int cxl_create_dc_regions(CXLType3Dev *ct3d)
>          /* dsmad_handle is set when creating cdat table entries */
>          region->flags = 0;
>  
> +        region->blk_bitmap = bitmap_new(region->len / region->block_size);

In common with many allocators in qemu if this fails it calls abort()
internally so no need to handle potential errors.

> +        if (!region->blk_bitmap) {
> +            break;
> +        }
> +
>          region_base += region->len;
>      }
> +
> +    if (i < ct3d->dc.num_regions) {
> +        while (--i >= 0) {
> +            g_free(ct3d->dc.regions[i].blk_bitmap);
> +        }
> +        return -1;
> +    }
> +
>      QTAILQ_INIT(&ct3d->dc.extents);
>  
>      return 0;
>  }
>  
> +static void cxl_destroy_dc_regions(CXLType3Dev *ct3d)
> +{
> +    int i;
> +    struct CXLDCD_Region *region;
> +
> +    for (i = 0; i < ct3d->dc.num_regions; i++) {
> +        region = &ct3d->dc.regions[i];
> +        g_free(region->blk_bitmap);
> +    }
> +}
> +
>  static bool cxl_setup_memory(CXLType3Dev *ct3d, Error **errp)
>  {
>      DeviceState *ds = DEVICE(ct3d);
> @@ -1021,6 +1045,7 @@ err_free_special_ops:
>      g_free(regs->special_ops);
>  err_address_space_free:
>      if (ct3d->dc.host_dc) {
> +        cxl_destroy_dc_regions(ct3d);
>          address_space_destroy(&ct3d->dc.host_dc_as);
>      }
>      if (ct3d->hostpmem) {
> @@ -1043,6 +1068,7 @@ static void ct3_exit(PCIDevice *pci_dev)
>      spdm_sock_fini(ct3d->doe_spdm.socket);
>      g_free(regs->special_ops);
>      if (ct3d->dc.host_dc) {
> +        cxl_destroy_dc_regions(ct3d);
>          address_space_destroy(&ct3d->dc.host_dc_as);
>      }
>      if (ct3d->hostpmem) {
> @@ -1053,6 +1079,110 @@ static void ct3_exit(PCIDevice *pci_dev)
>      }
>  }
>  
> +/*
> + * This function will marked the dpa range [dpa, dap + len) to be backed and
> + * accessible, this happens when a dc extent is added and accepted by the
> + * host.
> + */
> +static void set_region_block_backed(CXLType3Dev *ct3d, uint64_t dpa,
> +        uint64_t len)
> +{
> +    int i;
> +    CXLDCD_Region *region = &ct3d->dc.regions[0];
> +
> +    if (dpa < region->base
> +            || dpa >= region->base + ct3d->dc.total_capacity)
> +        return;
> +
> +    /*
> +     * spec 3.0 9.13.3: Regions are used in increasing-DPA order, with
> +     * Region 0 being used for the lowest DPA of Dynamic Capacity and
> +     * Region 7 for the highest DPA.
> +     * So we check from the last region to find where the dpa belongs.
> +     * access across multiple regions is not allowed.
> +     **/
> +    for (i = ct3d->dc.num_regions - 1; i >= 0; i--) {
> +        region = &ct3d->dc.regions[i];
> +        if (dpa >= region->base) {
> +            break;
> +        }
> +    }
> +
> +    bitmap_set(region->blk_bitmap, (dpa - region->base) / region->block_size,
> +            len / region->block_size);
> +}
> +
> +/*
> + * This function check whether a dpa range [dpa, dpa + len) has been backed
> + * with dc extents, used when validating read/write to dc regions
> + */
> +static bool test_region_block_backed(CXLType3Dev *ct3d, uint64_t dpa,
> +        uint64_t len)
> +{
> +    int i;
> +    CXLDCD_Region *region = &ct3d->dc.regions[0];
> +    uint64_t nbits;
> +    long nr;
> +
> +    if (dpa < region->base
> +            || dpa >= region->base + ct3d->dc.total_capacity)
> +        return false;
> +
> +    /*
> +     * spec 3.0 9.13.3: Regions are used in increasing-DPA order, with
> +     * Region 0 being used for the lowest DPA of Dynamic Capacity and
> +     * Region 7 for the highest DPA.
> +     * So we check from the last region to find where the dpa belongs.
> +     * access across multiple regions is not allowed.
> +     */
> +    for (i = ct3d->dc.num_regions - 1; i >= 0; i--) {
> +        region = &ct3d->dc.regions[i];
> +        if (dpa >= region->base) {
> +            break;
> +        }
> +    }
> +
> +    nr = (dpa - region->base) / region->block_size;
> +    nbits = len / region->block_size;
> +    return find_next_zero_bit(region->blk_bitmap, nbits, nr) >= nr + nbits;
> +}
> +
> +/*
> + * This function will marked the dpa range [dpa, dap + len) to be unbacked and
> + * inaccessible, this happens when a dc extent is added and accepted by the
> + * host.
> + */
> +static void clear_region_block_backed(CXLType3Dev *ct3d, uint64_t dpa,
> +        uint64_t len)
> +{
> +    int i;
> +    CXLDCD_Region *region = &ct3d->dc.regions[0];
> +    uint64_t nbits;
> +    long nr;
> +
> +    if (dpa < region->base
> +            || dpa >= region->base + ct3d->dc.total_capacity)
> +        return;
> +
> +    /*
> +     * spec 3.0 9.13.3: Regions are used in increasing-DPA order, with
> +     * Region 0 being used for the lowest DPA of Dynamic Capacity and
> +     * Region 7 for the highest DPA.
> +     * So we check from the last region to find where the dpa belongs.
> +     * access across multiple regions is not allowed.
> +     */
> +    for (i = ct3d->dc.num_regions - 1; i >= 0; i--) {
> +        region = &ct3d->dc.regions[i];
> +        if (dpa >= region->base) {
> +            break;
> +        }
> +    }
> +
> +    nr = (dpa - region->base) / region->block_size;
> +    nbits = len / region->block_size;
> +    bitmap_clear(region->blk_bitmap, nr, nbits);
> +}
> +
>  static bool cxl_type3_dpa(CXLType3Dev *ct3d, hwaddr host_addr, uint64_t *dpa)
>  {
>      uint32_t *cache_mem = ct3d->cxl_cstate.crb.cache_mem_registers;
> @@ -1145,6 +1275,10 @@ static int cxl_type3_hpa_to_as_and_dpa(CXLType3Dev *ct3d,
>          *as = &ct3d->hostpmem_as;
>          *dpa_offset -= vmr_size;
>      } else {
> +        if (!test_region_block_backed(ct3d, *dpa_offset, size)) {
> +            return -ENODEV;
> +        }
> +
>          *as = &ct3d->dc.host_dc_as;
>          *dpa_offset -= (vmr_size + pmr_size);
>      }
> @@ -1944,6 +2078,27 @@ static void qmp_cxl_process_dynamic_capacity_event(const char *path,
>      }
>  
>      g_free(extents);
> +
> +    /* Another choice is to do the set/clear after getting mailbox response*/
> +    list = records;
> +    while (list) {
> +        dpa = list->value->dpa * 1024 * 1024;
> +        len = list->value->len * 1024 * 1024;
> +        rid = list->value->region_id;
> +
> +        switch (type) {
> +        case DC_EVENT_ADD_CAPACITY:
> +            set_region_block_backed(dcd, dpa, len);
> +            break;
> +        case DC_EVENT_RELEASE_CAPACITY:
> +            clear_region_block_backed(dcd, dpa, len);
> +            break;
> +        default:
> +            error_setg(errp, "DC event type not handled yet");
> +            break;
> +        }
> +        list = list->next;
> +    }
>  }
>  
>  void qmp_cxl_add_dynamic_capacity_event(const char *path,
> diff --git a/include/hw/cxl/cxl_device.h b/include/hw/cxl/cxl_device.h
> index 01a5eaca48..1f85c88017 100644
> --- a/include/hw/cxl/cxl_device.h
> +++ b/include/hw/cxl/cxl_device.h
> @@ -412,6 +412,7 @@ typedef struct CXLDCD_Region {
>      uint64_t block_size;
>      uint32_t dsmadhandle;
>      uint8_t flags;
> +    unsigned long *blk_bitmap;
>  } CXLDCD_Region;
>  
>  struct CXLType3Dev {


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 2134FEB64DD
	for <linux-cxl@archiver.kernel.org>; Mon,  7 Aug 2023 09:37:59 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S229824AbjHGJh6 (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Mon, 7 Aug 2023 05:37:58 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:59960 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S231646AbjHGJhy (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Mon, 7 Aug 2023 05:37:54 -0400
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 279AC172D
        for <linux-cxl@vger.kernel.org>; Mon,  7 Aug 2023 02:37:50 -0700 (PDT)
Received: from lhrpeml500005.china.huawei.com (unknown [172.18.147.226])
        by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4RKB3T2SsKz6J6gH;
        Mon,  7 Aug 2023 17:34:13 +0800 (CST)
Received: from localhost (10.202.227.76) by lhrpeml500005.china.huawei.com
 (7.191.163.240) with Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id 15.1.2507.27; Mon, 7 Aug
 2023 10:37:47 +0100
Date: Mon, 7 Aug 2023 10:37:46 +0100
From: Jonathan Cameron <Jonathan.Cameron@Huawei.com>
To: Jonathan Cameron via <qemu-devel@nongnu.org>
CC: Jonathan Cameron <Jonathan.Cameron@Huawei.com>,
        Fan Ni <fan.ni@samsung.com>,
        "linux-cxl@vger.kernel.org" <linux-cxl@vger.kernel.org>,
        "gregory.price@memverge.com" <gregory.price@memverge.com>,
        "hchkuo@avery-design.com.tw" <hchkuo@avery-design.com.tw>,
        "cbrowy@avery-design.com" <cbrowy@avery-design.com>,
        "ira.weiny@intel.com" <ira.weiny@intel.com>,
        "dan.j.williams@intel.com" <dan.j.williams@intel.com>,
        Adam Manzanares <a.manzanares@samsung.com>,
        "dave@stgolabs.net" <dave@stgolabs.net>,
        "nmtadam.samsung@gmail.com" <nmtadam.samsung@gmail.com>,
        "nifan@outlook.com" <nifan@outlook.com>
Subject: Re: [Qemu PATCH v2 9/9] hw/mem/cxl_type3: Add dpa range validation
 for accesses to dc regions
Message-ID: <20230807103746.00003a88@Huawei.com>
In-Reply-To: <20230807095342.00006f88@Huawei.com>
References: <20230725183939.2741025-1-fan.ni@samsung.com>
        <CGME20230725183957uscas1p2ca5293c7229ab989ad1a2d95395436a6@uscas1p2.samsung.com>
        <20230725183939.2741025-10-fan.ni@samsung.com>
        <20230807095342.00006f88@Huawei.com>
Organization: Huawei Technologies Research and Development (UK) Ltd.
X-Mailer: Claws Mail 4.1.0 (GTK 3.24.33; x86_64-w64-mingw32)
MIME-Version: 1.0
Content-Type: text/plain; charset="US-ASCII"
Content-Transfer-Encoding: 7bit
X-Originating-IP: [10.202.227.76]
X-ClientProxiedBy: lhrpeml500004.china.huawei.com (7.191.163.9) To
 lhrpeml500005.china.huawei.com (7.191.163.240)
X-CFilter-Loop: Reflected
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

On Mon, 7 Aug 2023 09:53:42 +0100
Jonathan Cameron via <qemu-devel@nongnu.org> wrote:

> On Tue, 25 Jul 2023 18:39:56 +0000
> Fan Ni <fan.ni@samsung.com> wrote:
> 
> > From: Fan Ni <nifan@outlook.com>
> > 
> > Not all dpa range in the dc regions is valid to access until an extent
> > covering the range has been added. Add a bitmap for each region to
> > record whether a dc block in the region has been backed by dc extent.
> > For the bitmap, a bit in the bitmap represents a dc block. When a dc
> > extent is added, all the bits of the blocks in the extent will be set,
> > which will be cleared when the extent is released.
> > 
> > Signed-off-by: Fan Ni <fan.ni@samsung.com>  
> Hi Fan,
> 
> A few of the bits of feedback apply broadly across the series.  Given I'm
> rebasing this anyway to give myself something to test I'll tidy things up
> (feel free to disagree with and revert any changes !) 
> and push a tree out in next day or two.  I'll message when I've done so.
> 
> Jonathan
> 

I'll review here but note I've changed all this in my tree anyway 
unless I specifically add questions etc.

> > ---
> >  hw/mem/cxl_type3.c          | 155 ++++++++++++++++++++++++++++++++++++
> >  include/hw/cxl/cxl_device.h |   1 +
> >  2 files changed, 156 insertions(+)
> > 
> > diff --git a/hw/mem/cxl_type3.c b/hw/mem/cxl_type3.c
> > index 41a828598a..51943a36fc 100644
> > --- a/hw/mem/cxl_type3.c
> > +++ b/hw/mem/cxl_type3.c
> > @@ -787,13 +787,37 @@ static int cxl_create_dc_regions(CXLType3Dev *ct3d)
> >          /* dsmad_handle is set when creating cdat table entries */
> >          region->flags = 0;
> >  
> > +        region->blk_bitmap = bitmap_new(region->len / region->block_size);  
> 
> In common with many allocators in qemu if this fails it calls abort()
> internally so no need to handle potential errors.
> 
> > +        if (!region->blk_bitmap) {
> > +            break;
> > +        }
> > +
> >          region_base += region->len;
> >      }
> > +
> > +    if (i < ct3d->dc.num_regions) {
> > +        while (--i >= 0) {
> > +            g_free(ct3d->dc.regions[i].blk_bitmap);
> > +        }
> > +        return -1;
> > +    }
> > +
> >      QTAILQ_INIT(&ct3d->dc.extents);
> >  
> >      return 0;
> >  }
> >  
> > +static void cxl_destroy_dc_regions(CXLType3Dev *ct3d)
> > +{
> > +    int i;
> > +    struct CXLDCD_Region *region;
> > +
> > +    for (i = 0; i < ct3d->dc.num_regions; i++) {
> > +        region = &ct3d->dc.regions[i];
> > +        g_free(region->blk_bitmap);
> > +    }
> > +}
> > +
> >  static bool cxl_setup_memory(CXLType3Dev *ct3d, Error **errp)
> >  {
> >      DeviceState *ds = DEVICE(ct3d);
> > @@ -1021,6 +1045,7 @@ err_free_special_ops:
> >      g_free(regs->special_ops);
> >  err_address_space_free:
> >      if (ct3d->dc.host_dc) {
> > +        cxl_destroy_dc_regions(ct3d);
> >          address_space_destroy(&ct3d->dc.host_dc_as);
> >      }
> >      if (ct3d->hostpmem) {
> > @@ -1043,6 +1068,7 @@ static void ct3_exit(PCIDevice *pci_dev)
> >      spdm_sock_fini(ct3d->doe_spdm.socket);
> >      g_free(regs->special_ops);
> >      if (ct3d->dc.host_dc) {
> > +        cxl_destroy_dc_regions(ct3d);
> >          address_space_destroy(&ct3d->dc.host_dc_as);
> >      }
> >      if (ct3d->hostpmem) {
> > @@ -1053,6 +1079,110 @@ static void ct3_exit(PCIDevice *pci_dev)
> >      }
> >  }
> >  
> > +/*
> > + * This function will marked the dpa range [dpa, dap + len) to be backed and
> > + * accessible, this happens when a dc extent is added and accepted by the
> > + * host.
> > + */
> > +static void set_region_block_backed(CXLType3Dev *ct3d, uint64_t dpa,

I'd prefer all functions to be in the ct3 namespace.

> > +        uint64_t len)
> > +{
> > +    int i;

A large chunk of stuff here is repeated as it is just finding the
relevant region.  Pulled out to a ct3_find_dc_region() utility function.

> > +    CXLDCD_Region *region = &ct3d->dc.regions[0];
> > +
> > +    if (dpa < region->base
> > +            || dpa >= region->base + ct3d->dc.total_capacity)
> > +        return;
> > +
> > +    /*
> > +     * spec 3.0 9.13.3: Regions are used in increasing-DPA order, with
> > +     * Region 0 being used for the lowest DPA of Dynamic Capacity and
> > +     * Region 7 for the highest DPA.
> > +     * So we check from the last region to find where the dpa belongs.
> > +     * access across multiple regions is not allowed.
> > +     **/
> > +    for (i = ct3d->dc.num_regions - 1; i >= 0; i--) {
> > +        region = &ct3d->dc.regions[i];
> > +        if (dpa >= region->base) {
> > +            break;
> > +        }
> > +    }
> > +
> > +    bitmap_set(region->blk_bitmap, (dpa - region->base) / region->block_size,
> > +            len / region->block_size);
> > +}
> > +
> > +/*
> > + * This function check whether a dpa range [dpa, dpa + len) has been backed
> > + * with dc extents, used when validating read/write to dc regions
> > + */
> > +static bool test_region_block_backed(CXLType3Dev *ct3d, uint64_t dpa,
> > +        uint64_t len)
> > +{
> > +    int i;
> > +    CXLDCD_Region *region = &ct3d->dc.regions[0];
> > +    uint64_t nbits;
> > +    long nr;
> > +
> > +    if (dpa < region->base
> > +            || dpa >= region->base + ct3d->dc.total_capacity)
> > +        return false;
> > +
> > +    /*
> > +     * spec 3.0 9.13.3: Regions are used in increasing-DPA order, with
> > +     * Region 0 being used for the lowest DPA of Dynamic Capacity and
> > +     * Region 7 for the highest DPA.
> > +     * So we check from the last region to find where the dpa belongs.
> > +     * access across multiple regions is not allowed.
> > +     */
> > +    for (i = ct3d->dc.num_regions - 1; i >= 0; i--) {
> > +        region = &ct3d->dc.regions[i];
> > +        if (dpa >= region->base) {
> > +            break;
> > +        }
> > +    }
> > +
> > +    nr = (dpa - region->base) / region->block_size;
> > +    nbits = len / region->block_size;
> > +    return find_next_zero_bit(region->blk_bitmap, nbits, nr) >= nr + nbits;
> > +}
> > +
> > +/*
> > + * This function will marked the dpa range [dpa, dap + len) to be unbacked and
> > + * inaccessible, this happens when a dc extent is added and accepted by the
> > + * host.
Second part of comment wrong (Cut and paste fun ;)

> > + */
> > +static void clear_region_block_backed(CXLType3Dev *ct3d, uint64_t dpa,
> > +        uint64_t len)
> > +{
> > +    int i;
> > +    CXLDCD_Region *region = &ct3d->dc.regions[0];
> > +    uint64_t nbits;
> > +    long nr;
> > +
> > +    if (dpa < region->base
> > +            || dpa >= region->base + ct3d->dc.total_capacity)
> > +        return;
> > +
> > +    /*
> > +     * spec 3.0 9.13.3: Regions are used in increasing-DPA order, with
> > +     * Region 0 being used for the lowest DPA of Dynamic Capacity and
> > +     * Region 7 for the highest DPA.
> > +     * So we check from the last region to find where the dpa belongs.
> > +     * access across multiple regions is not allowed.
> > +     */
> > +    for (i = ct3d->dc.num_regions - 1; i >= 0; i--) {
> > +        region = &ct3d->dc.regions[i];
> > +        if (dpa >= region->base) {
> > +            break;
> > +        }
> > +    }
> > +
> > +    nr = (dpa - region->base) / region->block_size;
> > +    nbits = len / region->block_size;
> > +    bitmap_clear(region->blk_bitmap, nr, nbits);
> > +}
> > +
> >  static bool cxl_type3_dpa(CXLType3Dev *ct3d, hwaddr host_addr, uint64_t *dpa)
> >  {
> >      uint32_t *cache_mem = ct3d->cxl_cstate.crb.cache_mem_registers;
> > @@ -1145,6 +1275,10 @@ static int cxl_type3_hpa_to_as_and_dpa(CXLType3Dev *ct3d,
> >          *as = &ct3d->hostpmem_as;
> >          *dpa_offset -= vmr_size;
> >      } else {
> > +        if (!test_region_block_backed(ct3d, *dpa_offset, size)) {
> > +            return -ENODEV;
> > +        }
> > +
> >          *as = &ct3d->dc.host_dc_as;
> >          *dpa_offset -= (vmr_size + pmr_size);
> >      }
> > @@ -1944,6 +2078,27 @@ static void qmp_cxl_process_dynamic_capacity_event(const char *path,
> >      }
> >  
> >      g_free(extents);
> > +
> > +    /* Another choice is to do the set/clear after getting mailbox response*/

I haven't changed this yet - but it needs to be done on host acceptance, not on
the QMP command. We also need to validate it - so keep a record of what has
been offered and not yet accepted.  Unfortunately that probably doubles the bitmaps :(

I've updated the comment to reflect this.
> > +    list = records;
> > +    while (list) {
> > +        dpa = list->value->dpa * 1024 * 1024;
* MiB
> > +        len = list->value->len * 1024 * 1024;
> > +        rid = list->value->region_id;
> > +
> > +        switch (type) {
> > +        case DC_EVENT_ADD_CAPACITY:
> > +            set_region_block_backed(dcd, dpa, len);
> > +            break;
> > +        case DC_EVENT_RELEASE_CAPACITY:
> > +            clear_region_block_backed(dcd, dpa, len);
> > +            break;
> > +        default:
> > +            error_setg(errp, "DC event type not handled yet");
> > +            break;
> > +        }
> > +        list = list->next;
> > +    }
> >  }
> >  
> >  void qmp_cxl_add_dynamic_capacity_event(const char *path,
> > diff --git a/include/hw/cxl/cxl_device.h b/include/hw/cxl/cxl_device.h
> > index 01a5eaca48..1f85c88017 100644
> > --- a/include/hw/cxl/cxl_device.h
> > +++ b/include/hw/cxl/cxl_device.h
> > @@ -412,6 +412,7 @@ typedef struct CXLDCD_Region {
> >      uint64_t block_size;
> >      uint32_t dsmadhandle;
> >      uint8_t flags;
> > +    unsigned long *blk_bitmap;
> >  } CXLDCD_Region;
> >  
> >  struct CXLType3Dev {  
> 
> 
> 


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 10727EB64DD
	for <linux-cxl@archiver.kernel.org>; Mon,  7 Aug 2023 10:35:39 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S229515AbjHGKfh (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Mon, 7 Aug 2023 06:35:37 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:57026 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S229512AbjHGKfg (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Mon, 7 Aug 2023 06:35:36 -0400
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 916FCE68
        for <linux-cxl@vger.kernel.org>; Mon,  7 Aug 2023 03:35:34 -0700 (PDT)
Received: from lhrpeml500005.china.huawei.com (unknown [172.18.147.200])
        by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4RKCL53C62z67p9F;
        Mon,  7 Aug 2023 18:31:57 +0800 (CST)
Received: from localhost (10.202.227.76) by lhrpeml500005.china.huawei.com
 (7.191.163.240) with Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id 15.1.2507.27; Mon, 7 Aug
 2023 11:35:30 +0100
Date: Mon, 7 Aug 2023 11:35:20 +0100
From: Jonathan Cameron <Jonathan.Cameron@Huawei.com>
To: Fan Ni <fan.ni@samsung.com>
CC: "qemu-devel@nongnu.org" <qemu-devel@nongnu.org>,
        "linux-cxl@vger.kernel.org" <linux-cxl@vger.kernel.org>,
        "gregory.price@memverge.com" <gregory.price@memverge.com>,
        "hchkuo@avery-design.com.tw" <hchkuo@avery-design.com.tw>,
        "cbrowy@avery-design.com" <cbrowy@avery-design.com>,
        "ira.weiny@intel.com" <ira.weiny@intel.com>,
        "dan.j.williams@intel.com" <dan.j.williams@intel.com>,
        Adam Manzanares <a.manzanares@samsung.com>,
        "dave@stgolabs.net" <dave@stgolabs.net>,
        "nmtadam.samsung@gmail.com" <nmtadam.samsung@gmail.com>,
        "nifan@outlook.com" <nifan@outlook.com>
Subject: Re: [Qemu PATCH v2 8/9] hw/cxl/events: Add qmp interfaces to
 add/release dynamic capacity extents
Message-ID: <20230807113520.0000798b@Huawei.com>
In-Reply-To: <20230725183939.2741025-9-fan.ni@samsung.com>
References: <20230725183939.2741025-1-fan.ni@samsung.com>
        <CGME20230725183957uscas1p1ebf676c30d21896d1fd7f9b652250449@uscas1p1.samsung.com>
        <20230725183939.2741025-9-fan.ni@samsung.com>
Organization: Huawei Technologies Research and Development (UK) Ltd.
X-Mailer: Claws Mail 4.1.0 (GTK 3.24.33; x86_64-w64-mingw32)
MIME-Version: 1.0
Content-Type: text/plain; charset="US-ASCII"
Content-Transfer-Encoding: 7bit
X-Originating-IP: [10.202.227.76]
X-ClientProxiedBy: lhrpeml100006.china.huawei.com (7.191.160.224) To
 lhrpeml500005.china.huawei.com (7.191.163.240)
X-CFilter-Loop: Reflected
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

On Tue, 25 Jul 2023 18:39:56 +0000
Fan Ni <fan.ni@samsung.com> wrote:

> From: Fan Ni <nifan@outlook.com>
> 
> Since fabric manager emulation is not supported yet, the change implements
> the functions to add/release dynamic capacity extents as QMP interfaces.
> 
> 1. Add dynamic capacity extents:
> 
> For example, the command to add two continuous extents (each is 128MB long)
> to region 0 (starting at dpa offset 0 and 128MB) looks like below:
> 
> { "execute": "qmp_capabilities" }
> 
> { "execute": "cxl-add-dynamic-capacity-event",
>   "arguments": {
>       "path": "/machine/peripheral/cxl-dcd0",
>       "extents": [
>       {
>           "region-id": 0,
>           "dpa": 0,
>           "len": 128
>       },
>       {
>           "region-id": 0,
>           "dpa": 128,
>           "len": 128
>       }
>       ]
>   }
> }
> 
> 2. Release dynamic capacity extents:
> 
> For example, the command to release an extent of size 128MB from region 0
> (starting at dpa offset 128MB) look like below:
> 
> { "execute": "cxl-release-dynamic-capacity-event",
>   "arguments": {
>       "path": "/machine/peripheral/cxl-dcd0",
>       "extents": [
>       {
>           "region-id": 0,
>           "dpa": 128,
>           "len": 128
>       }
>       ]
>   }
> }
> 
> Signed-off-by: Fan Ni <fan.ni@samsung.com>
> ---
>  hw/mem/cxl_type3.c          | 145 ++++++++++++++++++++++++++++++++++++
>  hw/mem/cxl_type3_stubs.c    |   6 ++
>  include/hw/cxl/cxl_events.h |  16 ++++
>  qapi/cxl.json               |  49 ++++++++++++
>  4 files changed, 216 insertions(+)
> 
> diff --git a/hw/mem/cxl_type3.c b/hw/mem/cxl_type3.c
> index f1170b8047..41a828598a 100644
> --- a/hw/mem/cxl_type3.c
> +++ b/hw/mem/cxl_type3.c
> @@ -1817,6 +1817,151 @@ void qmp_cxl_inject_memory_module_event(const char *path, CxlEventLog log,
>      }
>  }
>  
> +static const QemuUUID dynamic_capacity_uuid = {
> +    .data = UUID(0xca95afa7, 0xf183, 0x4018, 0x8c, 0x2f,
> +            0x95, 0x26, 0x8e, 0x10, 0x1a, 0x2a),
> +};
> +
> +/*
> + * cxl r3.0: Table 8-47
> + * 00h: add capacity
> + * 01h: release capacity
> + * 02h: forced capacity release
> + * 03h: region configuration updated
> + * 04h: Add capacity response
> + * 05h: capacity released

If we explicitly set the values in the enum below then this
comment only adds the useful reference. Hence I've done that
and updated reference to my preferred format.
Also moved the reference up a few lines so it covers the
UUID as well.

> + */
> +enum DC_Event_Type {
> +    DC_EVENT_ADD_CAPACITY,
> +    DC_EVENT_RELEASE_CAPACITY,
> +    DC_EVENT_FORCED_RELEASE_CAPACITY,
> +    DC_EVENT_REGION_CONFIG_UPDATED,
> +    DC_EVENT_ADD_CAPACITY_RSP,
> +    DC_EVENT_CAPACITY_RELEASED,
> +    DC_EVENT_NUM
> +};
> +
> +#define MEM_BLK_SIZE_MB 128
> +static void qmp_cxl_process_dynamic_capacity_event(const char *path,
> +        CxlEventLog log, enum DC_Event_Type type,
> +        uint16_t hid, CXLDCExtentRecordList *records, Error **errp)
> +{
> +    Object *obj = object_resolve_path(path, NULL);
> +    CXLEventDynamicCapacity dCap;
> +    CXLEventRecordHdr *hdr = &dCap.hdr;
> +    CXLDeviceState *cxlds;
> +    CXLType3Dev *dcd;
> +    uint8_t flags = 1 << CXL_EVENT_TYPE_INFO;
> +    uint32_t num_extents = 0;
> +    CXLDCExtentRecordList *list = records;
For consistency (as we reset this for second pass) I've moved the
setting of this down to just above the first loop.

> +    CXLDCExtent_raw *extents;
> +    uint64_t dpa, len;
> +    uint8_t rid = 0;

> +    int i;
> +
> +    if (!obj) {
> +        error_setg(errp, "Unable to resolve path");
> +        return;
> +    }
> +    if (!object_dynamic_cast(obj, TYPE_CXL_TYPE3)) {
> +        error_setg(errp, "Path not point to a valid CXL type3 device");
> +        return;
> +    }
> +
> +    dcd = CXL_TYPE3(obj);
> +    cxlds = &dcd->cxl_dstate;

Only used once so I've moved it inline.

> +    memset(&dCap, 0, sizeof(dCap));

Can use dCap = {}; It's packed so no holes to be covered by the memset.
AS a side note, I'd have done this after the next check if we were doing
it explicitly.  With the {} approach we can rely on compiler to optimize
when it is done.


> +
> +    if (!dcd->dc.num_regions) {
> +        error_setg(errp, "No dynamic capacity support from the device");
> +        return;
> +    }
> +
> +    while (list) {
> +        dpa = list->value->dpa * 1024 * 1024;

MiB

> +        len = list->value->len * 1024 * 1024;
> +        rid = list->value->region_id;
> +
> +        if (rid >= dcd->dc.num_regions) {
> +            error_setg(errp, "region id is too large");
> +            return;
> +        }
> +
> +        if (dpa % dcd->dc.regions[rid].block_size
> +                || len % dcd->dc.regions[rid].block_size) {
> +            error_setg(errp, "dpa or len is not aligned to region block size");
> +            return;
> +        }
> +
> +        if (dpa + len > dcd->dc.regions[rid].decode_len * 256 * 1024 * 1024) {
> +            error_setg(errp, "extent range is beyond the region end");
> +            return;
> +        }
> +
> +        num_extents++;
> +        list = list->next;
> +    }
> +
> +    i = 0;
> +    list = records;
> +    extents = g_new0(CXLDCExtent_raw, num_extents);
> +    while (list) {
> +        dpa = list->value->dpa * 1024 * 1024;
> +        len = list->value->len * 1024 * 1024;

MiB

> +        rid = list->value->region_id;
> +
> +        extents[i].start_dpa = dpa + dcd->dc.regions[rid].base;
> +        extents[i].len = len;
> +        memset(extents[i].tag, 0, 0x10);

I'd suggest we add a tag sooner rather than later. Can make it optional
and default to zero though.  Note I'm not making that change whilst rebasing
this.

> +        extents[i].shared_seq = 0;
> +
> +        list = list->next;
> +        i++;
> +    }
> +
> +    /*
> +     * 8.2.9.1.5
> +     * All Dynamic Capacity event records shall set the Event Record
> +     * Severity field in the Common Event Record Format to Informational
> +     * Event. All Dynamic Capacity related events shall be logged in the
> +     * Dynamic Capacity Event Log.
> +     */
> +    cxl_assign_event_header(hdr, &dynamic_capacity_uuid, flags, sizeof(dCap),
> +            cxl_device_get_timestamp(&dcd->cxl_dstate));
> +
> +    dCap.type = type;
> +    stw_le_p(&dCap.host_id, hid);
> +    /* only valid for DC_REGION_CONFIG_UPDATED event */
> +    dCap.updated_region_id = rid;
> +    for (i = 0; i < num_extents; i++) {
> +        memcpy(&dCap.dynamic_capacity_extent, &extents[i]
> +                , sizeof(CXLDCExtent_raw));
> +
> +        if (cxl_event_insert(cxlds, CXL_EVENT_TYPE_DYNAMIC_CAP,
> +                    (CXLEventRecordRaw *)&dCap)) {
> +            cxl_event_irq_assert(dcd);
> +        }
> +    }
> +
> +    g_free(extents);
Can use g_autofree given lifetime of this can be governed by the scope.
Qemu code does this a lot - it's just starting to sneak into the kernel
as well and makes this sort of handling much nicer as they end up more
or less looking like they are on the stack ;)

> +}
> +
> +void qmp_cxl_add_dynamic_capacity_event(const char *path,
> +        struct CXLDCExtentRecordList  *records,
Don't need the struct as there is a typedef autocreated from the qmp
schema stuff.

> +        Error **errp)
Where it doesn't go over 80 chars, prefer aligned to one space after the (

> +{
> +   qmp_cxl_process_dynamic_capacity_event(path, CXL_EVENT_LOG_INFORMATIONAL,
> +           DC_EVENT_ADD_CAPACITY, 0, records, errp);
> +}
> +
> +void qmp_cxl_release_dynamic_capacity_event(const char *path,
> +        struct CXLDCExtentRecordList  *records,
> +        Error **errp)
> +{
> +    qmp_cxl_process_dynamic_capacity_event(path, CXL_EVENT_LOG_INFORMATIONAL,
> +            DC_EVENT_RELEASE_CAPACITY, 0, records, errp);
> +}
> +
>  static void ct3_class_init(ObjectClass *oc, void *data)
>  {
>      DeviceClass *dc = DEVICE_CLASS(oc);
> diff --git a/hw/mem/cxl_type3_stubs.c b/hw/mem/cxl_type3_stubs.c
> index f3e4a9fa72..482229f3bd 100644
> --- a/hw/mem/cxl_type3_stubs.c
> +++ b/hw/mem/cxl_type3_stubs.c
> @@ -56,3 +56,9 @@ void qmp_cxl_inject_correctable_error(const char *path, CxlCorErrorType type,
>  {
>      error_setg(errp, "CXL Type 3 support is not compiled in");
>  }
> +
> +void qmp_cxl_add_dynamic_capacity_event(const char *path,
> +        struct CXLDCExtentRecordList  *records, Error **errp) {}

Good to have the error prints as done for the other cases.

> +
> +void qmp_cxl_release_dynamic_capacity_event(const char *path,
> +        struct CXLDCExtentRecordList  *records, Error **errp) {}
> diff --git a/include/hw/cxl/cxl_events.h b/include/hw/cxl/cxl_events.h
> index 089ba2091f..3baf745f8d 100644
> --- a/include/hw/cxl/cxl_events.h
> +++ b/include/hw/cxl/cxl_events.h
> @@ -165,4 +165,20 @@ typedef struct CXLEventMemoryModule {
>      uint8_t reserved[0x3d];
>  } QEMU_PACKED CXLEventMemoryModule;
>  
> +/*
> + * Dynamic Capacity Event Record
> + * CXL Rev 3.0 Section 8.2.9.2.1.5: Table 8-47
> + * All fields little endian.
> + */
> +typedef struct CXLEventDynamicCapacity {
> +    CXLEventRecordHdr hdr;
> +    uint8_t type;
> +    uint8_t reserved1;
> +    uint16_t host_id;
> +    uint8_t updated_region_id;
> +    uint8_t reserved2[3];
> +    uint8_t dynamic_capacity_extent[0x28]; /* defined in cxl_device.h */
> +    uint8_t reserved[0x20];
> +} QEMU_PACKED CXLEventDynamicCapacity;
> +
>  #endif /* CXL_EVENTS_H */
> diff --git a/qapi/cxl.json b/qapi/cxl.json
> index 05c560cfe5..fb04ec4c41 100644
> --- a/qapi/cxl.json
> +++ b/qapi/cxl.json
> @@ -369,3 +369,52 @@
>  ##
>  {'command': 'cxl-inject-correctable-error',
>   'data': {'path': 'str', 'type': 'CxlCorErrorType'}}
> +
> +##
> +# @CXLDCExtentRecord:
> +#
> +# Record of a single extent to add/release
> +#
> +# @region-id: id of the region where the extent to add/release
> +# @dpa: start dpa (in MiB) of the extent, related to region base address
> +# @len: extent size (in MiB)
> +#
> +# Since: 8.0
> +##
> +{ 'struct': 'CXLDCExtentRecord',
> +  'data': {
> +      'region-id': 'uint8',
> +      'dpa':'uint64',
> +      'len': 'uint64'
> +  }
> +}
> +
> +##
> +# @cxl-add-dynamic-capacity-event:
In later patches this is going to add the capacity - the event is
just part of it. So I've renamed to simply cxl-add-dynamic-capacity
and added a bit about it 'starting the add capacity flow./

> +#
> +# Command to add dynamic capacity extent event
> +#
> +# @path: CXL DCD canonical QOM path
> +# @extents: Extents to add

Added a highly speculative (and optimistic) Since: 8.2
as hopefully we can remember to update them.  I'm thinking this
is at least 9.0 material but you never know! :)

> +#
> +##
> +{ 'command': 'cxl-add-dynamic-capacity-event',
> +  'data': { 'path': 'str',
> +            'extents': [ 'CXLDCExtentRecord' ]
> +           }
> +}
> +
> +##
> +# @cxl-release-dynamic-capacity-event:
> +#
> +# Command to release dynamic capacity extent event
> +#
> +# @path: CXL DCD canonical QOM path
> +# @extents: Extents to release
> +#
> +##
> +{ 'command': 'cxl-release-dynamic-capacity-event',
> +  'data': { 'path': 'str',
> +            'extents': [ 'CXLDCExtentRecord' ]
> +           }
> +}


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 8380FEB64DD
	for <linux-cxl@archiver.kernel.org>; Mon,  7 Aug 2023 12:00:20 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S229578AbjHGMAT (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Mon, 7 Aug 2023 08:00:19 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:36698 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S232317AbjHGMAP (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Mon, 7 Aug 2023 08:00:15 -0400
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id AF602128
        for <linux-cxl@vger.kernel.org>; Mon,  7 Aug 2023 04:59:55 -0700 (PDT)
Received: from lhrpeml500005.china.huawei.com (unknown [172.18.147.207])
        by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4RKDq91KC0z6J7Ys;
        Mon,  7 Aug 2023 19:38:45 +0800 (CST)
Received: from localhost (10.202.227.76) by lhrpeml500005.china.huawei.com
 (7.191.163.240) with Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id 15.1.2507.27; Mon, 7 Aug
 2023 12:42:31 +0100
Date: Mon, 7 Aug 2023 12:42:30 +0100
From: Jonathan Cameron <Jonathan.Cameron@Huawei.com>
To: Fan Ni <fan.ni@samsung.com>
CC: "qemu-devel@nongnu.org" <qemu-devel@nongnu.org>,
        "linux-cxl@vger.kernel.org" <linux-cxl@vger.kernel.org>,
        "gregory.price@memverge.com" <gregory.price@memverge.com>,
        "hchkuo@avery-design.com.tw" <hchkuo@avery-design.com.tw>,
        "cbrowy@avery-design.com" <cbrowy@avery-design.com>,
        "ira.weiny@intel.com" <ira.weiny@intel.com>,
        "dan.j.williams@intel.com" <dan.j.williams@intel.com>,
        Adam Manzanares <a.manzanares@samsung.com>,
        "dave@stgolabs.net" <dave@stgolabs.net>,
        "nmtadam.samsung@gmail.com" <nmtadam.samsung@gmail.com>,
        "nifan@outlook.com" <nifan@outlook.com>
Subject: Re: [Qemu PATCH v2 7/9] hw/cxl/cxl-mailbox-utils: Add mailbox
 commands to support add/release dynamic capacity response
Message-ID: <20230807124230.00002b3d@Huawei.com>
In-Reply-To: <20230725183939.2741025-8-fan.ni@samsung.com>
References: <20230725183939.2741025-1-fan.ni@samsung.com>
        <CGME20230725183957uscas1p2a076b6f7b694d2e632a0b8025ec331d7@uscas1p2.samsung.com>
        <20230725183939.2741025-8-fan.ni@samsung.com>
Organization: Huawei Technologies Research and Development (UK) Ltd.
X-Mailer: Claws Mail 4.1.0 (GTK 3.24.33; x86_64-w64-mingw32)
MIME-Version: 1.0
Content-Type: text/plain; charset="US-ASCII"
Content-Transfer-Encoding: 7bit
X-Originating-IP: [10.202.227.76]
X-ClientProxiedBy: lhrpeml500001.china.huawei.com (7.191.163.213) To
 lhrpeml500005.china.huawei.com (7.191.163.240)
X-CFilter-Loop: Reflected
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

On Tue, 25 Jul 2023 18:39:56 +0000
Fan Ni <fan.ni@samsung.com> wrote:

> From: Fan Ni <nifan@outlook.com>
> 
> Per CXL spec 3.0, two mailbox commands are implemented:
> Add Dynamic Capacity Response (Opcode 4802h) 8.2.9.8.9.3, and
> Release Dynamic Capacity (Opcode 4803h) 8.2.9.8.9.4.
> 
> Signed-off-by: Fan Ni <fan.ni@samsung.com>

I'm reviewing these backwards mostly because I'm tidying them up in that
order (makes rebases easier).  Hence some of this only makes sense in light of
patch 9 comments!

In my rebase of this, I've made some changes that are non trivial
so definitely want you to look at them.

I also left what I think is a nasty bug.  If we get extents
added next to each other they aren't fused, so a release extent that
covers more than one will fail.  Far as I can tell that's a valid
if weird corner cases.

Jonathan


> ---
>  hw/cxl/cxl-mailbox-utils.c  | 253 ++++++++++++++++++++++++++++++++++++
>  include/hw/cxl/cxl_device.h |   3 +-
>  2 files changed, 255 insertions(+), 1 deletion(-)
> 
> diff --git a/hw/cxl/cxl-mailbox-utils.c b/hw/cxl/cxl-mailbox-utils.c
> index 3d25a9697e..1e4944da95 100644
> --- a/hw/cxl/cxl-mailbox-utils.c
> +++ b/hw/cxl/cxl-mailbox-utils.c
> @@ -84,6 +84,8 @@ enum {
>      DCD_CONFIG  = 0x48, /*r3.0: 8.2.9.8.9*/
>          #define GET_DC_CONFIG          0x0
>          #define GET_DYN_CAP_EXT_LIST   0x1
> +        #define ADD_DYN_CAP_RSP        0x2
> +        #define RELEASE_DYN_CAP        0x3
>      PHYSICAL_SWITCH = 0x51
>          #define IDENTIFY_SWITCH_DEVICE      0x0
>  };
> @@ -1086,6 +1088,251 @@ static CXLRetCode cmd_dcd_get_dyn_cap_ext_list(struct cxl_cmd *cmd,
>      return CXL_MBOX_SUCCESS;
>  }
>  
> +/*
> + * Check whether the bits at addr between [nr, nr+size) are all set,
> + * return 1 if all 1s, else return 0
> + */
> +static inline int test_bits(const unsigned long *addr, int nr, int size)
bool

Also, let the compiler make decisions on inlining.

Hmm. Documentation lacking on find_next_zero_bit() but I think it returns
the size if there aren't any so this should be fine.

> +{
> +    unsigned long res = find_next_zero_bit(addr, size + nr, nr);
> +
> +    return (res >= nr + size) ? 1 : 0;
> +}
> +
> +/*
> + * Find dynamic capacity region id based on dpa range [dpa, dpa+len)
> + */
> +static uint8_t find_region_id(struct CXLType3Dev *dev, uint64_t dpa,
> +        uint64_t len)
> +{
> +    int8_t i = dev->dc.num_regions - 1;
> +
> +    while (i > 0 && dpa < dev->dc.regions[i].base) {
> +        i--;
> +    }
This is another search function, similar to the one I factored out when applying
patch 9.  I'll pull that function back here instead of having it in patch 9
+ rename it to be more in keeping with functions in this file.

The handling is a little different (NULL or the region pointer, and that also
simplifies the code around where it is used a little.

> +
> +    if (dpa < dev->dc.regions[i].base
> +            || dpa + len > dev->dc.regions[i].base + dev->dc.regions[i].len) {
> +        return dev->dc.num_regions;
> +    }
> +
> +    return i;
> +}
> +
> +static void insert_extent_to_extent_list(CXLDCDExtentList *list, uint64_t dpa,
> +        uint64_t len, uint8_t *tag, uint16_t shared_seq)
> +{
> +    CXLDCD_Extent *extent;
> +    extent = g_new0(CXLDCD_Extent, 1);
> +    extent->start_dpa = dpa;
> +    extent->len = len;
> +    if (tag) {
> +        memcpy(extent->tag, tag, 0x10);
> +    } else {
> +        memset(extent->tag, 0, 0x10);
> +    }
> +    extent->shared_seq = shared_seq;
> +
> +    QTAILQ_INSERT_TAIL(list, extent, node);
> +}
> +
Added a reference to both Table 8-129 and Table 8-131 here

> +typedef struct updated_dc_extent_list_in_pl {
> +    uint32_t num_entries_updated;
> +    uint8_t rsvd[4];
> +    struct { /* r3.0: Table 8-130 */

I reformatted this and added name of table. Makes it easier
to find in CXL rN.0

> +        uint64_t start_dpa;
> +        uint64_t len;
> +        uint8_t rsvd[8];
> +    } QEMU_PACKED updated_entries[];
> +} QEMU_PACKED updated_dc_extent_list_in_pl;
> +
> +/*
> + * The function only check the input extent list against itself.

I haven't added any info here yet, but feels like this function needs
comments on what those checks are doing.

> + */
> +static CXLRetCode detect_malformed_extent_list(CXLType3Dev *dev,

prefixed with cxl_ to keep everything that is easy to do namespaced.

> +        const updated_dc_extent_list_in_pl *in)
> +{
> +    unsigned long *blk_bitmap;
> +    uint64_t min_block_size = dev->dc.regions[0].block_size;

If we use UINT64_MAX then anything seen will be less than it and
we can just loop over all regions.

> +    struct CXLDCD_Region *region = &dev->dc.regions[0];
> +    uint32_t i;
> +    uint64_t dpa, len;
> +    uint8_t rid;
> +    CXLRetCode ret;
> +
> +    for (i = 1; i < dev->dc.num_regions; i++) {
> +        region = &dev->dc.regions[i];
> +        if (min_block_size > region->block_size) {
> +            min_block_size = region->block_size;
> +        }
	min_block_size = MIN(min_block_size, region->block_size);
> +    }
> +
> +    blk_bitmap = bitmap_new((region->len + region->base

This is tricky to read as relies on side effect loop above.
Better to use
	&dev->dc.regions[dev->dc.num_regions - 1]
explicitly via a
CXLDCDregion *lastregion = &dev->dc.regions[dev->dc.num_regions]
though I also renamed dev at ct3d to make the type more obvious.



> +                - dev->dc.regions[0].base) / min_block_size);
> +
> +    for (i = 0; i < in->num_entries_updated; i++) {
> +        dpa = in->updated_entries[i].start_dpa;
> +        len = in->updated_entries[i].len;
> +
> +        rid = find_region_id(dev, dpa, len);
rid is never needed here as such - just a check on whether the
region exists. Hence use the find function previously pulled out of patch 9.

> +        if (rid == dev->dc.num_regions) {
> +            ret = CXL_MBOX_INVALID_PA;
> +            goto out;
> +        }
> +
> +        region = &dev->dc.regions[rid];
> +        if (dpa % region->block_size || len % region->block_size) {
> +            ret = CXL_MBOX_INVALID_EXTENT_LIST;
> +            goto out;
> +        }
> +        /* the dpa range already covered by some other extents in the list */
> +        if (test_bits(blk_bitmap, dpa / min_block_size, len / min_block_size)) {
> +            ret = CXL_MBOX_INVALID_EXTENT_LIST;
> +            goto out;
> +        }
> +        bitmap_set(blk_bitmap, dpa / min_block_size, len / min_block_size);
> +   }
> +
> +    ret = CXL_MBOX_SUCCESS;
> +
> +out:

Great place for a g_autofree magic pointer as then can return above without any
manual cleanup.

> +    g_free(blk_bitmap);
> +    return ret;
> +}
> +
> +/*
> + * cxl spec 3.0: 8.2.9.8.9.3
> + * Add Dynamic Capacity Response (opcode 4802h)
> + * Assume an extent is added only after the response is processed successfully
> + * TODO: for better extent list validation, a better solution would be
> + * maintaining a pending extent list and use it to verify the extent list in
> + * the response.
> + */
> +static CXLRetCode cmd_dcd_add_dyn_cap_rsp(struct cxl_cmd *cmd,
> +        CXLDeviceState *cxl_dstate, uint16_t *len_unused)
> +{
> +    updated_dc_extent_list_in_pl *in = (void *)cmd->payload;
> +    struct CXLType3Dev *ct3d = container_of(cxl_dstate, CXLType3Dev,
> +            cxl_dstate);
> +    CXLDCDExtentList *extent_list = &ct3d->dc.extents;
> +    CXLDCD_Extent *ent;
> +    uint32_t i;
> +    uint64_t dpa, len;
> +    CXLRetCode ret;
> + 
> +    if (in->num_entries_updated == 0) {
> +        ret = CXL_MBOX_SUCCESS;
> +        goto out;

I always prefer direct returns as it makes the flows easier to follow.
(don't need to go see what cleanup is there - in this case none!)

> +    }
> +
> +    ret = detect_malformed_extent_list(ct3d, in);
> +    if (ret != CXL_MBOX_SUCCESS) {
> +        goto out;
> +    }
> +
> +    for (i = 0; i < in->num_entries_updated; i++) {
> +        dpa = in->updated_entries[i].start_dpa;
> +        len = in->updated_entries[i].len;
> +
> +        /*
> +         * Check if the DPA range of the to-be-added extent overlaps with
> +         * existing extent list maintained by the device.
> +         */
> +        QTAILQ_FOREACH(ent, extent_list, node) {
> +            if (ent->start_dpa == dpa && ent->len == len) {
> +                ret = CXL_MBOX_INVALID_PA;
> +                goto out;
> +            } else if (ent->start_dpa <= dpa
> +                    && dpa + len <= ent->start_dpa + ent->len) {

I think this second one always incorporates the first case.
I haven't changed this yet though...  Added a todo note.

> +                ret = CXL_MBOX_INVALID_PA;
> +                goto out;
> +            } else if ((dpa < ent->start_dpa + ent->len
> +                        && dpa + len > ent->start_dpa + ent->len)
> +                    || (dpa < ent->start_dpa && dpa + len > ent->start_dpa)) {
> +                ret = CXL_MBOX_INVALID_PA;
> +                goto out;
> +            }
> +        }
> +
> +        /*
> +         * TODO: add a pending extent list based on event log record and verify
> +         * the input response
> +         */
> +
> +        insert_extent_to_extent_list(extent_list, dpa, len, NULL, 0);
> +    }
> +    ret = CXL_MBOX_SUCCESS;
> +
> +out:
> +    return ret;
> +}
> +
> +/*
> + * Spec 3.0: 8.2.9.8.9.4
> + * Release Dynamic Capacity (opcode 4803h)
> + **/
> +static CXLRetCode cmd_dcd_release_dyn_cap(struct cxl_cmd *cmd,
> +        CXLDeviceState *cxl_dstate,
> +        uint16_t *len_unused)
> +{
> +    updated_dc_extent_list_in_pl *in = (void *)cmd->payload;
> +    struct CXLType3Dev *ct3d = container_of(cxl_dstate, CXLType3Dev,
> +            cxl_dstate);
> +    CXLDCDExtentList *extent_list = &ct3d->dc.extents;
> +    CXLDCD_Extent *ent;
> +    uint32_t i;
> +    uint64_t dpa, len;
> +    CXLRetCode ret;
> +
> +    if (in->num_entries_updated == 0) {
> +        return CXL_MBOX_INVALID_INPUT;
> +    }
> +
> +    ret = detect_malformed_extent_list(ct3d, in);
> +    if (ret != CXL_MBOX_SUCCESS) {
> +        return ret;
> +    }
> +
> +    for (i = 0; i < in->num_entries_updated; i++) {
> +        dpa = in->updated_entries[i].start_dpa;
> +        len = in->updated_entries[i].len;
> +
> +        QTAILQ_FOREACH(ent, extent_list, node) {
> +            if (ent->start_dpa == dpa && ent->len == len) {
> +                break;
> +            } else if (ent->start_dpa < dpa
<=  We want to do the partial but at start case.
Please check my logic on this! I'll test it later, but for now I've
made the change.

We shuould just let this code run even in the exact match case
as len1 == len2 == 0 and math is cehap.


> +                    && dpa + len <= ent->start_dpa + ent->len) {

Not commented on it though I've tidied this up in other places...
Local style is to have the boolean operator on the end of the line before
not the start of the next one.

> +                /* remove partial extent */
> +                uint64_t len1 = dpa - ent->start_dpa;
> +                uint64_t len2 = ent->start_dpa + ent->len - dpa - len;
> +
> +                if (len1) {
> +                    insert_extent_to_extent_list(extent_list, ent->start_dpa,
> +                            len1, NULL, 0);
> +                }
> +                if (len2) {
> +                    insert_extent_to_extent_list(extent_list, dpa + len, len2,
> +                            NULL, 0);
> +                }
> +                break;
> +            } else if ((dpa < ent->start_dpa + ent->len
> +                        && dpa + len > ent->start_dpa + ent->len)
> +                    || (dpa < ent->start_dpa && dpa + len > ent->start_dpa))

This is rejecting attempt to remove a superset. Fair enough but does this code
fuse neighbouring extents? Left for now.


> +                return CXL_MBOX_INVALID_EXTENT_LIST;
> +        }
> +
> +        if (ent) {
> +            QTAILQ_REMOVE(extent_list, ent, node);
> +            g_free(ent);
> +        } else {
> +            /* Try to remove a non-existing extent */
> +            return CXL_MBOX_INVALID_PA;
> +        }
> +    }
> +
> +    return CXL_MBOX_SUCCESS;
> +}
> + 
>  #define IMMEDIATE_CONFIG_CHANGE (1 << 1)
>  #define IMMEDIATE_DATA_CHANGE (1 << 2)
>  #define IMMEDIATE_POLICY_CHANGE (1 << 3)
> @@ -1129,6 +1376,12 @@ static struct cxl_cmd cxl_cmd_set[256][256] = {
>      [DCD_CONFIG][GET_DYN_CAP_EXT_LIST] = {
>          "DCD_GET_DYNAMIC_CAPACITY_EXTENT_LIST", cmd_dcd_get_dyn_cap_ext_list,
>          8, 0 },
> +    [DCD_CONFIG][ADD_DYN_CAP_RSP] = {
> +        "ADD_DCD_DYNAMIC_CAPACITY_RESPONSE", cmd_dcd_add_dyn_cap_rsp,
> +        ~0, IMMEDIATE_DATA_CHANGE },
> +    [DCD_CONFIG][RELEASE_DYN_CAP] = {
> +        "RELEASE_DCD_DYNAMIC_CAPACITY", cmd_dcd_release_dyn_cap,
> +        ~0, IMMEDIATE_DATA_CHANGE },
>  };
>  
>  static struct cxl_cmd cxl_cmd_set_sw[256][256] = {
> diff --git a/include/hw/cxl/cxl_device.h b/include/hw/cxl/cxl_device.h
> index 3a338b3b37..01a5eaca48 100644
> --- a/include/hw/cxl/cxl_device.h
> +++ b/include/hw/cxl/cxl_device.h
> @@ -130,7 +130,8 @@ typedef enum {
>      CXL_MBOX_INCORRECT_PASSPHRASE = 0x14,
>      CXL_MBOX_UNSUPPORTED_MAILBOX = 0x15,
>      CXL_MBOX_INVALID_PAYLOAD_LENGTH = 0x16,
> -    CXL_MBOX_MAX = 0x17
> +    CXL_MBOX_INVALID_EXTENT_LIST = 0x1E, /* cxl r3.0: Table 8-34*/
> +    CXL_MBOX_MAX = 0x1F
>  } CXLRetCode;
>  
>  struct cxl_cmd;


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 45FAEC001DF
	for <linux-cxl@archiver.kernel.org>; Mon,  7 Aug 2023 11:55:37 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S232670AbjHGLzg (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Mon, 7 Aug 2023 07:55:36 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:32834 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S229990AbjHGLzf (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Mon, 7 Aug 2023 07:55:35 -0400
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 6187FA6
        for <linux-cxl@vger.kernel.org>; Mon,  7 Aug 2023 04:55:33 -0700 (PDT)
Received: from lhrpeml500005.china.huawei.com (unknown [172.18.147.207])
        by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4RKF6M6lqRz6J6k9;
        Mon,  7 Aug 2023 19:51:55 +0800 (CST)
Received: from localhost (10.202.227.76) by lhrpeml500005.china.huawei.com
 (7.191.163.240) with Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id 15.1.2507.27; Mon, 7 Aug
 2023 12:55:30 +0100
Date: Mon, 7 Aug 2023 12:55:29 +0100
From: Jonathan Cameron <Jonathan.Cameron@Huawei.com>
To: Fan Ni <fan.ni@samsung.com>
CC: "qemu-devel@nongnu.org" <qemu-devel@nongnu.org>,
        "linux-cxl@vger.kernel.org" <linux-cxl@vger.kernel.org>,
        "gregory.price@memverge.com" <gregory.price@memverge.com>,
        "hchkuo@avery-design.com.tw" <hchkuo@avery-design.com.tw>,
        "cbrowy@avery-design.com" <cbrowy@avery-design.com>,
        "ira.weiny@intel.com" <ira.weiny@intel.com>,
        "dan.j.williams@intel.com" <dan.j.williams@intel.com>,
        Adam Manzanares <a.manzanares@samsung.com>,
        "dave@stgolabs.net" <dave@stgolabs.net>,
        "nmtadam.samsung@gmail.com" <nmtadam.samsung@gmail.com>,
        "nifan@outlook.com" <nifan@outlook.com>
Subject: Re: [Qemu PATCH v2 6/9] hw/mem/cxl_type3: Add DC extent list
 representative and get DC extent list mailbox support
Message-ID: <20230807125529.00002c79@Huawei.com>
In-Reply-To: <20230725183939.2741025-7-fan.ni@samsung.com>
References: <20230725183939.2741025-1-fan.ni@samsung.com>
        <CGME20230725183957uscas1p28b38d294f90b97f99769466cc533b4de@uscas1p2.samsung.com>
        <20230725183939.2741025-7-fan.ni@samsung.com>
Organization: Huawei Technologies Research and Development (UK) Ltd.
X-Mailer: Claws Mail 4.1.0 (GTK 3.24.33; x86_64-w64-mingw32)
MIME-Version: 1.0
Content-Type: text/plain; charset="US-ASCII"
Content-Transfer-Encoding: 7bit
X-Originating-IP: [10.202.227.76]
X-ClientProxiedBy: lhrpeml100004.china.huawei.com (7.191.162.219) To
 lhrpeml500005.china.huawei.com (7.191.163.240)
X-CFilter-Loop: Reflected
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

On Tue, 25 Jul 2023 18:39:56 +0000
Fan Ni <fan.ni@samsung.com> wrote:

> From: Fan Ni <nifan@outlook.com>
> 
> Add dynamic capacity extent list representative to the definition of
> CXLType3Dev and add get DC extent list mailbox command per
> CXL.spec.3.0:.8.2.9.8.9.2.
> 
> Signed-off-by: Fan Ni <fan.ni@samsung.com>

A couple of general name format changes. Otherwise LGTM

Jonathan

> ---
>  hw/cxl/cxl-mailbox-utils.c  | 71 +++++++++++++++++++++++++++++++++++++
>  hw/mem/cxl_type3.c          |  1 +
>  include/hw/cxl/cxl_device.h | 23 ++++++++++++
>  3 files changed, 95 insertions(+)
> 
> diff --git a/hw/cxl/cxl-mailbox-utils.c b/hw/cxl/cxl-mailbox-utils.c
> index 0511b8e6f7..3d25a9697e 100644
> --- a/hw/cxl/cxl-mailbox-utils.c
> +++ b/hw/cxl/cxl-mailbox-utils.c
> @@ -83,6 +83,7 @@ enum {
>          #define CLEAR_POISON           0x2
>      DCD_CONFIG  = 0x48, /*r3.0: 8.2.9.8.9*/
>          #define GET_DC_CONFIG          0x0
> +        #define GET_DYN_CAP_EXT_LIST   0x1
>      PHYSICAL_SWITCH = 0x51
>          #define IDENTIFY_SWITCH_DEVICE      0x0
>  };
> @@ -1018,6 +1019,73 @@ static CXLRetCode cmd_dcd_get_dyn_cap_config(struct cxl_cmd *cmd,
>      return CXL_MBOX_SUCCESS;
>  }
>  
> +/*
> + * cxl spec 3.0: 8.2.9.8.9.2
> + * Get Dynamic Capacity Extent List (Opcode 4810h)
> + */
> +static CXLRetCode cmd_dcd_get_dyn_cap_ext_list(struct cxl_cmd *cmd,
> +        CXLDeviceState *cxl_dstate,
> +        uint16_t *len)
> +{
> +    struct get_dyn_cap_ext_list_in_pl {
> +        uint32_t extent_cnt;
> +        uint32_t start_extent_id;
> +    } QEMU_PACKED;
> +
> +    struct get_dyn_cap_ext_list_out_pl {
> +        uint32_t count;
> +        uint32_t total_extents;
> +        uint32_t generation_num;
> +        uint8_t rsvd[4];
> +        CXLDCExtent_raw records[];
> +    } QEMU_PACKED;
> +
> +    struct get_dyn_cap_ext_list_in_pl *in = (void *)cmd->payload;
> +    struct get_dyn_cap_ext_list_out_pl *out = (void *)cmd->payload;
> +    struct CXLType3Dev *ct3d = container_of(cxl_dstate, CXLType3Dev,
> +            cxl_dstate);
> +    uint16_t record_count = 0, i = 0, record_done = 0;
> +    CXLDCDExtentList *extent_list = &ct3d->dc.extents;
> +    CXLDCD_Extent *ent;
> +    uint16_t out_pl_len;
> +    uint32_t start_extent_id = in->start_extent_id;
> +
> +    if (start_extent_id > ct3d->dc.total_extent_count) {
> +        return CXL_MBOX_INVALID_INPUT;
> +    }
> +
> +    record_count = MIN(in->extent_cnt,
> +            ct3d->dc.total_extent_count - start_extent_id);
> +
> +    out_pl_len = sizeof(*out) + record_count * sizeof(out->records[0]);
> +    /* May need more processing here in the future */
> +    assert(out_pl_len <= CXL_MAILBOX_MAX_PAYLOAD_SIZE);
> +
> +    memset(out, 0, out_pl_len);
> +    stl_le_p(&out->count, record_count);
> +    stl_le_p(&out->total_extents, ct3d->dc.total_extent_count);
> +    stl_le_p(&out->generation_num, ct3d->dc.ext_list_gen_seq);
> +
> +    if (record_count > 0) {
> +        QTAILQ_FOREACH(ent, extent_list, node) {
> +            if (i++ < start_extent_id) {
> +                continue;
> +            }
> +            stq_le_p(&out->records[record_done].start_dpa, ent->start_dpa);
> +            stq_le_p(&out->records[record_done].len, ent->len);
> +            memcpy(&out->records[record_done].tag, ent->tag, 0x10);
> +            stw_le_p(&out->records[record_done].shared_seq, ent->shared_seq);
> +            record_done++;
> +            if (record_done == record_count) {
> +                break;
> +            }
> +        }
> +    }
> +
> +    *len = out_pl_len;
> +    return CXL_MBOX_SUCCESS;
> +}
> +
>  #define IMMEDIATE_CONFIG_CHANGE (1 << 1)
>  #define IMMEDIATE_DATA_CHANGE (1 << 2)
>  #define IMMEDIATE_POLICY_CHANGE (1 << 3)
> @@ -1058,6 +1126,9 @@ static struct cxl_cmd cxl_cmd_set[256][256] = {
>          cmd_media_clear_poison, 72, 0 },
>      [DCD_CONFIG][GET_DC_CONFIG] = { "DCD_GET_DC_CONFIG",
>          cmd_dcd_get_dyn_cap_config, 2, 0 },
> +    [DCD_CONFIG][GET_DYN_CAP_EXT_LIST] = {
> +        "DCD_GET_DYNAMIC_CAPACITY_EXTENT_LIST", cmd_dcd_get_dyn_cap_ext_list,
> +        8, 0 },
>  };
>  
>  static struct cxl_cmd cxl_cmd_set_sw[256][256] = {
> diff --git a/hw/mem/cxl_type3.c b/hw/mem/cxl_type3.c
> index 76bbd9f785..f1170b8047 100644
> --- a/hw/mem/cxl_type3.c
> +++ b/hw/mem/cxl_type3.c
> @@ -789,6 +789,7 @@ static int cxl_create_dc_regions(CXLType3Dev *ct3d)
>  
>          region_base += region->len;
>      }
> +    QTAILQ_INIT(&ct3d->dc.extents);
>  
>      return 0;
>  }
> diff --git a/include/hw/cxl/cxl_device.h b/include/hw/cxl/cxl_device.h
> index 1c99b05a66..3a338b3b37 100644
> --- a/include/hw/cxl/cxl_device.h
> +++ b/include/hw/cxl/cxl_device.h
> @@ -385,6 +385,25 @@ typedef QLIST_HEAD(, CXLPoison) CXLPoisonList;
>  
>  #define DCD_MAX_REGION_NUM 8
>  
> +typedef struct CXLDCD_Extent_raw {

Renamed to match QEMU naming conventions (more or less)
CXLDCDExtentRaw

> +    uint64_t start_dpa;
> +    uint64_t len;
> +    uint8_t tag[0x10];
> +    uint16_t shared_seq;
> +    uint8_t rsvd[0x6];
> +} QEMU_PACKED CXLDCExtent_raw;
> +
> +typedef struct CXLDCD_Extent {

CXLDCDExtent

> +    uint64_t start_dpa;
> +    uint64_t len;
> +    uint8_t tag[0x10];
> +    uint16_t shared_seq;
> +    uint8_t rsvd[0x6];
> +
> +    QTAILQ_ENTRY(CXLDCD_Extent) node;
> +} CXLDCD_Extent;
> +typedef QTAILQ_HEAD(, CXLDCD_Extent) CXLDCDExtentList;
> +
>  typedef struct CXLDCD_Region {
>      uint64_t base;
>      uint64_t decode_len; /* in multiples of 256MB */
> @@ -433,6 +452,10 @@ struct CXLType3Dev {
>  
>          uint8_t num_regions; /* 0-8 regions */
>          struct CXLDCD_Region regions[DCD_MAX_REGION_NUM];
> +        CXLDCDExtentList extents;
> +
> +        uint32_t total_extent_count;
> +        uint32_t ext_list_gen_seq;
>      } dc;
>  };
>  


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 024E9C001DF
	for <linux-cxl@archiver.kernel.org>; Mon,  7 Aug 2023 12:10:24 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S233273AbjHGMKX (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Mon, 7 Aug 2023 08:10:23 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:44264 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S233281AbjHGMKT (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Mon, 7 Aug 2023 08:10:19 -0400
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 8EAFC125
        for <linux-cxl@vger.kernel.org>; Mon,  7 Aug 2023 05:10:13 -0700 (PDT)
Received: from lhrpeml500005.china.huawei.com (unknown [172.18.147.200])
        by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4RKFRH6PfJz6J6ct;
        Mon,  7 Aug 2023 20:06:35 +0800 (CST)
Received: from localhost (10.202.227.76) by lhrpeml500005.china.huawei.com
 (7.191.163.240) with Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id 15.1.2507.27; Mon, 7 Aug
 2023 13:10:10 +0100
Date: Mon, 7 Aug 2023 13:10:09 +0100
From: Jonathan Cameron <Jonathan.Cameron@Huawei.com>
To: Gregory Price <gregory.price@memverge.com>
CC: Fan Ni <fan.ni@samsung.com>,
        "qemu-devel@nongnu.org" <qemu-devel@nongnu.org>,
        "linux-cxl@vger.kernel.org" <linux-cxl@vger.kernel.org>,
        "hchkuo@avery-design.com.tw" <hchkuo@avery-design.com.tw>,
        "cbrowy@avery-design.com" <cbrowy@avery-design.com>,
        "ira.weiny@intel.com" <ira.weiny@intel.com>,
        "dan.j.williams@intel.com" <dan.j.williams@intel.com>,
        Adam Manzanares <a.manzanares@samsung.com>,
        "dave@stgolabs.net" <dave@stgolabs.net>,
        "nmtadam.samsung@gmail.com" <nmtadam.samsung@gmail.com>,
        "nifan@outlook.com" <nifan@outlook.com>
Subject: Re: [Qemu PATCH v2 5/9] hw/mem/cxl_type3: Add host backend and
 address space handling for DC regions
Message-ID: <20230807131009.00000fcc@Huawei.com>
In-Reply-To: <ZM0+ewZtknlOrGMl@memverge.com>
References: <20230725183939.2741025-1-fan.ni@samsung.com>
        <CGME20230725183957uscas1p1eeb8e8eccc6c00b460d183027642374b@uscas1p1.samsung.com>
        <20230725183939.2741025-6-fan.ni@samsung.com>
        <20230804173623.00007707@Huawei.com>
        <ZM0+ewZtknlOrGMl@memverge.com>
Organization: Huawei Technologies Research and Development (UK) Ltd.
X-Mailer: Claws Mail 4.1.0 (GTK 3.24.33; x86_64-w64-mingw32)
MIME-Version: 1.0
Content-Type: text/plain; charset="US-ASCII"
Content-Transfer-Encoding: 7bit
X-Originating-IP: [10.202.227.76]
X-ClientProxiedBy: lhrpeml100002.china.huawei.com (7.191.160.241) To
 lhrpeml500005.china.huawei.com (7.191.163.240)
X-CFilter-Loop: Reflected
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

On Fri, 4 Aug 2023 14:07:55 -0400
Gregory Price <gregory.price@memverge.com> wrote:

> On Fri, Aug 04, 2023 at 05:36:23PM +0100, Jonathan Cameron wrote:
> > On Tue, 25 Jul 2023 18:39:56 +0000
> > Fan Ni <fan.ni@samsung.com> wrote:
> >   
> > > From: Fan Ni <nifan@outlook.com>
> > > 
> > > Add (file/memory backed) host backend, all the dynamic capacity regions
> > > will share a single, large enough host backend. Set up address space for
> > > DC regions to support read/write operations to dynamic capacity for DCD.
> > > 
> > > With the change, following supports are added:
> > > 1. add a new property to type3 device "nonvolatile-dc-memdev" to point to host
> > >    memory backend for dynamic capacity;
> > > 2. add namespace for dynamic capacity for read/write support;
> > > 3. create cdat entries for each dynamic capacity region;
> > > 4. fix dvsec range registers to include DC regions.
> > > 
> > > Signed-off-by: Fan Ni <fan.ni@samsung.com>  
> > Hi Fan,
> > 
> > I'm not sure if we want to do all regions backed by one memory backend
> > or one backend each.  It will become complex when some are shared
> > (e.g. what Gregory is working on).  
> 
> I thought about this briefly when i implemented the original volatile
> support due to the potential for partitioning. We landed on, iirc, 
> 2 backends (1 for volatile, 1 for non-volatile).
> 
> The reality, though, is the driver (presently) does not have a good way
> to create more than 1 dax per memdev, and in practice with real devices
> we see that this just tends to be the case: 1 dax per device.  So unless
> that's going to change, ever having more than 1 backend will just be
> unused complexity.

I'm not sure how this will turn out.  I guess we play with what Fan has
done here and see if it ever ends up mattering!

> 
> To me, this is a good example of "maybe piling everything into the core
> ct3d is going to get ugly fast".  Maybe it would be better to do
> something similar to the CCI interface and allow for overriding the
> other functions as well.

In general I agree - but DCD is going to be a fairly standard facility
so for this one I think it'll end up either in ct3d or in the MHD / MLD
generalizations of that. For now I'm still thinking a normal type 3 device
is an MHD or MLD with a limited feature set - so easier to just turn things
off in one of those than do it as additions.   Now I'm not sure if
we end up with a MHD MLD with a lot of options in the end - probably still
as the ct3d but with a default where most stuff is turned off.

Ultimately I want that super device to be maintainable. That may mean
breaking the functionality up, but I don't yet think that means going
the simple + extend model.

> 
> just a thought.  I apologize for not engaging with the DCD patch set,
> conferences have been keeping me busier than expected.  I plan on
> putting it through the grinder this month.

No problem. Definitely some testing needed here so great to have
some more of that when you get to it.  I think most of the issues
will occur when the kernel isn't do it's normal flows. So weird
add and remove sequences linux many never use but which we should
emulate the handling for correctly.

> 
> > 
> > A few questions inline.  In particular there are subtle changes to
> > existing handling that are either bug fixes (in which case they need
> > to be sent first) or bugs / have no effect and shouldn't be in here.
> > 
> >   
> > > ---
> > >  hw/cxl/cxl-mailbox-utils.c  |  19 +++-
> > >  hw/mem/cxl_type3.c          | 203 +++++++++++++++++++++++++++++-------
> > >  include/hw/cxl/cxl_device.h |   4 +
> > >  3 files changed, 185 insertions(+), 41 deletions(-)
> > >   


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 536D1C7113B
	for <linux-cxl@archiver.kernel.org>; Thu, 24 Aug 2023 20:51:42 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S243595AbjHXUvK (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Thu, 24 Aug 2023 16:51:10 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:37886 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S243605AbjHXUuz (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Thu, 24 Aug 2023 16:50:55 -0400
Received: from mout.gmx.net (mout.gmx.net [212.227.15.18])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id E3AEE1989
        for <linux-cxl@vger.kernel.org>; Thu, 24 Aug 2023 13:50:52 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=gmx.us;
 s=s31663417; t=1692910154; x=1693514954; i=fan.ni@gmx.us;
 bh=cojvJ9Sk6Ei6IcvAfsXiEAhgupuX7yHbHAR5oyAk7YM=;
 h=X-UI-Sender-Class:Date:From:To:Cc:Subject:References:In-Reply-To;
 b=sLNe/uVSq5lQyagkSc6tJa0AcMFL+DwnDwRfDoP0SCFQ5LPaP1zmbRJLfuFJJTxDjFwmQNE
 K7fbDmvjn27u5A9mFMcbiV+9HL4KXpNec+BOGRZjVXe5juTcrN+6roNPtutJOXZFm20V8E1Zn
 l/7VkwbxH1zuDY582XBv+48iFE7L7751ffOwVsUHprfcu24k2bE63wrSrHJ1h41US2KBuQ9FC
 D86338VWJfPTatKLf+Ym1hv4AV8la6cL3UoKwkxnZBv5lvaty7Jjc0jEGKovfNzb3g8ZjVWZg
 SGt+0IVLXXHywwm5vGLP6pImtaGi2IMFa4HRp/C3v63QFywvYHlA==
X-UI-Sender-Class: 724b4f7f-cbec-4199-ad4e-598c01a50d3a
Received: from debian ([99.13.228.231]) by mail.gmx.net (mrgmx004
 [212.227.17.184]) with ESMTPSA (Nemesis) id 1Mel7v-1pyZbQ48hR-00anqO; Thu, 24
 Aug 2023 22:49:14 +0200
Date: Thu, 24 Aug 2023 13:49:00 -0700
From: Fan Ni <fan.ni@gmx.us>
To: Jonathan Cameron <Jonathan.Cameron@huawei.com>
Cc: Fan Ni <fan.ni@samsung.com>,
        "qemu-devel@nongnu.org" <qemu-devel@nongnu.org>,
        "linux-cxl@vger.kernel.org" <linux-cxl@vger.kernel.org>,
        "gregory.price@memverge.com" <gregory.price@memverge.com>,
        "hchkuo@avery-design.com.tw" <hchkuo@avery-design.com.tw>,
        "cbrowy@avery-design.com" <cbrowy@avery-design.com>,
        "ira.weiny@intel.com" <ira.weiny@intel.com>,
        "dan.j.williams@intel.com" <dan.j.williams@intel.com>,
        Adam Manzanares <a.manzanares@samsung.com>,
        "dave@stgolabs.net" <dave@stgolabs.net>,
        "nmtadam.samsung@gmail.com" <nmtadam.samsung@gmail.com>,
        "nifan@outlook.com" <nifan@outlook.com>
Subject: Re: [Qemu PATCH v2 9/9] hw/mem/cxl_type3: Add dpa range validation
 for accesses to dc regions
Message-ID: <ZOfCPADXcYMGIGC4@debian>
References: <20230725183939.2741025-1-fan.ni@samsung.com>
 <CGME20230725183957uscas1p2ca5293c7229ab989ad1a2d95395436a6@uscas1p2.samsung.com>
 <20230725183939.2741025-10-fan.ni@samsung.com>
 <20230807095342.00006f88@Huawei.com>
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: <20230807095342.00006f88@Huawei.com>
X-Provags-ID: V03:K1:3Z+LimPkf0jWtknBKvIuplqjYkTd/DAekeLJBu8RUW4sWIdP6UU
 ok8XjJr/tbUyJGLBKipJTgH0QgGEYf09yFVSQZM6hvGwjzPOf3eioDpWNAEAenK/3U7Tx4v
 6rgKsfAr3OxsQjx1R/gBKUjrTocA7+N5de9ZUs7piHtZMewB7DpiSnU1YzzCMFeuel+pUF0
 ez4cZmJ4ppjf0oW8Xx1GQ==
UI-OutboundReport: notjunk:1;M01:P0:aT6Nt0nTZOs=;ATfsrix915RjtRhcu21F2G6xnlQ
 vCWRcjxt7gqeaMyh1cKzuaHJjmt3BxMy6/txLAZ0vFDXxcBLT4Oh9cwoKP2fm/hqd1yFIlpus
 kDn08rwURtQIOi3ivSJJmuMEvYMLuxjFV5VNs8WFvHuxdmIuNID6HhkyX9OBF2sRyAfpsMK7X
 coTdE3kS5VFrZRpTzbrLDZNZqQ3fEKUSAln/gWbHhKtX8Rhn+wjSPc7mE0IR/yh8p9IXOaxCZ
 hkLQUfRt1rE0oX+yfqvBlsh0RI753MVLqGn72C5B7Cdxa/WfbdeToPx4QQ1VyoOkVIOOAtaG5
 GE2GgPGoyrPWUtY143kLQFqdb69iliB84pWpWjghOMNbwfBoXK71eXpyBOm4WDZLqufuEk2ww
 Hlz0QBOSbLO1vv84n+P7u3ACN1JefHxW0l66z40tm7mkO41FoHYLXWqffJhOhQd5rpVzJuxM0
 CpCYi9VVJjCGxheWgFl29Jy4fHFVhYoU1IxVPxOkD+dGuAHTK3j2FjGWoLEUCfWNFPtRkrYna
 GLmmJRL8juCyBIKbyyN0BNYTssIOC1hmvgMpLj+lK3065TKQc62C1epUxycDs6/d7B4CD/woG
 qBvHX3MkkRCUSn8zeUSHd3hW3Yx6Q7gZmDlSO2TG1NmO6mN2uBf4oucQY6rWBlky+vw6Epcbm
 PSMzjNfm+gGVlyvtrAaVFYlNuaYtbtWn9mKuSDtxjTOKdWcSdUOA24TwCZqbypPVWh0pU9w38
 k7xY2/VtM1IVnoi00iS0T4OGh0zBkL6P6rMSsXBzCTQ4tI+wkqbxfoPRnUJzrMcELxL4uCzjd
 cAe054+fceZJyhzznd8ekHxzu1kGTx2tMwdL1jKXVRujWa4tnJZouAYYA6cUK2oFL7/gPLsDV
 l10PPZTOI4NOAqq5ZPZjO2FYgeeWWSsyIMO7mI+E+ZEfwzEDv2PmFj49c7MLJINd8IzW8kyY4
 rBxeNbtiqntR3IIi1jqeh8JcXLU=
Content-Transfer-Encoding: quoted-printable
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

On Mon, Aug 07, 2023 at 09:53:42AM +0100, Jonathan Cameron wrote:
> On Tue, 25 Jul 2023 18:39:56 +0000
> Fan Ni <fan.ni@samsung.com> wrote:
>
> > From: Fan Ni <nifan@outlook.com>
> >
> > Not all dpa range in the dc regions is valid to access until an extent
> > covering the range has been added. Add a bitmap for each region to
> > record whether a dc block in the region has been backed by dc extent.
> > For the bitmap, a bit in the bitmap represents a dc block. When a dc
> > extent is added, all the bits of the blocks in the extent will be set,
> > which will be cleared when the extent is released.
> >
> > Signed-off-by: Fan Ni <fan.ni@samsung.com>
> Hi Fan,
>
> A few of the bits of feedback apply broadly across the series.  Given I'=
m
> rebasing this anyway to give myself something to test I'll tidy things u=
p
> (feel free to disagree with and revert any changes !)
> and push a tree out in next day or two.  I'll message when I've done so.
>
> Jonathan

Hi Jonathan,
I tried DCD with your branch "cxl-2023-08-07", and noticed the
following,
1. You made some changes to the bitmap functionality, now it is only
used to validate extents when adding/releasing dc extents. My original
thought of adding the bitmap is to 1) validating extents for extent
add/release as you do; 2) Add validating when doing read/write to the dc
regions since some address region may not have valid extent added yet.
Do you think 2) is not necessary?

2. Your change introduced a bug in the code.
https://gitlab.com/jic23/qemu/-/blob/cxl-2023-08-07/hw/cxl/cxl-mailbox-uti=
ls.c?ref_type=3Dheads#L1394
ct3d->dc.num_regions should be ct3d->dc.num_regions-1.

Thanks,
Fan

>
> > ---
> >  hw/mem/cxl_type3.c          | 155 +++++++++++++++++++++++++++++++++++=
+
> >  include/hw/cxl/cxl_device.h |   1 +
> >  2 files changed, 156 insertions(+)
> >
> > diff --git a/hw/mem/cxl_type3.c b/hw/mem/cxl_type3.c
> > index 41a828598a..51943a36fc 100644
> > --- a/hw/mem/cxl_type3.c
> > +++ b/hw/mem/cxl_type3.c
> > @@ -787,13 +787,37 @@ static int cxl_create_dc_regions(CXLType3Dev *ct=
3d)
> >          /* dsmad_handle is set when creating cdat table entries */
> >          region->flags =3D 0;
> >
> > +        region->blk_bitmap =3D bitmap_new(region->len / region->block=
_size);
>
> In common with many allocators in qemu if this fails it calls abort()
> internally so no need to handle potential errors.
>
> > +        if (!region->blk_bitmap) {
> > +            break;
> > +        }
> > +
> >          region_base +=3D region->len;
> >      }
> > +
> > +    if (i < ct3d->dc.num_regions) {
> > +        while (--i >=3D 0) {
> > +            g_free(ct3d->dc.regions[i].blk_bitmap);
> > +        }
> > +        return -1;
> > +    }
> > +
> >      QTAILQ_INIT(&ct3d->dc.extents);
> >
> >      return 0;
> >  }
> >
> > +static void cxl_destroy_dc_regions(CXLType3Dev *ct3d)
> > +{
> > +    int i;
> > +    struct CXLDCD_Region *region;
> > +
> > +    for (i =3D 0; i < ct3d->dc.num_regions; i++) {
> > +        region =3D &ct3d->dc.regions[i];
> > +        g_free(region->blk_bitmap);
> > +    }
> > +}
> > +
> >  static bool cxl_setup_memory(CXLType3Dev *ct3d, Error **errp)
> >  {
> >      DeviceState *ds =3D DEVICE(ct3d);
> > @@ -1021,6 +1045,7 @@ err_free_special_ops:
> >      g_free(regs->special_ops);
> >  err_address_space_free:
> >      if (ct3d->dc.host_dc) {
> > +        cxl_destroy_dc_regions(ct3d);
> >          address_space_destroy(&ct3d->dc.host_dc_as);
> >      }
> >      if (ct3d->hostpmem) {
> > @@ -1043,6 +1068,7 @@ static void ct3_exit(PCIDevice *pci_dev)
> >      spdm_sock_fini(ct3d->doe_spdm.socket);
> >      g_free(regs->special_ops);
> >      if (ct3d->dc.host_dc) {
> > +        cxl_destroy_dc_regions(ct3d);
> >          address_space_destroy(&ct3d->dc.host_dc_as);
> >      }
> >      if (ct3d->hostpmem) {
> > @@ -1053,6 +1079,110 @@ static void ct3_exit(PCIDevice *pci_dev)
> >      }
> >  }
> >
> > +/*
> > + * This function will marked the dpa range [dpa, dap + len) to be bac=
ked and
> > + * accessible, this happens when a dc extent is added and accepted by=
 the
> > + * host.
> > + */
> > +static void set_region_block_backed(CXLType3Dev *ct3d, uint64_t dpa,
> > +        uint64_t len)
> > +{
> > +    int i;
> > +    CXLDCD_Region *region =3D &ct3d->dc.regions[0];
> > +
> > +    if (dpa < region->base
> > +            || dpa >=3D region->base + ct3d->dc.total_capacity)
> > +        return;
> > +
> > +    /*
> > +     * spec 3.0 9.13.3: Regions are used in increasing-DPA order, wit=
h
> > +     * Region 0 being used for the lowest DPA of Dynamic Capacity and
> > +     * Region 7 for the highest DPA.
> > +     * So we check from the last region to find where the dpa belongs=
.
> > +     * access across multiple regions is not allowed.
> > +     **/
> > +    for (i =3D ct3d->dc.num_regions - 1; i >=3D 0; i--) {
> > +        region =3D &ct3d->dc.regions[i];
> > +        if (dpa >=3D region->base) {
> > +            break;
> > +        }
> > +    }
> > +
> > +    bitmap_set(region->blk_bitmap, (dpa - region->base) / region->blo=
ck_size,
> > +            len / region->block_size);
> > +}
> > +
> > +/*
> > + * This function check whether a dpa range [dpa, dpa + len) has been =
backed
> > + * with dc extents, used when validating read/write to dc regions
> > + */
> > +static bool test_region_block_backed(CXLType3Dev *ct3d, uint64_t dpa,
> > +        uint64_t len)
> > +{
> > +    int i;
> > +    CXLDCD_Region *region =3D &ct3d->dc.regions[0];
> > +    uint64_t nbits;
> > +    long nr;
> > +
> > +    if (dpa < region->base
> > +            || dpa >=3D region->base + ct3d->dc.total_capacity)
> > +        return false;
> > +
> > +    /*
> > +     * spec 3.0 9.13.3: Regions are used in increasing-DPA order, wit=
h
> > +     * Region 0 being used for the lowest DPA of Dynamic Capacity and
> > +     * Region 7 for the highest DPA.
> > +     * So we check from the last region to find where the dpa belongs=
.
> > +     * access across multiple regions is not allowed.
> > +     */
> > +    for (i =3D ct3d->dc.num_regions - 1; i >=3D 0; i--) {
> > +        region =3D &ct3d->dc.regions[i];
> > +        if (dpa >=3D region->base) {
> > +            break;
> > +        }
> > +    }
> > +
> > +    nr =3D (dpa - region->base) / region->block_size;
> > +    nbits =3D len / region->block_size;
> > +    return find_next_zero_bit(region->blk_bitmap, nbits, nr) >=3D nr =
+ nbits;
> > +}
> > +
> > +/*
> > + * This function will marked the dpa range [dpa, dap + len) to be unb=
acked and
> > + * inaccessible, this happens when a dc extent is added and accepted =
by the
> > + * host.
> > + */
> > +static void clear_region_block_backed(CXLType3Dev *ct3d, uint64_t dpa=
,
> > +        uint64_t len)
> > +{
> > +    int i;
> > +    CXLDCD_Region *region =3D &ct3d->dc.regions[0];
> > +    uint64_t nbits;
> > +    long nr;
> > +
> > +    if (dpa < region->base
> > +            || dpa >=3D region->base + ct3d->dc.total_capacity)
> > +        return;
> > +
> > +    /*
> > +     * spec 3.0 9.13.3: Regions are used in increasing-DPA order, wit=
h
> > +     * Region 0 being used for the lowest DPA of Dynamic Capacity and
> > +     * Region 7 for the highest DPA.
> > +     * So we check from the last region to find where the dpa belongs=
.
> > +     * access across multiple regions is not allowed.
> > +     */
> > +    for (i =3D ct3d->dc.num_regions - 1; i >=3D 0; i--) {
> > +        region =3D &ct3d->dc.regions[i];
> > +        if (dpa >=3D region->base) {
> > +            break;
> > +        }
> > +    }
> > +
> > +    nr =3D (dpa - region->base) / region->block_size;
> > +    nbits =3D len / region->block_size;
> > +    bitmap_clear(region->blk_bitmap, nr, nbits);
> > +}
> > +
> >  static bool cxl_type3_dpa(CXLType3Dev *ct3d, hwaddr host_addr, uint64=
_t *dpa)
> >  {
> >      uint32_t *cache_mem =3D ct3d->cxl_cstate.crb.cache_mem_registers;
> > @@ -1145,6 +1275,10 @@ static int cxl_type3_hpa_to_as_and_dpa(CXLType3=
Dev *ct3d,
> >          *as =3D &ct3d->hostpmem_as;
> >          *dpa_offset -=3D vmr_size;
> >      } else {
> > +        if (!test_region_block_backed(ct3d, *dpa_offset, size)) {
> > +            return -ENODEV;
> > +        }
> > +
> >          *as =3D &ct3d->dc.host_dc_as;
> >          *dpa_offset -=3D (vmr_size + pmr_size);
> >      }
> > @@ -1944,6 +2078,27 @@ static void qmp_cxl_process_dynamic_capacity_ev=
ent(const char *path,
> >      }
> >
> >      g_free(extents);
> > +
> > +    /* Another choice is to do the set/clear after getting mailbox re=
sponse*/
> > +    list =3D records;
> > +    while (list) {
> > +        dpa =3D list->value->dpa * 1024 * 1024;
> > +        len =3D list->value->len * 1024 * 1024;
> > +        rid =3D list->value->region_id;
> > +
> > +        switch (type) {
> > +        case DC_EVENT_ADD_CAPACITY:
> > +            set_region_block_backed(dcd, dpa, len);
> > +            break;
> > +        case DC_EVENT_RELEASE_CAPACITY:
> > +            clear_region_block_backed(dcd, dpa, len);
> > +            break;
> > +        default:
> > +            error_setg(errp, "DC event type not handled yet");
> > +            break;
> > +        }
> > +        list =3D list->next;
> > +    }
> >  }
> >
> >  void qmp_cxl_add_dynamic_capacity_event(const char *path,
> > diff --git a/include/hw/cxl/cxl_device.h b/include/hw/cxl/cxl_device.h
> > index 01a5eaca48..1f85c88017 100644
> > --- a/include/hw/cxl/cxl_device.h
> > +++ b/include/hw/cxl/cxl_device.h
> > @@ -412,6 +412,7 @@ typedef struct CXLDCD_Region {
> >      uint64_t block_size;
> >      uint32_t dsmadhandle;
> >      uint8_t flags;
> > +    unsigned long *blk_bitmap;
> >  } CXLDCD_Region;
> >
> >  struct CXLType3Dev {
>

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 070DBC7EE2C
	for <linux-cxl@archiver.kernel.org>; Fri, 25 Aug 2023 11:44:01 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S234723AbjHYLn3 (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Fri, 25 Aug 2023 07:43:29 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:38502 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S240884AbjHYLnD (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Fri, 25 Aug 2023 07:43:03 -0400
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 146442108
        for <linux-cxl@vger.kernel.org>; Fri, 25 Aug 2023 04:43:00 -0700 (PDT)
Received: from lhrpeml500005.china.huawei.com (unknown [172.18.147.226])
        by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4RXHyT59vpz6K5pT;
        Fri, 25 Aug 2023 19:38:25 +0800 (CST)
Received: from localhost (10.202.227.76) by lhrpeml500005.china.huawei.com
 (7.191.163.240) with Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id 15.1.2507.31; Fri, 25 Aug
 2023 12:42:57 +0100
Date: Fri, 25 Aug 2023 12:42:56 +0100
From: Jonathan Cameron <Jonathan.Cameron@Huawei.com>
To: Fan Ni <fan.ni@gmx.us>
CC: Fan Ni <fan.ni@samsung.com>,
        "qemu-devel@nongnu.org" <qemu-devel@nongnu.org>,
        "linux-cxl@vger.kernel.org" <linux-cxl@vger.kernel.org>,
        "gregory.price@memverge.com" <gregory.price@memverge.com>,
        "hchkuo@avery-design.com.tw" <hchkuo@avery-design.com.tw>,
        "cbrowy@avery-design.com" <cbrowy@avery-design.com>,
        "ira.weiny@intel.com" <ira.weiny@intel.com>,
        "dan.j.williams@intel.com" <dan.j.williams@intel.com>,
        Adam Manzanares <a.manzanares@samsung.com>,
        "dave@stgolabs.net" <dave@stgolabs.net>,
        "nmtadam.samsung@gmail.com" <nmtadam.samsung@gmail.com>,
        "nifan@outlook.com" <nifan@outlook.com>
Subject: Re: [Qemu PATCH v2 9/9] hw/mem/cxl_type3: Add dpa range validation
 for accesses to dc regions
Message-ID: <20230825124256.0000604c@Huawei.com>
In-Reply-To: <ZOfCPADXcYMGIGC4@debian>
References: <20230725183939.2741025-1-fan.ni@samsung.com>
        <CGME20230725183957uscas1p2ca5293c7229ab989ad1a2d95395436a6@uscas1p2.samsung.com>
        <20230725183939.2741025-10-fan.ni@samsung.com>
        <20230807095342.00006f88@Huawei.com>
        <ZOfCPADXcYMGIGC4@debian>
Organization: Huawei Technologies Research and Development (UK) Ltd.
X-Mailer: Claws Mail 4.1.0 (GTK 3.24.33; x86_64-w64-mingw32)
MIME-Version: 1.0
Content-Type: text/plain; charset="US-ASCII"
Content-Transfer-Encoding: 7bit
X-Originating-IP: [10.202.227.76]
X-ClientProxiedBy: lhrpeml500003.china.huawei.com (7.191.162.67) To
 lhrpeml500005.china.huawei.com (7.191.163.240)
X-CFilter-Loop: Reflected
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

On Thu, 24 Aug 2023 13:49:00 -0700
Fan Ni <fan.ni@gmx.us> wrote:

> On Mon, Aug 07, 2023 at 09:53:42AM +0100, Jonathan Cameron wrote:
> > On Tue, 25 Jul 2023 18:39:56 +0000
> > Fan Ni <fan.ni@samsung.com> wrote:
> >  
> > > From: Fan Ni <nifan@outlook.com>
> > >
> > > Not all dpa range in the dc regions is valid to access until an extent
> > > covering the range has been added. Add a bitmap for each region to
> > > record whether a dc block in the region has been backed by dc extent.
> > > For the bitmap, a bit in the bitmap represents a dc block. When a dc
> > > extent is added, all the bits of the blocks in the extent will be set,
> > > which will be cleared when the extent is released.
> > >
> > > Signed-off-by: Fan Ni <fan.ni@samsung.com>  
> > Hi Fan,
> >
> > A few of the bits of feedback apply broadly across the series.  Given I'm
> > rebasing this anyway to give myself something to test I'll tidy things up
> > (feel free to disagree with and revert any changes !)
> > and push a tree out in next day or two.  I'll message when I've done so.
> >
> > Jonathan  
> 
> Hi Jonathan,
> I tried DCD with your branch "cxl-2023-08-07", and noticed the
> following,
> 1. You made some changes to the bitmap functionality, now it is only
> used to validate extents when adding/releasing dc extents. My original
> thought of adding the bitmap is to 1) validating extents for extent
> add/release as you do; 2) Add validating when doing read/write to the dc
> regions since some address region may not have valid extent added yet.
> Do you think 2) is not necessary?

Change wasn't intentional. I probably just messed up the rebase!

> 
> 2. Your change introduced a bug in the code.
> https://gitlab.com/jic23/qemu/-/blob/cxl-2023-08-07/hw/cxl/cxl-mailbox-utils.c?ref_type=heads#L1394
> ct3d->dc.num_regions should be ct3d->dc.num_regions-1.
Thanks.  Given I might forget about about it, if you want to incorporate that in
your next version that would be great. I might remember to fix it in the meantime!

Jonathan

> 
> Thanks,
> Fan
> 
> >  
> > > ---
> > >  hw/mem/cxl_type3.c          | 155 ++++++++++++++++++++++++++++++++++++
> > >  include/hw/cxl/cxl_device.h |   1 +
> > >  2 files changed, 156 insertions(+)
> > >
> > > diff --git a/hw/mem/cxl_type3.c b/hw/mem/cxl_type3.c
> > > index 41a828598a..51943a36fc 100644
> > > --- a/hw/mem/cxl_type3.c
> > > +++ b/hw/mem/cxl_type3.c
> > > @@ -787,13 +787,37 @@ static int cxl_create_dc_regions(CXLType3Dev *ct3d)
> > >          /* dsmad_handle is set when creating cdat table entries */
> > >          region->flags = 0;
> > >
> > > +        region->blk_bitmap = bitmap_new(region->len / region->block_size);  
> >
> > In common with many allocators in qemu if this fails it calls abort()
> > internally so no need to handle potential errors.
> >  
> > > +        if (!region->blk_bitmap) {
> > > +            break;
> > > +        }
> > > +
> > >          region_base += region->len;
> > >      }
> > > +
> > > +    if (i < ct3d->dc.num_regions) {
> > > +        while (--i >= 0) {
> > > +            g_free(ct3d->dc.regions[i].blk_bitmap);
> > > +        }
> > > +        return -1;
> > > +    }
> > > +
> > >      QTAILQ_INIT(&ct3d->dc.extents);
> > >
> > >      return 0;
> > >  }
> > >
> > > +static void cxl_destroy_dc_regions(CXLType3Dev *ct3d)
> > > +{
> > > +    int i;
> > > +    struct CXLDCD_Region *region;
> > > +
> > > +    for (i = 0; i < ct3d->dc.num_regions; i++) {
> > > +        region = &ct3d->dc.regions[i];
> > > +        g_free(region->blk_bitmap);
> > > +    }
> > > +}
> > > +
> > >  static bool cxl_setup_memory(CXLType3Dev *ct3d, Error **errp)
> > >  {
> > >      DeviceState *ds = DEVICE(ct3d);
> > > @@ -1021,6 +1045,7 @@ err_free_special_ops:
> > >      g_free(regs->special_ops);
> > >  err_address_space_free:
> > >      if (ct3d->dc.host_dc) {
> > > +        cxl_destroy_dc_regions(ct3d);
> > >          address_space_destroy(&ct3d->dc.host_dc_as);
> > >      }
> > >      if (ct3d->hostpmem) {
> > > @@ -1043,6 +1068,7 @@ static void ct3_exit(PCIDevice *pci_dev)
> > >      spdm_sock_fini(ct3d->doe_spdm.socket);
> > >      g_free(regs->special_ops);
> > >      if (ct3d->dc.host_dc) {
> > > +        cxl_destroy_dc_regions(ct3d);
> > >          address_space_destroy(&ct3d->dc.host_dc_as);
> > >      }
> > >      if (ct3d->hostpmem) {
> > > @@ -1053,6 +1079,110 @@ static void ct3_exit(PCIDevice *pci_dev)
> > >      }
> > >  }
> > >
> > > +/*
> > > + * This function will marked the dpa range [dpa, dap + len) to be backed and
> > > + * accessible, this happens when a dc extent is added and accepted by the
> > > + * host.
> > > + */
> > > +static void set_region_block_backed(CXLType3Dev *ct3d, uint64_t dpa,
> > > +        uint64_t len)
> > > +{
> > > +    int i;
> > > +    CXLDCD_Region *region = &ct3d->dc.regions[0];
> > > +
> > > +    if (dpa < region->base
> > > +            || dpa >= region->base + ct3d->dc.total_capacity)
> > > +        return;
> > > +
> > > +    /*
> > > +     * spec 3.0 9.13.3: Regions are used in increasing-DPA order, with
> > > +     * Region 0 being used for the lowest DPA of Dynamic Capacity and
> > > +     * Region 7 for the highest DPA.
> > > +     * So we check from the last region to find where the dpa belongs.
> > > +     * access across multiple regions is not allowed.
> > > +     **/
> > > +    for (i = ct3d->dc.num_regions - 1; i >= 0; i--) {
> > > +        region = &ct3d->dc.regions[i];
> > > +        if (dpa >= region->base) {
> > > +            break;
> > > +        }
> > > +    }
> > > +
> > > +    bitmap_set(region->blk_bitmap, (dpa - region->base) / region->block_size,
> > > +            len / region->block_size);
> > > +}
> > > +
> > > +/*
> > > + * This function check whether a dpa range [dpa, dpa + len) has been backed
> > > + * with dc extents, used when validating read/write to dc regions
> > > + */
> > > +static bool test_region_block_backed(CXLType3Dev *ct3d, uint64_t dpa,
> > > +        uint64_t len)
> > > +{
> > > +    int i;
> > > +    CXLDCD_Region *region = &ct3d->dc.regions[0];
> > > +    uint64_t nbits;
> > > +    long nr;
> > > +
> > > +    if (dpa < region->base
> > > +            || dpa >= region->base + ct3d->dc.total_capacity)
> > > +        return false;
> > > +
> > > +    /*
> > > +     * spec 3.0 9.13.3: Regions are used in increasing-DPA order, with
> > > +     * Region 0 being used for the lowest DPA of Dynamic Capacity and
> > > +     * Region 7 for the highest DPA.
> > > +     * So we check from the last region to find where the dpa belongs.
> > > +     * access across multiple regions is not allowed.
> > > +     */
> > > +    for (i = ct3d->dc.num_regions - 1; i >= 0; i--) {
> > > +        region = &ct3d->dc.regions[i];
> > > +        if (dpa >= region->base) {
> > > +            break;
> > > +        }
> > > +    }
> > > +
> > > +    nr = (dpa - region->base) / region->block_size;
> > > +    nbits = len / region->block_size;
> > > +    return find_next_zero_bit(region->blk_bitmap, nbits, nr) >= nr + nbits;
> > > +}
> > > +
> > > +/*
> > > + * This function will marked the dpa range [dpa, dap + len) to be unbacked and
> > > + * inaccessible, this happens when a dc extent is added and accepted by the
> > > + * host.
> > > + */
> > > +static void clear_region_block_backed(CXLType3Dev *ct3d, uint64_t dpa,
> > > +        uint64_t len)
> > > +{
> > > +    int i;
> > > +    CXLDCD_Region *region = &ct3d->dc.regions[0];
> > > +    uint64_t nbits;
> > > +    long nr;
> > > +
> > > +    if (dpa < region->base
> > > +            || dpa >= region->base + ct3d->dc.total_capacity)
> > > +        return;
> > > +
> > > +    /*
> > > +     * spec 3.0 9.13.3: Regions are used in increasing-DPA order, with
> > > +     * Region 0 being used for the lowest DPA of Dynamic Capacity and
> > > +     * Region 7 for the highest DPA.
> > > +     * So we check from the last region to find where the dpa belongs.
> > > +     * access across multiple regions is not allowed.
> > > +     */
> > > +    for (i = ct3d->dc.num_regions - 1; i >= 0; i--) {
> > > +        region = &ct3d->dc.regions[i];
> > > +        if (dpa >= region->base) {
> > > +            break;
> > > +        }
> > > +    }
> > > +
> > > +    nr = (dpa - region->base) / region->block_size;
> > > +    nbits = len / region->block_size;
> > > +    bitmap_clear(region->blk_bitmap, nr, nbits);
> > > +}
> > > +
> > >  static bool cxl_type3_dpa(CXLType3Dev *ct3d, hwaddr host_addr, uint64_t *dpa)
> > >  {
> > >      uint32_t *cache_mem = ct3d->cxl_cstate.crb.cache_mem_registers;
> > > @@ -1145,6 +1275,10 @@ static int cxl_type3_hpa_to_as_and_dpa(CXLType3Dev *ct3d,
> > >          *as = &ct3d->hostpmem_as;
> > >          *dpa_offset -= vmr_size;
> > >      } else {
> > > +        if (!test_region_block_backed(ct3d, *dpa_offset, size)) {
> > > +            return -ENODEV;
> > > +        }
> > > +
> > >          *as = &ct3d->dc.host_dc_as;
> > >          *dpa_offset -= (vmr_size + pmr_size);
> > >      }
> > > @@ -1944,6 +2078,27 @@ static void qmp_cxl_process_dynamic_capacity_event(const char *path,
> > >      }
> > >
> > >      g_free(extents);
> > > +
> > > +    /* Another choice is to do the set/clear after getting mailbox response*/
> > > +    list = records;
> > > +    while (list) {
> > > +        dpa = list->value->dpa * 1024 * 1024;
> > > +        len = list->value->len * 1024 * 1024;
> > > +        rid = list->value->region_id;
> > > +
> > > +        switch (type) {
> > > +        case DC_EVENT_ADD_CAPACITY:
> > > +            set_region_block_backed(dcd, dpa, len);
> > > +            break;
> > > +        case DC_EVENT_RELEASE_CAPACITY:
> > > +            clear_region_block_backed(dcd, dpa, len);
> > > +            break;
> > > +        default:
> > > +            error_setg(errp, "DC event type not handled yet");
> > > +            break;
> > > +        }
> > > +        list = list->next;
> > > +    }
> > >  }
> > >
> > >  void qmp_cxl_add_dynamic_capacity_event(const char *path,
> > > diff --git a/include/hw/cxl/cxl_device.h b/include/hw/cxl/cxl_device.h
> > > index 01a5eaca48..1f85c88017 100644
> > > --- a/include/hw/cxl/cxl_device.h
> > > +++ b/include/hw/cxl/cxl_device.h
> > > @@ -412,6 +412,7 @@ typedef struct CXLDCD_Region {
> > >      uint64_t block_size;
> > >      uint32_t dsmadhandle;
> > >      uint8_t flags;
> > > +    unsigned long *blk_bitmap;
> > >  } CXLDCD_Region;
> > >
> > >  struct CXLType3Dev {  
> >  


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 36DC3C3DA66
	for <linux-cxl@archiver.kernel.org>; Fri, 25 Aug 2023 16:37:49 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1344023AbjHYQhT (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Fri, 25 Aug 2023 12:37:19 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:57402 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1344014AbjHYQgq (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Fri, 25 Aug 2023 12:36:46 -0400
Received: from mout.gmx.net (mout.gmx.net [212.227.17.20])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 9C05F1991
        for <linux-cxl@vger.kernel.org>; Fri, 25 Aug 2023 09:36:43 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=gmx.us;
 s=s31663417; t=1692981310; x=1693586110; i=fan.ni@gmx.us;
 bh=833F+CkwYAofFw4YYRSOBwzeI6Gm3qodAYkD5TIPTro=;
 h=X-UI-Sender-Class:Date:From:To:Cc:Subject:References:In-Reply-To;
 b=N2Ejh1IKRhZm0wEgEdi2gciYsXJ8gf/y6vARShoMJusv30ImmqBhWqy5z/sqXOGIjGyqj2v
 2VNG8vrXlmLq5qjxQAW+mavJsw7c8rjBRV6vrbSv1/MOyO+ezimydoU1jKmWCjgLmJGtLmktT
 lb8dJRv/zxnYnmSQn7CoaicfFQAZvSirioe0Uf0aA8jJBzsiNPiSHpduqYb7xDUP1HZS2N6XK
 RE72KrfrgNeB3CzguM4RMueKbe4iDcxzUilQ2V5Knq3dKmuvI0AtFJ93PVIJWqe6keFjxb/bT
 iJo9EaoRJnCNo5KUg7NUOLZCIQLi+ePue38B2kkaQ2USrZIaQb2A==
X-UI-Sender-Class: 724b4f7f-cbec-4199-ad4e-598c01a50d3a
Received: from debian ([99.13.228.231]) by mail.gmx.net (mrgmx104
 [212.227.17.174]) with ESMTPSA (Nemesis) id 1MryXN-1pxEs43TDp-00o1Gb; Fri, 25
 Aug 2023 18:35:10 +0200
Date: Fri, 25 Aug 2023 09:34:50 -0700
From: Fan Ni <fan.ni@gmx.us>
To: Jonathan Cameron <Jonathan.Cameron@huawei.com>
Cc: Fan Ni <fan.ni@samsung.com>,
        "qemu-devel@nongnu.org" <qemu-devel@nongnu.org>,
        "linux-cxl@vger.kernel.org" <linux-cxl@vger.kernel.org>,
        "gregory.price@memverge.com" <gregory.price@memverge.com>,
        "hchkuo@avery-design.com.tw" <hchkuo@avery-design.com.tw>,
        "cbrowy@avery-design.com" <cbrowy@avery-design.com>,
        "ira.weiny@intel.com" <ira.weiny@intel.com>,
        "dan.j.williams@intel.com" <dan.j.williams@intel.com>,
        Adam Manzanares <a.manzanares@samsung.com>,
        "dave@stgolabs.net" <dave@stgolabs.net>,
        "nmtadam.samsung@gmail.com" <nmtadam.samsung@gmail.com>,
        "nifan@outlook.com" <nifan@outlook.com>
Subject: Re: [Qemu PATCH v2 9/9] hw/mem/cxl_type3: Add dpa range validation
 for accesses to dc regions
Message-ID: <ZOjYKq+vDMIdFEl7@debian>
References: <20230725183939.2741025-1-fan.ni@samsung.com>
 <CGME20230725183957uscas1p2ca5293c7229ab989ad1a2d95395436a6@uscas1p2.samsung.com>
 <20230725183939.2741025-10-fan.ni@samsung.com>
 <20230807095342.00006f88@Huawei.com>
 <ZOfCPADXcYMGIGC4@debian>
 <20230825124256.0000604c@Huawei.com>
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: <20230825124256.0000604c@Huawei.com>
X-Provags-ID: V03:K1:GUwe59V/6OuK2RkHi4d6cpt1mbnbiLUJkSPN6EjN7+Zf+Puree/
 Du1nP7apcZg+7jI+yqee+Cs8hs5MySxYyvwunU0URTsmf/URvDPkpz4tss8JojXaEc2ucjc
 oV4EeUIZgXiUQMqE2ebvJE1wI9LHVJ1xcIiyg7GQ3syDsX80viowNySij36Mf57pLmHO2f7
 j2i+SbZ3JSjNZLcC+zbmQ==
UI-OutboundReport: notjunk:1;M01:P0:cHA8VV+7+bk=;yzpiO6uS5yusvVMFckfTxHWHGV/
 UXvrugLHR2+zuQsLx/alNDI99neV2mtr02JBXnaA/O9i15PmOJIUjXhLCL5Le5tA9kr9ybkq0
 pyrkTsHj679cq0izl448Pe9uX9nmsmJEcGSujyyF9ZJNhDDBeq63eO/iyQDl9CHzGij/8XetI
 LuEj7SzAjIGkppOVsp06Xv481evzJZR8ttgbGcI2cMlboerE67GcPkZlGnGrRHhs+XGijmr3K
 +yfKTv+a/gEibZFHt5+g/FPexpPzsQV8MKjy4s3CzZEy2LGeaOROtWQIUfM08WN5HlJf9YYRP
 Rux/3xK/uDS6eA5V7HnuLmgjMm+HLufQPfB2sgjyt7w1xS0vx0KDgendMHV745gGFbm5luGTo
 B30WZCHQhVpqlk/3gb+5iL1YU3/EC3BNx46JssEEcim0+ZlQvTe9oeG/h+x3njmYFVWdZGcU8
 uKpF85S9gYC+mVqBVFud+txDfGYXO9d97p+I2u7HpoJlXLd/UkRs+stkpP6WZ95zjCvu+E6CU
 6LS+xCCgKYt5/sW+oQNh8qXyY+t9oJp4jVSQ1ApsO3cMILe8cfwR8NhsUVphiIDSNTcsOmuzA
 UFWCB58NypB31dHl/Ut6hhRmI8ClSWYTeCc2u8DrvZ4FMkZVb5Swp400Cnug6VVJU4gLGuPwK
 qF1fmoXQFlJKUJX64NmqG8MjFa58pNtcntf0WGumcZg/NHkO6Y7+Ebdt759FWuIECOEGPIKpl
 8/YE4g8twKyTQaUo1BEQNuQhy2YfCKlYflBrMkX0IiNj0yC53c/lkYZzhJ+fervKb++nUuaDP
 tID0Hu834f0b7kaDZ7alhv+5/khBsT7AP4h7dRB3kF9dF7vg2wWf/49y71HeWsA/HEES8Wu6v
 yr/P2+EjAGlSrGdMxvEeo8xPqVAz7UhiSiFe3xXJbYiges9duvw5fMsmkTRaoOSA614XVc3nH
 2Km/rBL+Ggw3U3uzIdo3mPYXS+Q=
Content-Transfer-Encoding: quoted-printable
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

On Fri, Aug 25, 2023 at 12:42:56PM +0100, Jonathan Cameron wrote:
> On Thu, 24 Aug 2023 13:49:00 -0700
> Fan Ni <fan.ni@gmx.us> wrote:
>
> > On Mon, Aug 07, 2023 at 09:53:42AM +0100, Jonathan Cameron wrote:
> > > On Tue, 25 Jul 2023 18:39:56 +0000
> > > Fan Ni <fan.ni@samsung.com> wrote:
> > >
> > > > From: Fan Ni <nifan@outlook.com>
> > > >
> > > > Not all dpa range in the dc regions is valid to access until an ex=
tent
> > > > covering the range has been added. Add a bitmap for each region to
> > > > record whether a dc block in the region has been backed by dc exte=
nt.
> > > > For the bitmap, a bit in the bitmap represents a dc block. When a =
dc
> > > > extent is added, all the bits of the blocks in the extent will be =
set,
> > > > which will be cleared when the extent is released.
> > > >
> > > > Signed-off-by: Fan Ni <fan.ni@samsung.com>
> > > Hi Fan,
> > >
> > > A few of the bits of feedback apply broadly across the series.  Give=
n I'm
> > > rebasing this anyway to give myself something to test I'll tidy thin=
gs up
> > > (feel free to disagree with and revert any changes !)
> > > and push a tree out in next day or two.  I'll message when I've done=
 so.
> > >
> > > Jonathan
> >
> > Hi Jonathan,
> > I tried DCD with your branch "cxl-2023-08-07", and noticed the
> > following,
> > 1. You made some changes to the bitmap functionality, now it is only
> > used to validate extents when adding/releasing dc extents. My original
> > thought of adding the bitmap is to 1) validating extents for extent
> > add/release as you do; 2) Add validating when doing read/write to the =
dc
> > regions since some address region may not have valid extent added yet.
> > Do you think 2) is not necessary?
>
> Change wasn't intentional. I probably just messed up the rebase!

Just double checked the code. The logic is still there, but in another
patch in the series, so no issue and ignore my previous question.
Sorry for the confusion.

>
> >
> > 2. Your change introduced a bug in the code.
> > https://gitlab.com/jic23/qemu/-/blob/cxl-2023-08-07/hw/cxl/cxl-mailbox=
-utils.c?ref_type=3Dheads#L1394
> > ct3d->dc.num_regions should be ct3d->dc.num_regions-1.
> Thanks.  Given I might forget about about it, if you want to incorporate=
 that in
> your next version that would be great. I might remember to fix it in the=
 meantime!
>
> Jonathan
>

My code does not have this. It seems you added the lastregion variable
to record the last region, while I use the following logic to iterate
the regions and record last region automatically while collecting
min_block_size.

+    for (i =3D 1; i < dev->dc.num_regions; i++) {
+        region =3D &dev->dc.regions[i];
+        if (min_block_size > region->block_size) {
+            min_block_size =3D region->block_size;
+        }
+    }
+
+    blk_bitmap =3D bitmap_new((region->len + region->base
+                - dev->dc.regions[0].base) / min_block_size);


Fan

> >
> > Thanks,
> > Fan
> >
> > >
> > > > ---
> > > >  hw/mem/cxl_type3.c          | 155 +++++++++++++++++++++++++++++++=
+++++
> > > >  include/hw/cxl/cxl_device.h |   1 +
> > > >  2 files changed, 156 insertions(+)
> > > >
> > > > diff --git a/hw/mem/cxl_type3.c b/hw/mem/cxl_type3.c
> > > > index 41a828598a..51943a36fc 100644
> > > > --- a/hw/mem/cxl_type3.c
> > > > +++ b/hw/mem/cxl_type3.c
> > > > @@ -787,13 +787,37 @@ static int cxl_create_dc_regions(CXLType3Dev=
 *ct3d)
> > > >          /* dsmad_handle is set when creating cdat table entries *=
/
> > > >          region->flags =3D 0;
> > > >
> > > > +        region->blk_bitmap =3D bitmap_new(region->len / region->b=
lock_size);
> > >
> > > In common with many allocators in qemu if this fails it calls abort(=
)
> > > internally so no need to handle potential errors.
> > >
> > > > +        if (!region->blk_bitmap) {
> > > > +            break;
> > > > +        }
> > > > +
> > > >          region_base +=3D region->len;
> > > >      }
> > > > +
> > > > +    if (i < ct3d->dc.num_regions) {
> > > > +        while (--i >=3D 0) {
> > > > +            g_free(ct3d->dc.regions[i].blk_bitmap);
> > > > +        }
> > > > +        return -1;
> > > > +    }
> > > > +
> > > >      QTAILQ_INIT(&ct3d->dc.extents);
> > > >
> > > >      return 0;
> > > >  }
> > > >
> > > > +static void cxl_destroy_dc_regions(CXLType3Dev *ct3d)
> > > > +{
> > > > +    int i;
> > > > +    struct CXLDCD_Region *region;
> > > > +
> > > > +    for (i =3D 0; i < ct3d->dc.num_regions; i++) {
> > > > +        region =3D &ct3d->dc.regions[i];
> > > > +        g_free(region->blk_bitmap);
> > > > +    }
> > > > +}
> > > > +
> > > >  static bool cxl_setup_memory(CXLType3Dev *ct3d, Error **errp)
> > > >  {
> > > >      DeviceState *ds =3D DEVICE(ct3d);
> > > > @@ -1021,6 +1045,7 @@ err_free_special_ops:
> > > >      g_free(regs->special_ops);
> > > >  err_address_space_free:
> > > >      if (ct3d->dc.host_dc) {
> > > > +        cxl_destroy_dc_regions(ct3d);
> > > >          address_space_destroy(&ct3d->dc.host_dc_as);
> > > >      }
> > > >      if (ct3d->hostpmem) {
> > > > @@ -1043,6 +1068,7 @@ static void ct3_exit(PCIDevice *pci_dev)
> > > >      spdm_sock_fini(ct3d->doe_spdm.socket);
> > > >      g_free(regs->special_ops);
> > > >      if (ct3d->dc.host_dc) {
> > > > +        cxl_destroy_dc_regions(ct3d);
> > > >          address_space_destroy(&ct3d->dc.host_dc_as);
> > > >      }
> > > >      if (ct3d->hostpmem) {
> > > > @@ -1053,6 +1079,110 @@ static void ct3_exit(PCIDevice *pci_dev)
> > > >      }
> > > >  }
> > > >
> > > > +/*
> > > > + * This function will marked the dpa range [dpa, dap + len) to be=
 backed and
> > > > + * accessible, this happens when a dc extent is added and accepte=
d by the
> > > > + * host.
> > > > + */
> > > > +static void set_region_block_backed(CXLType3Dev *ct3d, uint64_t d=
pa,
> > > > +        uint64_t len)
> > > > +{
> > > > +    int i;
> > > > +    CXLDCD_Region *region =3D &ct3d->dc.regions[0];
> > > > +
> > > > +    if (dpa < region->base
> > > > +            || dpa >=3D region->base + ct3d->dc.total_capacity)
> > > > +        return;
> > > > +
> > > > +    /*
> > > > +     * spec 3.0 9.13.3: Regions are used in increasing-DPA order,=
 with
> > > > +     * Region 0 being used for the lowest DPA of Dynamic Capacity=
 and
> > > > +     * Region 7 for the highest DPA.
> > > > +     * So we check from the last region to find where the dpa bel=
ongs.
> > > > +     * access across multiple regions is not allowed.
> > > > +     **/
> > > > +    for (i =3D ct3d->dc.num_regions - 1; i >=3D 0; i--) {
> > > > +        region =3D &ct3d->dc.regions[i];
> > > > +        if (dpa >=3D region->base) {
> > > > +            break;
> > > > +        }
> > > > +    }
> > > > +
> > > > +    bitmap_set(region->blk_bitmap, (dpa - region->base) / region-=
>block_size,
> > > > +            len / region->block_size);
> > > > +}
> > > > +
> > > > +/*
> > > > + * This function check whether a dpa range [dpa, dpa + len) has b=
een backed
> > > > + * with dc extents, used when validating read/write to dc regions
> > > > + */
> > > > +static bool test_region_block_backed(CXLType3Dev *ct3d, uint64_t =
dpa,
> > > > +        uint64_t len)
> > > > +{
> > > > +    int i;
> > > > +    CXLDCD_Region *region =3D &ct3d->dc.regions[0];
> > > > +    uint64_t nbits;
> > > > +    long nr;
> > > > +
> > > > +    if (dpa < region->base
> > > > +            || dpa >=3D region->base + ct3d->dc.total_capacity)
> > > > +        return false;
> > > > +
> > > > +    /*
> > > > +     * spec 3.0 9.13.3: Regions are used in increasing-DPA order,=
 with
> > > > +     * Region 0 being used for the lowest DPA of Dynamic Capacity=
 and
> > > > +     * Region 7 for the highest DPA.
> > > > +     * So we check from the last region to find where the dpa bel=
ongs.
> > > > +     * access across multiple regions is not allowed.
> > > > +     */
> > > > +    for (i =3D ct3d->dc.num_regions - 1; i >=3D 0; i--) {
> > > > +        region =3D &ct3d->dc.regions[i];
> > > > +        if (dpa >=3D region->base) {
> > > > +            break;
> > > > +        }
> > > > +    }
> > > > +
> > > > +    nr =3D (dpa - region->base) / region->block_size;
> > > > +    nbits =3D len / region->block_size;
> > > > +    return find_next_zero_bit(region->blk_bitmap, nbits, nr) >=3D=
 nr + nbits;
> > > > +}
> > > > +
> > > > +/*
> > > > + * This function will marked the dpa range [dpa, dap + len) to be=
 unbacked and
> > > > + * inaccessible, this happens when a dc extent is added and accep=
ted by the
> > > > + * host.
> > > > + */
> > > > +static void clear_region_block_backed(CXLType3Dev *ct3d, uint64_t=
 dpa,
> > > > +        uint64_t len)
> > > > +{
> > > > +    int i;
> > > > +    CXLDCD_Region *region =3D &ct3d->dc.regions[0];
> > > > +    uint64_t nbits;
> > > > +    long nr;
> > > > +
> > > > +    if (dpa < region->base
> > > > +            || dpa >=3D region->base + ct3d->dc.total_capacity)
> > > > +        return;
> > > > +
> > > > +    /*
> > > > +     * spec 3.0 9.13.3: Regions are used in increasing-DPA order,=
 with
> > > > +     * Region 0 being used for the lowest DPA of Dynamic Capacity=
 and
> > > > +     * Region 7 for the highest DPA.
> > > > +     * So we check from the last region to find where the dpa bel=
ongs.
> > > > +     * access across multiple regions is not allowed.
> > > > +     */
> > > > +    for (i =3D ct3d->dc.num_regions - 1; i >=3D 0; i--) {
> > > > +        region =3D &ct3d->dc.regions[i];
> > > > +        if (dpa >=3D region->base) {
> > > > +            break;
> > > > +        }
> > > > +    }
> > > > +
> > > > +    nr =3D (dpa - region->base) / region->block_size;
> > > > +    nbits =3D len / region->block_size;
> > > > +    bitmap_clear(region->blk_bitmap, nr, nbits);
> > > > +}
> > > > +
> > > >  static bool cxl_type3_dpa(CXLType3Dev *ct3d, hwaddr host_addr, ui=
nt64_t *dpa)
> > > >  {
> > > >      uint32_t *cache_mem =3D ct3d->cxl_cstate.crb.cache_mem_regist=
ers;
> > > > @@ -1145,6 +1275,10 @@ static int cxl_type3_hpa_to_as_and_dpa(CXLT=
ype3Dev *ct3d,
> > > >          *as =3D &ct3d->hostpmem_as;
> > > >          *dpa_offset -=3D vmr_size;
> > > >      } else {
> > > > +        if (!test_region_block_backed(ct3d, *dpa_offset, size)) {
> > > > +            return -ENODEV;
> > > > +        }
> > > > +
> > > >          *as =3D &ct3d->dc.host_dc_as;
> > > >          *dpa_offset -=3D (vmr_size + pmr_size);
> > > >      }
> > > > @@ -1944,6 +2078,27 @@ static void qmp_cxl_process_dynamic_capacit=
y_event(const char *path,
> > > >      }
> > > >
> > > >      g_free(extents);
> > > > +
> > > > +    /* Another choice is to do the set/clear after getting mailbo=
x response*/
> > > > +    list =3D records;
> > > > +    while (list) {
> > > > +        dpa =3D list->value->dpa * 1024 * 1024;
> > > > +        len =3D list->value->len * 1024 * 1024;
> > > > +        rid =3D list->value->region_id;
> > > > +
> > > > +        switch (type) {
> > > > +        case DC_EVENT_ADD_CAPACITY:
> > > > +            set_region_block_backed(dcd, dpa, len);
> > > > +            break;
> > > > +        case DC_EVENT_RELEASE_CAPACITY:
> > > > +            clear_region_block_backed(dcd, dpa, len);
> > > > +            break;
> > > > +        default:
> > > > +            error_setg(errp, "DC event type not handled yet");
> > > > +            break;
> > > > +        }
> > > > +        list =3D list->next;
> > > > +    }
> > > >  }
> > > >
> > > >  void qmp_cxl_add_dynamic_capacity_event(const char *path,
> > > > diff --git a/include/hw/cxl/cxl_device.h b/include/hw/cxl/cxl_devi=
ce.h
> > > > index 01a5eaca48..1f85c88017 100644
> > > > --- a/include/hw/cxl/cxl_device.h
> > > > +++ b/include/hw/cxl/cxl_device.h
> > > > @@ -412,6 +412,7 @@ typedef struct CXLDCD_Region {
> > > >      uint64_t block_size;
> > > >      uint32_t dsmadhandle;
> > > >      uint8_t flags;
> > > > +    unsigned long *blk_bitmap;
> > > >  } CXLDCD_Region;
> > > >
> > > >  struct CXLType3Dev {
> > >
>

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 43800C6FA8F
	for <linux-cxl@archiver.kernel.org>; Wed, 30 Aug 2023 18:54:12 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S244284AbjH3Sw4 (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Wed, 30 Aug 2023 14:52:56 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:41108 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S243891AbjH3MIW (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Wed, 30 Aug 2023 08:08:22 -0400
Received: from esa4.hgst.iphmx.com (esa4.hgst.iphmx.com [216.71.154.42])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id BC5121B0
        for <linux-cxl@vger.kernel.org>; Wed, 30 Aug 2023 05:08:19 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=simple/simple;
  d=wdc.com; i=@wdc.com; q=dns/txt; s=dkim.wdc.com;
  t=1693397299; x=1724933299;
  h=from:to:cc:subject:date:message-id:references:
   in-reply-to:content-id:content-transfer-encoding:
   mime-version;
  bh=XSyIBuIEi0ENGGXAnaMGUTf6M9NbpNZVNQQbZgrhj0w=;
  b=NDQ5P7WR9Qnb7AeSP4RsIEbT1KixxgFLGeBE4tzkuE1jzbLEdHQr3GtY
   y/zeftYkPy1WxKILLCc5dAxOENcnQnV3F7P/3Ox/FV5G1scbZXmAY2PE5
   mQui7RthgoA2a7R3rIaLbIfixWe1Le0Le1OAD3ei6iT24LTzFWPEAgIcc
   W7vu03MZ3E/yTfTwfe//0af2MJetX8X1mm5YSYYjj4cnOjdTuPzNKcNPN
   urxN+p7YqNVzZbK9ACHOa7hY2EttOlFta8fMcS0kqp0Wt9C1w+glKFJs7
   BeGucMmieEjyAvX2KQrToLuhJqaOwbSsP/u0R7oRU6qpb+f21zNXDP9mr
   g==;
X-IronPort-AV: E=Sophos;i="6.02,213,1688400000"; 
   d="scan'208";a="240760636"
Received: from mail-dm6nam10lp2107.outbound.protection.outlook.com (HELO NAM10-DM6-obe.outbound.protection.outlook.com) ([104.47.58.107])
  by ob1.hgst.iphmx.com with ESMTP; 30 Aug 2023 20:08:15 +0800
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=O/ucrV6tF6Ovi7R6efUZff29v1qovqqf75FxWMaRdq6nNNXdePV/m27aulv6H+rpim8PAT2PIp4Of7A8VYdy76ZYXAOwKy2VujZX+GGGQCN8soPiGI2W8ME25T1YnnjUoRvqISs+zXyPYop3h0rlaHZoGWgayeHfgQj7Zb9YNAn2VLudzd9tW3D5kQqTsZtuLUP0ZYTzMU889JvgkB8xQs9R8hW4P5b0Mvfar8iKeNZ7N5nki1t848cOsa+k66kAS390LMy+QFREcvqi4tyn/pPmSc6sjbdmce9rW7mlyp0pDBDBkkXQtOfnZCWQ4pdykQMDi9WJ/+Edz72YtkU99g==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=XSyIBuIEi0ENGGXAnaMGUTf6M9NbpNZVNQQbZgrhj0w=;
 b=OSwKMh9msVFOhC1mtZDFKW/RPn+47k6Zdyjw548UTh/nuTW4us1DCeqgoPPuAUiApTvil+wF8q2gUTahLBQ0KvLbZZ3t3cFKONidS/VH9hte9G9On02oEpr+zDoimJkJr7os4x+y2aAcM8KbRvodjwZffyCxjzOdIzWAE8xpu7ELSumM6UzwKzbpSqgEsQa/Usw09KUBvSIQRypBPyM6X8t5VxUJ7fEngbyqpJnMxLRXOxXOndx96qsXX2LrIPnliC0om+stWh2slUsemCEkET7j9uWN0ckKS1KgsGk/1GBlsGF2jus/wecGptAzsaXTeYn1GDLordH1S4vqeH032w==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=wdc.com; dmarc=pass action=none header.from=wdc.com; dkim=pass
 header.d=wdc.com; arc=none
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
 d=sharedspace.onmicrosoft.com; s=selector2-sharedspace-onmicrosoft-com;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-SenderADCheck;
 bh=XSyIBuIEi0ENGGXAnaMGUTf6M9NbpNZVNQQbZgrhj0w=;
 b=QduVPsiSyz8r3rJntt1g8gVAUwMplPn1x3Kk2eBtbV4lUynZizwVJ1xgg0vgARaTBpBOUNjby2bqYLBX0MIG8xBWM+PYP5orPa1HU4pTIx9osh2v1GTW+IoB5sRara92nUUVE8lGfhjSNpgR50zq7ZKih3R1XeIs6x6hl/ijwxs=
Received: from SN4PR0401MB3582.namprd04.prod.outlook.com
 (2603:10b6:803:4c::10) by SA0PR04MB7433.namprd04.prod.outlook.com
 (2603:10b6:806:e2::8) with Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.6745.21; Wed, 30 Aug
 2023 12:08:14 +0000
Received: from SN4PR0401MB3582.namprd04.prod.outlook.com
 ([fe80::deb2:d582:29a5:b583]) by SN4PR0401MB3582.namprd04.prod.outlook.com
 ([fe80::deb2:d582:29a5:b583%4]) with mapi id 15.20.6723.020; Wed, 30 Aug 2023
 12:08:14 +0000
From: =?utf-8?B?SsO4cmdlbiBIYW5zZW4=?= <Jorgen.Hansen@wdc.com>
To: Fan Ni <fan.ni@samsung.com>,
        "qemu-devel@nongnu.org" <qemu-devel@nongnu.org>
CC: "jonathan.cameron@huawei.com" <jonathan.cameron@huawei.com>,
        "linux-cxl@vger.kernel.org" <linux-cxl@vger.kernel.org>,
        "gregory.price@memverge.com" <gregory.price@memverge.com>,
        "hchkuo@avery-design.com.tw" <hchkuo@avery-design.com.tw>,
        "cbrowy@avery-design.com" <cbrowy@avery-design.com>,
        "ira.weiny@intel.com" <ira.weiny@intel.com>,
        "dan.j.williams@intel.com" <dan.j.williams@intel.com>,
        Adam Manzanares <a.manzanares@samsung.com>,
        "dave@stgolabs.net" <dave@stgolabs.net>,
        "nmtadam.samsung@gmail.com" <nmtadam.samsung@gmail.com>,
        "nifan@outlook.com" <nifan@outlook.com>
Subject: Re: [Qemu PATCH v2 9/9] hw/mem/cxl_type3: Add dpa range validation
 for accesses to dc regions
Thread-Topic: [Qemu PATCH v2 9/9] hw/mem/cxl_type3: Add dpa range validation
 for accesses to dc regions
Thread-Index: AQHZvydoZ/a421rE4EydfsE7dZC6xbAC9vUA
Date: Wed, 30 Aug 2023 12:08:14 +0000
Message-ID: <d0d7ca1d-81bc-19b3-4904-d60046ded844@wdc.com>
References: <20230725183939.2741025-1-fan.ni@samsung.com>
 <CGME20230725183957uscas1p2ca5293c7229ab989ad1a2d95395436a6@uscas1p2.samsung.com>
 <20230725183939.2741025-10-fan.ni@samsung.com>
In-Reply-To: <20230725183939.2741025-10-fan.ni@samsung.com>
Accept-Language: en-GB, en-US
Content-Language: en-US
X-MS-Has-Attach: 
X-MS-TNEF-Correlator: 
authentication-results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=wdc.com;
x-ms-publictraffictype: Email
x-ms-traffictypediagnostic: SN4PR0401MB3582:EE_|SA0PR04MB7433:EE_
x-ms-office365-filtering-correlation-id: 9627bef0-3146-4f70-0dfb-08dba951c9b0
wdcipoutbound: EOP-TRUE
x-ms-exchange-senderadcheck: 1
x-ms-exchange-antispam-relay: 0
x-microsoft-antispam: BCL:0;
x-microsoft-antispam-message-info: 8jhxEzq/qchpOaDLXL3B8aNb2EVsryRAVrfB9kWINwZ/qon3af72bxRS2Y6dWrT+AbjIPQ91imPV+j43D3aqnho/qNjnlZRAlF2e+pmyvdE8zQoOnAXO5+bAIWeBkMpzDbul/F+vG96cnWZe0GndswrK30Ln8xMFqI9PdcSp++uU1paXB5cmRe77txkkP4vgjdi8zkuWe3CevGGTo53urHIeNEM+uYfX+Da12Unn9a79EW9sRC4bT27NLbuRCmKbq8SzUUvREsCMjauWznDdWsNygBK1a+ho1jWs/UhcRoqxWfV1yq5VUpoyp8Kxl8REmwmbV3//C9ef9HAulw9dX6I1FFDHzGa0MCjRw0bki8JH7d13b9wcmazgg9QHdvpc2J6eDwhmSKwHtBqaqEmervG7dwWu9HEBgtN3T72LOr1FKPOo8ukL/rIGdp1vAMGTsE4oMsTMO3G9ag0HJujDFfT5837h4I+L8DsGBS7jgry6dpUYpi5fgLG4fB/hm/RR8TTO+13NMUd91LvDrVEtqSHUKbRO/c03II0RpArWx3YgHdD+N6NOlOYtKyTIvaq350DmS21PvbFYAoe31e7nTF/nRtSUJYTF8/qRT+mVPQq02hhNCRwSz66M3RXbnJicilufy4bDnbRBl2bwiyryzw==
x-forefront-antispam-report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:SN4PR0401MB3582.namprd04.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230031)(136003)(39860400002)(396003)(346002)(366004)(376002)(451199024)(1800799009)(186009)(6512007)(71200400001)(53546011)(6486002)(6506007)(2616005)(26005)(38100700002)(38070700005)(7416002)(5660300002)(4326008)(86362001)(31696002)(2906002)(8676002)(85202003)(82960400001)(110136005)(41300700001)(85182001)(8936002)(36756003)(66446008)(66476007)(66556008)(64756008)(76116006)(66946007)(54906003)(91956017)(316002)(478600001)(122000001)(83380400001)(31686004)(45980500001);DIR:OUT;SFP:1102;
x-ms-exchange-antispam-messagedata-chunkcount: 1
x-ms-exchange-antispam-messagedata-0: =?utf-8?B?SUIxZCtFQ1Z4LzVobkNVYUMxWWZPdzJtcU5QNk1EVTZEc1B6YVBtT3VVZktv?=
 =?utf-8?B?WVl5d0o0bGNGem5VU0RGaGNUTVVVWlhwVkp5UDVHcTFhanhvbWQ2c0pPaDV0?=
 =?utf-8?B?cmVBa1pvMDZPRndycWNnY0NjYzM3d0RsNGVrOTJsdCsyNkJBTXZEb3U3bWEr?=
 =?utf-8?B?V2ZtMzVEUVNWZFZjMVBlcjlvMzk4SHBCOEU1cENodFVkUGwwdGRCeEJjSUho?=
 =?utf-8?B?RW1YQzNZQ0NwT1Z4amNicXRCTTRhOG9TSGlDWjd2Nk9MQ3lBV3FoK3hWekJP?=
 =?utf-8?B?bFJRVEI1VnBVaXUySzJLc0NoL0FiY3pHRWV0b1p6YWRqSXBTc0FrOS81cE9l?=
 =?utf-8?B?MlhKT2h2MXRWdWhwNHo3UkZmcnl0YXNNRitxVTE0WmZhaU9PMkFSb3ozK1lt?=
 =?utf-8?B?K1hYY0JvWTN4cGI1UXlzQk9QNXBNMyt3djIrdC9hUUpuM2ZsUWh2V2RWUTM3?=
 =?utf-8?B?blA0ZDNDT2l4Mk90Z0dLTDRvTGVuYmZhQStlOGJqYlVHcjJFV1Q0dTFJU2tF?=
 =?utf-8?B?MXBXZCtiZ3B4eS9ncmhtY0FhWk5tZFc1eFkxOXJtRjVETnlVWFp2ZU1qdXF3?=
 =?utf-8?B?RHdYM2NoU2gzUEhvMW05OE8vdWV0T2RxTVRiZEhicHd3YldBazJIWVM3VXZI?=
 =?utf-8?B?bC9CMlF4R3lieFo5aFg2Z0tyOG02Y2lEQTJsLzBpZU1sM1cvRVZCOS82eXNq?=
 =?utf-8?B?WUdtcmpVSU5ZTEtSQ2xVWE5qNnNxR3M0cUU1Q2hCOGpLZTNZbDhIbWN5VzZ3?=
 =?utf-8?B?UDJUYzkzQysrL3FseEVZVllwV0pJVnRwTlE0dG12djNXMzhBVmVYZStPcks4?=
 =?utf-8?B?TUxlSldDLzJWZFo5djZYNlloU2J1dHVhU1FRaXJreGNkV01JTi9PamU0K2o5?=
 =?utf-8?B?Uk81YUtQdkw1U09XM0ErVFROZEh5Q0hHSTFUVXVRNUxLNWlCQ1QxY2dvdDMr?=
 =?utf-8?B?RU9YL2UxWnhvMnF6UEJ6SmEzSVprR3dmeUV2WnNzckRrVS85MDQ3N09pUDlL?=
 =?utf-8?B?TTh1Zk9NME1hUUtZazJuODhaZmh0d3pGdVdQSGxXaGxENFNwOGNFYlBZZE5i?=
 =?utf-8?B?aVVaM2lyaUNMMEowa2gzR05sOWptS2twVTZvQ1VCQ1VDOXMwRTVQcGVsK2F5?=
 =?utf-8?B?eGZJM05YNHBiWFdGSnhsUmFLUDFhWUptcHNrOElSUTB0MGdKcVF2dDRUa2dV?=
 =?utf-8?B?NVRSMDA4aHJXd1NMR1U3cElZYlNIS2hoUHFaL3NmQ3Zqampsb0pCOTNzMW9C?=
 =?utf-8?B?Nkp5UWxVVXNQTFhyR1VOTndlWGJ1YVZGRmlyK2ZJZ2dWVlREemIrdzZFOGNq?=
 =?utf-8?B?cDdJbURiRUFiVlB3QVJyUjRMS2QvS2RjVml2UWNrckRSYUFYdFpIdTU5RW1O?=
 =?utf-8?B?V2NjWU9naGhZc2FLYS8wOGhGVjZkcTRMUEdWMzBQelR5VG9KVDVsSlM4RXBR?=
 =?utf-8?B?VjVpRGNuOGtvRGZ3Y3dxM2F6Q3R2VklUZHA4TmNEUHVmcVFxVG9rRUtjYy9o?=
 =?utf-8?B?QVdBVU5Cc2o1VGVYc2g5SGNuUGdTVnBORFlGZ25EckpBZ2VZanR6aG9wbEVh?=
 =?utf-8?B?LzJWMWhhbithakhSTWM2ZTFLVnZELzQzVXpoUGJ1WWxZcUZhaW9wdE8wTlAz?=
 =?utf-8?B?aitDUHc4SFh0QmJRc0IvSkpnOTFnZ0JzZjN6Wlc0NHhaR3RkYXN4SVU3Qkcx?=
 =?utf-8?B?ZFBGTFBhazZxM1BrMUdZeTlaRlpsaUlkdm43c1dOV0N6TlNtQ21EdUMraThq?=
 =?utf-8?B?RlkzcDQ5WTBsZFgza2JLUThackJCZUJVN2RJTERkZ1Rna21ZbVFqTTA3cmxq?=
 =?utf-8?B?eE5LbjA1U3lvcGQ4SDNHNkt0M05DUUJvVnoxQ0lBcGRPMEw2MUlCVWtlRU1u?=
 =?utf-8?B?RmJLTUlmNm5BaytPWlp4UDBQNUVYZkxCZVNubjM3Nno0RFQ0Q1BhTFNTd2tB?=
 =?utf-8?B?UW8xcUE5S2t2T2VmQnUxWkhJbUIvQkJtWnVFbGlHb3JiZ2NLOEF5cHRGMm1M?=
 =?utf-8?B?a3llR1BVT3FtdUpyZlNqSG8zeEZiaFppNlE0SXZuQnhEek0xRnhCMWhhd0Jq?=
 =?utf-8?B?Y2VsMERtV1JxK1UrUFVSdjdUaU9pU0JEWkE3YlVaMDFIb0lZd2ZqV08wcVZa?=
 =?utf-8?Q?AUFWvukKO59pUThp0HU6DlkiL?=
Content-Type: text/plain; charset="utf-8"
Content-ID: <734B11FD1D33CE4987100D6F12B4E89D@namprd04.prod.outlook.com>
Content-Transfer-Encoding: base64
MIME-Version: 1.0
X-MS-Exchange-AntiSpam-ExternalHop-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-ExternalHop-MessageData-0: =?utf-8?B?RHVGUGdPQXhzZjVsVHVENHZWM2xXT2h4Z1RLcXlKREZyanl3MGgxTEFGNW96?=
 =?utf-8?B?YlYrT2R2MjdhSy8zMjRDS2ZvS3l5UTByd2NtVXFEcUsvR2VQaUhQcHNMcEpO?=
 =?utf-8?B?L1hCanBBNEJaNVVkbmJZQkRIbk9COGNkWmp1QVQ1S0E4ZXo1czY5YUU1SWEz?=
 =?utf-8?B?Y21WeWVDV3ZnVWtWazk4SzVjTS9mMW12OTVrRUhpNzU2SS9HRVFtMmNkSE5D?=
 =?utf-8?B?Y0hld3ZzSjdCcGZaZ0E4UE41Szd0S3p6SDhtYVU3Zlk2eUt0NGpVNW1PT1Bo?=
 =?utf-8?B?UHhFMnhrN0ovWHlXNTQ0cmwrZlkvZDI0SkpDSHZQQ2xlM3BtNHlHNjBvTGsy?=
 =?utf-8?B?a2pRQ3c3RC9KOTdwMU44N2RuNXFiNnNkVU1aSjlYTytmZnBtQVdpbVZmWDlZ?=
 =?utf-8?B?UjVxdmdzK3F3RjZsUm1VM1FzVDNmbXphVHBtVVRQenNvajZjZUdqZ214SHlq?=
 =?utf-8?B?cFNVUTE2QXdPbzVoTkVjejIyTUNJRHBGVzFOcjA2R015QXRRMktqa2puVWNS?=
 =?utf-8?B?YlhzZkFncEloeVRwS0x3NDlCK1BMNVcvUU8zc1c4ZEpvRVlFelRxNnpscnl6?=
 =?utf-8?B?SS9FSU01SkFIeWx1bUYwM3JGZmRPYU85Qk1YdDA1Q21Ib1p6MW1PS2VKVE4v?=
 =?utf-8?B?OTRFblcrelFHb3RwZ09CS1VRZ0g0MXdCaHNPRXNkbEh2d28rekcyakxjSm82?=
 =?utf-8?B?aWxTc2VmVHdrTnZTOTk1VllMUFA3cnZWWGZ2QlFNZmllUWp6cTUvRWZPNDFv?=
 =?utf-8?B?cEZSb1pkL3ZzYWJ2WVVBb3Y4bTVJZ1U2eTFiL2tJeHFpbzlzanEvakp3Umgz?=
 =?utf-8?B?Zmp6eFJtdTFNbUlUMmZUSkxXbVEyYTBTdVJZOHpsa0hXOFFzOHVSckFoTXhj?=
 =?utf-8?B?M3FJSFpHOVpqV2ovSHZ4VmtCWUl2Y0ZwZ3JXblhZb0w0NjdBWEJuUHFiUExK?=
 =?utf-8?B?WEdHRGJmL3Z6TUwyajdHdWdpZ2pjYmYvM0pRRkxFclA5c2FFbFBoVGtpVk1Y?=
 =?utf-8?B?WDhEM0NDZlp1YktSN2s3ZU4rTlZoalFpSkw5OEtublZuWW5DeTBkYXNyNHhX?=
 =?utf-8?B?VlUvaE9kT0oyY3d5YjNDNzlPdExRVkdHQTh5bHE4UjdEYUcxQnU2L2lMMGRR?=
 =?utf-8?B?eXFOUGhJSzMrUzFJZU5uME5GbUVVTFZLUVNjdTZrQTRKcEx1Tm5BN2RNU1V5?=
 =?utf-8?B?RkdjN2tQbmk3bDBRK3QzOGxKdmZERDl0VDBPT1NodkNJMnh4elFpT1oxQU04?=
 =?utf-8?B?RmFiVHgyQnh4WllZaWpmeU1OQy9oWGVubnE5K29sY1Q2eVNJMTVmYmhleWpk?=
 =?utf-8?B?SllBbjZQNWc5MGJFK0hDMytZVGNKK3hZUjUrQnY0RjB5MEhhKzVmTm1jckl4?=
 =?utf-8?B?aWM3SmpJZXUzQ3JDU05Vc0ZpS3BDWE1CSzlRVE9QWGM2REw1MXJ6dzJ3SC9S?=
 =?utf-8?B?dlZ1ZGd2cU5vVWJCZjBDM0VCajI5NW81eEFPOUJKT25VZzVjNnMzN080N29G?=
 =?utf-8?Q?+fnlcGTECPeDyIIJtFt/nBX2ROP?=
X-OriginatorOrg: wdc.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-AuthSource: SN4PR0401MB3582.namprd04.prod.outlook.com
X-MS-Exchange-CrossTenant-Network-Message-Id: 9627bef0-3146-4f70-0dfb-08dba951c9b0
X-MS-Exchange-CrossTenant-originalarrivaltime: 30 Aug 2023 12:08:14.3938
 (UTC)
X-MS-Exchange-CrossTenant-fromentityheader: Hosted
X-MS-Exchange-CrossTenant-id: b61c8803-16f3-4c35-9b17-6f65f441df86
X-MS-Exchange-CrossTenant-mailboxtype: HOSTED
X-MS-Exchange-CrossTenant-userprincipalname: 61DP6NRxVkewkOFCyh9EbH2FbBey3BCeT6RGxUazprsTystIlsF31/fOkb6CJhPFFFavkWbbIrFj8bZ5SN4Dpw==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: SA0PR04MB7433
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

T24gNy8yNS8yMyAyMDozOSwgRmFuIE5pIHdyb3RlOg0KPiBGcm9tOiBGYW4gTmkgPG5pZmFuQG91
dGxvb2suY29tPg0KPiANCj4gTm90IGFsbCBkcGEgcmFuZ2UgaW4gdGhlIGRjIHJlZ2lvbnMgaXMg
dmFsaWQgdG8gYWNjZXNzIHVudGlsIGFuIGV4dGVudA0KPiBjb3ZlcmluZyB0aGUgcmFuZ2UgaGFz
IGJlZW4gYWRkZWQuIEFkZCBhIGJpdG1hcCBmb3IgZWFjaCByZWdpb24gdG8NCj4gcmVjb3JkIHdo
ZXRoZXIgYSBkYyBibG9jayBpbiB0aGUgcmVnaW9uIGhhcyBiZWVuIGJhY2tlZCBieSBkYyBleHRl
bnQuDQo+IEZvciB0aGUgYml0bWFwLCBhIGJpdCBpbiB0aGUgYml0bWFwIHJlcHJlc2VudHMgYSBk
YyBibG9jay4gV2hlbiBhIGRjDQo+IGV4dGVudCBpcyBhZGRlZCwgYWxsIHRoZSBiaXRzIG9mIHRo
ZSBibG9ja3MgaW4gdGhlIGV4dGVudCB3aWxsIGJlIHNldCwNCj4gd2hpY2ggd2lsbCBiZSBjbGVh
cmVkIHdoZW4gdGhlIGV4dGVudCBpcyByZWxlYXNlZC4NCj4gDQo+IFNpZ25lZC1vZmYtYnk6IEZh
biBOaSA8ZmFuLm5pQHNhbXN1bmcuY29tPg0KDQpIaSBGYW4sDQoNCkdyZWF0IHRvIHNlZSB0aGlz
IGJlaW5nIGltcGxlbWVudGVkLiBJJ3ZlIGJlZW4gcGxheWluZyBhcm91bmQgd2l0aCBpdCANCmZv
ciBhIGJpdCwgYW5kIHJhbiBpbnRvIHRoZSBpc3N1ZSBtZW50aW9uZWQgYmVsb3cuDQoNCj4gLS0t
DQo+ICAgaHcvbWVtL2N4bF90eXBlMy5jICAgICAgICAgIHwgMTU1ICsrKysrKysrKysrKysrKysr
KysrKysrKysrKysrKysrKysrKw0KPiAgIGluY2x1ZGUvaHcvY3hsL2N4bF9kZXZpY2UuaCB8ICAg
MSArDQo+ICAgMiBmaWxlcyBjaGFuZ2VkLCAxNTYgaW5zZXJ0aW9ucygrKQ0KPiANCj4gZGlmZiAt
LWdpdCBhL2h3L21lbS9jeGxfdHlwZTMuYyBiL2h3L21lbS9jeGxfdHlwZTMuYw0KPiBpbmRleCA0
MWE4Mjg1OThhLi41MTk0M2EzNmZjIDEwMDY0NA0KPiAtLS0gYS9ody9tZW0vY3hsX3R5cGUzLmMN
Cj4gKysrIGIvaHcvbWVtL2N4bF90eXBlMy5jDQo+IEBAIC03ODcsMTMgKzc4NywzNyBAQCBzdGF0
aWMgaW50IGN4bF9jcmVhdGVfZGNfcmVnaW9ucyhDWExUeXBlM0RldiAqY3QzZCkNCj4gICAgICAg
ICAgIC8qIGRzbWFkX2hhbmRsZSBpcyBzZXQgd2hlbiBjcmVhdGluZyBjZGF0IHRhYmxlIGVudHJp
ZXMgKi8NCj4gICAgICAgICAgIHJlZ2lvbi0+ZmxhZ3MgPSAwOw0KPiANCj4gKyAgICAgICAgcmVn
aW9uLT5ibGtfYml0bWFwID0gYml0bWFwX25ldyhyZWdpb24tPmxlbiAvIHJlZ2lvbi0+YmxvY2tf
c2l6ZSk7DQo+ICsgICAgICAgIGlmICghcmVnaW9uLT5ibGtfYml0bWFwKSB7DQo+ICsgICAgICAg
ICAgICBicmVhazsNCj4gKyAgICAgICAgfQ0KPiArDQo+ICAgICAgICAgICByZWdpb25fYmFzZSAr
PSByZWdpb24tPmxlbjsNCj4gICAgICAgfQ0KPiArDQo+ICsgICAgaWYgKGkgPCBjdDNkLT5kYy5u
dW1fcmVnaW9ucykgew0KPiArICAgICAgICB3aGlsZSAoLS1pID49IDApIHsNCj4gKyAgICAgICAg
ICAgIGdfZnJlZShjdDNkLT5kYy5yZWdpb25zW2ldLmJsa19iaXRtYXApOw0KPiArICAgICAgICB9
DQo+ICsgICAgICAgIHJldHVybiAtMTsNCj4gKyAgICB9DQo+ICsNCj4gICAgICAgUVRBSUxRX0lO
SVQoJmN0M2QtPmRjLmV4dGVudHMpOw0KPiANCj4gICAgICAgcmV0dXJuIDA7DQo+ICAgfQ0KPiAN
Cj4gK3N0YXRpYyB2b2lkIGN4bF9kZXN0cm95X2RjX3JlZ2lvbnMoQ1hMVHlwZTNEZXYgKmN0M2Qp
DQo+ICt7DQo+ICsgICAgaW50IGk7DQo+ICsgICAgc3RydWN0IENYTERDRF9SZWdpb24gKnJlZ2lv
bjsNCj4gKw0KPiArICAgIGZvciAoaSA9IDA7IGkgPCBjdDNkLT5kYy5udW1fcmVnaW9uczsgaSsr
KSB7DQo+ICsgICAgICAgIHJlZ2lvbiA9ICZjdDNkLT5kYy5yZWdpb25zW2ldOw0KPiArICAgICAg
ICBnX2ZyZWUocmVnaW9uLT5ibGtfYml0bWFwKTsNCj4gKyAgICB9DQo+ICt9DQo+ICsNCj4gICBz
dGF0aWMgYm9vbCBjeGxfc2V0dXBfbWVtb3J5KENYTFR5cGUzRGV2ICpjdDNkLCBFcnJvciAqKmVy
cnApDQo+ICAgew0KPiAgICAgICBEZXZpY2VTdGF0ZSAqZHMgPSBERVZJQ0UoY3QzZCk7DQo+IEBA
IC0xMDIxLDYgKzEwNDUsNyBAQCBlcnJfZnJlZV9zcGVjaWFsX29wczoNCj4gICAgICAgZ19mcmVl
KHJlZ3MtPnNwZWNpYWxfb3BzKTsNCj4gICBlcnJfYWRkcmVzc19zcGFjZV9mcmVlOg0KPiAgICAg
ICBpZiAoY3QzZC0+ZGMuaG9zdF9kYykgew0KPiArICAgICAgICBjeGxfZGVzdHJveV9kY19yZWdp
b25zKGN0M2QpOw0KPiAgICAgICAgICAgYWRkcmVzc19zcGFjZV9kZXN0cm95KCZjdDNkLT5kYy5o
b3N0X2RjX2FzKTsNCj4gICAgICAgfQ0KPiAgICAgICBpZiAoY3QzZC0+aG9zdHBtZW0pIHsNCj4g
QEAgLTEwNDMsNiArMTA2OCw3IEBAIHN0YXRpYyB2b2lkIGN0M19leGl0KFBDSURldmljZSAqcGNp
X2RldikNCj4gICAgICAgc3BkbV9zb2NrX2ZpbmkoY3QzZC0+ZG9lX3NwZG0uc29ja2V0KTsNCj4g
ICAgICAgZ19mcmVlKHJlZ3MtPnNwZWNpYWxfb3BzKTsNCj4gICAgICAgaWYgKGN0M2QtPmRjLmhv
c3RfZGMpIHsNCj4gKyAgICAgICAgY3hsX2Rlc3Ryb3lfZGNfcmVnaW9ucyhjdDNkKTsNCj4gICAg
ICAgICAgIGFkZHJlc3Nfc3BhY2VfZGVzdHJveSgmY3QzZC0+ZGMuaG9zdF9kY19hcyk7DQo+ICAg
ICAgIH0NCj4gICAgICAgaWYgKGN0M2QtPmhvc3RwbWVtKSB7DQo+IEBAIC0xMDUzLDYgKzEwNzks
MTEwIEBAIHN0YXRpYyB2b2lkIGN0M19leGl0KFBDSURldmljZSAqcGNpX2RldikNCj4gICAgICAg
fQ0KPiAgIH0NCj4gDQo+ICsvKg0KPiArICogVGhpcyBmdW5jdGlvbiB3aWxsIG1hcmtlZCB0aGUg
ZHBhIHJhbmdlIFtkcGEsIGRhcCArIGxlbikgdG8gYmUgYmFja2VkIGFuZA0KPiArICogYWNjZXNz
aWJsZSwgdGhpcyBoYXBwZW5zIHdoZW4gYSBkYyBleHRlbnQgaXMgYWRkZWQgYW5kIGFjY2VwdGVk
IGJ5IHRoZQ0KPiArICogaG9zdC4NCj4gKyAqLw0KPiArc3RhdGljIHZvaWQgc2V0X3JlZ2lvbl9i
bG9ja19iYWNrZWQoQ1hMVHlwZTNEZXYgKmN0M2QsIHVpbnQ2NF90IGRwYSwNCj4gKyAgICAgICAg
dWludDY0X3QgbGVuKQ0KPiArew0KPiArICAgIGludCBpOw0KPiArICAgIENYTERDRF9SZWdpb24g
KnJlZ2lvbiA9ICZjdDNkLT5kYy5yZWdpb25zWzBdOw0KPiArDQo+ICsgICAgaWYgKGRwYSA8IHJl
Z2lvbi0+YmFzZQ0KPiArICAgICAgICAgICAgfHwgZHBhID49IHJlZ2lvbi0+YmFzZSArIGN0M2Qt
PmRjLnRvdGFsX2NhcGFjaXR5KQ0KPiArICAgICAgICByZXR1cm47DQo+ICsNCj4gKyAgICAvKg0K
PiArICAgICAqIHNwZWMgMy4wIDkuMTMuMzogUmVnaW9ucyBhcmUgdXNlZCBpbiBpbmNyZWFzaW5n
LURQQSBvcmRlciwgd2l0aA0KPiArICAgICAqIFJlZ2lvbiAwIGJlaW5nIHVzZWQgZm9yIHRoZSBs
b3dlc3QgRFBBIG9mIER5bmFtaWMgQ2FwYWNpdHkgYW5kDQo+ICsgICAgICogUmVnaW9uIDcgZm9y
IHRoZSBoaWdoZXN0IERQQS4NCj4gKyAgICAgKiBTbyB3ZSBjaGVjayBmcm9tIHRoZSBsYXN0IHJl
Z2lvbiB0byBmaW5kIHdoZXJlIHRoZSBkcGEgYmVsb25ncy4NCj4gKyAgICAgKiBhY2Nlc3MgYWNy
b3NzIG11bHRpcGxlIHJlZ2lvbnMgaXMgbm90IGFsbG93ZWQuDQo+ICsgICAgICoqLw0KPiArICAg
IGZvciAoaSA9IGN0M2QtPmRjLm51bV9yZWdpb25zIC0gMTsgaSA+PSAwOyBpLS0pIHsNCj4gKyAg
ICAgICAgcmVnaW9uID0gJmN0M2QtPmRjLnJlZ2lvbnNbaV07DQo+ICsgICAgICAgIGlmIChkcGEg
Pj0gcmVnaW9uLT5iYXNlKSB7DQo+ICsgICAgICAgICAgICBicmVhazsNCj4gKyAgICAgICAgfQ0K
PiArICAgIH0NCj4gKw0KPiArICAgIGJpdG1hcF9zZXQocmVnaW9uLT5ibGtfYml0bWFwLCAoZHBh
IC0gcmVnaW9uLT5iYXNlKSAvIHJlZ2lvbi0+YmxvY2tfc2l6ZSwNCj4gKyAgICAgICAgICAgIGxl
biAvIHJlZ2lvbi0+YmxvY2tfc2l6ZSk7DQo+ICt9DQo+ICsNCj4gKy8qDQo+ICsgKiBUaGlzIGZ1
bmN0aW9uIGNoZWNrIHdoZXRoZXIgYSBkcGEgcmFuZ2UgW2RwYSwgZHBhICsgbGVuKSBoYXMgYmVl
biBiYWNrZWQNCj4gKyAqIHdpdGggZGMgZXh0ZW50cywgdXNlZCB3aGVuIHZhbGlkYXRpbmcgcmVh
ZC93cml0ZSB0byBkYyByZWdpb25zDQo+ICsgKi8NCj4gK3N0YXRpYyBib29sIHRlc3RfcmVnaW9u
X2Jsb2NrX2JhY2tlZChDWExUeXBlM0RldiAqY3QzZCwgdWludDY0X3QgZHBhLA0KPiArICAgICAg
ICB1aW50NjRfdCBsZW4pDQo+ICt7DQo+ICsgICAgaW50IGk7DQo+ICsgICAgQ1hMRENEX1JlZ2lv
biAqcmVnaW9uID0gJmN0M2QtPmRjLnJlZ2lvbnNbMF07DQo+ICsgICAgdWludDY0X3QgbmJpdHM7
DQo+ICsgICAgbG9uZyBucjsNCj4gKw0KPiArICAgIGlmIChkcGEgPCByZWdpb24tPmJhc2UNCj4g
KyAgICAgICAgICAgIHx8IGRwYSA+PSByZWdpb24tPmJhc2UgKyBjdDNkLT5kYy50b3RhbF9jYXBh
Y2l0eSkNCj4gKyAgICAgICAgcmV0dXJuIGZhbHNlOw0KPiArDQo+ICsgICAgLyoNCj4gKyAgICAg
KiBzcGVjIDMuMCA5LjEzLjM6IFJlZ2lvbnMgYXJlIHVzZWQgaW4gaW5jcmVhc2luZy1EUEEgb3Jk
ZXIsIHdpdGgNCj4gKyAgICAgKiBSZWdpb24gMCBiZWluZyB1c2VkIGZvciB0aGUgbG93ZXN0IERQ
QSBvZiBEeW5hbWljIENhcGFjaXR5IGFuZA0KPiArICAgICAqIFJlZ2lvbiA3IGZvciB0aGUgaGln
aGVzdCBEUEEuDQo+ICsgICAgICogU28gd2UgY2hlY2sgZnJvbSB0aGUgbGFzdCByZWdpb24gdG8g
ZmluZCB3aGVyZSB0aGUgZHBhIGJlbG9uZ3MuDQo+ICsgICAgICogYWNjZXNzIGFjcm9zcyBtdWx0
aXBsZSByZWdpb25zIGlzIG5vdCBhbGxvd2VkLg0KPiArICAgICAqLw0KPiArICAgIGZvciAoaSA9
IGN0M2QtPmRjLm51bV9yZWdpb25zIC0gMTsgaSA+PSAwOyBpLS0pIHsNCj4gKyAgICAgICAgcmVn
aW9uID0gJmN0M2QtPmRjLnJlZ2lvbnNbaV07DQo+ICsgICAgICAgIGlmIChkcGEgPj0gcmVnaW9u
LT5iYXNlKSB7DQo+ICsgICAgICAgICAgICBicmVhazsNCj4gKyAgICAgICAgfQ0KPiArICAgIH0N
Cj4gKw0KPiArICAgIG5yID0gKGRwYSAtIHJlZ2lvbi0+YmFzZSkgLyByZWdpb24tPmJsb2NrX3Np
emU7DQoNCj4gKyAgICBuYml0cyA9IGxlbiAvIHJlZ2lvbi0+YmxvY2tfc2l6ZTsNCj4gKyAgICBy
ZXR1cm4gZmluZF9uZXh0X3plcm9fYml0KHJlZ2lvbi0+YmxrX2JpdG1hcCwgbmJpdHMsIG5yKSA+
PSBuciArIG5iaXRzOw0KDQpUaGUgMm5kIHBhcmFtZXRlciB0byBmaW5kX25leHRfemVyb19iaXQg
aXMgdGhlIGxlbmd0aCBvZiB0aGUgYml0bWFwLCBzbyANCnNob3VsZG4ndCB0aGlzIGJlIHNvbWV0
aGluZyBsaWtlIChhbHNvIGNvbnNpZGVyaW5nIHRoYXQgbGVuIGlzIHRoZSANCnJlYWQvd3JpdGUg
bGVuLCBhbmQgd2lsbCBiZSBzbWFsbGVyIHRoYW4gdGhlIHJlZ2lvbiBibG9jayBzaXplKToNCg0K
ICAgbmJpdHMgPSBESVZfUk9VTkRfVVAobGVuLCByZWdpb24tPmJsb2NrX3NpemUpOyANCiANCg0K
ICAgcmV0dXJuIGZpbmRfbmV4dF96ZXJvX2JpdChyZWdpb24tPmJsa19iaXRtYXAsIG5iaXRzICsg
bnIsIG5yKSA9PQ0KICAgICAgICAgIG5iaXRzICsgbnI7DQoNCj4gK30NCj4gKw0KPiArLyoNCj4g
KyAqIFRoaXMgZnVuY3Rpb24gd2lsbCBtYXJrZWQgdGhlIGRwYSByYW5nZSBbZHBhLCBkYXAgKyBs
ZW4pIHRvIGJlIHVuYmFja2VkIGFuZA0KPiArICogaW5hY2Nlc3NpYmxlLCB0aGlzIGhhcHBlbnMg
d2hlbiBhIGRjIGV4dGVudCBpcyBhZGRlZCBhbmQgYWNjZXB0ZWQgYnkgdGhlDQo+ICsgKiBob3N0
Lg0KPiArICovDQo+ICtzdGF0aWMgdm9pZCBjbGVhcl9yZWdpb25fYmxvY2tfYmFja2VkKENYTFR5
cGUzRGV2ICpjdDNkLCB1aW50NjRfdCBkcGEsDQo+ICsgICAgICAgIHVpbnQ2NF90IGxlbikNCj4g
K3sNCj4gKyAgICBpbnQgaTsNCj4gKyAgICBDWExEQ0RfUmVnaW9uICpyZWdpb24gPSAmY3QzZC0+
ZGMucmVnaW9uc1swXTsNCj4gKyAgICB1aW50NjRfdCBuYml0czsNCj4gKyAgICBsb25nIG5yOw0K
PiArDQo+ICsgICAgaWYgKGRwYSA8IHJlZ2lvbi0+YmFzZQ0KPiArICAgICAgICAgICAgfHwgZHBh
ID49IHJlZ2lvbi0+YmFzZSArIGN0M2QtPmRjLnRvdGFsX2NhcGFjaXR5KQ0KPiArICAgICAgICBy
ZXR1cm47DQo+ICsNCj4gKyAgICAvKg0KPiArICAgICAqIHNwZWMgMy4wIDkuMTMuMzogUmVnaW9u
cyBhcmUgdXNlZCBpbiBpbmNyZWFzaW5nLURQQSBvcmRlciwgd2l0aA0KPiArICAgICAqIFJlZ2lv
biAwIGJlaW5nIHVzZWQgZm9yIHRoZSBsb3dlc3QgRFBBIG9mIER5bmFtaWMgQ2FwYWNpdHkgYW5k
DQo+ICsgICAgICogUmVnaW9uIDcgZm9yIHRoZSBoaWdoZXN0IERQQS4NCj4gKyAgICAgKiBTbyB3
ZSBjaGVjayBmcm9tIHRoZSBsYXN0IHJlZ2lvbiB0byBmaW5kIHdoZXJlIHRoZSBkcGEgYmVsb25n
cy4NCj4gKyAgICAgKiBhY2Nlc3MgYWNyb3NzIG11bHRpcGxlIHJlZ2lvbnMgaXMgbm90IGFsbG93
ZWQuDQo+ICsgICAgICovDQo+ICsgICAgZm9yIChpID0gY3QzZC0+ZGMubnVtX3JlZ2lvbnMgLSAx
OyBpID49IDA7IGktLSkgew0KPiArICAgICAgICByZWdpb24gPSAmY3QzZC0+ZGMucmVnaW9uc1tp
XTsNCj4gKyAgICAgICAgaWYgKGRwYSA+PSByZWdpb24tPmJhc2UpIHsNCj4gKyAgICAgICAgICAg
IGJyZWFrOw0KPiArICAgICAgICB9DQo+ICsgICAgfQ0KPiArDQo+ICsgICAgbnIgPSAoZHBhIC0g
cmVnaW9uLT5iYXNlKSAvIHJlZ2lvbi0+YmxvY2tfc2l6ZTsNCj4gKyAgICBuYml0cyA9IGxlbiAv
IHJlZ2lvbi0+YmxvY2tfc2l6ZTsNCj4gKyAgICBiaXRtYXBfY2xlYXIocmVnaW9uLT5ibGtfYml0
bWFwLCBuciwgbmJpdHMpOw0KPiArfQ0KPiArDQo+ICAgc3RhdGljIGJvb2wgY3hsX3R5cGUzX2Rw
YShDWExUeXBlM0RldiAqY3QzZCwgaHdhZGRyIGhvc3RfYWRkciwgdWludDY0X3QgKmRwYSkNCj4g
ICB7DQo+ICAgICAgIHVpbnQzMl90ICpjYWNoZV9tZW0gPSBjdDNkLT5jeGxfY3N0YXRlLmNyYi5j
YWNoZV9tZW1fcmVnaXN0ZXJzOw0KPiBAQCAtMTE0NSw2ICsxMjc1LDEwIEBAIHN0YXRpYyBpbnQg
Y3hsX3R5cGUzX2hwYV90b19hc19hbmRfZHBhKENYTFR5cGUzRGV2ICpjdDNkLA0KPiAgICAgICAg
ICAgKmFzID0gJmN0M2QtPmhvc3RwbWVtX2FzOw0KPiAgICAgICAgICAgKmRwYV9vZmZzZXQgLT0g
dm1yX3NpemU7DQo+ICAgICAgIH0gZWxzZSB7DQo+ICsgICAgICAgIGlmICghdGVzdF9yZWdpb25f
YmxvY2tfYmFja2VkKGN0M2QsICpkcGFfb2Zmc2V0LCBzaXplKSkgew0KPiArICAgICAgICAgICAg
cmV0dXJuIC1FTk9ERVY7DQo+ICsgICAgICAgIH0NCj4gKw0KPiAgICAgICAgICAgKmFzID0gJmN0
M2QtPmRjLmhvc3RfZGNfYXM7DQo+ICAgICAgICAgICAqZHBhX29mZnNldCAtPSAodm1yX3NpemUg
KyBwbXJfc2l6ZSk7DQo+ICAgICAgIH0NCj4gQEAgLTE5NDQsNiArMjA3OCwyNyBAQCBzdGF0aWMg
dm9pZCBxbXBfY3hsX3Byb2Nlc3NfZHluYW1pY19jYXBhY2l0eV9ldmVudChjb25zdCBjaGFyICpw
YXRoLA0KPiAgICAgICB9DQo+IA0KPiAgICAgICBnX2ZyZWUoZXh0ZW50cyk7DQo+ICsNCj4gKyAg
ICAvKiBBbm90aGVyIGNob2ljZSBpcyB0byBkbyB0aGUgc2V0L2NsZWFyIGFmdGVyIGdldHRpbmcg
bWFpbGJveCByZXNwb25zZSovDQo+ICsgICAgbGlzdCA9IHJlY29yZHM7DQo+ICsgICAgd2hpbGUg
KGxpc3QpIHsNCj4gKyAgICAgICAgZHBhID0gbGlzdC0+dmFsdWUtPmRwYSAqIDEwMjQgKiAxMDI0
Ow0KPiArICAgICAgICBsZW4gPSBsaXN0LT52YWx1ZS0+bGVuICogMTAyNCAqIDEwMjQ7DQo+ICsg
ICAgICAgIHJpZCA9IGxpc3QtPnZhbHVlLT5yZWdpb25faWQ7DQo+ICsNCj4gKyAgICAgICAgc3dp
dGNoICh0eXBlKSB7DQo+ICsgICAgICAgIGNhc2UgRENfRVZFTlRfQUREX0NBUEFDSVRZOg0KPiAr
ICAgICAgICAgICAgc2V0X3JlZ2lvbl9ibG9ja19iYWNrZWQoZGNkLCBkcGEsIGxlbik7DQo+ICsg
ICAgICAgICAgICBicmVhazsNCj4gKyAgICAgICAgY2FzZSBEQ19FVkVOVF9SRUxFQVNFX0NBUEFD
SVRZOg0KPiArICAgICAgICAgICAgY2xlYXJfcmVnaW9uX2Jsb2NrX2JhY2tlZChkY2QsIGRwYSwg
bGVuKTsNCj4gKyAgICAgICAgICAgIGJyZWFrOw0KPiArICAgICAgICBkZWZhdWx0Og0KPiArICAg
ICAgICAgICAgZXJyb3Jfc2V0ZyhlcnJwLCAiREMgZXZlbnQgdHlwZSBub3QgaGFuZGxlZCB5ZXQi
KTsNCj4gKyAgICAgICAgICAgIGJyZWFrOw0KPiArICAgICAgICB9DQo+ICsgICAgICAgIGxpc3Qg
PSBsaXN0LT5uZXh0Ow0KPiArICAgIH0NCj4gICB9DQo+IA0KPiAgIHZvaWQgcW1wX2N4bF9hZGRf
ZHluYW1pY19jYXBhY2l0eV9ldmVudChjb25zdCBjaGFyICpwYXRoLA0KPiBkaWZmIC0tZ2l0IGEv
aW5jbHVkZS9ody9jeGwvY3hsX2RldmljZS5oIGIvaW5jbHVkZS9ody9jeGwvY3hsX2RldmljZS5o
DQo+IGluZGV4IDAxYTVlYWNhNDguLjFmODVjODgwMTcgMTAwNjQ0DQo+IC0tLSBhL2luY2x1ZGUv
aHcvY3hsL2N4bF9kZXZpY2UuaA0KPiArKysgYi9pbmNsdWRlL2h3L2N4bC9jeGxfZGV2aWNlLmgN
Cj4gQEAgLTQxMiw2ICs0MTIsNyBAQCB0eXBlZGVmIHN0cnVjdCBDWExEQ0RfUmVnaW9uIHsNCj4g
ICAgICAgdWludDY0X3QgYmxvY2tfc2l6ZTsNCj4gICAgICAgdWludDMyX3QgZHNtYWRoYW5kbGU7
DQo+ICAgICAgIHVpbnQ4X3QgZmxhZ3M7DQo+ICsgICAgdW5zaWduZWQgbG9uZyAqYmxrX2JpdG1h
cDsNCj4gICB9IENYTERDRF9SZWdpb247DQo+IA0KPiAgIHN0cnVjdCBDWExUeXBlM0RldiB7DQo+
IC0tDQo+IDIuMjUuMQ0KDQpUaGFua3MsDQpKb3JnZW4=

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 7D187C83F19
	for <linux-cxl@archiver.kernel.org>; Wed, 30 Aug 2023 18:54:20 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S241436AbjH3SxR (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Wed, 30 Aug 2023 14:53:17 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:43134 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S245290AbjH3PE0 (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Wed, 30 Aug 2023 11:04:26 -0400
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 6D0701A2
        for <linux-cxl@vger.kernel.org>; Wed, 30 Aug 2023 08:04:22 -0700 (PDT)
Received: from lhrpeml500005.china.huawei.com (unknown [172.18.147.200])
        by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4RbSGW5nDwz67Ph9;
        Wed, 30 Aug 2023 23:03:15 +0800 (CST)
Received: from localhost (10.202.227.76) by lhrpeml500005.china.huawei.com
 (7.191.163.240) with Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id 15.1.2507.31; Wed, 30 Aug
 2023 16:04:18 +0100
Date: Wed, 30 Aug 2023 16:04:17 +0100
From: Jonathan Cameron <Jonathan.Cameron@Huawei.com>
To: Fan Ni <fan.ni@gmx.us>
CC: Fan Ni <fan.ni@samsung.com>,
        "qemu-devel@nongnu.org" <qemu-devel@nongnu.org>,
        "linux-cxl@vger.kernel.org" <linux-cxl@vger.kernel.org>,
        "gregory.price@memverge.com" <gregory.price@memverge.com>,
        "hchkuo@avery-design.com.tw" <hchkuo@avery-design.com.tw>,
        "cbrowy@avery-design.com" <cbrowy@avery-design.com>,
        "ira.weiny@intel.com" <ira.weiny@intel.com>,
        "dan.j.williams@intel.com" <dan.j.williams@intel.com>,
        Adam Manzanares <a.manzanares@samsung.com>,
        "dave@stgolabs.net" <dave@stgolabs.net>,
        "nmtadam.samsung@gmail.com" <nmtadam.samsung@gmail.com>,
        "nifan@outlook.com" <nifan@outlook.com>
Subject: Re: [Qemu PATCH v2 9/9] hw/mem/cxl_type3: Add dpa range validation
 for accesses to dc regions
Message-ID: <20230830160417.000060d3@Huawei.com>
In-Reply-To: <ZOjYKq+vDMIdFEl7@debian>
References: <20230725183939.2741025-1-fan.ni@samsung.com>
        <CGME20230725183957uscas1p2ca5293c7229ab989ad1a2d95395436a6@uscas1p2.samsung.com>
        <20230725183939.2741025-10-fan.ni@samsung.com>
        <20230807095342.00006f88@Huawei.com>
        <ZOfCPADXcYMGIGC4@debian>
        <20230825124256.0000604c@Huawei.com>
        <ZOjYKq+vDMIdFEl7@debian>
Organization: Huawei Technologies Research and Development (UK) Ltd.
X-Mailer: Claws Mail 4.1.0 (GTK 3.24.33; x86_64-w64-mingw32)
MIME-Version: 1.0
Content-Type: text/plain; charset="US-ASCII"
Content-Transfer-Encoding: 7bit
X-Originating-IP: [10.202.227.76]
X-ClientProxiedBy: lhrpeml500005.china.huawei.com (7.191.163.240) To
 lhrpeml500005.china.huawei.com (7.191.163.240)
X-CFilter-Loop: Reflected
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

On Fri, 25 Aug 2023 09:34:50 -0700
Fan Ni <fan.ni@gmx.us> wrote:

> On Fri, Aug 25, 2023 at 12:42:56PM +0100, Jonathan Cameron wrote:
> > On Thu, 24 Aug 2023 13:49:00 -0700
> > Fan Ni <fan.ni@gmx.us> wrote:
> >  
> > > On Mon, Aug 07, 2023 at 09:53:42AM +0100, Jonathan Cameron wrote:  
> > > > On Tue, 25 Jul 2023 18:39:56 +0000
> > > > Fan Ni <fan.ni@samsung.com> wrote:
> > > >  
> > > > > From: Fan Ni <nifan@outlook.com>
> > > > >
> > > > > Not all dpa range in the dc regions is valid to access until an extent
> > > > > covering the range has been added. Add a bitmap for each region to
> > > > > record whether a dc block in the region has been backed by dc extent.
> > > > > For the bitmap, a bit in the bitmap represents a dc block. When a dc
> > > > > extent is added, all the bits of the blocks in the extent will be set,
> > > > > which will be cleared when the extent is released.
> > > > >
> > > > > Signed-off-by: Fan Ni <fan.ni@samsung.com>  
> > > > Hi Fan,
> > > >
> > > > A few of the bits of feedback apply broadly across the series.  Given I'm
> > > > rebasing this anyway to give myself something to test I'll tidy things up
> > > > (feel free to disagree with and revert any changes !)
> > > > and push a tree out in next day or two.  I'll message when I've done so.
> > > >
> > > > Jonathan  
> > >
> > > Hi Jonathan,
> > > I tried DCD with your branch "cxl-2023-08-07", and noticed the
> > > following,
> > > 1. You made some changes to the bitmap functionality, now it is only
> > > used to validate extents when adding/releasing dc extents. My original
> > > thought of adding the bitmap is to 1) validating extents for extent
> > > add/release as you do; 2) Add validating when doing read/write to the dc
> > > regions since some address region may not have valid extent added yet.
> > > Do you think 2) is not necessary?  
> >
> > Change wasn't intentional. I probably just messed up the rebase!  
> 
> Just double checked the code. The logic is still there, but in another
> patch in the series, so no issue and ignore my previous question.
> Sorry for the confusion.
> 
> >  
> > >
> > > 2. Your change introduced a bug in the code.
> > > https://gitlab.com/jic23/qemu/-/blob/cxl-2023-08-07/hw/cxl/cxl-mailbox-utils.c?ref_type=heads#L1394
> > > ct3d->dc.num_regions should be ct3d->dc.num_regions-1.  
> > Thanks.  Given I might forget about about it, if you want to incorporate that in
> > your next version that would be great. I might remember to fix it in the meantime!
Oops. I'll tiddy that up in my tree. 
> >
> > Jonathan
> >  
> 
> My code does not have this. It seems you added the lastregion variable
> to record the last region, while I use the following logic to iterate
> the regions and record last region automatically while collecting
> min_block_size.
> 
> +    for (i = 1; i < dev->dc.num_regions; i++) {
> +        region = &dev->dc.regions[i];
> +        if (min_block_size > region->block_size) {
> +            min_block_size = region->block_size;
> +        }
> +    }
> +
> +    blk_bitmap = bitmap_new((region->len + region->base
> +                - dev->dc.regions[0].base) / min_block_size);
Understood.  I found that hard to read (see review of patch 7).
I then messed up the cleanup as you've noted.

Jonathan
> 
> 
> Fan
> 
> > >
> > > Thanks,
> > > Fan
> > >  
> > > >  
> > > > > ---
> > > > >  hw/mem/cxl_type3.c          | 155 ++++++++++++++++++++++++++++++++++++
> > > > >  include/hw/cxl/cxl_device.h |   1 +
> > > > >  2 files changed, 156 insertions(+)
> > > > >
> > > > > diff --git a/hw/mem/cxl_type3.c b/hw/mem/cxl_type3.c
> > > > > index 41a828598a..51943a36fc 100644
> > > > > --- a/hw/mem/cxl_type3.c
> > > > > +++ b/hw/mem/cxl_type3.c
> > > > > @@ -787,13 +787,37 @@ static int cxl_create_dc_regions(CXLType3Dev *ct3d)
> > > > >          /* dsmad_handle is set when creating cdat table entries */
> > > > >          region->flags = 0;
> > > > >
> > > > > +        region->blk_bitmap = bitmap_new(region->len / region->block_size);  
> > > >
> > > > In common with many allocators in qemu if this fails it calls abort()
> > > > internally so no need to handle potential errors.
> > > >  
> > > > > +        if (!region->blk_bitmap) {
> > > > > +            break;
> > > > > +        }
> > > > > +
> > > > >          region_base += region->len;
> > > > >      }
> > > > > +
> > > > > +    if (i < ct3d->dc.num_regions) {
> > > > > +        while (--i >= 0) {
> > > > > +            g_free(ct3d->dc.regions[i].blk_bitmap);
> > > > > +        }
> > > > > +        return -1;
> > > > > +    }
> > > > > +
> > > > >      QTAILQ_INIT(&ct3d->dc.extents);
> > > > >
> > > > >      return 0;
> > > > >  }
> > > > >
> > > > > +static void cxl_destroy_dc_regions(CXLType3Dev *ct3d)
> > > > > +{
> > > > > +    int i;
> > > > > +    struct CXLDCD_Region *region;
> > > > > +
> > > > > +    for (i = 0; i < ct3d->dc.num_regions; i++) {
> > > > > +        region = &ct3d->dc.regions[i];
> > > > > +        g_free(region->blk_bitmap);
> > > > > +    }
> > > > > +}
> > > > > +
> > > > >  static bool cxl_setup_memory(CXLType3Dev *ct3d, Error **errp)
> > > > >  {
> > > > >      DeviceState *ds = DEVICE(ct3d);
> > > > > @@ -1021,6 +1045,7 @@ err_free_special_ops:
> > > > >      g_free(regs->special_ops);
> > > > >  err_address_space_free:
> > > > >      if (ct3d->dc.host_dc) {
> > > > > +        cxl_destroy_dc_regions(ct3d);
> > > > >          address_space_destroy(&ct3d->dc.host_dc_as);
> > > > >      }
> > > > >      if (ct3d->hostpmem) {
> > > > > @@ -1043,6 +1068,7 @@ static void ct3_exit(PCIDevice *pci_dev)
> > > > >      spdm_sock_fini(ct3d->doe_spdm.socket);
> > > > >      g_free(regs->special_ops);
> > > > >      if (ct3d->dc.host_dc) {
> > > > > +        cxl_destroy_dc_regions(ct3d);
> > > > >          address_space_destroy(&ct3d->dc.host_dc_as);
> > > > >      }
> > > > >      if (ct3d->hostpmem) {
> > > > > @@ -1053,6 +1079,110 @@ static void ct3_exit(PCIDevice *pci_dev)
> > > > >      }
> > > > >  }
> > > > >
> > > > > +/*
> > > > > + * This function will marked the dpa range [dpa, dap + len) to be backed and
> > > > > + * accessible, this happens when a dc extent is added and accepted by the
> > > > > + * host.
> > > > > + */
> > > > > +static void set_region_block_backed(CXLType3Dev *ct3d, uint64_t dpa,
> > > > > +        uint64_t len)
> > > > > +{
> > > > > +    int i;
> > > > > +    CXLDCD_Region *region = &ct3d->dc.regions[0];
> > > > > +
> > > > > +    if (dpa < region->base
> > > > > +            || dpa >= region->base + ct3d->dc.total_capacity)
> > > > > +        return;
> > > > > +
> > > > > +    /*
> > > > > +     * spec 3.0 9.13.3: Regions are used in increasing-DPA order, with
> > > > > +     * Region 0 being used for the lowest DPA of Dynamic Capacity and
> > > > > +     * Region 7 for the highest DPA.
> > > > > +     * So we check from the last region to find where the dpa belongs.
> > > > > +     * access across multiple regions is not allowed.
> > > > > +     **/
> > > > > +    for (i = ct3d->dc.num_regions - 1; i >= 0; i--) {
> > > > > +        region = &ct3d->dc.regions[i];
> > > > > +        if (dpa >= region->base) {
> > > > > +            break;
> > > > > +        }
> > > > > +    }
> > > > > +
> > > > > +    bitmap_set(region->blk_bitmap, (dpa - region->base) / region->block_size,
> > > > > +            len / region->block_size);
> > > > > +}
> > > > > +
> > > > > +/*
> > > > > + * This function check whether a dpa range [dpa, dpa + len) has been backed
> > > > > + * with dc extents, used when validating read/write to dc regions
> > > > > + */
> > > > > +static bool test_region_block_backed(CXLType3Dev *ct3d, uint64_t dpa,
> > > > > +        uint64_t len)
> > > > > +{
> > > > > +    int i;
> > > > > +    CXLDCD_Region *region = &ct3d->dc.regions[0];
> > > > > +    uint64_t nbits;
> > > > > +    long nr;
> > > > > +
> > > > > +    if (dpa < region->base
> > > > > +            || dpa >= region->base + ct3d->dc.total_capacity)
> > > > > +        return false;
> > > > > +
> > > > > +    /*
> > > > > +     * spec 3.0 9.13.3: Regions are used in increasing-DPA order, with
> > > > > +     * Region 0 being used for the lowest DPA of Dynamic Capacity and
> > > > > +     * Region 7 for the highest DPA.
> > > > > +     * So we check from the last region to find where the dpa belongs.
> > > > > +     * access across multiple regions is not allowed.
> > > > > +     */
> > > > > +    for (i = ct3d->dc.num_regions - 1; i >= 0; i--) {
> > > > > +        region = &ct3d->dc.regions[i];
> > > > > +        if (dpa >= region->base) {
> > > > > +            break;
> > > > > +        }
> > > > > +    }
> > > > > +
> > > > > +    nr = (dpa - region->base) / region->block_size;
> > > > > +    nbits = len / region->block_size;
> > > > > +    return find_next_zero_bit(region->blk_bitmap, nbits, nr) >= nr + nbits;
> > > > > +}
> > > > > +
> > > > > +/*
> > > > > + * This function will marked the dpa range [dpa, dap + len) to be unbacked and
> > > > > + * inaccessible, this happens when a dc extent is added and accepted by the
> > > > > + * host.
> > > > > + */
> > > > > +static void clear_region_block_backed(CXLType3Dev *ct3d, uint64_t dpa,
> > > > > +        uint64_t len)
> > > > > +{
> > > > > +    int i;
> > > > > +    CXLDCD_Region *region = &ct3d->dc.regions[0];
> > > > > +    uint64_t nbits;
> > > > > +    long nr;
> > > > > +
> > > > > +    if (dpa < region->base
> > > > > +            || dpa >= region->base + ct3d->dc.total_capacity)
> > > > > +        return;
> > > > > +
> > > > > +    /*
> > > > > +     * spec 3.0 9.13.3: Regions are used in increasing-DPA order, with
> > > > > +     * Region 0 being used for the lowest DPA of Dynamic Capacity and
> > > > > +     * Region 7 for the highest DPA.
> > > > > +     * So we check from the last region to find where the dpa belongs.
> > > > > +     * access across multiple regions is not allowed.
> > > > > +     */
> > > > > +    for (i = ct3d->dc.num_regions - 1; i >= 0; i--) {
> > > > > +        region = &ct3d->dc.regions[i];
> > > > > +        if (dpa >= region->base) {
> > > > > +            break;
> > > > > +        }
> > > > > +    }
> > > > > +
> > > > > +    nr = (dpa - region->base) / region->block_size;
> > > > > +    nbits = len / region->block_size;
> > > > > +    bitmap_clear(region->blk_bitmap, nr, nbits);
> > > > > +}
> > > > > +
> > > > >  static bool cxl_type3_dpa(CXLType3Dev *ct3d, hwaddr host_addr, uint64_t *dpa)
> > > > >  {
> > > > >      uint32_t *cache_mem = ct3d->cxl_cstate.crb.cache_mem_registers;
> > > > > @@ -1145,6 +1275,10 @@ static int cxl_type3_hpa_to_as_and_dpa(CXLType3Dev *ct3d,
> > > > >          *as = &ct3d->hostpmem_as;
> > > > >          *dpa_offset -= vmr_size;
> > > > >      } else {
> > > > > +        if (!test_region_block_backed(ct3d, *dpa_offset, size)) {
> > > > > +            return -ENODEV;
> > > > > +        }
> > > > > +
> > > > >          *as = &ct3d->dc.host_dc_as;
> > > > >          *dpa_offset -= (vmr_size + pmr_size);
> > > > >      }
> > > > > @@ -1944,6 +2078,27 @@ static void qmp_cxl_process_dynamic_capacity_event(const char *path,
> > > > >      }
> > > > >
> > > > >      g_free(extents);
> > > > > +
> > > > > +    /* Another choice is to do the set/clear after getting mailbox response*/
> > > > > +    list = records;
> > > > > +    while (list) {
> > > > > +        dpa = list->value->dpa * 1024 * 1024;
> > > > > +        len = list->value->len * 1024 * 1024;
> > > > > +        rid = list->value->region_id;
> > > > > +
> > > > > +        switch (type) {
> > > > > +        case DC_EVENT_ADD_CAPACITY:
> > > > > +            set_region_block_backed(dcd, dpa, len);
> > > > > +            break;
> > > > > +        case DC_EVENT_RELEASE_CAPACITY:
> > > > > +            clear_region_block_backed(dcd, dpa, len);
> > > > > +            break;
> > > > > +        default:
> > > > > +            error_setg(errp, "DC event type not handled yet");
> > > > > +            break;
> > > > > +        }
> > > > > +        list = list->next;
> > > > > +    }
> > > > >  }
> > > > >
> > > > >  void qmp_cxl_add_dynamic_capacity_event(const char *path,
> > > > > diff --git a/include/hw/cxl/cxl_device.h b/include/hw/cxl/cxl_device.h
> > > > > index 01a5eaca48..1f85c88017 100644
> > > > > --- a/include/hw/cxl/cxl_device.h
> > > > > +++ b/include/hw/cxl/cxl_device.h
> > > > > @@ -412,6 +412,7 @@ typedef struct CXLDCD_Region {
> > > > >      uint64_t block_size;
> > > > >      uint32_t dsmadhandle;
> > > > >      uint8_t flags;
> > > > > +    unsigned long *blk_bitmap;
> > > > >  } CXLDCD_Region;
> > > > >
> > > > >  struct CXLType3Dev {  
> > > >  
> >  


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id C5E39C83F1F
	for <linux-cxl@archiver.kernel.org>; Wed, 30 Aug 2023 18:54:17 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S245310AbjH3SxM (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Wed, 30 Aug 2023 14:53:12 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:38190 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S245586AbjH3Ph3 (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Wed, 30 Aug 2023 11:37:29 -0400
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 9BAD5113
        for <linux-cxl@vger.kernel.org>; Wed, 30 Aug 2023 08:37:24 -0700 (PDT)
Received: from lhrpeml500005.china.huawei.com (unknown [172.18.147.200])
        by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4RbT0f1VYxz6HJZZ;
        Wed, 30 Aug 2023 23:36:18 +0800 (CST)
Received: from localhost (10.202.227.76) by lhrpeml500005.china.huawei.com
 (7.191.163.240) with Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id 15.1.2507.31; Wed, 30 Aug
 2023 16:37:21 +0100
Date: Wed, 30 Aug 2023 16:37:20 +0100
From: Jonathan Cameron <Jonathan.Cameron@Huawei.com>
To: =?ISO-8859-1?Q?J=F8rgen?= Hansen <Jorgen.Hansen@wdc.com>
CC: Fan Ni <fan.ni@samsung.com>,
        "qemu-devel@nongnu.org" <qemu-devel@nongnu.org>,
        "linux-cxl@vger.kernel.org" <linux-cxl@vger.kernel.org>,
        "gregory.price@memverge.com" <gregory.price@memverge.com>,
        "hchkuo@avery-design.com.tw" <hchkuo@avery-design.com.tw>,
        "cbrowy@avery-design.com" <cbrowy@avery-design.com>,
        "ira.weiny@intel.com" <ira.weiny@intel.com>,
        "dan.j.williams@intel.com" <dan.j.williams@intel.com>,
        Adam Manzanares <a.manzanares@samsung.com>,
        "dave@stgolabs.net" <dave@stgolabs.net>,
        "nmtadam.samsung@gmail.com" <nmtadam.samsung@gmail.com>,
        "nifan@outlook.com" <nifan@outlook.com>
Subject: Re: [Qemu PATCH v2 9/9] hw/mem/cxl_type3: Add dpa range validation
 for accesses to dc regions
Message-ID: <20230830163720.00000f9c@Huawei.com>
In-Reply-To: <d0d7ca1d-81bc-19b3-4904-d60046ded844@wdc.com>
References: <20230725183939.2741025-1-fan.ni@samsung.com>
        <CGME20230725183957uscas1p2ca5293c7229ab989ad1a2d95395436a6@uscas1p2.samsung.com>
        <20230725183939.2741025-10-fan.ni@samsung.com>
        <d0d7ca1d-81bc-19b3-4904-d60046ded844@wdc.com>
Organization: Huawei Technologies Research and Development (UK) Ltd.
X-Mailer: Claws Mail 4.1.0 (GTK 3.24.33; x86_64-w64-mingw32)
MIME-Version: 1.0
Content-Type: text/plain; charset="US-ASCII"
Content-Transfer-Encoding: 7bit
X-Originating-IP: [10.202.227.76]
X-ClientProxiedBy: lhrpeml100006.china.huawei.com (7.191.160.224) To
 lhrpeml500005.china.huawei.com (7.191.163.240)
X-CFilter-Loop: Reflected
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org


> > +
> > +/*
> > + * This function check whether a dpa range [dpa, dpa + len) has been backed
> > + * with dc extents, used when validating read/write to dc regions
> > + */
> > +static bool test_region_block_backed(CXLType3Dev *ct3d, uint64_t dpa,
> > +        uint64_t len)
> > +{
> > +    int i;
> > +    CXLDCD_Region *region = &ct3d->dc.regions[0];
> > +    uint64_t nbits;
> > +    long nr;
> > +
> > +    if (dpa < region->base
> > +            || dpa >= region->base + ct3d->dc.total_capacity)
> > +        return false;
> > +
> > +    /*
> > +     * spec 3.0 9.13.3: Regions are used in increasing-DPA order, with
> > +     * Region 0 being used for the lowest DPA of Dynamic Capacity and
> > +     * Region 7 for the highest DPA.
> > +     * So we check from the last region to find where the dpa belongs.
> > +     * access across multiple regions is not allowed.
> > +     */
> > +    for (i = ct3d->dc.num_regions - 1; i >= 0; i--) {
> > +        region = &ct3d->dc.regions[i];
> > +        if (dpa >= region->base) {
> > +            break;
> > +        }
> > +    }
> > +
> > +    nr = (dpa - region->base) / region->block_size;  
> 
> > +    nbits = len / region->block_size;
oops. Len is probably always smaller than block_size (typically 8 or less)
so nbits always 0.  Should be 1 in those cases.

> > +    return find_next_zero_bit(region->blk_bitmap, nbits, nr) >= nr + nbits;  
> 
> The 2nd parameter to find_next_zero_bit is the length of the bitmap, so 
> shouldn't this be something like (also considering that len is the 
> read/write len, and will be smaller than the region block size):
> 
>    nbits = DIV_ROUND_UP(len, region->block_size);

>  
> 
>    return find_next_zero_bit(region->blk_bitmap, nbits + nr, nr) ==
>           nbits + nr;

Agreed with your suggestion. I'll carry that in my forward port of this
series for now and update my tree at
gitlab.com/jic23/qemu branch will probably be cxl-2023-08-30
a bit later today.

Jonathan


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id C7CE9EE7FE3
	for <linux-cxl@archiver.kernel.org>; Fri,  8 Sep 2023 13:00:24 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S235187AbjIHNA1 (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Fri, 8 Sep 2023 09:00:27 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:39564 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S232859AbjIHNA0 (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Fri, 8 Sep 2023 09:00:26 -0400
Received: from esa4.hgst.iphmx.com (esa4.hgst.iphmx.com [216.71.154.42])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 1818419AE
        for <linux-cxl@vger.kernel.org>; Fri,  8 Sep 2023 06:00:22 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=simple/simple;
  d=wdc.com; i=@wdc.com; q=dns/txt; s=dkim.wdc.com;
  t=1694178022; x=1725714022;
  h=from:to:cc:subject:date:message-id:references:
   in-reply-to:content-id:content-transfer-encoding:
   mime-version;
  bh=1U6hat8NQjcc2UhRtBbmKUWQ3ifvzvHwjNunQbkuXv0=;
  b=A8WR8PucVfjAWZz1bQ+usj0nonkSIreW/uw6pIci6lOSARiyQNvcBNz7
   0Msr84zceTtt6JCUQlgww77G8c9mgFkRqEY0/XPn/Q75b7nJYqm7RmH/d
   XbBY7yb51OPWbjZBP99XobvqkA3pR80TiRMN1oW8A2CibXrur/YIgzyPt
   0Nj8cVwfyDp0qfCfwOIJf8c3UO9/7LHG1nGxLMOlHUncPgm5i0hsMgTYC
   kGzEubxvkv5D9HM8PZK5YZj2F5ARrI8kT+uZRvWX37Gckno0KMyOQLLqr
   wKHNMn1jfD+Bsgf1TrIFvT91+WtNOe6AiUqdNCMfreQ0X+1A3D5CGlPyZ
   A==;
X-CSE-ConnectionGUID: daZoub70Ru2GT8p4ye+4wQ==
X-CSE-MsgGUID: stNB13WwSGaCGTQgafvg5g==
X-IronPort-AV: E=Sophos;i="6.02,237,1688400000"; 
   d="scan'208";a="241562577"
Received: from mail-mw2nam12lp2043.outbound.protection.outlook.com (HELO NAM12-MW2-obe.outbound.protection.outlook.com) ([104.47.66.43])
  by ob1.hgst.iphmx.com with ESMTP; 08 Sep 2023 21:00:20 +0800
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=PCf6DCi9uUiz9kFcL0XBjKYLpeaZ9OPOGgt+cQWv+GWyu5RAFBZC/lVcXiup3lgPpyZFQi01ICG1pTysg/jnIEnLc1idE4kWIrQzNM4/CZDCpWYltzfIaMlf8Ql8rQjFQF69Ql7ylZMvM84Qmc82cW0PqoZFgDuhXubd+oQeOwNmrVWTM1qKKG6ZJxfzf5JNz9vp08nDXeA3CkJVOXH/6XzeG57xc9EC7oggg1QmPXwpFL071wdDrMHBtnpMa3bl8igPbXODJdiGMwmJ1DMST5sM1w0511H4E1mjtIZjQzIMpwgVDv9gqn35HFZQSDC2zMlE7wxVSE8Rp/IOXwUZzQ==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=1U6hat8NQjcc2UhRtBbmKUWQ3ifvzvHwjNunQbkuXv0=;
 b=ZtioS6UiCR/Sy1URfM3JEjfOo9i0pg7AqbWLLe4dkDyG8/25E5ykc33bCXnOW5r5VGyIpakHNJt/GG03Hpdok4pXzm4lGtxV4ejOGaWqNjgd/CGV2euOo8xjDIzUcesr+2R06SM3WNIIDonD+A/s4Egyij2lf7UA7M/YwNhedVwKU48qfjaHCpPMiO5+JTk6zULRfyAGI0UMIQ6slLwDPOqu5dKcE8Wm3xS+PGmhz1fK4HcBQsaeKQJnyzxJQQBry0Y5s56ZfPEuIZTKnllE6CGf6+VqqL0S+sHxgSStbSaEfcopCjRcVxmH5t+uPhiybWBeMvsm5qULYfbzm6jopw==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=wdc.com; dmarc=pass action=none header.from=wdc.com; dkim=pass
 header.d=wdc.com; arc=none
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
 d=sharedspace.onmicrosoft.com; s=selector2-sharedspace-onmicrosoft-com;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-SenderADCheck;
 bh=1U6hat8NQjcc2UhRtBbmKUWQ3ifvzvHwjNunQbkuXv0=;
 b=Ew2gSM3lGt4GifDc31qhQN2C9LD0KfNlkN+u53lUzToFJpUtE2iNA+TK5DnREmXIjIuoRj8N6/3dMP58FLOYXOFaP+doLNHq1VjVrZrO537L7admVFxROFz0uWK5dPU7metRUZrq62vQ/yAnWnC36xQfDpE3uuaGSkBI+jl8gu0=
Received: from SN4PR0401MB3582.namprd04.prod.outlook.com
 (2603:10b6:803:4c::10) by DM6PR04MB6623.namprd04.prod.outlook.com
 (2603:10b6:5:1bc::14) with Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.6792.10; Fri, 8 Sep
 2023 13:00:16 +0000
Received: from SN4PR0401MB3582.namprd04.prod.outlook.com
 ([fe80::b35e:d4f9:1de8:f321]) by SN4PR0401MB3582.namprd04.prod.outlook.com
 ([fe80::b35e:d4f9:1de8:f321%6]) with mapi id 15.20.6792.009; Fri, 8 Sep 2023
 13:00:16 +0000
From: =?utf-8?B?SsO4cmdlbiBIYW5zZW4=?= <Jorgen.Hansen@wdc.com>
To: Fan Ni <fan.ni@samsung.com>,
        "qemu-devel@nongnu.org" <qemu-devel@nongnu.org>
CC: "jonathan.cameron@huawei.com" <jonathan.cameron@huawei.com>,
        "linux-cxl@vger.kernel.org" <linux-cxl@vger.kernel.org>,
        "gregory.price@memverge.com" <gregory.price@memverge.com>,
        "hchkuo@avery-design.com.tw" <hchkuo@avery-design.com.tw>,
        "cbrowy@avery-design.com" <cbrowy@avery-design.com>,
        "ira.weiny@intel.com" <ira.weiny@intel.com>,
        "dan.j.williams@intel.com" <dan.j.williams@intel.com>,
        Adam Manzanares <a.manzanares@samsung.com>,
        "dave@stgolabs.net" <dave@stgolabs.net>,
        "nmtadam.samsung@gmail.com" <nmtadam.samsung@gmail.com>,
        "nifan@outlook.com" <nifan@outlook.com>
Subject: Re: [Qemu PATCH v2 7/9] hw/cxl/cxl-mailbox-utils: Add mailbox
 commands to support add/release dynamic capacity response
Thread-Topic: [Qemu PATCH v2 7/9] hw/cxl/cxl-mailbox-utils: Add mailbox
 commands to support add/release dynamic capacity response
Thread-Index: AQHZvydoEWnb5qMfxEi9SRoRqte0zLARKoOA
Date: Fri, 8 Sep 2023 13:00:16 +0000
Message-ID: <e1640028-6b9d-3cdf-52fb-241f985c4bbb@wdc.com>
References: <20230725183939.2741025-1-fan.ni@samsung.com>
 <CGME20230725183957uscas1p2a076b6f7b694d2e632a0b8025ec331d7@uscas1p2.samsung.com>
 <20230725183939.2741025-8-fan.ni@samsung.com>
In-Reply-To: <20230725183939.2741025-8-fan.ni@samsung.com>
Accept-Language: en-GB, en-US
Content-Language: en-US
X-MS-Has-Attach: 
X-MS-TNEF-Correlator: 
authentication-results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=wdc.com;
x-ms-publictraffictype: Email
x-ms-traffictypediagnostic: SN4PR0401MB3582:EE_|DM6PR04MB6623:EE_
x-ms-office365-filtering-correlation-id: 0284f0b2-d467-4fd6-6924-08dbb06b8c50
wdcipoutbound: EOP-TRUE
x-ms-exchange-senderadcheck: 1
x-ms-exchange-antispam-relay: 0
x-microsoft-antispam: BCL:0;
x-microsoft-antispam-message-info: r4JNh2B7vn7h74BPGtAV3Ll1znfshwK8qvPe4m7wqjh7Oc2CYJqt5OKjZ+jhojkz+qx/s7+S0zJx4ktOT1H0mGqX4QbOfkiNpxIq7HSscwoIxtzGUn4wLBJSbgbaLqlhfvjHUkQYvXibS8g6Z+I4rsZ34SlsQnFgDp90oYaPiTGM52CSwSoEO2wvz8Q/700SITWjlh886ryCwmSYLU4pt2HLnlPpkNnAOX3GmltzIhSfkcwRlE0R3xkDHonMswsFYTcWDLgKLo3yc+AfMamWAdnJ7XkUgpbwetVghNVjD0abE7jvfr2EqXALXgsvVsmLBFapN3VeVshvxTbKjyWDpE0qXc8ERrJ3YCAEJhtDmVCgFRYbfId5coTMs7QDjDCIeA1Z2mp8J4t2uSQNs5LTFo2vEouedTEzEM7n4wEoYWn558JArpIE/h3JbYBdl/8Afd4KkEHKg5mcqa/DwTHM5LW5+nIq4x20ZE4dg92w2SigshVap7wWwPydTfzfjn8kOJBuo7Fa9p+8Vva6hXmsf44E5TFksos0Gnz47K9c/JqHGsGvrfgqUACG8Af8XDbbL17ypGXLtZqzSSzB69UrdAtuESBqW++8Ia5VwRYP5OvpiGEY2m9XliztWw55GaRhJ42lDN3AiBPeR0pQXxMaGw==
x-forefront-antispam-report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:SN4PR0401MB3582.namprd04.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230031)(136003)(39860400002)(366004)(396003)(376002)(346002)(186009)(1800799009)(451199024)(4326008)(71200400001)(6506007)(6486002)(53546011)(41300700001)(6512007)(76116006)(91956017)(83380400001)(478600001)(2906002)(26005)(2616005)(15650500001)(66946007)(7416002)(54906003)(66446008)(64756008)(110136005)(316002)(66556008)(66476007)(5660300002)(8936002)(8676002)(31696002)(38100700002)(86362001)(85182001)(38070700005)(36756003)(85202003)(31686004)(82960400001)(122000001)(45980500001);DIR:OUT;SFP:1102;
x-ms-exchange-antispam-messagedata-chunkcount: 1
x-ms-exchange-antispam-messagedata-0: =?utf-8?B?V2U3WVhzbzJhWnptd21hTUNSTWVNT1huMGdIVXFTREliTGkvd3dONjRIcG5p?=
 =?utf-8?B?eU11WDl0TXZodldNa2JKd2FxbnVzbkxab3paQUVVcXRwTXpyOFJPc0RrZmFL?=
 =?utf-8?B?cG4yUUVqTmpZYktVUTlsRVV6MTE4OCtFbGFjMDEwNng5M1dEdlBXSmRNTmVH?=
 =?utf-8?B?bk0yWG9CUE1QQmJJTGQ5ZHlwRXp1S1V4MHpDMlBUcTkrOFl5YStrZ01xQUJE?=
 =?utf-8?B?WEpvWmFGdWZpalVtdUtpTW5JTFVqUzRWNk10cHhsTExudmtQdmI0aEpMc3pt?=
 =?utf-8?B?ckJ5U3JBMEt6MnFydytBOGxxUHNuUWw1eXRlK1hDVE1PRkRhSFhVUkRMd0FC?=
 =?utf-8?B?Q0dYd2hYbFpvOHJKSlFWR2pldFBJM241K3huZ01QeGJHTEZMc25xUk9jN1BQ?=
 =?utf-8?B?ZFpRaXdxRGlqaWZmWjlIb3U2V0NlVURwZWt2bGtEeXdzTUt0cVJPNys0UlJk?=
 =?utf-8?B?M3NCcENxMGxGZ21jaGo3OXZ3bmVaOFVPbit1b3NCUmpveGNZcTZSMWlCSnFQ?=
 =?utf-8?B?U21hMkRvQkVJVklOeWhQT0NBOGplMENBWk5aSnZPR2F6Z0ZQdGNiTDJHYXls?=
 =?utf-8?B?VCt3Rlg3Y2lKTmRrUndNMys2bWl5cTR6M2U3Qk5QT1p0Y251eXBwcXBZN2sz?=
 =?utf-8?B?YXVnR2Uwa0k0RFZjWEo5NTBuaVpxd1p5eFJRL0sxMmY2bVhKQlZJVnQ1eDVw?=
 =?utf-8?B?a1lsWlBjOE93bkZOMU9YKzJpbVJjdDF0UWluU3Y3OVdEenJheTRyU1Y5eFFQ?=
 =?utf-8?B?Yk9QcUJhSTdyZHdwTkdwMU5xWkZsSnhGLzlqRW4vUHFIZWwzb2xqZEVVK0Zi?=
 =?utf-8?B?THQ4SlVFaGNPUDVoZUFScEZialJPYmM3WUpWMDVJZUVndUhGSEtNZktycFAy?=
 =?utf-8?B?RnkyOFFidk5UL3ZEMVIwWTNlNzRXbmYzbTdHaHhnTXlUM0krc04xcW5nSEFP?=
 =?utf-8?B?SWdhYWZ4cmpVdkhIZXNUYUhFZU5hYVBWMkc3K1lXMEpFWnJTaURNQktYSG1s?=
 =?utf-8?B?bkNRRkJMRHBqaG11UjJraHNCUEd0aTh5dTlOVVRpcld2bkFEeWQrYTVyanZo?=
 =?utf-8?B?dkVsVGhhOVEvTWZnN0dMSy9xcEdxOGdsSTBTUktTZExGRVJjRE9ReGVWdkh6?=
 =?utf-8?B?SDhKSVRtY21CSkY0MDB6a1BQRXRmMmJtZE1oeUVWN2QrUHJSOGtzd0V5eDRq?=
 =?utf-8?B?blY4ZG9EQ0N3YjErM012T2liWVZseTAzS3lxa2FNb0tObE0wdFRhNFJGeE45?=
 =?utf-8?B?c2hwS1BNVUl0WkN0bDVmUWVwZnBWc3hZNS9NcW9nZ3haQXY2RGMrWXVpRlZ5?=
 =?utf-8?B?RTJsVUZiMlg2UXVmZnhjemliYmdpOFB5VnVCV3hRME1UekF6dmFiNDRPazB4?=
 =?utf-8?B?cXd0ckVnSFFtbnM5ZGtNUnhCeEVoUU9ZTTF4S0xURmloeHN5cmJlRkRUekhM?=
 =?utf-8?B?eDBIWkFqUEpHcnIya2o4RWRaTU5tOVRMZzZVR1lHRGVGWXdMcUc3SnpNZk1s?=
 =?utf-8?B?a2NhOHZjakMwaGVjV3lkMTNCTUVMWnBjcHJkTTVodEdETFhlSUZRb1BGSk5B?=
 =?utf-8?B?UVlIVm5FTFFIMkxKYTAzNW80QlZwK3ZNL3JkU25rRmczUmt1UFA4TGIxaEdU?=
 =?utf-8?B?cnEycVpvOUdFakF2Z3ZrbkVxT2RDdmovZlcvSkR3UVB2UHpZU1JXcVdSeWds?=
 =?utf-8?B?Nko2UWlPL3lQUnk3M0ViSjMxNEREalNTeEVzYVhjTjFUUjduN3R6cXZzaXNr?=
 =?utf-8?B?YXdMWGxrOHhQK3oyN3NSOUlwODRveHYxSDhCQndNWnNzNTlPN3J0bDB6ak9P?=
 =?utf-8?B?OTM5U2V6aW5pNTRodjlYbGE4a05YSDJTNnFGLzhIK0tXeXJsVzhvZHJET1dT?=
 =?utf-8?B?RzZOa0tMelRjRWk3UGpFR3UxY3pkMFIxK3F3akN6aHJyemsxUklxSEtqOXps?=
 =?utf-8?B?UDZNa3ZjcWZqbTRKZ0JnQmkwUUlxWHVpRDNyNjJHL1NrekpGUlc0ZDh5K3JJ?=
 =?utf-8?B?cndHUnp2UVd6L09kUE9PcW5peVB3LzdWV2xvTy85dDIxcmxuVkRBb0FNMnR2?=
 =?utf-8?B?N0E2YmtWeG9XeVNRN2lkYmR5OVBJc3YzVXdGaGpoMXpwS1hUMVVlL0s3MnB6?=
 =?utf-8?B?YUtxK1RFNVBFT2g4c2VMWm9YcGxjcFdLYzk2alNXaDhUK3RjOUE0VFl4WkpS?=
 =?utf-8?B?bkE9PQ==?=
Content-Type: text/plain; charset="utf-8"
Content-ID: <993F057689964249A131C4347A01AFB8@namprd04.prod.outlook.com>
Content-Transfer-Encoding: base64
MIME-Version: 1.0
X-MS-Exchange-AntiSpam-ExternalHop-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-ExternalHop-MessageData-0: =?utf-8?B?WitOSVphTnVXdzhGZU1NN3ltQmt1eGZwRkt1M2R0TWh3U3pTenNnUSs3UElr?=
 =?utf-8?B?L0ttUmlsTHE3UWxGOExZK01rNTBnVFlucDlPMTI4SlViZG8wUnBUYUhmRU5j?=
 =?utf-8?B?enpuZXpITTNVMzBMVHhGaU93R2NUa1hWcWMybFRXcnBoN0p3bWNkRmQycDEv?=
 =?utf-8?B?WVN1d3VHMUgxOVJqbEF1RUk1SzdXajJXU1NnaHB4VDZKS3ZQMFBOQUt5Q00y?=
 =?utf-8?B?eHIzOEtrUzdMbHYyVkFSVDM0cHhEUEo5L3lqQkdJMDFhODQvN1piNUFiNmRv?=
 =?utf-8?B?b1FNbERxajBMYW9sSDhHQVhGUnJFemxaNCtXMndyU1Q4Y1dXdnV1ME9MSHJV?=
 =?utf-8?B?SEF4VUd2My9oVVUwcWVoYVd1c3l3bmxQNXZ0Y1l4L0kvREs5WWlNY0ZvMk9l?=
 =?utf-8?B?Y0o2Q1NhMjhLOERWOWdCTkJCNFlEZUt4RmRNdHVaNVN0YVZTYUNzWDVPSkZn?=
 =?utf-8?B?MThBOW1jdWZ1S2pWQktaY2Z3eFlkeEhoYmd2cmpRRXNLQi9YQ0NyczVqemdX?=
 =?utf-8?B?WWZTaTBRWWZRVlZIaXNib0xqUFBZMnJRNk5jY2F0Z29ZeVJHM2plMU1sUlRG?=
 =?utf-8?B?NFk5NmpWMGNsNk5GWG1aTGE4YlkxTGd4a1c5SUNsR1orQUNrcEZyZWVsMkJQ?=
 =?utf-8?B?MVYzL2tBcmJaZWo2a1BPVUNUeGVHdTVzbnp6OFZsKzdRNkw2VUM5RlVNbEZ0?=
 =?utf-8?B?TGZGa1Zia3ZVRnlQNHVMRHpBS2o4ZWFVTXpHTStYeXFVbVBKL2ZibHcySWJt?=
 =?utf-8?B?Wjd0VXJXZE1kT29mMlFIUGl1SWthdnZhZ1pmeXlOd0FlWllCZVZNS2t2bTZ3?=
 =?utf-8?B?djNvSEd0Wk9qOFRHOER4S0xhZWUyV0wvZlFpVDZEYnJUNXR4QWQ5OUpXYjZh?=
 =?utf-8?B?WjVTU25pSE9FY01zSHJYQjN5Q010MjRDQU5aSktzM2cvWGlWWE1iczIrclF4?=
 =?utf-8?B?M3FPNGx3UzBmSE56NlI4SmtwNlZvR3pyblhvK3UyMXl5b2dvUVpYUTdSNWpr?=
 =?utf-8?B?UGNsMEpsSTBXOTRiVFByMWFIQUZCckwwZE8wUENuRUQreDIzVEhHSnphb0Rw?=
 =?utf-8?B?M0txSlYzQ0JsQWxTcnhnaDNpN3I4THpuejRxSEIxRHlMZUYzOFArRFVMQ1VR?=
 =?utf-8?B?S3A1eVlOSG1CS24wTkJsc28wZHBsOW9qSHRTeGhuMStXUStGVzZoZ09Jd2tN?=
 =?utf-8?B?blNONm5IZDVkaG9INlhWcUJOTzg0Yks2YXZQZWNxOTFNR2dqSlMybGJnWUtX?=
 =?utf-8?B?Uk9NU0NwVWFTVHpwaExWK3hiamM0NXF3UXhYWVRNVHBWYzhvb1E3NHFMV2xY?=
 =?utf-8?B?MU1EUzZiRnh4N0VtdVQ0T0YzaTk5QUpJZFZMRllMbEZYUnNBN2xPTXRLNkFs?=
 =?utf-8?B?MWJtaUVNUFFJbG5Ubk9BYzJuS3hOdms2SDFEZ1pFMjluc3huZEVCY3cxNVVv?=
 =?utf-8?B?MEErMVQ3UVg2dktrbVNjbVpJdGV5aG5JcElaODJZeTlJcGk5Ukh4OUhMdkRx?=
 =?utf-8?Q?2oQG0BzoW6AD+zyP+VkekgY4vB1?=
X-OriginatorOrg: wdc.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-AuthSource: SN4PR0401MB3582.namprd04.prod.outlook.com
X-MS-Exchange-CrossTenant-Network-Message-Id: 0284f0b2-d467-4fd6-6924-08dbb06b8c50
X-MS-Exchange-CrossTenant-originalarrivaltime: 08 Sep 2023 13:00:16.4583
 (UTC)
X-MS-Exchange-CrossTenant-fromentityheader: Hosted
X-MS-Exchange-CrossTenant-id: b61c8803-16f3-4c35-9b17-6f65f441df86
X-MS-Exchange-CrossTenant-mailboxtype: HOSTED
X-MS-Exchange-CrossTenant-userprincipalname: 2vTtdM/jBR7lj5IFME9MCNAdFMmRyeNENZdLGh/bNw/9JhfomvfNctNuJ5jEReV5ubn7yFXAxZBDvdz859nk5A==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: DM6PR04MB6623
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

T24gNy8yNS8yMyAyMDozOSwgRmFuIE5pIHdyb3RlOg0KPiBGcm9tOiBGYW4gTmkgPG5pZmFuQG91
dGxvb2suY29tPg0KPiANCj4gUGVyIENYTCBzcGVjIDMuMCwgdHdvIG1haWxib3ggY29tbWFuZHMg
YXJlIGltcGxlbWVudGVkOg0KPiBBZGQgRHluYW1pYyBDYXBhY2l0eSBSZXNwb25zZSAoT3Bjb2Rl
IDQ4MDJoKSA4LjIuOS44LjkuMywgYW5kDQo+IFJlbGVhc2UgRHluYW1pYyBDYXBhY2l0eSAoT3Bj
b2RlIDQ4MDNoKSA4LjIuOS44LjkuNC4NCj4gDQo+IFNpZ25lZC1vZmYtYnk6IEZhbiBOaSA8ZmFu
Lm5pQHNhbXN1bmcuY29tPg0KPiAtLS0NCj4gICBody9jeGwvY3hsLW1haWxib3gtdXRpbHMuYyAg
fCAyNTMgKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrDQo+ICAgaW5jbHVkZS9o
dy9jeGwvY3hsX2RldmljZS5oIHwgICAzICstDQo+ICAgMiBmaWxlcyBjaGFuZ2VkLCAyNTUgaW5z
ZXJ0aW9ucygrKSwgMSBkZWxldGlvbigtKQ0KPiANCj4gZGlmZiAtLWdpdCBhL2h3L2N4bC9jeGwt
bWFpbGJveC11dGlscy5jIGIvaHcvY3hsL2N4bC1tYWlsYm94LXV0aWxzLmMNCj4gaW5kZXggM2Qy
NWE5Njk3ZS4uMWU0OTQ0ZGE5NSAxMDA2NDQNCj4gLS0tIGEvaHcvY3hsL2N4bC1tYWlsYm94LXV0
aWxzLmMNCj4gKysrIGIvaHcvY3hsL2N4bC1tYWlsYm94LXV0aWxzLmMNCj4gQEAgLTg0LDYgKzg0
LDggQEAgZW51bSB7DQo+ICAgICAgIERDRF9DT05GSUcgID0gMHg0OCwgLypyMy4wOiA4LjIuOS44
LjkqLw0KPiAgICAgICAgICAgI2RlZmluZSBHRVRfRENfQ09ORklHICAgICAgICAgIDB4MA0KPiAg
ICAgICAgICAgI2RlZmluZSBHRVRfRFlOX0NBUF9FWFRfTElTVCAgIDB4MQ0KPiArICAgICAgICAj
ZGVmaW5lIEFERF9EWU5fQ0FQX1JTUCAgICAgICAgMHgyDQo+ICsgICAgICAgICNkZWZpbmUgUkVM
RUFTRV9EWU5fQ0FQICAgICAgICAweDMNCj4gICAgICAgUEhZU0lDQUxfU1dJVENIID0gMHg1MQ0K
PiAgICAgICAgICAgI2RlZmluZSBJREVOVElGWV9TV0lUQ0hfREVWSUNFICAgICAgMHgwDQo+ICAg
fTsNCj4gQEAgLTEwODYsNiArMTA4OCwyNTEgQEAgc3RhdGljIENYTFJldENvZGUgY21kX2RjZF9n
ZXRfZHluX2NhcF9leHRfbGlzdChzdHJ1Y3QgY3hsX2NtZCAqY21kLA0KPiAgICAgICByZXR1cm4g
Q1hMX01CT1hfU1VDQ0VTUzsNCj4gICB9DQo+IA0KPiArLyoNCj4gKyAqIENoZWNrIHdoZXRoZXIg
dGhlIGJpdHMgYXQgYWRkciBiZXR3ZWVuIFtuciwgbnIrc2l6ZSkgYXJlIGFsbCBzZXQsDQo+ICsg
KiByZXR1cm4gMSBpZiBhbGwgMXMsIGVsc2UgcmV0dXJuIDANCj4gKyAqLw0KPiArc3RhdGljIGlu
bGluZSBpbnQgdGVzdF9iaXRzKGNvbnN0IHVuc2lnbmVkIGxvbmcgKmFkZHIsIGludCBuciwgaW50
IHNpemUpDQo+ICt7DQo+ICsgICAgdW5zaWduZWQgbG9uZyByZXMgPSBmaW5kX25leHRfemVyb19i
aXQoYWRkciwgc2l6ZSArIG5yLCBucik7DQo+ICsNCj4gKyAgICByZXR1cm4gKHJlcyA+PSBuciAr
IHNpemUpID8gMSA6IDA7DQo+ICt9DQo+ICsNCj4gKy8qDQo+ICsgKiBGaW5kIGR5bmFtaWMgY2Fw
YWNpdHkgcmVnaW9uIGlkIGJhc2VkIG9uIGRwYSByYW5nZSBbZHBhLCBkcGErbGVuKQ0KPiArICov
DQo+ICtzdGF0aWMgdWludDhfdCBmaW5kX3JlZ2lvbl9pZChzdHJ1Y3QgQ1hMVHlwZTNEZXYgKmRl
diwgdWludDY0X3QgZHBhLA0KPiArICAgICAgICB1aW50NjRfdCBsZW4pDQo+ICt7DQo+ICsgICAg
aW50OF90IGkgPSBkZXYtPmRjLm51bV9yZWdpb25zIC0gMTsNCj4gKw0KPiArICAgIHdoaWxlIChp
ID4gMCAmJiBkcGEgPCBkZXYtPmRjLnJlZ2lvbnNbaV0uYmFzZSkgew0KPiArICAgICAgICBpLS07
DQo+ICsgICAgfQ0KPiArDQo+ICsgICAgaWYgKGRwYSA8IGRldi0+ZGMucmVnaW9uc1tpXS5iYXNl
DQo+ICsgICAgICAgICAgICB8fCBkcGEgKyBsZW4gPiBkZXYtPmRjLnJlZ2lvbnNbaV0uYmFzZSAr
IGRldi0+ZGMucmVnaW9uc1tpXS5sZW4pIHsNCj4gKyAgICAgICAgcmV0dXJuIGRldi0+ZGMubnVt
X3JlZ2lvbnM7DQo+ICsgICAgfQ0KPiArDQo+ICsgICAgcmV0dXJuIGk7DQo+ICt9DQo+ICsNCj4g
K3N0YXRpYyB2b2lkIGluc2VydF9leHRlbnRfdG9fZXh0ZW50X2xpc3QoQ1hMRENERXh0ZW50TGlz
dCAqbGlzdCwgdWludDY0X3QgZHBhLA0KPiArICAgICAgICB1aW50NjRfdCBsZW4sIHVpbnQ4X3Qg
KnRhZywgdWludDE2X3Qgc2hhcmVkX3NlcSkNCj4gK3sNCj4gKyAgICBDWExEQ0RfRXh0ZW50ICpl
eHRlbnQ7DQo+ICsgICAgZXh0ZW50ID0gZ19uZXcwKENYTERDRF9FeHRlbnQsIDEpOw0KPiArICAg
IGV4dGVudC0+c3RhcnRfZHBhID0gZHBhOw0KPiArICAgIGV4dGVudC0+bGVuID0gbGVuOw0KPiAr
ICAgIGlmICh0YWcpIHsNCj4gKyAgICAgICAgbWVtY3B5KGV4dGVudC0+dGFnLCB0YWcsIDB4MTAp
Ow0KPiArICAgIH0gZWxzZSB7DQo+ICsgICAgICAgIG1lbXNldChleHRlbnQtPnRhZywgMCwgMHgx
MCk7DQo+ICsgICAgfQ0KPiArICAgIGV4dGVudC0+c2hhcmVkX3NlcSA9IHNoYXJlZF9zZXE7DQo+
ICsNCj4gKyAgICBRVEFJTFFfSU5TRVJUX1RBSUwobGlzdCwgZXh0ZW50LCBub2RlKTsNCj4gK30N
Cj4gKw0KPiArdHlwZWRlZiBzdHJ1Y3QgdXBkYXRlZF9kY19leHRlbnRfbGlzdF9pbl9wbCB7DQo+
ICsgICAgdWludDMyX3QgbnVtX2VudHJpZXNfdXBkYXRlZDsNCj4gKyAgICB1aW50OF90IHJzdmRb
NF07DQo+ICsgICAgc3RydWN0IHsgLyogcjMuMDogVGFibGUgOC0xMzAgKi8NCj4gKyAgICAgICAg
dWludDY0X3Qgc3RhcnRfZHBhOw0KPiArICAgICAgICB1aW50NjRfdCBsZW47DQo+ICsgICAgICAg
IHVpbnQ4X3QgcnN2ZFs4XTsNCj4gKyAgICB9IFFFTVVfUEFDS0VEIHVwZGF0ZWRfZW50cmllc1td
Ow0KPiArfSBRRU1VX1BBQ0tFRCB1cGRhdGVkX2RjX2V4dGVudF9saXN0X2luX3BsOw0KPiArDQo+
ICsvKg0KPiArICogVGhlIGZ1bmN0aW9uIG9ubHkgY2hlY2sgdGhlIGlucHV0IGV4dGVudCBsaXN0
IGFnYWluc3QgaXRzZWxmLg0KPiArICovDQo+ICtzdGF0aWMgQ1hMUmV0Q29kZSBkZXRlY3RfbWFs
Zm9ybWVkX2V4dGVudF9saXN0KENYTFR5cGUzRGV2ICpkZXYsDQo+ICsgICAgICAgIGNvbnN0IHVw
ZGF0ZWRfZGNfZXh0ZW50X2xpc3RfaW5fcGwgKmluKQ0KPiArew0KPiArICAgIHVuc2lnbmVkIGxv
bmcgKmJsa19iaXRtYXA7DQo+ICsgICAgdWludDY0X3QgbWluX2Jsb2NrX3NpemUgPSBkZXYtPmRj
LnJlZ2lvbnNbMF0uYmxvY2tfc2l6ZTsNCj4gKyAgICBzdHJ1Y3QgQ1hMRENEX1JlZ2lvbiAqcmVn
aW9uID0gJmRldi0+ZGMucmVnaW9uc1swXTsNCj4gKyAgICB1aW50MzJfdCBpOw0KPiArICAgIHVp
bnQ2NF90IGRwYSwgbGVuOw0KPiArICAgIHVpbnQ4X3QgcmlkOw0KPiArICAgIENYTFJldENvZGUg
cmV0Ow0KPiArDQo+ICsgICAgZm9yIChpID0gMTsgaSA8IGRldi0+ZGMubnVtX3JlZ2lvbnM7IGkr
Kykgew0KPiArICAgICAgICByZWdpb24gPSAmZGV2LT5kYy5yZWdpb25zW2ldOw0KPiArICAgICAg
ICBpZiAobWluX2Jsb2NrX3NpemUgPiByZWdpb24tPmJsb2NrX3NpemUpIHsNCj4gKyAgICAgICAg
ICAgIG1pbl9ibG9ja19zaXplID0gcmVnaW9uLT5ibG9ja19zaXplOw0KPiArICAgICAgICB9DQo+
ICsgICAgfQ0KPiArDQo+ICsgICAgYmxrX2JpdG1hcCA9IGJpdG1hcF9uZXcoKHJlZ2lvbi0+bGVu
ICsgcmVnaW9uLT5iYXNlDQo+ICsgICAgICAgICAgICAgICAgLSBkZXYtPmRjLnJlZ2lvbnNbMF0u
YmFzZSkgLyBtaW5fYmxvY2tfc2l6ZSk7DQo+ICsNCj4gKyAgICBmb3IgKGkgPSAwOyBpIDwgaW4t
Pm51bV9lbnRyaWVzX3VwZGF0ZWQ7IGkrKykgew0KPiArICAgICAgICBkcGEgPSBpbi0+dXBkYXRl
ZF9lbnRyaWVzW2ldLnN0YXJ0X2RwYTsNCj4gKyAgICAgICAgbGVuID0gaW4tPnVwZGF0ZWRfZW50
cmllc1tpXS5sZW47DQo+ICsNCj4gKyAgICAgICAgcmlkID0gZmluZF9yZWdpb25faWQoZGV2LCBk
cGEsIGxlbik7DQo+ICsgICAgICAgIGlmIChyaWQgPT0gZGV2LT5kYy5udW1fcmVnaW9ucykgew0K
PiArICAgICAgICAgICAgcmV0ID0gQ1hMX01CT1hfSU5WQUxJRF9QQTsNCj4gKyAgICAgICAgICAg
IGdvdG8gb3V0Ow0KPiArICAgICAgICB9DQo+ICsNCj4gKyAgICAgICAgcmVnaW9uID0gJmRldi0+
ZGMucmVnaW9uc1tyaWRdOw0KPiArICAgICAgICBpZiAoZHBhICUgcmVnaW9uLT5ibG9ja19zaXpl
IHx8IGxlbiAlIHJlZ2lvbi0+YmxvY2tfc2l6ZSkgew0KPiArICAgICAgICAgICAgcmV0ID0gQ1hM
X01CT1hfSU5WQUxJRF9FWFRFTlRfTElTVDsNCj4gKyAgICAgICAgICAgIGdvdG8gb3V0Ow0KPiAr
ICAgICAgICB9DQoNCkhpLA0KDQpUaGUgYml0bWFwIHVzZXMgdGhlIGRjIHJlZ2lvbiAwIGJhc2Ug
YWRkcmVzcyBhcyB0aGUgYmFzZWxpbmUsIHNvIHdoZW4gDQpjaGVja2luZyB0aGUgZHBhIGFnYWlu
c3QgdGhlIGJpdG1hcCBpdCBuZWVkcyB0byBiZSBhZGp1c3RlZCBmb3IgdGhhdCANCmJlZm9yZSB0
aGUgYml0bWFwIGNoZWNrcywgZS5nLiwNCg0KKyAgICAgICAgZHBhIC09IGRldi0+ZGMucmVnaW9u
c1swXS5iYXNlOw0KDQpUaGFua3MsDQpKb3JnZW4NCg0KPiArICAgICAgICAvKiB0aGUgZHBhIHJh
bmdlIGFscmVhZHkgY292ZXJlZCBieSBzb21lIG90aGVyIGV4dGVudHMgaW4gdGhlIGxpc3QgKi8N
Cj4gKyAgICAgICAgaWYgKHRlc3RfYml0cyhibGtfYml0bWFwLCBkcGEgLyBtaW5fYmxvY2tfc2l6
ZSwgbGVuIC8gbWluX2Jsb2NrX3NpemUpKSB7DQo+ICsgICAgICAgICAgICByZXQgPSBDWExfTUJP
WF9JTlZBTElEX0VYVEVOVF9MSVNUOw0KPiArICAgICAgICAgICAgZ290byBvdXQ7DQo+ICsgICAg
ICAgIH0NCj4gKyAgICAgICAgYml0bWFwX3NldChibGtfYml0bWFwLCBkcGEgLyBtaW5fYmxvY2tf
c2l6ZSwgbGVuIC8gbWluX2Jsb2NrX3NpemUpOw0KPiArICAgfQ0KPiArDQo+ICsgICAgcmV0ID0g
Q1hMX01CT1hfU1VDQ0VTUzsNCj4gKw0KPiArb3V0Og0KPiArICAgIGdfZnJlZShibGtfYml0bWFw
KTsNCj4gKyAgICByZXR1cm4gcmV0Ow0KPiArfQ0KPiArDQo+ICsvKg0KPiArICogY3hsIHNwZWMg
My4wOiA4LjIuOS44LjkuMw0KPiArICogQWRkIER5bmFtaWMgQ2FwYWNpdHkgUmVzcG9uc2UgKG9w
Y29kZSA0ODAyaCkNCj4gKyAqIEFzc3VtZSBhbiBleHRlbnQgaXMgYWRkZWQgb25seSBhZnRlciB0
aGUgcmVzcG9uc2UgaXMgcHJvY2Vzc2VkIHN1Y2Nlc3NmdWxseQ0KPiArICogVE9ETzogZm9yIGJl
dHRlciBleHRlbnQgbGlzdCB2YWxpZGF0aW9uLCBhIGJldHRlciBzb2x1dGlvbiB3b3VsZCBiZQ0K
PiArICogbWFpbnRhaW5pbmcgYSBwZW5kaW5nIGV4dGVudCBsaXN0IGFuZCB1c2UgaXQgdG8gdmVy
aWZ5IHRoZSBleHRlbnQgbGlzdCBpbg0KPiArICogdGhlIHJlc3BvbnNlLg0KPiArICovDQo+ICtz
dGF0aWMgQ1hMUmV0Q29kZSBjbWRfZGNkX2FkZF9keW5fY2FwX3JzcChzdHJ1Y3QgY3hsX2NtZCAq
Y21kLA0KPiArICAgICAgICBDWExEZXZpY2VTdGF0ZSAqY3hsX2RzdGF0ZSwgdWludDE2X3QgKmxl
bl91bnVzZWQpDQo+ICt7DQo+ICsgICAgdXBkYXRlZF9kY19leHRlbnRfbGlzdF9pbl9wbCAqaW4g
PSAodm9pZCAqKWNtZC0+cGF5bG9hZDsNCj4gKyAgICBzdHJ1Y3QgQ1hMVHlwZTNEZXYgKmN0M2Qg
PSBjb250YWluZXJfb2YoY3hsX2RzdGF0ZSwgQ1hMVHlwZTNEZXYsDQo+ICsgICAgICAgICAgICBj
eGxfZHN0YXRlKTsNCj4gKyAgICBDWExEQ0RFeHRlbnRMaXN0ICpleHRlbnRfbGlzdCA9ICZjdDNk
LT5kYy5leHRlbnRzOw0KPiArICAgIENYTERDRF9FeHRlbnQgKmVudDsNCj4gKyAgICB1aW50MzJf
dCBpOw0KPiArICAgIHVpbnQ2NF90IGRwYSwgbGVuOw0KPiArICAgIENYTFJldENvZGUgcmV0Ow0K
PiArDQo+ICsgICAgaWYgKGluLT5udW1fZW50cmllc191cGRhdGVkID09IDApIHsNCj4gKyAgICAg
ICAgcmV0ID0gQ1hMX01CT1hfU1VDQ0VTUzsNCj4gKyAgICAgICAgZ290byBvdXQ7DQo+ICsgICAg
fQ0KPiArDQo+ICsgICAgcmV0ID0gZGV0ZWN0X21hbGZvcm1lZF9leHRlbnRfbGlzdChjdDNkLCBp
bik7DQo+ICsgICAgaWYgKHJldCAhPSBDWExfTUJPWF9TVUNDRVNTKSB7DQo+ICsgICAgICAgIGdv
dG8gb3V0Ow0KPiArICAgIH0NCj4gKw0KPiArICAgIGZvciAoaSA9IDA7IGkgPCBpbi0+bnVtX2Vu
dHJpZXNfdXBkYXRlZDsgaSsrKSB7DQo+ICsgICAgICAgIGRwYSA9IGluLT51cGRhdGVkX2VudHJp
ZXNbaV0uc3RhcnRfZHBhOw0KPiArICAgICAgICBsZW4gPSBpbi0+dXBkYXRlZF9lbnRyaWVzW2ld
LmxlbjsNCj4gKw0KPiArICAgICAgICAvKg0KPiArICAgICAgICAgKiBDaGVjayBpZiB0aGUgRFBB
IHJhbmdlIG9mIHRoZSB0by1iZS1hZGRlZCBleHRlbnQgb3ZlcmxhcHMgd2l0aA0KPiArICAgICAg
ICAgKiBleGlzdGluZyBleHRlbnQgbGlzdCBtYWludGFpbmVkIGJ5IHRoZSBkZXZpY2UuDQo+ICsg
ICAgICAgICAqLw0KPiArICAgICAgICBRVEFJTFFfRk9SRUFDSChlbnQsIGV4dGVudF9saXN0LCBu
b2RlKSB7DQo+ICsgICAgICAgICAgICBpZiAoZW50LT5zdGFydF9kcGEgPT0gZHBhICYmIGVudC0+
bGVuID09IGxlbikgew0KPiArICAgICAgICAgICAgICAgIHJldCA9IENYTF9NQk9YX0lOVkFMSURf
UEE7DQo+ICsgICAgICAgICAgICAgICAgZ290byBvdXQ7DQo+ICsgICAgICAgICAgICB9IGVsc2Ug
aWYgKGVudC0+c3RhcnRfZHBhIDw9IGRwYQ0KPiArICAgICAgICAgICAgICAgICAgICAmJiBkcGEg
KyBsZW4gPD0gZW50LT5zdGFydF9kcGEgKyBlbnQtPmxlbikgew0KPiArICAgICAgICAgICAgICAg
IHJldCA9IENYTF9NQk9YX0lOVkFMSURfUEE7DQo+ICsgICAgICAgICAgICAgICAgZ290byBvdXQ7
DQo+ICsgICAgICAgICAgICB9IGVsc2UgaWYgKChkcGEgPCBlbnQtPnN0YXJ0X2RwYSArIGVudC0+
bGVuDQo+ICsgICAgICAgICAgICAgICAgICAgICAgICAmJiBkcGEgKyBsZW4gPiBlbnQtPnN0YXJ0
X2RwYSArIGVudC0+bGVuKQ0KPiArICAgICAgICAgICAgICAgICAgICB8fCAoZHBhIDwgZW50LT5z
dGFydF9kcGEgJiYgZHBhICsgbGVuID4gZW50LT5zdGFydF9kcGEpKSB7DQo+ICsgICAgICAgICAg
ICAgICAgcmV0ID0gQ1hMX01CT1hfSU5WQUxJRF9QQTsNCj4gKyAgICAgICAgICAgICAgICBnb3Rv
IG91dDsNCj4gKyAgICAgICAgICAgIH0NCj4gKyAgICAgICAgfQ0KPiArDQo+ICsgICAgICAgIC8q
DQo+ICsgICAgICAgICAqIFRPRE86IGFkZCBhIHBlbmRpbmcgZXh0ZW50IGxpc3QgYmFzZWQgb24g
ZXZlbnQgbG9nIHJlY29yZCBhbmQgdmVyaWZ5DQo+ICsgICAgICAgICAqIHRoZSBpbnB1dCByZXNw
b25zZQ0KPiArICAgICAgICAgKi8NCj4gKw0KPiArICAgICAgICBpbnNlcnRfZXh0ZW50X3RvX2V4
dGVudF9saXN0KGV4dGVudF9saXN0LCBkcGEsIGxlbiwgTlVMTCwgMCk7DQo+ICsgICAgfQ0KPiAr
ICAgIHJldCA9IENYTF9NQk9YX1NVQ0NFU1M7DQo+ICsNCj4gK291dDoNCj4gKyAgICByZXR1cm4g
cmV0Ow0KPiArfQ0KPiArDQo+ICsvKg0KPiArICogU3BlYyAzLjA6IDguMi45LjguOS40DQo+ICsg
KiBSZWxlYXNlIER5bmFtaWMgQ2FwYWNpdHkgKG9wY29kZSA0ODAzaCkNCj4gKyAqKi8NCj4gK3N0
YXRpYyBDWExSZXRDb2RlIGNtZF9kY2RfcmVsZWFzZV9keW5fY2FwKHN0cnVjdCBjeGxfY21kICpj
bWQsDQo+ICsgICAgICAgIENYTERldmljZVN0YXRlICpjeGxfZHN0YXRlLA0KPiArICAgICAgICB1
aW50MTZfdCAqbGVuX3VudXNlZCkNCj4gK3sNCj4gKyAgICB1cGRhdGVkX2RjX2V4dGVudF9saXN0
X2luX3BsICppbiA9ICh2b2lkICopY21kLT5wYXlsb2FkOw0KPiArICAgIHN0cnVjdCBDWExUeXBl
M0RldiAqY3QzZCA9IGNvbnRhaW5lcl9vZihjeGxfZHN0YXRlLCBDWExUeXBlM0RldiwNCj4gKyAg
ICAgICAgICAgIGN4bF9kc3RhdGUpOw0KPiArICAgIENYTERDREV4dGVudExpc3QgKmV4dGVudF9s
aXN0ID0gJmN0M2QtPmRjLmV4dGVudHM7DQo+ICsgICAgQ1hMRENEX0V4dGVudCAqZW50Ow0KPiAr
ICAgIHVpbnQzMl90IGk7DQo+ICsgICAgdWludDY0X3QgZHBhLCBsZW47DQo+ICsgICAgQ1hMUmV0
Q29kZSByZXQ7DQo+ICsNCj4gKyAgICBpZiAoaW4tPm51bV9lbnRyaWVzX3VwZGF0ZWQgPT0gMCkg
ew0KPiArICAgICAgICByZXR1cm4gQ1hMX01CT1hfSU5WQUxJRF9JTlBVVDsNCj4gKyAgICB9DQo+
ICsNCj4gKyAgICByZXQgPSBkZXRlY3RfbWFsZm9ybWVkX2V4dGVudF9saXN0KGN0M2QsIGluKTsN
Cj4gKyAgICBpZiAocmV0ICE9IENYTF9NQk9YX1NVQ0NFU1MpIHsNCj4gKyAgICAgICAgcmV0dXJu
IHJldDsNCj4gKyAgICB9DQo+ICsNCj4gKyAgICBmb3IgKGkgPSAwOyBpIDwgaW4tPm51bV9lbnRy
aWVzX3VwZGF0ZWQ7IGkrKykgew0KPiArICAgICAgICBkcGEgPSBpbi0+dXBkYXRlZF9lbnRyaWVz
W2ldLnN0YXJ0X2RwYTsNCj4gKyAgICAgICAgbGVuID0gaW4tPnVwZGF0ZWRfZW50cmllc1tpXS5s
ZW47DQo+ICsNCj4gKyAgICAgICAgUVRBSUxRX0ZPUkVBQ0goZW50LCBleHRlbnRfbGlzdCwgbm9k
ZSkgew0KPiArICAgICAgICAgICAgaWYgKGVudC0+c3RhcnRfZHBhID09IGRwYSAmJiBlbnQtPmxl
biA9PSBsZW4pIHsNCj4gKyAgICAgICAgICAgICAgICBicmVhazsNCj4gKyAgICAgICAgICAgIH0g
ZWxzZSBpZiAoZW50LT5zdGFydF9kcGEgPCBkcGENCj4gKyAgICAgICAgICAgICAgICAgICAgJiYg
ZHBhICsgbGVuIDw9IGVudC0+c3RhcnRfZHBhICsgZW50LT5sZW4pIHsNCj4gKyAgICAgICAgICAg
ICAgICAvKiByZW1vdmUgcGFydGlhbCBleHRlbnQgKi8NCj4gKyAgICAgICAgICAgICAgICB1aW50
NjRfdCBsZW4xID0gZHBhIC0gZW50LT5zdGFydF9kcGE7DQo+ICsgICAgICAgICAgICAgICAgdWlu
dDY0X3QgbGVuMiA9IGVudC0+c3RhcnRfZHBhICsgZW50LT5sZW4gLSBkcGEgLSBsZW47DQo+ICsN
Cj4gKyAgICAgICAgICAgICAgICBpZiAobGVuMSkgew0KPiArICAgICAgICAgICAgICAgICAgICBp
bnNlcnRfZXh0ZW50X3RvX2V4dGVudF9saXN0KGV4dGVudF9saXN0LCBlbnQtPnN0YXJ0X2RwYSwN
Cj4gKyAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW4xLCBOVUxMLCAwKTsNCj4gKyAgICAg
ICAgICAgICAgICB9DQo+ICsgICAgICAgICAgICAgICAgaWYgKGxlbjIpIHsNCj4gKyAgICAgICAg
ICAgICAgICAgICAgaW5zZXJ0X2V4dGVudF90b19leHRlbnRfbGlzdChleHRlbnRfbGlzdCwgZHBh
ICsgbGVuLCBsZW4yLA0KPiArICAgICAgICAgICAgICAgICAgICAgICAgICAgIE5VTEwsIDApOw0K
PiArICAgICAgICAgICAgICAgIH0NCj4gKyAgICAgICAgICAgICAgICBicmVhazsNCj4gKyAgICAg
ICAgICAgIH0gZWxzZSBpZiAoKGRwYSA8IGVudC0+c3RhcnRfZHBhICsgZW50LT5sZW4NCj4gKyAg
ICAgICAgICAgICAgICAgICAgICAgICYmIGRwYSArIGxlbiA+IGVudC0+c3RhcnRfZHBhICsgZW50
LT5sZW4pDQo+ICsgICAgICAgICAgICAgICAgICAgIHx8IChkcGEgPCBlbnQtPnN0YXJ0X2RwYSAm
JiBkcGEgKyBsZW4gPiBlbnQtPnN0YXJ0X2RwYSkpDQo+ICsgICAgICAgICAgICAgICAgcmV0dXJu
IENYTF9NQk9YX0lOVkFMSURfRVhURU5UX0xJU1Q7DQo+ICsgICAgICAgIH0NCj4gKw0KPiArICAg
ICAgICBpZiAoZW50KSB7DQo+ICsgICAgICAgICAgICBRVEFJTFFfUkVNT1ZFKGV4dGVudF9saXN0
LCBlbnQsIG5vZGUpOw0KPiArICAgICAgICAgICAgZ19mcmVlKGVudCk7DQo+ICsgICAgICAgIH0g
ZWxzZSB7DQo+ICsgICAgICAgICAgICAvKiBUcnkgdG8gcmVtb3ZlIGEgbm9uLWV4aXN0aW5nIGV4
dGVudCAqLw0KPiArICAgICAgICAgICAgcmV0dXJuIENYTF9NQk9YX0lOVkFMSURfUEE7DQo+ICsg
ICAgICAgIH0NCj4gKyAgICB9DQo+ICsNCj4gKyAgICByZXR1cm4gQ1hMX01CT1hfU1VDQ0VTUzsN
Cj4gK30NCj4gKw0KPiAgICNkZWZpbmUgSU1NRURJQVRFX0NPTkZJR19DSEFOR0UgKDEgPDwgMSkN
Cj4gICAjZGVmaW5lIElNTUVESUFURV9EQVRBX0NIQU5HRSAoMSA8PCAyKQ0KPiAgICNkZWZpbmUg
SU1NRURJQVRFX1BPTElDWV9DSEFOR0UgKDEgPDwgMykNCj4gQEAgLTExMjksNiArMTM3NiwxMiBA
QCBzdGF0aWMgc3RydWN0IGN4bF9jbWQgY3hsX2NtZF9zZXRbMjU2XVsyNTZdID0gew0KPiAgICAg
ICBbRENEX0NPTkZJR11bR0VUX0RZTl9DQVBfRVhUX0xJU1RdID0gew0KPiAgICAgICAgICAgIkRD
RF9HRVRfRFlOQU1JQ19DQVBBQ0lUWV9FWFRFTlRfTElTVCIsIGNtZF9kY2RfZ2V0X2R5bl9jYXBf
ZXh0X2xpc3QsDQo+ICAgICAgICAgICA4LCAwIH0sDQo+ICsgICAgW0RDRF9DT05GSUddW0FERF9E
WU5fQ0FQX1JTUF0gPSB7DQo+ICsgICAgICAgICJBRERfRENEX0RZTkFNSUNfQ0FQQUNJVFlfUkVT
UE9OU0UiLCBjbWRfZGNkX2FkZF9keW5fY2FwX3JzcCwNCj4gKyAgICAgICAgfjAsIElNTUVESUFU
RV9EQVRBX0NIQU5HRSB9LA0KPiArICAgIFtEQ0RfQ09ORklHXVtSRUxFQVNFX0RZTl9DQVBdID0g
ew0KPiArICAgICAgICAiUkVMRUFTRV9EQ0RfRFlOQU1JQ19DQVBBQ0lUWSIsIGNtZF9kY2RfcmVs
ZWFzZV9keW5fY2FwLA0KPiArICAgICAgICB+MCwgSU1NRURJQVRFX0RBVEFfQ0hBTkdFIH0sDQo+
ICAgfTsNCj4gDQo+ICAgc3RhdGljIHN0cnVjdCBjeGxfY21kIGN4bF9jbWRfc2V0X3N3WzI1Nl1b
MjU2XSA9IHsNCj4gZGlmZiAtLWdpdCBhL2luY2x1ZGUvaHcvY3hsL2N4bF9kZXZpY2UuaCBiL2lu
Y2x1ZGUvaHcvY3hsL2N4bF9kZXZpY2UuaA0KPiBpbmRleCAzYTMzOGIzYjM3Li4wMWE1ZWFjYTQ4
IDEwMDY0NA0KPiAtLS0gYS9pbmNsdWRlL2h3L2N4bC9jeGxfZGV2aWNlLmgNCj4gKysrIGIvaW5j
bHVkZS9ody9jeGwvY3hsX2RldmljZS5oDQo+IEBAIC0xMzAsNyArMTMwLDggQEAgdHlwZWRlZiBl
bnVtIHsNCj4gICAgICAgQ1hMX01CT1hfSU5DT1JSRUNUX1BBU1NQSFJBU0UgPSAweDE0LA0KPiAg
ICAgICBDWExfTUJPWF9VTlNVUFBPUlRFRF9NQUlMQk9YID0gMHgxNSwNCj4gICAgICAgQ1hMX01C
T1hfSU5WQUxJRF9QQVlMT0FEX0xFTkdUSCA9IDB4MTYsDQo+IC0gICAgQ1hMX01CT1hfTUFYID0g
MHgxNw0KPiArICAgIENYTF9NQk9YX0lOVkFMSURfRVhURU5UX0xJU1QgPSAweDFFLCAvKiBjeGwg
cjMuMDogVGFibGUgOC0zNCovDQo+ICsgICAgQ1hMX01CT1hfTUFYID0gMHgxRg0KPiAgIH0gQ1hM
UmV0Q29kZTsNCj4gDQo+ICAgc3RydWN0IGN4bF9jbWQ7DQo+IC0tDQo+IDIuMjUuMQ0K

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id DD9C1EE7FF2
	for <linux-cxl@archiver.kernel.org>; Fri,  8 Sep 2023 13:12:51 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S229699AbjIHNMy (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Fri, 8 Sep 2023 09:12:54 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:32998 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S243459AbjIHNMx (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Fri, 8 Sep 2023 09:12:53 -0400
Received: from esa5.hgst.iphmx.com (esa5.hgst.iphmx.com [216.71.153.144])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 1C80A19B5
        for <linux-cxl@vger.kernel.org>; Fri,  8 Sep 2023 06:12:49 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=simple/simple;
  d=wdc.com; i=@wdc.com; q=dns/txt; s=dkim.wdc.com;
  t=1694178769; x=1725714769;
  h=from:to:cc:subject:date:message-id:references:
   in-reply-to:content-id:content-transfer-encoding:
   mime-version;
  bh=6ONAQku2Q+Vo77gvZ0BxhAamhEWbvM7J6PCyx4L57l8=;
  b=S6nep1p3wu4909CEbQYgQUlZHQpmeecwtx1Cw/0arRxc/su1ydS1xhyl
   7xNRz0GuOA3kgDemRsaWS2rAuy7yWZdlrRTjGrVwP9GMGNxFHdhJiohi0
   lNgEd0zVOKTv92+XfIaGQcB7w8Op19u7ZgCdCxEPBZ1y1ZEsd760yrHCw
   mfWQ4F+DfUCkWxOF2jmA6OW+iMs6T9i1/nlE8NlJln/ZydBQBLhUnQFBo
   U2GhdrFu2n730JM4nHzN6BX237ABlD7Cx+b/mGzxopE56PpB50ujm9CdM
   5y/T2i6gEN+BdKySsS1tIWsC+pzj5gdtq2i2XiO03MZZBV4E+rTw3KKhp
   A==;
X-CSE-ConnectionGUID: VmneYmmLQMemfxyKZ5JaGg==
X-CSE-MsgGUID: I5lgTqu7R0efAp2votjXYQ==
X-IronPort-AV: E=Sophos;i="6.02,237,1688400000"; 
   d="scan'208";a="243310975"
Received: from mail-bn8nam12lp2174.outbound.protection.outlook.com (HELO NAM12-BN8-obe.outbound.protection.outlook.com) ([104.47.55.174])
  by ob1.hgst.iphmx.com with ESMTP; 08 Sep 2023 21:12:48 +0800
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=GWwkM0CoWt4ewBkaaMXyc5uASrBds4x2XQpChDBqqiJriBfdaNwJ0WGezxzQG3tAEP493EhOAo+5gaC+m3oT+K7YRD8LBwrqi+AUv4KUoOgCWif8Mj7JiWI5HiSfJ3E1TTp5wPYXM6s3zC/ESuD4ZEGe8cjShu2l0ztKnE88JY3T9XdnwyKoBhtzA1AkqTOxwpI1EtzcyEWqYUzBO7H5pw01HZNB84Kp5lAwb8jXNqCg8kZQelRTLnfgrEMgMynPAqtQaXMenvLj0FtfIgbSibfIuhBXMJ4AiVzfI63eMP9qVT8asp4xBkFbYDigFsrfy5abXuxebbkY5LsUWNbApg==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=6ONAQku2Q+Vo77gvZ0BxhAamhEWbvM7J6PCyx4L57l8=;
 b=e7dSItqLpXNw/LNkRPC/z4aUTlTqIr9Mb0jOoxsAfOZxO5jRBdtXdvLw0IHPM80LsJbVTCpdxy6hTkfbc/T3RKUAaNTtd43Uxx7iJtHdbf24pVBEZoX0N9QvVZa035+X5NfC/t+gsPDPb6yO2EkZs+zAz6SOP9L74uSt/hjZ79rk9H1TvrgL/cgthVEtQ5d60Qwo8+WmTiFGCR5IPCQH1o3yOdE3I+yMNsvXWIAIJ0FwpMw1K/gSS2qMS3j68whOjwA1yVIZwXJxmksklSFq8jtGPSnVPkuyRFNXJ0XxexNRifqUJg+OAcN56l7wvHacvP9jSlZJSSJghVaySVpoag==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=wdc.com; dmarc=pass action=none header.from=wdc.com; dkim=pass
 header.d=wdc.com; arc=none
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
 d=sharedspace.onmicrosoft.com; s=selector2-sharedspace-onmicrosoft-com;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-SenderADCheck;
 bh=6ONAQku2Q+Vo77gvZ0BxhAamhEWbvM7J6PCyx4L57l8=;
 b=d3ngLL/Q2SFyJHpztgUsBUi94JO8KoMu4Re8uR2HqGlO+jKFH6nQdwceusHBH/608FpiFmR6jR1TIRdSpRX/osQlknGYuyUnUeh9ffCCiGGUDqrxR323hHI1FPJKqxedmtAQIxvoW5WZA1ZWppvhXUdwQhiePH6QPNS+DQQ40Gs=
Received: from SN4PR0401MB3582.namprd04.prod.outlook.com
 (2603:10b6:803:4c::10) by BL3PR04MB8105.namprd04.prod.outlook.com
 (2603:10b6:208:348::23) with Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.6792.11; Fri, 8 Sep
 2023 13:12:45 +0000
Received: from SN4PR0401MB3582.namprd04.prod.outlook.com
 ([fe80::b35e:d4f9:1de8:f321]) by SN4PR0401MB3582.namprd04.prod.outlook.com
 ([fe80::b35e:d4f9:1de8:f321%6]) with mapi id 15.20.6792.009; Fri, 8 Sep 2023
 13:12:45 +0000
From: =?utf-8?B?SsO4cmdlbiBIYW5zZW4=?= <Jorgen.Hansen@wdc.com>
To: Fan Ni <fan.ni@samsung.com>,
        "qemu-devel@nongnu.org" <qemu-devel@nongnu.org>
CC: "jonathan.cameron@huawei.com" <jonathan.cameron@huawei.com>,
        "linux-cxl@vger.kernel.org" <linux-cxl@vger.kernel.org>,
        "gregory.price@memverge.com" <gregory.price@memverge.com>,
        "hchkuo@avery-design.com.tw" <hchkuo@avery-design.com.tw>,
        "cbrowy@avery-design.com" <cbrowy@avery-design.com>,
        "ira.weiny@intel.com" <ira.weiny@intel.com>,
        "dan.j.williams@intel.com" <dan.j.williams@intel.com>,
        Adam Manzanares <a.manzanares@samsung.com>,
        "dave@stgolabs.net" <dave@stgolabs.net>,
        "nmtadam.samsung@gmail.com" <nmtadam.samsung@gmail.com>,
        "nifan@outlook.com" <nifan@outlook.com>
Subject: Re: [Qemu PATCH v2 6/9] hw/mem/cxl_type3: Add DC extent list
 representative and get DC extent list mailbox support
Thread-Topic: [Qemu PATCH v2 6/9] hw/mem/cxl_type3: Add DC extent list
 representative and get DC extent list mailbox support
Thread-Index: AQHZvyd8GCwEW8xWH06l9DaX+skObrARLf8A
Date: Fri, 8 Sep 2023 13:12:45 +0000
Message-ID: <ca63022b-0447-74b8-06fc-0e6d47455ebc@wdc.com>
References: <20230725183939.2741025-1-fan.ni@samsung.com>
 <CGME20230725183957uscas1p28b38d294f90b97f99769466cc533b4de@uscas1p2.samsung.com>
 <20230725183939.2741025-7-fan.ni@samsung.com>
In-Reply-To: <20230725183939.2741025-7-fan.ni@samsung.com>
Accept-Language: en-GB, en-US
Content-Language: en-US
X-MS-Has-Attach: 
X-MS-TNEF-Correlator: 
authentication-results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=wdc.com;
x-ms-publictraffictype: Email
x-ms-traffictypediagnostic: SN4PR0401MB3582:EE_|BL3PR04MB8105:EE_
x-ms-office365-filtering-correlation-id: f06c4cf1-0097-403e-d1af-08dbb06d4abd
wdcipoutbound: EOP-TRUE
x-ms-exchange-senderadcheck: 1
x-ms-exchange-antispam-relay: 0
x-microsoft-antispam: BCL:0;
x-microsoft-antispam-message-info: ztJonTAigEQf16Y3G3VrEgU8WJL6QcCZ8LXMa0ZphbJQLMFF25GY8mv79mLI3oiBoXH5MVsir/MuqJg4zj5LRvDbduODSASqU2eZVeJ73NU04JdVzlF/JsvbUS4/Sg5BUDnmIaBJV2Xt2uiZRvH+wQp7KhwYv1qlpJKFcdnXs0mD6FJi87HKdIzu7tVWWsXr4Fh+3EVHUFPEsLASColyS8/+S+Pq9yNBD9vrR2izazHXbpx4SKyUzd2A95tDkYdCn2k+KDjih70IzyCfqbGnCzQinnfdGfbdSD17ZjmSEr6WVtdYF2BnSUxr54ETWwjWuuOipM00it7IKYwIpCpmK5bpu5tzrfeMAQNUSrT6+wXBdZv/BnermjxIr+NMyDAVatc5cvDpd3W9/PtCF/Dp1rkaJmNaDVBd19PpwjqrabzIvZ0nsTAFW/f8MyaK1xHolXfnQpwZouEDcAHONSxSMzFeVIv2QvYLgbg2BelwwRSyzJ5RFrxonczvCcFZIgwEzSGFNw8EUiVay5OVvwR2CbTG7LsK80gWKo4+SsH6VFt4BZNnvH7Iqvg2U/Zpw8Pjg/w3D2e10FjMMdnCsCJvwkabX64aB03YKMX0M+xO+8pSWJzkdpx7hK9L/q2VxdfWbH3yEsnduLWkhjjbKB3qtg==
x-forefront-antispam-report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:SN4PR0401MB3582.namprd04.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230031)(39860400002)(396003)(136003)(366004)(346002)(376002)(451199024)(1800799009)(186009)(122000001)(82960400001)(31686004)(71200400001)(53546011)(6506007)(6486002)(31696002)(86362001)(85202003)(85182001)(36756003)(38070700005)(38100700002)(2616005)(26005)(41300700001)(15650500001)(2906002)(6512007)(83380400001)(478600001)(76116006)(91956017)(110136005)(4326008)(8676002)(8936002)(5660300002)(7416002)(64756008)(66446008)(54906003)(66946007)(66476007)(316002)(66556008)(45980500001);DIR:OUT;SFP:1102;
x-ms-exchange-antispam-messagedata-chunkcount: 1
x-ms-exchange-antispam-messagedata-0: =?utf-8?B?OVdPcDFzRVpoWW9CRE84T28wZlpGak9lejNyRzUvbHNEM0w1UytmKzViSEhj?=
 =?utf-8?B?N294VExIVFdxWWs2R0w0NmZyL2pqczFzRE8yTDQ2UzBnMFVnVnlhck44VEg2?=
 =?utf-8?B?L1lKYXBYNDNYNHJ0RkZSbU40d3l5VEVPMjA0QytlWmJuYXdxUThuVzhpOTQy?=
 =?utf-8?B?TGdmWG5qamhhN1NadUNKb28yMEJsTHZLaTFLSzYrSjFTR1BQMjU0RTMzYnV5?=
 =?utf-8?B?L2JEb0JUeTgzMCtYNnN2WnpsRkpUY3BvcGYwblc5bDhBQ1lqQ1IxS0E1Uklt?=
 =?utf-8?B?SnNnUkRjRm84ZlUrOEdhQlZ2QnlPZmJSQ1FwVnBXSjlSaWV5M3RwelJ6aC9T?=
 =?utf-8?B?S1U3T2dqRS95MjhtV0phKzh4ZGtSRHAzUWZXUVlqQVptcVMvZkd5eDZqa1ow?=
 =?utf-8?B?VGlvOWk2c3FPRWJiUzI4MUhTb0R3ZmE2RXlKQVphb2RkUTdLN0tnbTNPZStK?=
 =?utf-8?B?ZUZxYWpwMXZuWGpOZzZxRm11ZUdWVFRNdDVCSVJ2OUhHZGc4THJiZ1p4VHBB?=
 =?utf-8?B?T05YUjdBZldsdDJnVkluVFJQUkhhN2hRbG1GM3lvN2tzR2IwTldCdUljRlVj?=
 =?utf-8?B?VEtWa2lyYTl5RGpnck81SDlnTzNtTmpiSjIxemhVeXE2MzduZHdidjVXc0FQ?=
 =?utf-8?B?RE51TXJ4NCsvVEF4N1prbHZZOWdWQk94bEpSYWFmaHNrbXpTUkNKTlowUFFT?=
 =?utf-8?B?VGtKbGNmalpNSWpNQkVDSDAxeDNUUFBtd29yTXEydTc3ZldWUDhxVjNSRmU4?=
 =?utf-8?B?cW45NzV0ZnJyNzdvZDVMQnRaMDJpbDBZQXMrcmMwMHZSaXFkczJ6d1BPYnRS?=
 =?utf-8?B?eU4zN0t0d09zaVdLNzdaR1VZdWdzRlVjM2RwblFOeDd5em5KaWtPQWN1a1A2?=
 =?utf-8?B?eTIvc0lSUVhzUGozdXlsM1FuTForSkQ0Z0U3bGM0MWRRcmtqVkdrdXpUMUkz?=
 =?utf-8?B?VW5XUTFkeGNXaXRrSm5DZzBISnJQTDBzd2lZSmxqTkNoU3N2VXgxVzhxRUdy?=
 =?utf-8?B?b2tnbmp4QmN0S1B6QTF3T0lvc0VJcVJ0QVhyUCt0bW5aZmRDbzV3TFpjZVFK?=
 =?utf-8?B?aENPWFgzU1p5RG9kYzFjeEpneEp0SzUyL0NTcGtjT2JraTJ1QlZMWnRGSkhT?=
 =?utf-8?B?RnNaa2lxTjJOUEVuWXk0VERoY3N0dVVnZXFZVE1nSTI3SlZ3TjhHRXpIZEor?=
 =?utf-8?B?b0dwaThiOFV3NlFFcllKQSt0dUJEa0tsMEQ1SzVRcU9vbW9CbktqM0c1ZFpm?=
 =?utf-8?B?dndxcHo1eTF4R0p6a2NPK0ZvTGlieFZFSTRYRzFZUmRoSlRiekxYa1FOT05B?=
 =?utf-8?B?SzZkV3crb3E3UzNBNEVEeCtRdkFwT2pza2poemZEQmRnQjUvYlRGTm95YlN6?=
 =?utf-8?B?cnU5SlEyWVEzSndFWEtoVGxQVmx4bnZuRHFlUjI3N3V2VDkxSnVGL1BYd2Yw?=
 =?utf-8?B?NHY4VWVZTFpUSStGSnhtbHZ6YVlKaTNxc2ZpV2I2NFhobjlMd1pzYVVONkJP?=
 =?utf-8?B?bHhKRGpvUFZOdlhqWGRZdDEzSGg5WEVUZXhJQUxkcmFCNlRDcFRQNmF3NkNp?=
 =?utf-8?B?c29IZ0VMaS9yaDEwMjZKMnpRTzhCUkdvNmRSejNSRE9MUW0vajFqdmZpNE1D?=
 =?utf-8?B?UVpGNWRkWXphMndtT3lDQzJNY2M2YlRNZ1N1RFgxNkhsZ1F0NGN6cWZnL1Ft?=
 =?utf-8?B?R0xFZlBkRUJ4MElmejAxQXhzM1hJenJRblg4dDhWSkVaQzBSUFNXRUpMaTVZ?=
 =?utf-8?B?THEwTmZuZGdnVUR4dklWZGdNbmJZQXBCUTJSdDBRWkNzVUxtVlVHYndzUjBp?=
 =?utf-8?B?eGNPRHV4T1B0THhOY3RTZFJhT0c1UHNVdzk1bVFNTC9BS1QzUkp1WU8zMTQv?=
 =?utf-8?B?aGJnVmZxWG9Ocy9aNDJObEYzRU9nc1NIZkY2d1g1aDFucVJacTY2YnJ6YW5q?=
 =?utf-8?B?Vm40ZkhJdmNFODhxcHU5MEgxSDZnbWZPZ09obzErdHNDZXZwby9lR1JvY0Zw?=
 =?utf-8?B?Wk8yR3lRRDlXamtsSTdtdCsySEFoVUN2SVdpMmZqNERsT0hqcHhVOTFWa3hu?=
 =?utf-8?B?RzNzd21yV2tFdUEvbDdOVzQ3MmtOUTgwaW10empKSVhDQW5RWURLdUtud0tn?=
 =?utf-8?B?NmhUVnk4NFlWbzF5bVdBdk83emp0RHkvYmJHZFRUTHFlUEhURnNJaGw0ZFdF?=
 =?utf-8?B?Ymc9PQ==?=
Content-Type: text/plain; charset="utf-8"
Content-ID: <7DC4B56633C1F542A3015F340549B15A@namprd04.prod.outlook.com>
Content-Transfer-Encoding: base64
MIME-Version: 1.0
X-MS-Exchange-AntiSpam-ExternalHop-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-ExternalHop-MessageData-0: =?utf-8?B?b0VCSC90SXRxVnJtbWV6MEdlTWJtYUZ5dEJUcURPR3V3WGZRYm1nYUR6SUxW?=
 =?utf-8?B?MitsckM2cEpJTjVPQ1VWNytNWWE5WklGT216d3NyVkRqUFN1U2VuQy8yaHNV?=
 =?utf-8?B?b0NTZ09CS3p4QU0ycTF3OElTSFR1WG5aeTNLdXozOGtKU3p1Y2J2cFRVZDk5?=
 =?utf-8?B?NEpUZ0pUbnJucnVqKy9zYkdMbUIyUStCNzNJejRRMkYySnRKS09RWExxMDk5?=
 =?utf-8?B?WDg4NHlQRW85MWt5L0xaeTF0SDIyOEoyVzF4a2VPZXFROWxsWk04K200djVQ?=
 =?utf-8?B?N3lUcnBlTFdtMWpYU2NlM2pEMURZUVBRZy9lSjNoTWNrZUNhMjZ0Smk0VWY4?=
 =?utf-8?B?VzFPL0NETE1jeFhNU1pIQldDWnk3Z0lZWGgxQlBRSUN5N1lnTDd5U3Y1QUxr?=
 =?utf-8?B?MGxrVDZ1OHBsQjF3aHVTc2tYSVVkSEtyOXUzKzJWRkZtc1JnTFl4dXN4ZVZk?=
 =?utf-8?B?R01yVGxuQTZvOXJOQllHbzExSlBkZUxJcHlvUFdiQnNwNDVta09YSUpyUnlD?=
 =?utf-8?B?U3ZibU13TnBJeHlGZ3ljeFRXaXg1QlNiNzZiQ3JXSVlLUTNneDBXNTFyM2N6?=
 =?utf-8?B?R1Z1U0V5ajY1ekt5NnNWTFRxYjFmYVM0UUxZcFArS3B0cUJ6bGpRUHRwZjNO?=
 =?utf-8?B?ODVwdkxLT1BLNSswVXJKcjAwaHNkZ2FBd2UyZW53VFZGc1BpS3N2bWJST2Rt?=
 =?utf-8?B?OWc5MXZ3UHlsdjZGbnRKUWNoMGNaTDJKY0FiM3FBc2xxK1l0d2lDTGdBVG9M?=
 =?utf-8?B?OVNJQkJHV1lPcXFyVFUyaEYreEtMM1lRL2sxZ3hSUTJ4ZUYzdC8vbmM4d0Nr?=
 =?utf-8?B?aDdNVVpDU1NwTVNKNWZ0VlRSRWJWL0JPMEZwa1FaMkVXWHJmcy9ESFltL3Bu?=
 =?utf-8?B?S2t0QTJOY3dRQmZSQ2VEdjhKZFZpRWQ2MzZRZTFEaVhWUHBrMXdwNDVBQkV5?=
 =?utf-8?B?Z2RuNkhNYjM2eVhRZ2kxY3dVZ0l6MnM3azhnUVdTcDkweG0reUtGcWtmdDRr?=
 =?utf-8?B?RFEzSHB3ZmZRdEZtUGtFQ0tsNGQ2dC9HR3kzRnVqWDQ3dzVVSlFDakhkcHhr?=
 =?utf-8?B?VkhtRzRyMTRKa1gya0ZKT0NNa2xhcm5admMxTEhyZ0JKQnduRjVWQTFiVWJZ?=
 =?utf-8?B?cGI4Mm9JdzlXcUZLTG1IRkNFcncwOElyOGdMbjJUU0k2MXFScVhSa2NWNDQ2?=
 =?utf-8?B?UTNsSkVqYmZ4QUVBMStxQ2M1RGVPSEphdjZIN3p2SG4rUEFLZFJQUFVJT1Z2?=
 =?utf-8?B?enNKTHFTenVrSk9iWFpTMDE4b1p5RU9EaVhrZHh2Sk9LdzVxMk0yR2R1Y3E1?=
 =?utf-8?B?b2plYkM2YjMxM2tBRlNmU3B5Y0ZLTEpBcm9IOGZHR0ZwUE1uWjJXTU93TGx6?=
 =?utf-8?B?SlR3d2RIaXdDZ0hiZWZKRWsxS0pVTGR0elBOamVGNE9lOWdialI0Q0p1Z3lo?=
 =?utf-8?B?bHhUbGZmdWR2ZWxwcEhCSTErUVBYYXlVdjFZcWxMT0lzU3pUYitVMHBvQmU5?=
 =?utf-8?Q?azyPN4+IO6HP//m+Zfij2CnQbL5?=
X-OriginatorOrg: wdc.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-AuthSource: SN4PR0401MB3582.namprd04.prod.outlook.com
X-MS-Exchange-CrossTenant-Network-Message-Id: f06c4cf1-0097-403e-d1af-08dbb06d4abd
X-MS-Exchange-CrossTenant-originalarrivaltime: 08 Sep 2023 13:12:45.4917
 (UTC)
X-MS-Exchange-CrossTenant-fromentityheader: Hosted
X-MS-Exchange-CrossTenant-id: b61c8803-16f3-4c35-9b17-6f65f441df86
X-MS-Exchange-CrossTenant-mailboxtype: HOSTED
X-MS-Exchange-CrossTenant-userprincipalname: P67ZoOaggHlCW9ZedLY36oyIK4BwA+1RAmEMLE+NeVDWmGKc7LA/otJnhaDCexSiWWD3gDdTtxZ1cAuJRtJhQg==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: BL3PR04MB8105
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

T24gNy8yNS8yMyAyMDozOSwgRmFuIE5pIHdyb3RlOg0KPiBGcm9tOiBGYW4gTmkgPG5pZmFuQG91
dGxvb2suY29tPg0KPiANCj4gQWRkIGR5bmFtaWMgY2FwYWNpdHkgZXh0ZW50IGxpc3QgcmVwcmVz
ZW50YXRpdmUgdG8gdGhlIGRlZmluaXRpb24gb2YNCj4gQ1hMVHlwZTNEZXYgYW5kIGFkZCBnZXQg
REMgZXh0ZW50IGxpc3QgbWFpbGJveCBjb21tYW5kIHBlcg0KPiBDWEwuc3BlYy4zLjA6LjguMi45
LjguOS4yLg0KPiANCj4gU2lnbmVkLW9mZi1ieTogRmFuIE5pIDxmYW4ubmlAc2Ftc3VuZy5jb20+
DQo+IC0tLQ0KPiAgIGh3L2N4bC9jeGwtbWFpbGJveC11dGlscy5jICB8IDcxICsrKysrKysrKysr
KysrKysrKysrKysrKysrKysrKysrKysrKysNCj4gICBody9tZW0vY3hsX3R5cGUzLmMgICAgICAg
ICAgfCAgMSArDQo+ICAgaW5jbHVkZS9ody9jeGwvY3hsX2RldmljZS5oIHwgMjMgKysrKysrKysr
KysrDQo+ICAgMyBmaWxlcyBjaGFuZ2VkLCA5NSBpbnNlcnRpb25zKCspDQo+IA0KPiBkaWZmIC0t
Z2l0IGEvaHcvY3hsL2N4bC1tYWlsYm94LXV0aWxzLmMgYi9ody9jeGwvY3hsLW1haWxib3gtdXRp
bHMuYw0KPiBpbmRleCAwNTExYjhlNmY3Li4zZDI1YTk2OTdlIDEwMDY0NA0KPiAtLS0gYS9ody9j
eGwvY3hsLW1haWxib3gtdXRpbHMuYw0KPiArKysgYi9ody9jeGwvY3hsLW1haWxib3gtdXRpbHMu
Yw0KPiBAQCAtODMsNiArODMsNyBAQCBlbnVtIHsNCj4gICAgICAgICAgICNkZWZpbmUgQ0xFQVJf
UE9JU09OICAgICAgICAgICAweDINCj4gICAgICAgRENEX0NPTkZJRyAgPSAweDQ4LCAvKnIzLjA6
IDguMi45LjguOSovDQo+ICAgICAgICAgICAjZGVmaW5lIEdFVF9EQ19DT05GSUcgICAgICAgICAg
MHgwDQo+ICsgICAgICAgICNkZWZpbmUgR0VUX0RZTl9DQVBfRVhUX0xJU1QgICAweDENCj4gICAg
ICAgUEhZU0lDQUxfU1dJVENIID0gMHg1MQ0KPiAgICAgICAgICAgI2RlZmluZSBJREVOVElGWV9T
V0lUQ0hfREVWSUNFICAgICAgMHgwDQo+ICAgfTsNCj4gQEAgLTEwMTgsNiArMTAxOSw3MyBAQCBz
dGF0aWMgQ1hMUmV0Q29kZSBjbWRfZGNkX2dldF9keW5fY2FwX2NvbmZpZyhzdHJ1Y3QgY3hsX2Nt
ZCAqY21kLA0KPiAgICAgICByZXR1cm4gQ1hMX01CT1hfU1VDQ0VTUzsNCj4gICB9DQo+IA0KPiAr
LyoNCj4gKyAqIGN4bCBzcGVjIDMuMDogOC4yLjkuOC45LjINCj4gKyAqIEdldCBEeW5hbWljIENh
cGFjaXR5IEV4dGVudCBMaXN0IChPcGNvZGUgNDgxMGgpDQo+ICsgKi8NCj4gK3N0YXRpYyBDWExS
ZXRDb2RlIGNtZF9kY2RfZ2V0X2R5bl9jYXBfZXh0X2xpc3Qoc3RydWN0IGN4bF9jbWQgKmNtZCwN
Cj4gKyAgICAgICAgQ1hMRGV2aWNlU3RhdGUgKmN4bF9kc3RhdGUsDQo+ICsgICAgICAgIHVpbnQx
Nl90ICpsZW4pDQo+ICt7DQo+ICsgICAgc3RydWN0IGdldF9keW5fY2FwX2V4dF9saXN0X2luX3Bs
IHsNCj4gKyAgICAgICAgdWludDMyX3QgZXh0ZW50X2NudDsNCj4gKyAgICAgICAgdWludDMyX3Qg
c3RhcnRfZXh0ZW50X2lkOw0KPiArICAgIH0gUUVNVV9QQUNLRUQ7DQo+ICsNCj4gKyAgICBzdHJ1
Y3QgZ2V0X2R5bl9jYXBfZXh0X2xpc3Rfb3V0X3BsIHsNCj4gKyAgICAgICAgdWludDMyX3QgY291
bnQ7DQo+ICsgICAgICAgIHVpbnQzMl90IHRvdGFsX2V4dGVudHM7DQo+ICsgICAgICAgIHVpbnQz
Ml90IGdlbmVyYXRpb25fbnVtOw0KPiArICAgICAgICB1aW50OF90IHJzdmRbNF07DQo+ICsgICAg
ICAgIENYTERDRXh0ZW50X3JhdyByZWNvcmRzW107DQo+ICsgICAgfSBRRU1VX1BBQ0tFRDsNCj4g
Kw0KPiArICAgIHN0cnVjdCBnZXRfZHluX2NhcF9leHRfbGlzdF9pbl9wbCAqaW4gPSAodm9pZCAq
KWNtZC0+cGF5bG9hZDsNCj4gKyAgICBzdHJ1Y3QgZ2V0X2R5bl9jYXBfZXh0X2xpc3Rfb3V0X3Bs
ICpvdXQgPSAodm9pZCAqKWNtZC0+cGF5bG9hZDsNCj4gKyAgICBzdHJ1Y3QgQ1hMVHlwZTNEZXYg
KmN0M2QgPSBjb250YWluZXJfb2YoY3hsX2RzdGF0ZSwgQ1hMVHlwZTNEZXYsDQo+ICsgICAgICAg
ICAgICBjeGxfZHN0YXRlKTsNCj4gKyAgICB1aW50MTZfdCByZWNvcmRfY291bnQgPSAwLCBpID0g
MCwgcmVjb3JkX2RvbmUgPSAwOw0KPiArICAgIENYTERDREV4dGVudExpc3QgKmV4dGVudF9saXN0
ID0gJmN0M2QtPmRjLmV4dGVudHM7DQo+ICsgICAgQ1hMRENEX0V4dGVudCAqZW50Ow0KPiArICAg
IHVpbnQxNl90IG91dF9wbF9sZW47DQo+ICsgICAgdWludDMyX3Qgc3RhcnRfZXh0ZW50X2lkID0g
aW4tPnN0YXJ0X2V4dGVudF9pZDsNCj4gKw0KPiArICAgIGlmIChzdGFydF9leHRlbnRfaWQgPiBj
dDNkLT5kYy50b3RhbF9leHRlbnRfY291bnQpIHsNCj4gKyAgICAgICAgcmV0dXJuIENYTF9NQk9Y
X0lOVkFMSURfSU5QVVQ7DQo+ICsgICAgfQ0KPiArDQo+ICsgICAgcmVjb3JkX2NvdW50ID0gTUlO
KGluLT5leHRlbnRfY250LA0KPiArICAgICAgICAgICAgY3QzZC0+ZGMudG90YWxfZXh0ZW50X2Nv
dW50IC0gc3RhcnRfZXh0ZW50X2lkKTsNCj4gKw0KPiArICAgIG91dF9wbF9sZW4gPSBzaXplb2Yo
Km91dCkgKyByZWNvcmRfY291bnQgKiBzaXplb2Yob3V0LT5yZWNvcmRzWzBdKTsNCj4gKyAgICAv
KiBNYXkgbmVlZCBtb3JlIHByb2Nlc3NpbmcgaGVyZSBpbiB0aGUgZnV0dXJlICovDQo+ICsgICAg
YXNzZXJ0KG91dF9wbF9sZW4gPD0gQ1hMX01BSUxCT1hfTUFYX1BBWUxPQURfU0laRSk7DQo+ICsN
Cj4gKyAgICBtZW1zZXQob3V0LCAwLCBvdXRfcGxfbGVuKTsNCj4gKyAgICBzdGxfbGVfcCgmb3V0
LT5jb3VudCwgcmVjb3JkX2NvdW50KTsNCj4gKyAgICBzdGxfbGVfcCgmb3V0LT50b3RhbF9leHRl
bnRzLCBjdDNkLT5kYy50b3RhbF9leHRlbnRfY291bnQpOw0KPiArICAgIHN0bF9sZV9wKCZvdXQt
PmdlbmVyYXRpb25fbnVtLCBjdDNkLT5kYy5leHRfbGlzdF9nZW5fc2VxKTsNCj4gKw0KPiArICAg
IGlmIChyZWNvcmRfY291bnQgPiAwKSB7DQo+ICsgICAgICAgIFFUQUlMUV9GT1JFQUNIKGVudCwg
ZXh0ZW50X2xpc3QsIG5vZGUpIHsNCj4gKyAgICAgICAgICAgIGlmIChpKysgPCBzdGFydF9leHRl
bnRfaWQpIHsNCj4gKyAgICAgICAgICAgICAgICBjb250aW51ZTsNCj4gKyAgICAgICAgICAgIH0N
Cj4gKyAgICAgICAgICAgIHN0cV9sZV9wKCZvdXQtPnJlY29yZHNbcmVjb3JkX2RvbmVdLnN0YXJ0
X2RwYSwgZW50LT5zdGFydF9kcGEpOw0KPiArICAgICAgICAgICAgc3RxX2xlX3AoJm91dC0+cmVj
b3Jkc1tyZWNvcmRfZG9uZV0ubGVuLCBlbnQtPmxlbik7DQo+ICsgICAgICAgICAgICBtZW1jcHko
Jm91dC0+cmVjb3Jkc1tyZWNvcmRfZG9uZV0udGFnLCBlbnQtPnRhZywgMHgxMCk7DQo+ICsgICAg
ICAgICAgICBzdHdfbGVfcCgmb3V0LT5yZWNvcmRzW3JlY29yZF9kb25lXS5zaGFyZWRfc2VxLCBl
bnQtPnNoYXJlZF9zZXEpOw0KPiArICAgICAgICAgICAgcmVjb3JkX2RvbmUrKzsNCj4gKyAgICAg
ICAgICAgIGlmIChyZWNvcmRfZG9uZSA9PSByZWNvcmRfY291bnQpIHsNCj4gKyAgICAgICAgICAg
ICAgICBicmVhazsNCj4gKyAgICAgICAgICAgIH0NCj4gKyAgICAgICAgfQ0KPiArICAgIH0NCj4g
Kw0KPiArICAgICpsZW4gPSBvdXRfcGxfbGVuOw0KPiArICAgIHJldHVybiBDWExfTUJPWF9TVUND
RVNTOw0KPiArfQ0KPiArDQo+ICAgI2RlZmluZSBJTU1FRElBVEVfQ09ORklHX0NIQU5HRSAoMSA8
PCAxKQ0KPiAgICNkZWZpbmUgSU1NRURJQVRFX0RBVEFfQ0hBTkdFICgxIDw8IDIpDQo+ICAgI2Rl
ZmluZSBJTU1FRElBVEVfUE9MSUNZX0NIQU5HRSAoMSA8PCAzKQ0KPiBAQCAtMTA1OCw2ICsxMTI2
LDkgQEAgc3RhdGljIHN0cnVjdCBjeGxfY21kIGN4bF9jbWRfc2V0WzI1Nl1bMjU2XSA9IHsNCj4g
ICAgICAgICAgIGNtZF9tZWRpYV9jbGVhcl9wb2lzb24sIDcyLCAwIH0sDQo+ICAgICAgIFtEQ0Rf
Q09ORklHXVtHRVRfRENfQ09ORklHXSA9IHsgIkRDRF9HRVRfRENfQ09ORklHIiwNCj4gICAgICAg
ICAgIGNtZF9kY2RfZ2V0X2R5bl9jYXBfY29uZmlnLCAyLCAwIH0sDQo+ICsgICAgW0RDRF9DT05G
SUddW0dFVF9EWU5fQ0FQX0VYVF9MSVNUXSA9IHsNCj4gKyAgICAgICAgIkRDRF9HRVRfRFlOQU1J
Q19DQVBBQ0lUWV9FWFRFTlRfTElTVCIsIGNtZF9kY2RfZ2V0X2R5bl9jYXBfZXh0X2xpc3QsDQo+
ICsgICAgICAgIDgsIDAgfSwNCj4gICB9Ow0KPiANCj4gICBzdGF0aWMgc3RydWN0IGN4bF9jbWQg
Y3hsX2NtZF9zZXRfc3dbMjU2XVsyNTZdID0gew0KPiBkaWZmIC0tZ2l0IGEvaHcvbWVtL2N4bF90
eXBlMy5jIGIvaHcvbWVtL2N4bF90eXBlMy5jDQo+IGluZGV4IDc2YmJkOWY3ODUuLmYxMTcwYjgw
NDcgMTAwNjQ0DQo+IC0tLSBhL2h3L21lbS9jeGxfdHlwZTMuYw0KPiArKysgYi9ody9tZW0vY3hs
X3R5cGUzLmMNCj4gQEAgLTc4OSw2ICs3ODksNyBAQCBzdGF0aWMgaW50IGN4bF9jcmVhdGVfZGNf
cmVnaW9ucyhDWExUeXBlM0RldiAqY3QzZCkNCj4gDQo+ICAgICAgICAgICByZWdpb25fYmFzZSAr
PSByZWdpb24tPmxlbjsNCj4gICAgICAgfQ0KPiArICAgIFFUQUlMUV9JTklUKCZjdDNkLT5kYy5l
eHRlbnRzKTsNCj4gDQo+ICAgICAgIHJldHVybiAwOw0KPiAgIH0NCj4gZGlmZiAtLWdpdCBhL2lu
Y2x1ZGUvaHcvY3hsL2N4bF9kZXZpY2UuaCBiL2luY2x1ZGUvaHcvY3hsL2N4bF9kZXZpY2UuaA0K
PiBpbmRleCAxYzk5YjA1YTY2Li4zYTMzOGIzYjM3IDEwMDY0NA0KPiAtLS0gYS9pbmNsdWRlL2h3
L2N4bC9jeGxfZGV2aWNlLmgNCj4gKysrIGIvaW5jbHVkZS9ody9jeGwvY3hsX2RldmljZS5oDQo+
IEBAIC0zODUsNiArMzg1LDI1IEBAIHR5cGVkZWYgUUxJU1RfSEVBRCgsIENYTFBvaXNvbikgQ1hM
UG9pc29uTGlzdDsNCj4gDQo+ICAgI2RlZmluZSBEQ0RfTUFYX1JFR0lPTl9OVU0gOA0KPiANCj4g
K3R5cGVkZWYgc3RydWN0IENYTERDRF9FeHRlbnRfcmF3IHsNCj4gKyAgICB1aW50NjRfdCBzdGFy
dF9kcGE7DQo+ICsgICAgdWludDY0X3QgbGVuOw0KPiArICAgIHVpbnQ4X3QgdGFnWzB4MTBdOw0K
PiArICAgIHVpbnQxNl90IHNoYXJlZF9zZXE7DQo+ICsgICAgdWludDhfdCByc3ZkWzB4Nl07DQo+
ICt9IFFFTVVfUEFDS0VEIENYTERDRXh0ZW50X3JhdzsNCj4gKw0KPiArdHlwZWRlZiBzdHJ1Y3Qg
Q1hMRENEX0V4dGVudCB7DQo+ICsgICAgdWludDY0X3Qgc3RhcnRfZHBhOw0KPiArICAgIHVpbnQ2
NF90IGxlbjsNCj4gKyAgICB1aW50OF90IHRhZ1sweDEwXTsNCj4gKyAgICB1aW50MTZfdCBzaGFy
ZWRfc2VxOw0KPiArICAgIHVpbnQ4X3QgcnN2ZFsweDZdOw0KPiArDQo+ICsgICAgUVRBSUxRX0VO
VFJZKENYTERDRF9FeHRlbnQpIG5vZGU7DQo+ICt9IENYTERDRF9FeHRlbnQ7DQo+ICt0eXBlZGVm
IFFUQUlMUV9IRUFEKCwgQ1hMRENEX0V4dGVudCkgQ1hMRENERXh0ZW50TGlzdDsNCj4gKw0KPiAg
IHR5cGVkZWYgc3RydWN0IENYTERDRF9SZWdpb24gew0KPiAgICAgICB1aW50NjRfdCBiYXNlOw0K
PiAgICAgICB1aW50NjRfdCBkZWNvZGVfbGVuOyAvKiBpbiBtdWx0aXBsZXMgb2YgMjU2TUIgKi8N
Cj4gQEAgLTQzMyw2ICs0NTIsMTAgQEAgc3RydWN0IENYTFR5cGUzRGV2IHsNCj4gDQo+ICAgICAg
ICAgICB1aW50OF90IG51bV9yZWdpb25zOyAvKiAwLTggcmVnaW9ucyAqLw0KPiAgICAgICAgICAg
c3RydWN0IENYTERDRF9SZWdpb24gcmVnaW9uc1tEQ0RfTUFYX1JFR0lPTl9OVU1dOw0KPiArICAg
ICAgICBDWExEQ0RFeHRlbnRMaXN0IGV4dGVudHM7DQo+ICsNCj4gKyAgICAgICAgdWludDMyX3Qg
dG90YWxfZXh0ZW50X2NvdW50Ow0KDQpIaSwNCg0KSSBkb24ndCBzZWUgdG90YWxfZXh0ZW50X2Nv
dW50IGJlaW5nIHVwZGF0ZWQgYW55d2hlcmUuIFNob3VsZG4ndCB0aGlzIGJlIA0KYWRqdXN0ZWQg
YXMgcGFydCBvZiBjbWRfZGNkX2FkZF9keW5fY2FwX3JzcCgpL2NtZF9kY2RfcmVsZWFzZV9keW5f
Y2FwKCk/DQoNClRoYW5rcywNCkpvcmdlbg0KDQoNCj4gKyAgICAgICAgdWludDMyX3QgZXh0X2xp
c3RfZ2VuX3NlcTsNCj4gICAgICAgfSBkYzsNCj4gICB9Ow0KPiANCj4gLS0NCj4gMi4yNS4xDQo=

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id AA1E3EE801F
	for <linux-cxl@archiver.kernel.org>; Fri,  8 Sep 2023 17:15:00 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S240495AbjIHRPD (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Fri, 8 Sep 2023 13:15:03 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:46820 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S229492AbjIHRPC (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Fri, 8 Sep 2023 13:15:02 -0400
Received: from mout.gmx.net (mout.gmx.net [212.227.17.21])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id EE098CE6
        for <linux-cxl@vger.kernel.org>; Fri,  8 Sep 2023 10:14:57 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=gmx.us;
 s=s31663417; t=1694193196; x=1694797996; i=fan.ni@gmx.us;
 bh=PyTtTSGkK0YDDu75CUsELW/zziVqpZYsIv90hJn8nFQ=;
 h=X-UI-Sender-Class:Date:From:To:Cc:Subject:References:In-Reply-To;
 b=tb/TGIMYR7d2IQMDLkwwr2IjNhtMhbJ9RtZlihJ9+YJFHGaMrWNdpzi6JanCNOeVgihgkIl
 0W0PAdYiIVPvXrBSKPxViYQJwq6xKglJVMYw5Mku8HKtEy5Dpi085d1txOd5LmZ3wMxq/LNLJ
 od1FcGzGNU3CLeK62mcR6mdNEDLUUswG6ORCYxw3fBcTikpI2qdA9WowpqZc2k3ito5n4zZz3
 BUkvj7cyBprGplSCpz/IDWtZNu/Ofrbm1Zi2I0HuFtE0J2jdfo1+PGXlTwo/Ce4F4pe5Uz5Im
 4w1hxK7PEU5ZId3dPesBIFtaqS3xnfxkthhdSNSEqQHSgmJCLk7g==
X-UI-Sender-Class: 724b4f7f-cbec-4199-ad4e-598c01a50d3a
Received: from debian ([99.13.228.231]) by mail.gmx.net (mrgmx104
 [212.227.17.174]) with ESMTPSA (Nemesis) id 1M1po0-1qcTBL3aIq-002Ets; Fri, 08
 Sep 2023 19:13:16 +0200
Date: Fri, 8 Sep 2023 10:12:58 -0700
From: Fan Ni <fan.ni@gmx.us>
To: J?rgen Hansen <Jorgen.Hansen@wdc.com>
Cc: Fan Ni <fan.ni@samsung.com>,
        "qemu-devel@nongnu.org" <qemu-devel@nongnu.org>,
        "jonathan.cameron@huawei.com" <jonathan.cameron@huawei.com>,
        "linux-cxl@vger.kernel.org" <linux-cxl@vger.kernel.org>,
        "gregory.price@memverge.com" <gregory.price@memverge.com>,
        "hchkuo@avery-design.com.tw" <hchkuo@avery-design.com.tw>,
        "cbrowy@avery-design.com" <cbrowy@avery-design.com>,
        "ira.weiny@intel.com" <ira.weiny@intel.com>,
        "dan.j.williams@intel.com" <dan.j.williams@intel.com>,
        Adam Manzanares <a.manzanares@samsung.com>,
        "dave@stgolabs.net" <dave@stgolabs.net>,
        "nmtadam.samsung@gmail.com" <nmtadam.samsung@gmail.com>,
        "nifan@outlook.com" <nifan@outlook.com>
Subject: Re: [Qemu PATCH v2 6/9] hw/mem/cxl_type3: Add DC extent list
 representative and get DC extent list mailbox support
Message-ID: <ZPtWGqBCISsaDbY/@debian>
References: <20230725183939.2741025-1-fan.ni@samsung.com>
 <CGME20230725183957uscas1p28b38d294f90b97f99769466cc533b4de@uscas1p2.samsung.com>
 <20230725183939.2741025-7-fan.ni@samsung.com>
 <ca63022b-0447-74b8-06fc-0e6d47455ebc@wdc.com>
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: <ca63022b-0447-74b8-06fc-0e6d47455ebc@wdc.com>
X-Provags-ID: V03:K1:T3FLWp3hDCYbgtq2nkmqGqy0qgYjfFD0239x81DbBjfOZExWxBz
 1QgCWvCHwgNaSZB0sS/mIy5Zl/0BWBLJHia9Vh2qNBMkxzHmVql+ZxcVwpAD/uOgGeVhQIV
 9ZYfxCSLpB7s1mxsX6YupY1D+2NhRzjXGEh4yVAcp4+5JdE49TBVjskmpG3dekg497lOmpi
 3AHoONQihpYQm67rSqO3g==
UI-OutboundReport: notjunk:1;M01:P0:QCLOZH0v20k=;wkgkaIDRH6F4SSliiPwWT94LDKy
 vJkuNWCLhmuwIGIpnBZiuhJlk0gQg9vKpysXZmObQqMCCqf7Q/jyyQI+TT+Czjhy4mgphprfw
 Z0jst0VyY+P2OaZjLF8lM+pWXDCVy6zTE3T2BvNeUxM8gmqLNWxV4mNMaSRSrKaNHYa0QCIYV
 Xle3OlnjrFOAs+mYRsLANRVjiP40jaTsjRptage+Nh62XjXjnSREdj4vWbTCkhbOMtJUgVBOw
 bLs4NjtR1vc5TuHYMMUX2M+zQG5bqLD46ldZ8MYRoCfqlTCivdZQv6/AChK2bi1XYA4gJlh+5
 zjze6KPszKqyGLhIYRUTrVfUYoBeK6X9lfQs5uLYOzc2YKyJPacB7wxBt7UUuEwQLsXkVPOSL
 AYYLA1J3Uypx/0uyO/IBquTLVypSuQIo8oZpE3bwFhWxUE+w2TwOEqDHGMnO4eTPJcAIFFCrg
 /MwZO2mJqrhgjRGvhjWkp+FYhh7tiBCmqQvPwDvZnTTFv/7uHbkiWsoTJgcWfOZQCbqld4xcO
 3UzhztUCEH4IYqyhABVMDhDwqWQdkHuXhC4o0PL2KHjtZoQ/kLX5nwJvFUeZwpnF+If4ewHLS
 6tAQdn0kktSZMp6Q4owX3s9wHSfhY2nFvpUA99vpwiHBuMB2O6lvOd55Q8kZyXbwq8LH54jWr
 gdVAy/duxGAU/TL+mAXKG+n779U7alVniBLgiZXkgLSCutf0P0E08aQhPnPTkDHbM7FPPi+B/
 sF+qffAQ6FAla6RknEUcZww6sd7tiBWSkoVfhjD2ecu8SHPbEAbXVw+ndz+ChLYdpaeuMMHwD
 YAzs+y7xBb9yUJb0dQ9ZYRFp/PR8xRDZG8RJedhft11qdFJn4seuNQI9lWtTSljME4uc5bLu2
 crOZJVUxogND0wOIe7giWLsnNSrWSjtcmSK7oHaQapJ2aQWKVzsNxEFlOECSJLq87p+Tla9j1
 EoAq7Syr+y8QkzfvzWGeUDO1aIs=
Content-Transfer-Encoding: quoted-printable
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

On Fri, Sep 08, 2023 at 01:12:45PM +0000, J?rgen Hansen wrote:
> On 7/25/23 20:39, Fan Ni wrote:
> > From: Fan Ni <nifan@outlook.com>
> >
> > Add dynamic capacity extent list representative to the definition of
> > CXLType3Dev and add get DC extent list mailbox command per
> > CXL.spec.3.0:.8.2.9.8.9.2.
> >
> > Signed-off-by: Fan Ni <fan.ni@samsung.com>
> > ---
> >   hw/cxl/cxl-mailbox-utils.c  | 71 +++++++++++++++++++++++++++++++++++=
++
> >   hw/mem/cxl_type3.c          |  1 +
> >   include/hw/cxl/cxl_device.h | 23 ++++++++++++
> >   3 files changed, 95 insertions(+)
> >
> > diff --git a/hw/cxl/cxl-mailbox-utils.c b/hw/cxl/cxl-mailbox-utils.c
> > index 0511b8e6f7..3d25a9697e 100644
> > --- a/hw/cxl/cxl-mailbox-utils.c
> > +++ b/hw/cxl/cxl-mailbox-utils.c
> > @@ -83,6 +83,7 @@ enum {
> >           #define CLEAR_POISON           0x2
> >       DCD_CONFIG  =3D 0x48, /*r3.0: 8.2.9.8.9*/
> >           #define GET_DC_CONFIG          0x0
> > +        #define GET_DYN_CAP_EXT_LIST   0x1
> >       PHYSICAL_SWITCH =3D 0x51
> >           #define IDENTIFY_SWITCH_DEVICE      0x0
> >   };
> > @@ -1018,6 +1019,73 @@ static CXLRetCode cmd_dcd_get_dyn_cap_config(st=
ruct cxl_cmd *cmd,
> >       return CXL_MBOX_SUCCESS;
> >   }
> >
> > +/*
> > + * cxl spec 3.0: 8.2.9.8.9.2
> > + * Get Dynamic Capacity Extent List (Opcode 4810h)
> > + */
> > +static CXLRetCode cmd_dcd_get_dyn_cap_ext_list(struct cxl_cmd *cmd,
> > +        CXLDeviceState *cxl_dstate,
> > +        uint16_t *len)
> > +{
> > +    struct get_dyn_cap_ext_list_in_pl {
> > +        uint32_t extent_cnt;
> > +        uint32_t start_extent_id;
> > +    } QEMU_PACKED;
> > +
> > +    struct get_dyn_cap_ext_list_out_pl {
> > +        uint32_t count;
> > +        uint32_t total_extents;
> > +        uint32_t generation_num;
> > +        uint8_t rsvd[4];
> > +        CXLDCExtent_raw records[];
> > +    } QEMU_PACKED;
> > +
> > +    struct get_dyn_cap_ext_list_in_pl *in =3D (void *)cmd->payload;
> > +    struct get_dyn_cap_ext_list_out_pl *out =3D (void *)cmd->payload;
> > +    struct CXLType3Dev *ct3d =3D container_of(cxl_dstate, CXLType3Dev=
,
> > +            cxl_dstate);
> > +    uint16_t record_count =3D 0, i =3D 0, record_done =3D 0;
> > +    CXLDCDExtentList *extent_list =3D &ct3d->dc.extents;
> > +    CXLDCD_Extent *ent;
> > +    uint16_t out_pl_len;
> > +    uint32_t start_extent_id =3D in->start_extent_id;
> > +
> > +    if (start_extent_id > ct3d->dc.total_extent_count) {
> > +        return CXL_MBOX_INVALID_INPUT;
> > +    }
> > +
> > +    record_count =3D MIN(in->extent_cnt,
> > +            ct3d->dc.total_extent_count - start_extent_id);
> > +
> > +    out_pl_len =3D sizeof(*out) + record_count * sizeof(out->records[=
0]);
> > +    /* May need more processing here in the future */
> > +    assert(out_pl_len <=3D CXL_MAILBOX_MAX_PAYLOAD_SIZE);
> > +
> > +    memset(out, 0, out_pl_len);
> > +    stl_le_p(&out->count, record_count);
> > +    stl_le_p(&out->total_extents, ct3d->dc.total_extent_count);
> > +    stl_le_p(&out->generation_num, ct3d->dc.ext_list_gen_seq);
> > +
> > +    if (record_count > 0) {
> > +        QTAILQ_FOREACH(ent, extent_list, node) {
> > +            if (i++ < start_extent_id) {
> > +                continue;
> > +            }
> > +            stq_le_p(&out->records[record_done].start_dpa, ent->start=
_dpa);
> > +            stq_le_p(&out->records[record_done].len, ent->len);
> > +            memcpy(&out->records[record_done].tag, ent->tag, 0x10);
> > +            stw_le_p(&out->records[record_done].shared_seq, ent->shar=
ed_seq);
> > +            record_done++;
> > +            if (record_done =3D=3D record_count) {
> > +                break;
> > +            }
> > +        }
> > +    }
> > +
> > +    *len =3D out_pl_len;
> > +    return CXL_MBOX_SUCCESS;
> > +}
> > +
> >   #define IMMEDIATE_CONFIG_CHANGE (1 << 1)
> >   #define IMMEDIATE_DATA_CHANGE (1 << 2)
> >   #define IMMEDIATE_POLICY_CHANGE (1 << 3)
> > @@ -1058,6 +1126,9 @@ static struct cxl_cmd cxl_cmd_set[256][256] =3D =
{
> >           cmd_media_clear_poison, 72, 0 },
> >       [DCD_CONFIG][GET_DC_CONFIG] =3D { "DCD_GET_DC_CONFIG",
> >           cmd_dcd_get_dyn_cap_config, 2, 0 },
> > +    [DCD_CONFIG][GET_DYN_CAP_EXT_LIST] =3D {
> > +        "DCD_GET_DYNAMIC_CAPACITY_EXTENT_LIST", cmd_dcd_get_dyn_cap_e=
xt_list,
> > +        8, 0 },
> >   };
> >
> >   static struct cxl_cmd cxl_cmd_set_sw[256][256] =3D {
> > diff --git a/hw/mem/cxl_type3.c b/hw/mem/cxl_type3.c
> > index 76bbd9f785..f1170b8047 100644
> > --- a/hw/mem/cxl_type3.c
> > +++ b/hw/mem/cxl_type3.c
> > @@ -789,6 +789,7 @@ static int cxl_create_dc_regions(CXLType3Dev *ct3d=
)
> >
> >           region_base +=3D region->len;
> >       }
> > +    QTAILQ_INIT(&ct3d->dc.extents);
> >
> >       return 0;
> >   }
> > diff --git a/include/hw/cxl/cxl_device.h b/include/hw/cxl/cxl_device.h
> > index 1c99b05a66..3a338b3b37 100644
> > --- a/include/hw/cxl/cxl_device.h
> > +++ b/include/hw/cxl/cxl_device.h
> > @@ -385,6 +385,25 @@ typedef QLIST_HEAD(, CXLPoison) CXLPoisonList;
> >
> >   #define DCD_MAX_REGION_NUM 8
> >
> > +typedef struct CXLDCD_Extent_raw {
> > +    uint64_t start_dpa;
> > +    uint64_t len;
> > +    uint8_t tag[0x10];
> > +    uint16_t shared_seq;
> > +    uint8_t rsvd[0x6];
> > +} QEMU_PACKED CXLDCExtent_raw;
> > +
> > +typedef struct CXLDCD_Extent {
> > +    uint64_t start_dpa;
> > +    uint64_t len;
> > +    uint8_t tag[0x10];
> > +    uint16_t shared_seq;
> > +    uint8_t rsvd[0x6];
> > +
> > +    QTAILQ_ENTRY(CXLDCD_Extent) node;
> > +} CXLDCD_Extent;
> > +typedef QTAILQ_HEAD(, CXLDCD_Extent) CXLDCDExtentList;
> > +
> >   typedef struct CXLDCD_Region {
> >       uint64_t base;
> >       uint64_t decode_len; /* in multiples of 256MB */
> > @@ -433,6 +452,10 @@ struct CXLType3Dev {
> >
> >           uint8_t num_regions; /* 0-8 regions */
> >           struct CXLDCD_Region regions[DCD_MAX_REGION_NUM];
> > +        CXLDCDExtentList extents;
> > +
> > +        uint32_t total_extent_count;
>
> Hi,
>
> I don't see total_extent_count being updated anywhere. Shouldn't this be
> adjusted as part of cmd_dcd_add_dyn_cap_rsp()/cmd_dcd_release_dyn_cap()?
>
> Thanks,
> Jorgen

Good catch. Thanks Jorgen, will fix in the next version.

Fan

>
>
> > +        uint32_t ext_list_gen_seq;
> >       } dc;
> >   };
> >
> > --
> > 2.25.1

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 3FEADEEB560
	for <linux-cxl@archiver.kernel.org>; Fri,  8 Sep 2023 17:21:52 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S229600AbjIHRVy (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Fri, 8 Sep 2023 13:21:54 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:54388 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S235888AbjIHRVx (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Fri, 8 Sep 2023 13:21:53 -0400
Received: from mout.gmx.net (mout.gmx.net [212.227.15.18])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id CE4AF1FC4
        for <linux-cxl@vger.kernel.org>; Fri,  8 Sep 2023 10:21:48 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=gmx.us;
 s=s31663417; t=1694193609; x=1694798409; i=fan.ni@gmx.us;
 bh=eTuAMCtxIep1hkQhE9WfgRxSJEMBNLNyy1WUCrC1IlY=;
 h=X-UI-Sender-Class:Date:From:To:Cc:Subject:References:In-Reply-To;
 b=UucjMoheG9kEHhtv7iyNw4nzNkbJ9koDQ+Y6Z/LmfyjRv4eFMZ9C27u7Hmw0xfLI2qhYusp
 0a4ZmhlNP/9sNyhj46UzD3N7uAk3IDpzO7qrC/NqGlF5g6+p3rShJN0gNMDHvKW2ug/tO27VZ
 +ZEbPq6EHaoPROMpXDuJr1w1gvMJJtUQU4zk69mOp/AMBHsExTCPoSGQLD0QOP67scAO0DSjO
 Ti8XuRv+WoWEzm8+78tY9btwHB4rn3tjW+59gCalf0agHb0Iijs2WJvp+tDC4u5qF25zp24S4
 mGAFwsCX+IfmGC8UgRbQBHZpxSPw7k92ATGoC7LB67w0nnAVjYYg==
X-UI-Sender-Class: 724b4f7f-cbec-4199-ad4e-598c01a50d3a
Received: from debian ([99.13.228.231]) by mail.gmx.net (mrgmx005
 [212.227.17.184]) with ESMTPSA (Nemesis) id 1MbRfv-1q38PB2db7-00brwB; Fri, 08
 Sep 2023 19:20:09 +0200
Date: Fri, 8 Sep 2023 10:19:55 -0700
From: Fan Ni <fan.ni@gmx.us>
To: J?rgen Hansen <Jorgen.Hansen@wdc.com>
Cc: Fan Ni <fan.ni@samsung.com>,
        "qemu-devel@nongnu.org" <qemu-devel@nongnu.org>,
        "jonathan.cameron@huawei.com" <jonathan.cameron@huawei.com>,
        "linux-cxl@vger.kernel.org" <linux-cxl@vger.kernel.org>,
        "gregory.price@memverge.com" <gregory.price@memverge.com>,
        "hchkuo@avery-design.com.tw" <hchkuo@avery-design.com.tw>,
        "cbrowy@avery-design.com" <cbrowy@avery-design.com>,
        "ira.weiny@intel.com" <ira.weiny@intel.com>,
        "dan.j.williams@intel.com" <dan.j.williams@intel.com>,
        Adam Manzanares <a.manzanares@samsung.com>,
        "dave@stgolabs.net" <dave@stgolabs.net>,
        "nmtadam.samsung@gmail.com" <nmtadam.samsung@gmail.com>,
        "nifan@outlook.com" <nifan@outlook.com>
Subject: Re: [Qemu PATCH v2 7/9] hw/cxl/cxl-mailbox-utils: Add mailbox
 commands to support add/release dynamic capacity response
Message-ID: <ZPtXuyJkFKgBpL9A@debian>
References: <20230725183939.2741025-1-fan.ni@samsung.com>
 <CGME20230725183957uscas1p2a076b6f7b694d2e632a0b8025ec331d7@uscas1p2.samsung.com>
 <20230725183939.2741025-8-fan.ni@samsung.com>
 <e1640028-6b9d-3cdf-52fb-241f985c4bbb@wdc.com>
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: <e1640028-6b9d-3cdf-52fb-241f985c4bbb@wdc.com>
X-Provags-ID: V03:K1:QOKSHZN38gt922xEcnREdH3Tslemuxy+b9ml1WlkVVpglkGkJqN
 OPacRVz8/gO+I0m1ozpn2VbTQkV5EwMh9+xrMFLdKxolorY+Wdvbvtb3fhZL0F6VmTuGF5Q
 zQHN28ur4vpp3a+E3QlGsLqerE3tpHpNORjDuT5DD2ALViwm2B3JvNBhIiJm2EGmgkXtQFL
 6vCI7t30MrkWwdviUNwFg==
UI-OutboundReport: notjunk:1;M01:P0:cQMkAvkz3fM=;x3zDOCgKmb3VZDXqVcZ8tuoSEkM
 M9HM4eT7Zdu2y+mljRzb64V/39LvZuXlU1AOoLPCtb9XOpjCdB/5yKc2FY6cmNlkOwcHg8cV2
 6WqSEIxzMJYPEfEP8madX72WuovzpvMh8CMlYc10mgpz7IjDu0qGE6Y9X4eRunNkOEVPU/tT+
 VCavPghGkHTnDqBFGGX29xboaa8MCqDPwFyPv96VCShpFHIzgv23+ue8pC3Lwr7mz67uP3vIJ
 fDqAF4r2Gae3ZrlUNa5/O6x2pt3jlT0YOvdrU+gSlNPyF+aQ+LvT2iDQFgVXQDVhy6fOM4NDV
 LGmkHvjzuR4mmrhu1Ss0Bp7NQFFUQBpNBGJ/6gQ4sCMRGPb+/qmez717p3AyW58ZUBDJGp8U/
 UTKf1v5OGsiyjN6dN51ntqLzpkqn0f4mRq5NXo3jlyR5WZ0keKkW7GYZKIXMH//2xCSxBd7su
 SjoeIGJh/w3kBTKpFzF8Le0HCf02/Kp42GtS3aJT6sVFzwrSi5uBgnHm2fbB0/McvXWaxJkgi
 +LtVtu90UAIctKpPXXRzP8eXvveThWYvN4iVevD9vYZjINXXRIObsBjSSuUVZ1OI+0fuX7psD
 8itWhby3I4bXk9NCuX34ExcA76TL2stpbeZy5GqExfBXLe0Fpo3Zl/t1/mmQymm1751YXw/zQ
 qTkx7q3j0qffvqrwcc8vatpByI1Q7Z1Vw79FSpIdrY7xYahtEySof1RmYZgynyVUNnLRbhuJn
 XzL4oBvWl03ziSBYusMlePPX+WJQ28frci64WEr3Vf56ShNMJP1ZbfwGc4qZ/7sANTu6d54MI
 YDHvh7MJqRd0qyp6mI8DiCJ3Y4ThlzsAjOgZyAX1DFoA8hFgnnxMdCwz2dkyH3AjMxGPtn/XX
 Lqz2U18isn0iK+ep9C4ZTCcDVHm7wUkq+FTfzLzqJWehngVwoIvZtOxsPTRGXXUdKiuxof5AZ
 F6kkwsIbSD98I2d2eFrYujMQK0g=
Content-Transfer-Encoding: quoted-printable
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

On Fri, Sep 08, 2023 at 01:00:16PM +0000, J?rgen Hansen wrote:
> On 7/25/23 20:39, Fan Ni wrote:
> > From: Fan Ni <nifan@outlook.com>
> >
> > Per CXL spec 3.0, two mailbox commands are implemented:
> > Add Dynamic Capacity Response (Opcode 4802h) 8.2.9.8.9.3, and
> > Release Dynamic Capacity (Opcode 4803h) 8.2.9.8.9.4.
> >
> > Signed-off-by: Fan Ni <fan.ni@samsung.com>
> > ---
> >   hw/cxl/cxl-mailbox-utils.c  | 253 ++++++++++++++++++++++++++++++++++=
++
> >   include/hw/cxl/cxl_device.h |   3 +-
> >   2 files changed, 255 insertions(+), 1 deletion(-)
> >
> > diff --git a/hw/cxl/cxl-mailbox-utils.c b/hw/cxl/cxl-mailbox-utils.c
> > index 3d25a9697e..1e4944da95 100644
> > --- a/hw/cxl/cxl-mailbox-utils.c
> > +++ b/hw/cxl/cxl-mailbox-utils.c
> > @@ -84,6 +84,8 @@ enum {
> >       DCD_CONFIG  =3D 0x48, /*r3.0: 8.2.9.8.9*/
> >           #define GET_DC_CONFIG          0x0
> >           #define GET_DYN_CAP_EXT_LIST   0x1
> > +        #define ADD_DYN_CAP_RSP        0x2
> > +        #define RELEASE_DYN_CAP        0x3
> >       PHYSICAL_SWITCH =3D 0x51
> >           #define IDENTIFY_SWITCH_DEVICE      0x0
> >   };
> > @@ -1086,6 +1088,251 @@ static CXLRetCode cmd_dcd_get_dyn_cap_ext_list=
(struct cxl_cmd *cmd,
> >       return CXL_MBOX_SUCCESS;
> >   }
> >
> > +/*
> > + * Check whether the bits at addr between [nr, nr+size) are all set,
> > + * return 1 if all 1s, else return 0
> > + */
> > +static inline int test_bits(const unsigned long *addr, int nr, int si=
ze)
> > +{
> > +    unsigned long res =3D find_next_zero_bit(addr, size + nr, nr);
> > +
> > +    return (res >=3D nr + size) ? 1 : 0;
> > +}
> > +
> > +/*
> > + * Find dynamic capacity region id based on dpa range [dpa, dpa+len)
> > + */
> > +static uint8_t find_region_id(struct CXLType3Dev *dev, uint64_t dpa,
> > +        uint64_t len)
> > +{
> > +    int8_t i =3D dev->dc.num_regions - 1;
> > +
> > +    while (i > 0 && dpa < dev->dc.regions[i].base) {
> > +        i--;
> > +    }
> > +
> > +    if (dpa < dev->dc.regions[i].base
> > +            || dpa + len > dev->dc.regions[i].base + dev->dc.regions[=
i].len) {
> > +        return dev->dc.num_regions;
> > +    }
> > +
> > +    return i;
> > +}
> > +
> > +static void insert_extent_to_extent_list(CXLDCDExtentList *list, uint=
64_t dpa,
> > +        uint64_t len, uint8_t *tag, uint16_t shared_seq)
> > +{
> > +    CXLDCD_Extent *extent;
> > +    extent =3D g_new0(CXLDCD_Extent, 1);
> > +    extent->start_dpa =3D dpa;
> > +    extent->len =3D len;
> > +    if (tag) {
> > +        memcpy(extent->tag, tag, 0x10);
> > +    } else {
> > +        memset(extent->tag, 0, 0x10);
> > +    }
> > +    extent->shared_seq =3D shared_seq;
> > +
> > +    QTAILQ_INSERT_TAIL(list, extent, node);
> > +}
> > +
> > +typedef struct updated_dc_extent_list_in_pl {
> > +    uint32_t num_entries_updated;
> > +    uint8_t rsvd[4];
> > +    struct { /* r3.0: Table 8-130 */
> > +        uint64_t start_dpa;
> > +        uint64_t len;
> > +        uint8_t rsvd[8];
> > +    } QEMU_PACKED updated_entries[];
> > +} QEMU_PACKED updated_dc_extent_list_in_pl;
> > +
> > +/*
> > + * The function only check the input extent list against itself.
> > + */
> > +static CXLRetCode detect_malformed_extent_list(CXLType3Dev *dev,
> > +        const updated_dc_extent_list_in_pl *in)
> > +{
> > +    unsigned long *blk_bitmap;
> > +    uint64_t min_block_size =3D dev->dc.regions[0].block_size;
> > +    struct CXLDCD_Region *region =3D &dev->dc.regions[0];
> > +    uint32_t i;
> > +    uint64_t dpa, len;
> > +    uint8_t rid;
> > +    CXLRetCode ret;
> > +
> > +    for (i =3D 1; i < dev->dc.num_regions; i++) {
> > +        region =3D &dev->dc.regions[i];
> > +        if (min_block_size > region->block_size) {
> > +            min_block_size =3D region->block_size;
> > +        }
> > +    }
> > +
> > +    blk_bitmap =3D bitmap_new((region->len + region->base
> > +                - dev->dc.regions[0].base) / min_block_size);
> > +
> > +    for (i =3D 0; i < in->num_entries_updated; i++) {
> > +        dpa =3D in->updated_entries[i].start_dpa;
> > +        len =3D in->updated_entries[i].len;
> > +
> > +        rid =3D find_region_id(dev, dpa, len);
> > +        if (rid =3D=3D dev->dc.num_regions) {
> > +            ret =3D CXL_MBOX_INVALID_PA;
> > +            goto out;
> > +        }
> > +
> > +        region =3D &dev->dc.regions[rid];
> > +        if (dpa % region->block_size || len % region->block_size) {
> > +            ret =3D CXL_MBOX_INVALID_EXTENT_LIST;
> > +            goto out;
> > +        }
>
> Hi,
>
> The bitmap uses the dc region 0 base address as the baseline, so when
> checking the dpa against the bitmap it needs to be adjusted for that
> before the bitmap checks, e.g.,
>
> +        dpa -=3D dev->dc.regions[0].base;
>
> Thanks,
> Jorgen

Make sense. Will fix. Thanks.

Fan
>
> > +        /* the dpa range already covered by some other extents in the=
 list */
> > +        if (test_bits(blk_bitmap, dpa / min_block_size, len / min_blo=
ck_size)) {
> > +            ret =3D CXL_MBOX_INVALID_EXTENT_LIST;
> > +            goto out;
> > +        }
> > +        bitmap_set(blk_bitmap, dpa / min_block_size, len / min_block_=
size);
> > +   }
> > +
> > +    ret =3D CXL_MBOX_SUCCESS;
> > +
> > +out:
> > +    g_free(blk_bitmap);
> > +    return ret;
> > +}
> > +
> > +/*
> > + * cxl spec 3.0: 8.2.9.8.9.3
> > + * Add Dynamic Capacity Response (opcode 4802h)
> > + * Assume an extent is added only after the response is processed suc=
cessfully
> > + * TODO: for better extent list validation, a better solution would b=
e
> > + * maintaining a pending extent list and use it to verify the extent =
list in
> > + * the response.
> > + */
> > +static CXLRetCode cmd_dcd_add_dyn_cap_rsp(struct cxl_cmd *cmd,
> > +        CXLDeviceState *cxl_dstate, uint16_t *len_unused)
> > +{
> > +    updated_dc_extent_list_in_pl *in =3D (void *)cmd->payload;
> > +    struct CXLType3Dev *ct3d =3D container_of(cxl_dstate, CXLType3Dev=
,
> > +            cxl_dstate);
> > +    CXLDCDExtentList *extent_list =3D &ct3d->dc.extents;
> > +    CXLDCD_Extent *ent;
> > +    uint32_t i;
> > +    uint64_t dpa, len;
> > +    CXLRetCode ret;
> > +
> > +    if (in->num_entries_updated =3D=3D 0) {
> > +        ret =3D CXL_MBOX_SUCCESS;
> > +        goto out;
> > +    }
> > +
> > +    ret =3D detect_malformed_extent_list(ct3d, in);
> > +    if (ret !=3D CXL_MBOX_SUCCESS) {
> > +        goto out;
> > +    }
> > +
> > +    for (i =3D 0; i < in->num_entries_updated; i++) {
> > +        dpa =3D in->updated_entries[i].start_dpa;
> > +        len =3D in->updated_entries[i].len;
> > +
> > +        /*
> > +         * Check if the DPA range of the to-be-added extent overlaps =
with
> > +         * existing extent list maintained by the device.
> > +         */
> > +        QTAILQ_FOREACH(ent, extent_list, node) {
> > +            if (ent->start_dpa =3D=3D dpa && ent->len =3D=3D len) {
> > +                ret =3D CXL_MBOX_INVALID_PA;
> > +                goto out;
> > +            } else if (ent->start_dpa <=3D dpa
> > +                    && dpa + len <=3D ent->start_dpa + ent->len) {
> > +                ret =3D CXL_MBOX_INVALID_PA;
> > +                goto out;
> > +            } else if ((dpa < ent->start_dpa + ent->len
> > +                        && dpa + len > ent->start_dpa + ent->len)
> > +                    || (dpa < ent->start_dpa && dpa + len > ent->star=
t_dpa)) {
> > +                ret =3D CXL_MBOX_INVALID_PA;
> > +                goto out;
> > +            }
> > +        }
> > +
> > +        /*
> > +         * TODO: add a pending extent list based on event log record =
and verify
> > +         * the input response
> > +         */
> > +
> > +        insert_extent_to_extent_list(extent_list, dpa, len, NULL, 0);
> > +    }
> > +    ret =3D CXL_MBOX_SUCCESS;
> > +
> > +out:
> > +    return ret;
> > +}
> > +
> > +/*
> > + * Spec 3.0: 8.2.9.8.9.4
> > + * Release Dynamic Capacity (opcode 4803h)
> > + **/
> > +static CXLRetCode cmd_dcd_release_dyn_cap(struct cxl_cmd *cmd,
> > +        CXLDeviceState *cxl_dstate,
> > +        uint16_t *len_unused)
> > +{
> > +    updated_dc_extent_list_in_pl *in =3D (void *)cmd->payload;
> > +    struct CXLType3Dev *ct3d =3D container_of(cxl_dstate, CXLType3Dev=
,
> > +            cxl_dstate);
> > +    CXLDCDExtentList *extent_list =3D &ct3d->dc.extents;
> > +    CXLDCD_Extent *ent;
> > +    uint32_t i;
> > +    uint64_t dpa, len;
> > +    CXLRetCode ret;
> > +
> > +    if (in->num_entries_updated =3D=3D 0) {
> > +        return CXL_MBOX_INVALID_INPUT;
> > +    }
> > +
> > +    ret =3D detect_malformed_extent_list(ct3d, in);
> > +    if (ret !=3D CXL_MBOX_SUCCESS) {
> > +        return ret;
> > +    }
> > +
> > +    for (i =3D 0; i < in->num_entries_updated; i++) {
> > +        dpa =3D in->updated_entries[i].start_dpa;
> > +        len =3D in->updated_entries[i].len;
> > +
> > +        QTAILQ_FOREACH(ent, extent_list, node) {
> > +            if (ent->start_dpa =3D=3D dpa && ent->len =3D=3D len) {
> > +                break;
> > +            } else if (ent->start_dpa < dpa
> > +                    && dpa + len <=3D ent->start_dpa + ent->len) {
> > +                /* remove partial extent */
> > +                uint64_t len1 =3D dpa - ent->start_dpa;
> > +                uint64_t len2 =3D ent->start_dpa + ent->len - dpa - l=
en;
> > +
> > +                if (len1) {
> > +                    insert_extent_to_extent_list(extent_list, ent->st=
art_dpa,
> > +                            len1, NULL, 0);
> > +                }
> > +                if (len2) {
> > +                    insert_extent_to_extent_list(extent_list, dpa + l=
en, len2,
> > +                            NULL, 0);
> > +                }
> > +                break;
> > +            } else if ((dpa < ent->start_dpa + ent->len
> > +                        && dpa + len > ent->start_dpa + ent->len)
> > +                    || (dpa < ent->start_dpa && dpa + len > ent->star=
t_dpa))
> > +                return CXL_MBOX_INVALID_EXTENT_LIST;
> > +        }
> > +
> > +        if (ent) {
> > +            QTAILQ_REMOVE(extent_list, ent, node);
> > +            g_free(ent);
> > +        } else {
> > +            /* Try to remove a non-existing extent */
> > +            return CXL_MBOX_INVALID_PA;
> > +        }
> > +    }
> > +
> > +    return CXL_MBOX_SUCCESS;
> > +}
> > +
> >   #define IMMEDIATE_CONFIG_CHANGE (1 << 1)
> >   #define IMMEDIATE_DATA_CHANGE (1 << 2)
> >   #define IMMEDIATE_POLICY_CHANGE (1 << 3)
> > @@ -1129,6 +1376,12 @@ static struct cxl_cmd cxl_cmd_set[256][256] =3D=
 {
> >       [DCD_CONFIG][GET_DYN_CAP_EXT_LIST] =3D {
> >           "DCD_GET_DYNAMIC_CAPACITY_EXTENT_LIST", cmd_dcd_get_dyn_cap_=
ext_list,
> >           8, 0 },
> > +    [DCD_CONFIG][ADD_DYN_CAP_RSP] =3D {
> > +        "ADD_DCD_DYNAMIC_CAPACITY_RESPONSE", cmd_dcd_add_dyn_cap_rsp,
> > +        ~0, IMMEDIATE_DATA_CHANGE },
> > +    [DCD_CONFIG][RELEASE_DYN_CAP] =3D {
> > +        "RELEASE_DCD_DYNAMIC_CAPACITY", cmd_dcd_release_dyn_cap,
> > +        ~0, IMMEDIATE_DATA_CHANGE },
> >   };
> >
> >   static struct cxl_cmd cxl_cmd_set_sw[256][256] =3D {
> > diff --git a/include/hw/cxl/cxl_device.h b/include/hw/cxl/cxl_device.h
> > index 3a338b3b37..01a5eaca48 100644
> > --- a/include/hw/cxl/cxl_device.h
> > +++ b/include/hw/cxl/cxl_device.h
> > @@ -130,7 +130,8 @@ typedef enum {
> >       CXL_MBOX_INCORRECT_PASSPHRASE =3D 0x14,
> >       CXL_MBOX_UNSUPPORTED_MAILBOX =3D 0x15,
> >       CXL_MBOX_INVALID_PAYLOAD_LENGTH =3D 0x16,
> > -    CXL_MBOX_MAX =3D 0x17
> > +    CXL_MBOX_INVALID_EXTENT_LIST =3D 0x1E, /* cxl r3.0: Table 8-34*/
> > +    CXL_MBOX_MAX =3D 0x1F
> >   } CXLRetCode;
> >
> >   struct cxl_cmd;
> > --
> > 2.25.1

