From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 8CB71CA0ECF
	for <linux-cxl@archiver.kernel.org>; Mon, 11 Sep 2023 22:24:12 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S235445AbjIKWVi (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Mon, 11 Sep 2023 18:21:38 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:52532 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S236958AbjIKLow (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Mon, 11 Sep 2023 07:44:52 -0400
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 9E3E8E40
        for <linux-cxl@vger.kernel.org>; Mon, 11 Sep 2023 04:44:47 -0700 (PDT)
Received: from lhrpeml500005.china.huawei.com (unknown [172.18.147.226])
        by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4RklBd36gKz6J7wT;
        Mon, 11 Sep 2023 19:40:09 +0800 (CST)
Received: from SecurePC-101-06.china.huawei.com (10.122.247.231) by
 lhrpeml500005.china.huawei.com (7.191.163.240) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.31; Mon, 11 Sep 2023 12:44:45 +0100
From: Jonathan Cameron <Jonathan.Cameron@huawei.com>
To: <qemu-devel@nongnu.org>, Michael Tsirkin <mst@redhat.com>,
        Fan Ni <fan.ni@samsung.com>,
        =?UTF-8?q?Philippe=20Mathieu-Daud=C3=A9?= <philmd@linaro.org>,
        <linux-cxl@vger.kernel.org>
CC: <linuxarm@huawei.com>
Subject: [PATCH v3 3/4] hw/cxl: Fix and use same calculation for HDM decoder block size everywhere
Date: Mon, 11 Sep 2023 12:43:12 +0100
Message-ID: <20230911114313.6144-4-Jonathan.Cameron@huawei.com>
X-Mailer: git-send-email 2.39.2
In-Reply-To: <20230911114313.6144-1-Jonathan.Cameron@huawei.com>
References: <20230911114313.6144-1-Jonathan.Cameron@huawei.com>
MIME-Version: 1.0
Content-Transfer-Encoding: 7BIT
Content-Type: text/plain; charset=US-ASCII
X-Originating-IP: [10.122.247.231]
X-ClientProxiedBy: lhrpeml500002.china.huawei.com (7.191.160.78) To
 lhrpeml500005.china.huawei.com (7.191.163.240)
X-CFilter-Loop: Reflected
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

In order to avoid having the size of the per HDM decoder register block
repeated in lots of places, create the register definitions for HDM
decoder 1 and use the offset between the first registers in HDM decoder 0 and
HDM decoder 1 to establish the offset.

Calculate in each function as this is more obvious and leads to shorter
line lengths than a single #define which would need a long name
to be specific enough.

Note that the code currently only supports one decoder, so the bugs this
fixes don't actually affect anything. Previously the offset didn't
take into account that the write_msk etc are 4 byte fields.

Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

--
v3:
New patch to separate this out from the addition of HDM decoders.
---
 include/hw/cxl/cxl_component.h |  2 ++
 hw/cxl/cxl-component-utils.c   | 19 +++++++++++--------
 hw/cxl/cxl-host.c              |  4 +++-
 hw/mem/cxl_type3.c             | 24 +++++++++++++++---------
 4 files changed, 31 insertions(+), 18 deletions(-)

diff --git a/include/hw/cxl/cxl_component.h b/include/hw/cxl/cxl_component.h
index ef9e033919..7c864d2044 100644
--- a/include/hw/cxl/cxl_component.h
+++ b/include/hw/cxl/cxl_component.h
@@ -148,6 +148,8 @@ REG32(CXL_HDM_DECODER_GLOBAL_CONTROL, CXL_HDM_REGISTERS_OFFSET + 4)
     FIELD(CXL_HDM_DECODER_GLOBAL_CONTROL, HDM_DECODER_ENABLE, 1, 1)
 
 HDM_DECODER_INIT(0);
+/* Only used for HDM decoder registers block address increment */
+HDM_DECODER_INIT(1);
 
 /* 8.2.5.13 - CXL Extended Security Capability Structure (Root complex only) */
 #define EXTSEC_ENTRY_MAX        256
diff --git a/hw/cxl/cxl-component-utils.c b/hw/cxl/cxl-component-utils.c
index 352d0dace2..aa011a8f34 100644
--- a/hw/cxl/cxl-component-utils.c
+++ b/hw/cxl/cxl-component-utils.c
@@ -210,6 +210,7 @@ static void hdm_init_common(uint32_t *reg_state, uint32_t *write_msk,
                             enum reg_type type)
 {
     int decoder_count = 1;
+    int hdm_inc = R_CXL_HDM_DECODER1_BASE_LO - R_CXL_HDM_DECODER0_BASE_LO;
     int i;
 
     ARRAY_FIELD_DP32(reg_state, CXL_HDM_DECODER_CAPABILITY, DECODER_COUNT,
@@ -222,19 +223,21 @@ static void hdm_init_common(uint32_t *reg_state, uint32_t *write_msk,
                      HDM_DECODER_ENABLE, 0);
     write_msk[R_CXL_HDM_DECODER_GLOBAL_CONTROL] = 0x3;
     for (i = 0; i < decoder_count; i++) {
-        write_msk[R_CXL_HDM_DECODER0_BASE_LO + i * 0x20] = 0xf0000000;
-        write_msk[R_CXL_HDM_DECODER0_BASE_HI + i * 0x20] = 0xffffffff;
-        write_msk[R_CXL_HDM_DECODER0_SIZE_LO + i * 0x20] = 0xf0000000;
-        write_msk[R_CXL_HDM_DECODER0_SIZE_HI + i * 0x20] = 0xffffffff;
-        write_msk[R_CXL_HDM_DECODER0_CTRL + i * 0x20] = 0x13ff;
+        write_msk[R_CXL_HDM_DECODER0_BASE_LO + i * hdm_inc] = 0xf0000000;
+        write_msk[R_CXL_HDM_DECODER0_BASE_HI + i * hdm_inc] = 0xffffffff;
+        write_msk[R_CXL_HDM_DECODER0_SIZE_LO + i * hdm_inc] = 0xf0000000;
+        write_msk[R_CXL_HDM_DECODER0_SIZE_HI + i * hdm_inc] = 0xffffffff;
+        write_msk[R_CXL_HDM_DECODER0_CTRL + i * hdm_inc] = 0x13ff;
         if (type == CXL2_DEVICE ||
             type == CXL2_TYPE3_DEVICE ||
             type == CXL2_LOGICAL_DEVICE) {
-            write_msk[R_CXL_HDM_DECODER0_TARGET_LIST_LO + i * 0x20] = 0xf0000000;
+            write_msk[R_CXL_HDM_DECODER0_TARGET_LIST_LO + i * hdm_inc] =
+                0xf0000000;
         } else {
-            write_msk[R_CXL_HDM_DECODER0_TARGET_LIST_LO + i * 0x20] = 0xffffffff;
+            write_msk[R_CXL_HDM_DECODER0_TARGET_LIST_LO + i * hdm_inc] =
+                0xffffffff;
         }
-        write_msk[R_CXL_HDM_DECODER0_TARGET_LIST_HI + i * 0x20] = 0xffffffff;
+        write_msk[R_CXL_HDM_DECODER0_TARGET_LIST_HI + i * hdm_inc] = 0xffffffff;
     }
 }
 
diff --git a/hw/cxl/cxl-host.c b/hw/cxl/cxl-host.c
index f0920da956..73c5426476 100644
--- a/hw/cxl/cxl-host.c
+++ b/hw/cxl/cxl-host.c
@@ -101,12 +101,14 @@ void cxl_fmws_link_targets(CXLState *cxl_state, Error **errp)
 static bool cxl_hdm_find_target(uint32_t *cache_mem, hwaddr addr,
                                 uint8_t *target)
 {
+    int hdm_inc = R_CXL_HDM_DECODER1_BASE_LO - R_CXL_HDM_DECODER0_BASE_LO;
     uint32_t ctrl;
     uint32_t ig_enc;
     uint32_t iw_enc;
     uint32_t target_idx;
+    int i = 0;
 
-    ctrl = cache_mem[R_CXL_HDM_DECODER0_CTRL];
+    ctrl = cache_mem[R_CXL_HDM_DECODER0_CTRL + i * hdm_inc];
     if (!FIELD_EX32(ctrl, CXL_HDM_DECODER0_CTRL, COMMITTED)) {
         return false;
     }
diff --git a/hw/mem/cxl_type3.c b/hw/mem/cxl_type3.c
index 4e314748d3..cd92813436 100644
--- a/hw/mem/cxl_type3.c
+++ b/hw/mem/cxl_type3.c
@@ -377,34 +377,36 @@ static void build_dvsecs(CXLType3Dev *ct3d)
 
 static void hdm_decoder_commit(CXLType3Dev *ct3d, int which)
 {
+    int hdm_inc = R_CXL_HDM_DECODER1_BASE_LO - R_CXL_HDM_DECODER0_BASE_LO;
     ComponentRegisters *cregs = &ct3d->cxl_cstate.crb;
     uint32_t *cache_mem = cregs->cache_mem_registers;
     uint32_t ctrl;
 
     assert(which == 0);
 
-    ctrl = ldl_le_p(cache_mem + R_CXL_HDM_DECODER0_CTRL);
+    ctrl = ldl_le_p(cache_mem + R_CXL_HDM_DECODER0_CTRL + which * hdm_inc);
     /* TODO: Sanity checks that the decoder is possible */
     ctrl = FIELD_DP32(ctrl, CXL_HDM_DECODER0_CTRL, ERR, 0);
     ctrl = FIELD_DP32(ctrl, CXL_HDM_DECODER0_CTRL, COMMITTED, 1);
 
-    stl_le_p(cache_mem + R_CXL_HDM_DECODER0_CTRL, ctrl);
+    stl_le_p(cache_mem + R_CXL_HDM_DECODER0_CTRL + which * hdm_inc, ctrl);
 }
 
 static void hdm_decoder_uncommit(CXLType3Dev *ct3d, int which)
 {
+    int hdm_inc = R_CXL_HDM_DECODER1_BASE_LO - R_CXL_HDM_DECODER0_BASE_LO;
     ComponentRegisters *cregs = &ct3d->cxl_cstate.crb;
     uint32_t *cache_mem = cregs->cache_mem_registers;
     uint32_t ctrl;
 
     assert(which == 0);
 
-    ctrl = ldl_le_p(cache_mem + R_CXL_HDM_DECODER0_CTRL);
+    ctrl = ldl_le_p(cache_mem + R_CXL_HDM_DECODER0_CTRL + which * hdm_inc);
 
     ctrl = FIELD_DP32(ctrl, CXL_HDM_DECODER0_CTRL, ERR, 0);
     ctrl = FIELD_DP32(ctrl, CXL_HDM_DECODER0_CTRL, COMMITTED, 0);
 
-    stl_le_p(cache_mem + R_CXL_HDM_DECODER0_CTRL, ctrl);
+    stl_le_p(cache_mem + R_CXL_HDM_DECODER0_CTRL + which * hdm_inc, ctrl);
 }
 
 static int ct3d_qmp_uncor_err_to_cxl(CxlUncorErrorType qmp_err)
@@ -761,26 +763,30 @@ static void ct3_exit(PCIDevice *pci_dev)
 /* TODO: Support multiple HDM decoders and DPA skip */
 static bool cxl_type3_dpa(CXLType3Dev *ct3d, hwaddr host_addr, uint64_t *dpa)
 {
+    int hdm_inc = R_CXL_HDM_DECODER1_BASE_LO - R_CXL_HDM_DECODER0_BASE_LO;
     uint32_t *cache_mem = ct3d->cxl_cstate.crb.cache_mem_registers;
     uint64_t decoder_base, decoder_size, hpa_offset;
     uint32_t hdm0_ctrl;
     int ig, iw;
+    int i = 0;
 
-    decoder_base = (((uint64_t)cache_mem[R_CXL_HDM_DECODER0_BASE_HI] << 32) |
-                    cache_mem[R_CXL_HDM_DECODER0_BASE_LO]);
+    decoder_base =
+        (((uint64_t)cache_mem[R_CXL_HDM_DECODER0_BASE_HI + i * hdm_inc] << 32) |
+                    cache_mem[R_CXL_HDM_DECODER0_BASE_LO + i * hdm_inc]);
     if ((uint64_t)host_addr < decoder_base) {
         return false;
     }
 
     hpa_offset = (uint64_t)host_addr - decoder_base;
 
-    decoder_size = ((uint64_t)cache_mem[R_CXL_HDM_DECODER0_SIZE_HI] << 32) |
-        cache_mem[R_CXL_HDM_DECODER0_SIZE_LO];
+    decoder_size =
+        ((uint64_t)cache_mem[R_CXL_HDM_DECODER0_SIZE_HI + i * hdm_inc] << 32) |
+        cache_mem[R_CXL_HDM_DECODER0_SIZE_LO + i * hdm_inc];
     if (hpa_offset >= decoder_size) {
         return false;
     }
 
-    hdm0_ctrl = cache_mem[R_CXL_HDM_DECODER0_CTRL];
+    hdm0_ctrl = cache_mem[R_CXL_HDM_DECODER0_CTRL + i * hdm_inc];
     iw = FIELD_EX32(hdm0_ctrl, CXL_HDM_DECODER0_CTRL, IW);
     ig = FIELD_EX32(hdm0_ctrl, CXL_HDM_DECODER0_CTRL, IG);
 
-- 
2.39.2


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 3A56CCA0EDC
	for <linux-cxl@archiver.kernel.org>; Mon, 11 Sep 2023 22:24:29 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S236345AbjIKWWH (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Mon, 11 Sep 2023 18:22:07 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:59786 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S236932AbjIKLnV (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Mon, 11 Sep 2023 07:43:21 -0400
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 08902E40
        for <linux-cxl@vger.kernel.org>; Mon, 11 Sep 2023 04:43:16 -0700 (PDT)
Received: from lhrpeml500005.china.huawei.com (unknown [172.18.147.207])
        by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4RklDK2PSbz67FSP;
        Mon, 11 Sep 2023 19:41:37 +0800 (CST)
Received: from SecurePC-101-06.china.huawei.com (10.122.247.231) by
 lhrpeml500005.china.huawei.com (7.191.163.240) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.31; Mon, 11 Sep 2023 12:43:13 +0100
From: Jonathan Cameron <Jonathan.Cameron@huawei.com>
To: <qemu-devel@nongnu.org>, Michael Tsirkin <mst@redhat.com>,
        Fan Ni <fan.ni@samsung.com>,
        =?UTF-8?q?Philippe=20Mathieu-Daud=C3=A9?= <philmd@linaro.org>,
        <linux-cxl@vger.kernel.org>
CC: <linuxarm@huawei.com>
Subject: [PATCH v3 0/4] hw/cxl: Support emulating 4 HDM decoders throughout topology
Date: Mon, 11 Sep 2023 12:43:09 +0100
Message-ID: <20230911114313.6144-1-Jonathan.Cameron@huawei.com>
X-Mailer: git-send-email 2.39.2
MIME-Version: 1.0
Content-Type: text/plain; charset="UTF-8"
Content-Transfer-Encoding: 8bit
X-Originating-IP: [10.122.247.231]
X-ClientProxiedBy: lhrpeml500002.china.huawei.com (7.191.160.78) To
 lhrpeml500005.china.huawei.com (7.191.163.240)
X-CFilter-Loop: Reflected
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

v3: Thanks to Philippe.
 - Pull the hdm_inc change out as a precursor to the increase in HDM
   decoders (new patch: 3)
 - Fix a bug where cxl-host used the encoded count as if it were the
   decoded version.

For initial CXL emulation / kernel driver bring up a single Host-managed
Device Memory (HDM) decoder instance was sufficient as it let us test the
basic region creation code etc. More complex testing appropriate today
requires a more realistic configuration with multiple decoders.

The Linux kernel will use separate decoders for each memory type (and
shortly per DCD region) and for each interleave set within a memory type
or DCD region. 4 decoders are sufficient for most test cases today but
we may need to grow these further in future.

This patch set already allowed us to identify one kernel bug which is
now fixed.
https://lore.kernel.org/linux-cxl/168696507968.3590522.14484000711718573626.stgit@dwillia2-xfh.jf.intel.com/

Note that, whilst I'm proposing this series for upstream (based on
priorities of what we have out of tree) it hasn't previously been posted
so needs review. (I failed to send it out previously)

Based on: [PATCH 0/4] hw/cxl: Minor CXL emulation fixes and cleanup
Based on: [PATCH v2 0/3] hw/cxl: Add dummy ACPI QTG DSM

Based on: Message ID: 20230904132806.6094-1-Jonathan.Cameron@huawei.com
Based on: Message ID: 20230904161847.18468-1-Jonathan.Cameron@huawei.com

Jonathan Cameron (4):
  hw/cxl: Push cxl_decoder_count_enc() and cxl_decode_ig() into .c
  hw/cxl: Add utility functions decoder interleave ways and target
    count.
  hw/cxl: Fix and use same calculation for HDM decoder block size
    everywhere
  hw/cxl: Support 4 HDM decoders at all levels of topology

 include/hw/cxl/cxl_component.h |  30 +++++-----
 hw/cxl/cxl-component-utils.c   |  91 +++++++++++++++++++++++++----
 hw/cxl/cxl-host.c              |  67 +++++++++++++++-------
 hw/mem/cxl_type3.c             | 102 +++++++++++++++++++++++----------
 4 files changed, 212 insertions(+), 78 deletions(-)

-- 
2.39.2


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id E13C6CA0EDE
	for <linux-cxl@archiver.kernel.org>; Mon, 11 Sep 2023 22:24:30 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S239207AbjIKWWL (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Mon, 11 Sep 2023 18:22:11 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:45608 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S236938AbjIKLnv (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Mon, 11 Sep 2023 07:43:51 -0400
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id A1C9CE40
        for <linux-cxl@vger.kernel.org>; Mon, 11 Sep 2023 04:43:46 -0700 (PDT)
Received: from lhrpeml500005.china.huawei.com (unknown [172.18.147.200])
        by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4RklDw00Vkz67FSP;
        Mon, 11 Sep 2023 19:42:07 +0800 (CST)
Received: from SecurePC-101-06.china.huawei.com (10.122.247.231) by
 lhrpeml500005.china.huawei.com (7.191.163.240) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.31; Mon, 11 Sep 2023 12:43:44 +0100
From: Jonathan Cameron <Jonathan.Cameron@huawei.com>
To: <qemu-devel@nongnu.org>, Michael Tsirkin <mst@redhat.com>,
        Fan Ni <fan.ni@samsung.com>,
        =?UTF-8?q?Philippe=20Mathieu-Daud=C3=A9?= <philmd@linaro.org>,
        <linux-cxl@vger.kernel.org>
CC: <linuxarm@huawei.com>
Subject: [PATCH v3 1/4] hw/cxl: Push cxl_decoder_count_enc() and cxl_decode_ig() into .c
Date: Mon, 11 Sep 2023 12:43:10 +0100
Message-ID: <20230911114313.6144-2-Jonathan.Cameron@huawei.com>
X-Mailer: git-send-email 2.39.2
In-Reply-To: <20230911114313.6144-1-Jonathan.Cameron@huawei.com>
References: <20230911114313.6144-1-Jonathan.Cameron@huawei.com>
MIME-Version: 1.0
Content-Type: text/plain; charset="UTF-8"
Content-Transfer-Encoding: 8bit
X-Originating-IP: [10.122.247.231]
X-ClientProxiedBy: lhrpeml500002.china.huawei.com (7.191.160.78) To
 lhrpeml500005.china.huawei.com (7.191.163.240)
X-CFilter-Loop: Reflected
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

There is no strong justification for keeping these in the header
so push them down into the associated cxl-component-utils.c file.

Suggested-by: Philippe Mathieu-Daudé <philmd@linaro.org>
Reviewed-by: Philippe Mathieu-Daudé <philmd@linaro.org>
Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
---
 include/hw/cxl/cxl_component.h | 18 ++----------------
 hw/cxl/cxl-component-utils.c   | 18 ++++++++++++++++++
 2 files changed, 20 insertions(+), 16 deletions(-)

diff --git a/include/hw/cxl/cxl_component.h b/include/hw/cxl/cxl_component.h
index 42c7e581a7..bdb3881a6b 100644
--- a/include/hw/cxl/cxl_component.h
+++ b/include/hw/cxl/cxl_component.h
@@ -225,26 +225,12 @@ void cxl_component_create_dvsec(CXLComponentState *cxl_cstate,
                                 enum reg_type cxl_dev_type, uint16_t length,
                                 uint16_t type, uint8_t rev, uint8_t *body);
 
-static inline int cxl_decoder_count_enc(int count)
-{
-    switch (count) {
-    case 1: return 0;
-    case 2: return 1;
-    case 4: return 2;
-    case 6: return 3;
-    case 8: return 4;
-    case 10: return 5;
-    }
-    return 0;
-}
+int cxl_decoder_count_enc(int count);
 
 uint8_t cxl_interleave_ways_enc(int iw, Error **errp);
 uint8_t cxl_interleave_granularity_enc(uint64_t gran, Error **errp);
 
-static inline hwaddr cxl_decode_ig(int ig)
-{
-    return 1ULL << (ig + 8);
-}
+hwaddr cxl_decode_ig(int ig);
 
 CXLComponentState *cxl_get_hb_cstate(PCIHostState *hb);
 bool cxl_get_hb_passthrough(PCIHostState *hb);
diff --git a/hw/cxl/cxl-component-utils.c b/hw/cxl/cxl-component-utils.c
index 378f1082ce..ea2d4770ec 100644
--- a/hw/cxl/cxl-component-utils.c
+++ b/hw/cxl/cxl-component-utils.c
@@ -13,6 +13,24 @@
 #include "hw/pci/pci.h"
 #include "hw/cxl/cxl.h"
 
+int cxl_decoder_count_enc(int count)
+{
+    switch (count) {
+    case 1: return 0;
+    case 2: return 1;
+    case 4: return 2;
+    case 6: return 3;
+    case 8: return 4;
+    case 10: return 5;
+    }
+    return 0;
+}
+
+hwaddr cxl_decode_ig(int ig)
+{
+    return 1ULL << (ig + 8);
+}
+
 static uint64_t cxl_cache_mem_read_reg(void *opaque, hwaddr offset,
                                        unsigned size)
 {
-- 
2.39.2


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 295DBCA0ECE
	for <linux-cxl@archiver.kernel.org>; Mon, 11 Sep 2023 22:24:40 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S240476AbjIKWWR (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Mon, 11 Sep 2023 18:22:17 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:38984 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S236947AbjIKLod (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Mon, 11 Sep 2023 07:44:33 -0400
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id C77EFCDD
        for <linux-cxl@vger.kernel.org>; Mon, 11 Sep 2023 04:44:27 -0700 (PDT)
Received: from lhrpeml500005.china.huawei.com (unknown [172.18.147.201])
        by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4RklH32zPzz6K6gx;
        Mon, 11 Sep 2023 19:43:59 +0800 (CST)
Received: from SecurePC-101-06.china.huawei.com (10.122.247.231) by
 lhrpeml500005.china.huawei.com (7.191.163.240) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.31; Mon, 11 Sep 2023 12:44:15 +0100
From: Jonathan Cameron <Jonathan.Cameron@huawei.com>
To: <qemu-devel@nongnu.org>, Michael Tsirkin <mst@redhat.com>,
        Fan Ni <fan.ni@samsung.com>,
        =?UTF-8?q?Philippe=20Mathieu-Daud=C3=A9?= <philmd@linaro.org>,
        <linux-cxl@vger.kernel.org>
CC: <linuxarm@huawei.com>
Subject: [PATCH v3 2/4] hw/cxl: Add utility functions decoder interleave ways and target count.
Date: Mon, 11 Sep 2023 12:43:11 +0100
Message-ID: <20230911114313.6144-3-Jonathan.Cameron@huawei.com>
X-Mailer: git-send-email 2.39.2
In-Reply-To: <20230911114313.6144-1-Jonathan.Cameron@huawei.com>
References: <20230911114313.6144-1-Jonathan.Cameron@huawei.com>
MIME-Version: 1.0
Content-Type: text/plain; charset="UTF-8"
Content-Transfer-Encoding: 8bit
X-Originating-IP: [10.122.247.231]
X-ClientProxiedBy: lhrpeml500002.china.huawei.com (7.191.160.78) To
 lhrpeml500005.china.huawei.com (7.191.163.240)
X-CFilter-Loop: Reflected
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

As an encoded version of these key configuration parameters is available
in a register, provide functions to extract it again so as to avoid
the need for duplicating the storage.

Whilst here update the _enc() function to include additional values
as defined in the CXL 3.0 specification. Whilst they are not
currently used in the emulation, they may be in future and it is
easier to compare with the specification if all values are covered.

Reviewed-by: Philippe Mathieu-Daudé <philmd@linaro.org>
Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
---
v3: No changes, picked up tags.
v2: Thanks to Philippe Mathieu-Daudé
 - Expand both enc() and dec() functions to include full set of values
   defined in CXL r3.0
 - Pushed implementation down into the .c file.
---
 include/hw/cxl/cxl_component.h |  2 ++
 hw/cxl/cxl-component-utils.c   | 59 ++++++++++++++++++++++++++++++----
 2 files changed, 55 insertions(+), 6 deletions(-)

diff --git a/include/hw/cxl/cxl_component.h b/include/hw/cxl/cxl_component.h
index bdb3881a6b..ef9e033919 100644
--- a/include/hw/cxl/cxl_component.h
+++ b/include/hw/cxl/cxl_component.h
@@ -226,8 +226,10 @@ void cxl_component_create_dvsec(CXLComponentState *cxl_cstate,
                                 uint16_t type, uint8_t rev, uint8_t *body);
 
 int cxl_decoder_count_enc(int count);
+int cxl_decoder_count_dec(int enc_cnt);
 
 uint8_t cxl_interleave_ways_enc(int iw, Error **errp);
+int cxl_interleave_ways_dec(uint8_t iw_enc, Error **errp);
 uint8_t cxl_interleave_granularity_enc(uint64_t gran, Error **errp);
 
 hwaddr cxl_decode_ig(int ig);
diff --git a/hw/cxl/cxl-component-utils.c b/hw/cxl/cxl-component-utils.c
index ea2d4770ec..352d0dace2 100644
--- a/hw/cxl/cxl-component-utils.c
+++ b/hw/cxl/cxl-component-utils.c
@@ -13,15 +13,45 @@
 #include "hw/pci/pci.h"
 #include "hw/cxl/cxl.h"
 
+/* CXL r3.0 Section 8.2.4.19.1 CXL HDM Decoder Capability Register */
 int cxl_decoder_count_enc(int count)
 {
     switch (count) {
-    case 1: return 0;
-    case 2: return 1;
-    case 4: return 2;
-    case 6: return 3;
-    case 8: return 4;
-    case 10: return 5;
+    case 1: return 0x0;
+    case 2: return 0x1;
+    case 4: return 0x2;
+    case 6: return 0x3;
+    case 8: return 0x4;
+    case 10: return 0x5;
+    /* Switches and Host Bridges may have more than 10 decoders */
+    case 12: return 0x6;
+    case 14: return 0x7;
+    case 16: return 0x8;
+    case 20: return 0x9;
+    case 24: return 0xa;
+    case 28: return 0xb;
+    case 32: return 0xc;
+    }
+    return 0;
+}
+
+int cxl_decoder_count_dec(int enc_cnt)
+{
+    switch (enc_cnt) {
+    case 0x0: return 1;
+    case 0x1: return 2;
+    case 0x2: return 4;
+    case 0x3: return 6;
+    case 0x4: return 8;
+    case 0x5: return 10;
+    /* Switches and Host Bridges may have more than 10 decoders */
+    case 0x6: return 12;
+    case 0x7: return 14;
+    case 0x8: return 16;
+    case 0x9: return 20;
+    case 0xa: return 24;
+    case 0xb: return 28;
+    case 0xc: return 32;
     }
     return 0;
 }
@@ -410,6 +440,23 @@ uint8_t cxl_interleave_ways_enc(int iw, Error **errp)
     }
 }
 
+int cxl_interleave_ways_dec(uint8_t iw_enc, Error **errp)
+{
+    switch (iw_enc) {
+    case 0x0: return 1;
+    case 0x1: return 2;
+    case 0x2: return 4;
+    case 0x3: return 8;
+    case 0x4: return 16;
+    case 0x8: return 3;
+    case 0x9: return 6;
+    case 0xa: return 12;
+    default:
+        error_setg(errp, "Encoded interleave ways: %d not supported", iw_enc);
+        return 0;
+    }
+}
+
 uint8_t cxl_interleave_granularity_enc(uint64_t gran, Error **errp)
 {
     switch (gran) {
-- 
2.39.2


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 49ADECA0EC9
	for <linux-cxl@archiver.kernel.org>; Mon, 11 Sep 2023 22:24:51 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S240660AbjIKWW3 (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Mon, 11 Sep 2023 18:22:29 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:43216 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S236966AbjIKLpX (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Mon, 11 Sep 2023 07:45:23 -0400
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id AA21CCDD
        for <linux-cxl@vger.kernel.org>; Mon, 11 Sep 2023 04:45:18 -0700 (PDT)
Received: from lhrpeml500005.china.huawei.com (unknown [172.18.147.206])
        by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4RklGh00Cxz6HJqj;
        Mon, 11 Sep 2023 19:43:39 +0800 (CST)
Received: from SecurePC-101-06.china.huawei.com (10.122.247.231) by
 lhrpeml500005.china.huawei.com (7.191.163.240) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.31; Mon, 11 Sep 2023 12:45:16 +0100
From: Jonathan Cameron <Jonathan.Cameron@huawei.com>
To: <qemu-devel@nongnu.org>, Michael Tsirkin <mst@redhat.com>,
        Fan Ni <fan.ni@samsung.com>,
        =?UTF-8?q?Philippe=20Mathieu-Daud=C3=A9?= <philmd@linaro.org>,
        <linux-cxl@vger.kernel.org>
CC: <linuxarm@huawei.com>
Subject: [PATCH v3 4/4] hw/cxl: Support 4 HDM decoders at all levels of topology
Date: Mon, 11 Sep 2023 12:43:13 +0100
Message-ID: <20230911114313.6144-5-Jonathan.Cameron@huawei.com>
X-Mailer: git-send-email 2.39.2
In-Reply-To: <20230911114313.6144-1-Jonathan.Cameron@huawei.com>
References: <20230911114313.6144-1-Jonathan.Cameron@huawei.com>
MIME-Version: 1.0
Content-Transfer-Encoding: 7BIT
Content-Type: text/plain; charset=US-ASCII
X-Originating-IP: [10.122.247.231]
X-ClientProxiedBy: lhrpeml500002.china.huawei.com (7.191.160.78) To
 lhrpeml500005.china.huawei.com (7.191.163.240)
X-CFilter-Loop: Reflected
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

Support these decoders in CXL host bridges (pxb-cxl), CXL Switch USP
and CXL Type 3 end points.

Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

---
v3: Factor out the hdm_inc changes to previous patch.
    Fix use of encoded hdm count as if it were decoded in cxl-host.
    Minor refactoring to make that path and one in cxl_type3.c
    look more similar.
---
 include/hw/cxl/cxl_component.h | 10 +++-
 hw/cxl/cxl-component-utils.c   |  7 ++-
 hw/cxl/cxl-host.c              | 67 ++++++++++++++++--------
 hw/mem/cxl_type3.c             | 96 +++++++++++++++++++++++-----------
 4 files changed, 124 insertions(+), 56 deletions(-)

diff --git a/include/hw/cxl/cxl_component.h b/include/hw/cxl/cxl_component.h
index 7c864d2044..3c795a6278 100644
--- a/include/hw/cxl/cxl_component.h
+++ b/include/hw/cxl/cxl_component.h
@@ -135,6 +135,10 @@ REG32(CXL_RAS_ERR_HEADER0, CXL_RAS_REGISTERS_OFFSET + 0x18)
   REG32(CXL_HDM_DECODER##n##_TARGET_LIST_LO,                                   \
         CXL_HDM_REGISTERS_OFFSET + (0x20 * n) + 0x24)                          \
   REG32(CXL_HDM_DECODER##n##_TARGET_LIST_HI,                                   \
+        CXL_HDM_REGISTERS_OFFSET + (0x20 * n) + 0x28)                          \
+  REG32(CXL_HDM_DECODER##n##_DPA_SKIP_LO,                                      \
+        CXL_HDM_REGISTERS_OFFSET + (0x20 * n) + 0x24)                          \
+  REG32(CXL_HDM_DECODER##n##_DPA_SKIP_HI,                                      \
         CXL_HDM_REGISTERS_OFFSET + (0x20 * n) + 0x28)
 
 REG32(CXL_HDM_DECODER_CAPABILITY, CXL_HDM_REGISTERS_OFFSET)
@@ -147,9 +151,13 @@ REG32(CXL_HDM_DECODER_GLOBAL_CONTROL, CXL_HDM_REGISTERS_OFFSET + 4)
     FIELD(CXL_HDM_DECODER_GLOBAL_CONTROL, POISON_ON_ERR_EN, 0, 1)
     FIELD(CXL_HDM_DECODER_GLOBAL_CONTROL, HDM_DECODER_ENABLE, 1, 1)
 
+/* Support 4 decoders at all levels of topology */
+#define CXL_HDM_DECODER_COUNT 4
+
 HDM_DECODER_INIT(0);
-/* Only used for HDM decoder registers block address increment */
 HDM_DECODER_INIT(1);
+HDM_DECODER_INIT(2);
+HDM_DECODER_INIT(3);
 
 /* 8.2.5.13 - CXL Extended Security Capability Structure (Root complex only) */
 #define EXTSEC_ENTRY_MAX        256
diff --git a/hw/cxl/cxl-component-utils.c b/hw/cxl/cxl-component-utils.c
index aa011a8f34..3ecdad4a5e 100644
--- a/hw/cxl/cxl-component-utils.c
+++ b/hw/cxl/cxl-component-utils.c
@@ -90,6 +90,9 @@ static void dumb_hdm_handler(CXLComponentState *cxl_cstate, hwaddr offset,
 
     switch (offset) {
     case A_CXL_HDM_DECODER0_CTRL:
+    case A_CXL_HDM_DECODER1_CTRL:
+    case A_CXL_HDM_DECODER2_CTRL:
+    case A_CXL_HDM_DECODER3_CTRL:
         should_commit = FIELD_EX32(value, CXL_HDM_DECODER0_CTRL, COMMIT);
         should_uncommit = !should_commit;
         break;
@@ -129,7 +132,7 @@ static void cxl_cache_mem_write_reg(void *opaque, hwaddr offset, uint64_t value,
     }
 
     if (offset >= A_CXL_HDM_DECODER_CAPABILITY &&
-        offset <= A_CXL_HDM_DECODER0_TARGET_LIST_HI) {
+        offset <= A_CXL_HDM_DECODER3_TARGET_LIST_HI) {
         dumb_hdm_handler(cxl_cstate, offset, value);
     } else {
         cregs->cache_mem_registers[offset / sizeof(*cregs->cache_mem_registers)] = value;
@@ -209,7 +212,7 @@ static void ras_init_common(uint32_t *reg_state, uint32_t *write_msk)
 static void hdm_init_common(uint32_t *reg_state, uint32_t *write_msk,
                             enum reg_type type)
 {
-    int decoder_count = 1;
+    int decoder_count = CXL_HDM_DECODER_COUNT;
     int hdm_inc = R_CXL_HDM_DECODER1_BASE_LO - R_CXL_HDM_DECODER0_BASE_LO;
     int i;
 
diff --git a/hw/cxl/cxl-host.c b/hw/cxl/cxl-host.c
index 73c5426476..2aa776c79c 100644
--- a/hw/cxl/cxl-host.c
+++ b/hw/cxl/cxl-host.c
@@ -97,35 +97,58 @@ void cxl_fmws_link_targets(CXLState *cxl_state, Error **errp)
     }
 }
 
-/* TODO: support, multiple hdm decoders */
 static bool cxl_hdm_find_target(uint32_t *cache_mem, hwaddr addr,
                                 uint8_t *target)
 {
     int hdm_inc = R_CXL_HDM_DECODER1_BASE_LO - R_CXL_HDM_DECODER0_BASE_LO;
-    uint32_t ctrl;
-    uint32_t ig_enc;
-    uint32_t iw_enc;
-    uint32_t target_idx;
-    int i = 0;
-
-    ctrl = cache_mem[R_CXL_HDM_DECODER0_CTRL + i * hdm_inc];
-    if (!FIELD_EX32(ctrl, CXL_HDM_DECODER0_CTRL, COMMITTED)) {
-        return false;
-    }
-
-    ig_enc = FIELD_EX32(ctrl, CXL_HDM_DECODER0_CTRL, IG);
-    iw_enc = FIELD_EX32(ctrl, CXL_HDM_DECODER0_CTRL, IW);
-    target_idx = (addr / cxl_decode_ig(ig_enc)) % (1 << iw_enc);
+    unsigned int hdm_count;
+    bool found = false;
+    int i;
+    uint32_t cap;
+
+    cap = ldl_le_p(cache_mem + R_CXL_HDM_DECODER_CAPABILITY);
+    hdm_count = cxl_decoder_count_dec(FIELD_EX32(cap,
+                                                 CXL_HDM_DECODER_CAPABILITY,
+                                                 DECODER_COUNT));
+    for (i = 0; i < hdm_count; i++) {
+        uint32_t ctrl, ig_enc, iw_enc, target_idx;
+        uint32_t low, high;
+        uint64_t base, size;
+
+        low = ldl_le_p(cache_mem + R_CXL_HDM_DECODER0_BASE_LO + i * hdm_inc);
+        high = ldl_le_p(cache_mem + R_CXL_HDM_DECODER0_BASE_HI + i * hdm_inc);
+        base = (low & 0xf0000000) | ((uint64_t)high << 32);
+        low = ldl_le_p(cache_mem + R_CXL_HDM_DECODER0_SIZE_LO + i * hdm_inc);
+        high = ldl_le_p(cache_mem + R_CXL_HDM_DECODER0_SIZE_HI + i * hdm_inc);
+        size = (low & 0xf0000000) | ((uint64_t)high << 32);
+        if (addr < base || addr >= base + size) {
+            continue;
+        }
 
-    if (target_idx < 4) {
-        *target = extract32(cache_mem[R_CXL_HDM_DECODER0_TARGET_LIST_LO],
-                            target_idx * 8, 8);
-    } else {
-        *target = extract32(cache_mem[R_CXL_HDM_DECODER0_TARGET_LIST_HI],
-                            (target_idx - 4) * 8, 8);
+        ctrl = ldl_le_p(cache_mem + R_CXL_HDM_DECODER0_CTRL + i * hdm_inc);
+        if (!FIELD_EX32(ctrl, CXL_HDM_DECODER0_CTRL, COMMITTED)) {
+            return false;
+        }
+        found = true;
+        ig_enc = FIELD_EX32(ctrl, CXL_HDM_DECODER0_CTRL, IG);
+        iw_enc = FIELD_EX32(ctrl, CXL_HDM_DECODER0_CTRL, IW);
+        target_idx = (addr / cxl_decode_ig(ig_enc)) % (1 << iw_enc);
+
+        if (target_idx < 4) {
+            uint32_t val = ldl_le_p(cache_mem +
+                                    R_CXL_HDM_DECODER0_TARGET_LIST_LO +
+                                    i * hdm_inc);
+            *target = extract32(val, target_idx * 8, 8);
+        } else {
+            uint32_t val = ldl_le_p(cache_mem +
+                                    R_CXL_HDM_DECODER0_TARGET_LIST_HI +
+                                    i * hdm_inc);
+            *target = extract32(val, (target_idx - 4) * 8, 8);
+        }
+        break;
     }
 
-    return true;
+    return found;
 }
 
 static PCIDevice *cxl_cfmws_find_device(CXLFixedWindow *fw, hwaddr addr)
diff --git a/hw/mem/cxl_type3.c b/hw/mem/cxl_type3.c
index cd92813436..1658e0cc59 100644
--- a/hw/mem/cxl_type3.c
+++ b/hw/mem/cxl_type3.c
@@ -382,8 +382,6 @@ static void hdm_decoder_commit(CXLType3Dev *ct3d, int which)
     uint32_t *cache_mem = cregs->cache_mem_registers;
     uint32_t ctrl;
 
-    assert(which == 0);
-
     ctrl = ldl_le_p(cache_mem + R_CXL_HDM_DECODER0_CTRL + which * hdm_inc);
     /* TODO: Sanity checks that the decoder is possible */
     ctrl = FIELD_DP32(ctrl, CXL_HDM_DECODER0_CTRL, ERR, 0);
@@ -399,8 +397,6 @@ static void hdm_decoder_uncommit(CXLType3Dev *ct3d, int which)
     uint32_t *cache_mem = cregs->cache_mem_registers;
     uint32_t ctrl;
 
-    assert(which == 0);
-
     ctrl = ldl_le_p(cache_mem + R_CXL_HDM_DECODER0_CTRL + which * hdm_inc);
 
     ctrl = FIELD_DP32(ctrl, CXL_HDM_DECODER0_CTRL, ERR, 0);
@@ -489,6 +485,21 @@ static void ct3d_reg_write(void *opaque, hwaddr offset, uint64_t value,
         should_uncommit = !should_commit;
         which_hdm = 0;
         break;
+    case A_CXL_HDM_DECODER1_CTRL:
+        should_commit = FIELD_EX32(value, CXL_HDM_DECODER0_CTRL, COMMIT);
+        should_uncommit = !should_commit;
+        which_hdm = 1;
+        break;
+    case A_CXL_HDM_DECODER2_CTRL:
+        should_commit = FIELD_EX32(value, CXL_HDM_DECODER0_CTRL, COMMIT);
+        should_uncommit = !should_commit;
+        which_hdm = 2;
+        break;
+    case A_CXL_HDM_DECODER3_CTRL:
+        should_commit = FIELD_EX32(value, CXL_HDM_DECODER0_CTRL, COMMIT);
+        should_uncommit = !should_commit;
+        which_hdm = 3;
+        break;
     case A_CXL_RAS_UNC_ERR_STATUS:
     {
         uint32_t capctrl = ldl_le_p(cache_mem + R_CXL_RAS_ERR_CAP_CTRL);
@@ -760,40 +771,63 @@ static void ct3_exit(PCIDevice *pci_dev)
     }
 }
 
-/* TODO: Support multiple HDM decoders and DPA skip */
 static bool cxl_type3_dpa(CXLType3Dev *ct3d, hwaddr host_addr, uint64_t *dpa)
 {
     int hdm_inc = R_CXL_HDM_DECODER1_BASE_LO - R_CXL_HDM_DECODER0_BASE_LO;
     uint32_t *cache_mem = ct3d->cxl_cstate.crb.cache_mem_registers;
-    uint64_t decoder_base, decoder_size, hpa_offset;
-    uint32_t hdm0_ctrl;
-    int ig, iw;
-    int i = 0;
-
-    decoder_base =
-        (((uint64_t)cache_mem[R_CXL_HDM_DECODER0_BASE_HI + i * hdm_inc] << 32) |
-                    cache_mem[R_CXL_HDM_DECODER0_BASE_LO + i * hdm_inc]);
-    if ((uint64_t)host_addr < decoder_base) {
-        return false;
-    }
-
-    hpa_offset = (uint64_t)host_addr - decoder_base;
-
-    decoder_size =
-        ((uint64_t)cache_mem[R_CXL_HDM_DECODER0_SIZE_HI + i * hdm_inc] << 32) |
-        cache_mem[R_CXL_HDM_DECODER0_SIZE_LO + i * hdm_inc];
-    if (hpa_offset >= decoder_size) {
-        return false;
-    }
+    unsigned int hdm_count;
+    uint32_t cap;
+    uint64_t dpa_base = 0;
+    int i;
 
-    hdm0_ctrl = cache_mem[R_CXL_HDM_DECODER0_CTRL + i * hdm_inc];
-    iw = FIELD_EX32(hdm0_ctrl, CXL_HDM_DECODER0_CTRL, IW);
-    ig = FIELD_EX32(hdm0_ctrl, CXL_HDM_DECODER0_CTRL, IG);
+    cap = ldl_le_p(cache_mem + R_CXL_HDM_DECODER_CAPABILITY);
+    hdm_count = cxl_decoder_count_dec(FIELD_EX32(cap,
+                                                 CXL_HDM_DECODER_CAPABILITY,
+                                                 DECODER_COUNT));
+
+    for (i = 0; i < hdm_count; i++) {
+        uint64_t decoder_base, decoder_size, hpa_offset, skip;
+        uint32_t hdm_ctrl, low, high;
+        int ig, iw;
+
+        low = ldl_le_p(cache_mem + R_CXL_HDM_DECODER0_BASE_LO + i * hdm_inc);
+        high = ldl_le_p(cache_mem + R_CXL_HDM_DECODER0_BASE_HI + i * hdm_inc);
+        decoder_base = ((uint64_t)high << 32) | (low & 0xf0000000);
+
+        low = ldl_le_p(cache_mem + R_CXL_HDM_DECODER0_SIZE_LO + i * hdm_inc);
+        high = ldl_le_p(cache_mem + R_CXL_HDM_DECODER0_SIZE_HI + i * hdm_inc);
+        decoder_size = ((uint64_t)high << 32) | (low & 0xf0000000);
+
+        low = ldl_le_p(cache_mem + R_CXL_HDM_DECODER0_DPA_SKIP_LO +
+                       i * hdm_inc);
+        high = ldl_le_p(cache_mem + R_CXL_HDM_DECODER0_DPA_SKIP_HI +
+                        i * hdm_inc);
+        skip = ((uint64_t)high << 32) | (low & 0xf0000000);
+        dpa_base += skip;
+
+        hpa_offset = (uint64_t)host_addr - decoder_base;
+
+        hdm_ctrl = ldl_le_p(cache_mem + R_CXL_HDM_DECODER0_CTRL + i * hdm_inc);
+        iw = FIELD_EX32(hdm_ctrl, CXL_HDM_DECODER0_CTRL, IW);
+        ig = FIELD_EX32(hdm_ctrl, CXL_HDM_DECODER0_CTRL, IG);
+        if (!FIELD_EX32(hdm_ctrl, CXL_HDM_DECODER0_CTRL, COMMITTED)) {
+            return false;
+        }
+        if (((uint64_t)host_addr < decoder_base) ||
+            (hpa_offset >= decoder_size)) {
+            dpa_base += decoder_size /
+                cxl_interleave_ways_dec(iw, &error_fatal);
+            continue;
+        }
 
-    *dpa = (MAKE_64BIT_MASK(0, 8 + ig) & hpa_offset) |
-        ((MAKE_64BIT_MASK(8 + ig + iw, 64 - 8 - ig - iw) & hpa_offset) >> iw);
+        *dpa = dpa_base +
+            ((MAKE_64BIT_MASK(0, 8 + ig) & hpa_offset) |
+             ((MAKE_64BIT_MASK(8 + ig + iw, 64 - 8 - ig - iw) & hpa_offset)
+              >> iw));
 
-    return true;
+        return true;
+    }
+    return false;
 }
 
 static int cxl_type3_hpa_to_as_and_dpa(CXLType3Dev *ct3d,
-- 
2.39.2


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 8218ECA0EEB
	for <linux-cxl@archiver.kernel.org>; Tue, 12 Sep 2023 16:14:45 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S229698AbjILQOs (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 12 Sep 2023 12:14:48 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:36820 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S235252AbjILQOr (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 12 Sep 2023 12:14:47 -0400
Received: from mailout2.w2.samsung.com (mailout2.w2.samsung.com [211.189.100.12])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id B9AAC10E5
        for <linux-cxl@vger.kernel.org>; Tue, 12 Sep 2023 09:14:43 -0700 (PDT)
Received: from uscas1p2.samsung.com (unknown [182.198.245.207])
        by mailout2.w2.samsung.com (KnoxPortal) with ESMTP id 20230912161442usoutp02493718226df949e658d1937e2f808bde~EMtxnM12p1898418984usoutp02P;
        Tue, 12 Sep 2023 16:14:42 +0000 (GMT)
DKIM-Filter: OpenDKIM Filter v2.11.0 mailout2.w2.samsung.com 20230912161442usoutp02493718226df949e658d1937e2f808bde~EMtxnM12p1898418984usoutp02P
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=samsung.com;
        s=mail20170921; t=1694535282;
        bh=wGkaSqDWm/FewYay7BQYkQVtoGPehXvrZCwE9w9U9Os=;
        h=From:To:CC:Subject:Date:In-Reply-To:References:From;
        b=tF63ZyNIyWlJX8AA8dr6f27ABFi1cLV5enyJ8hZjFWGJBJMiEHL7KOvEVwNh7eDoK
         eQrHOXuAT3AFfV6bpElxhHQVnmTnllYfq4hlRzGcSa3KqNgEu7s3YXidAsxVb8GwXQ
         yRRdKjxItHoFDKkHxLUgiSI9N08dsHzEuIn1YH3g=
Received: from ussmges3new.samsung.com (u112.gpu85.samsung.co.kr
        [203.254.195.112]) by uscas1p1.samsung.com (KnoxPortal) with ESMTP id
        20230912161441uscas1p1ffa5f81cf76a1208bb751a1653bb8c91~EMtxhZLjJ3000230002uscas1p12;
        Tue, 12 Sep 2023 16:14:41 +0000 (GMT)
Received: from uscas1p2.samsung.com ( [182.198.245.207]) by
        ussmges3new.samsung.com (USCPEMTA) with SMTP id 4C.30.62237.17E80056; Tue,
        12 Sep 2023 12:14:41 -0400 (EDT)
Received: from ussmgxs1new.samsung.com (u89.gpu85.samsung.co.kr
        [203.254.195.89]) by uscas1p1.samsung.com (KnoxPortal) with ESMTP id
        20230912161441uscas1p11618b32cdd50462c8267f12e1518e590~EMtxQHJb30825908259uscas1p1L;
        Tue, 12 Sep 2023 16:14:41 +0000 (GMT)
X-AuditID: cbfec370-b17ff7000001f31d-d5-65008e711c6f
Received: from SSI-EX2.ssi.samsung.com ( [105.128.2.146]) by
        ussmgxs1new.samsung.com (USCPEXMTA) with SMTP id 10.97.28590.17E80056; Tue,
        12 Sep 2023 12:14:41 -0400 (EDT)
Received: from SSI-EX2.ssi.samsung.com (105.128.2.227) by
        SSI-EX2.ssi.samsung.com (105.128.2.227) with Microsoft SMTP Server
        (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384) id
        15.1.2375.24; Tue, 12 Sep 2023 09:14:40 -0700
Received: from SSI-EX2.ssi.samsung.com ([105.128.2.227]) by
        SSI-EX2.ssi.samsung.com ([105.128.2.227]) with mapi id 15.01.2375.024; Tue,
        12 Sep 2023 09:14:40 -0700
From: Fan Ni <fan.ni@samsung.com>
To: Jonathan Cameron <Jonathan.Cameron@huawei.com>
CC: "qemu-devel@nongnu.org" <qemu-devel@nongnu.org>,
        Michael Tsirkin <mst@redhat.com>,
        =?iso-8859-1?Q?Philippe_Mathieu-Daud=E9?= <philmd@linaro.org>,
        "linux-cxl@vger.kernel.org" <linux-cxl@vger.kernel.org>,
        "linuxarm@huawei.com" <linuxarm@huawei.com>
Subject: Re: [PATCH v3 1/4] hw/cxl: Push cxl_decoder_count_enc() and
 cxl_decode_ig() into .c
Thread-Topic: [PATCH v3 1/4] hw/cxl: Push cxl_decoder_count_enc() and
        cxl_decode_ig() into .c
Thread-Index: AQHZ5KU8sJTQo84yaEm3U62/PXpD0bAX1HyA
Date: Tue, 12 Sep 2023 16:14:40 +0000
Message-ID: <20230912161343.GA319114@bgt-140510-bm03>
In-Reply-To: <20230911114313.6144-2-Jonathan.Cameron@huawei.com>
Accept-Language: en-US
Content-Language: en-US
X-MS-Has-Attach: 
X-MS-TNEF-Correlator: 
x-originating-ip: [105.128.2.176]
Content-Type: text/plain; charset="iso-8859-1"
Content-ID: <F6D7216C74B1BD4CA04EE2AD18F3AD8E@ssi.samsung.com>
Content-Transfer-Encoding: quoted-printable
MIME-Version: 1.0
X-CFilter-Loop: Reflected
X-Brightmail-Tracker: H4sIAAAAAAAAA+NgFlrKKsWRmVeSWpSXmKPExsWy7djX87qFfQypBptvG1isWniNzeL8rFMs
        Foc3nmGy+P/rFavFmhXCFsd7d7A4sHm0HHnL6nHn2h42jyfXNjN5vN93lc3j8ya5ANYoLpuU
        1JzMstQifbsEroxTJ0+zFKwUqeho/cTewHiAv4uRk0NCwETi44WHLF2MXBxCAisZJc50ToZy
        Wpkk3jZ+Z4epmtGwAyqxllHixdIDbBDOJ0aJpf+boZxljBL3t3axgrSwCShK7OvazgZiiwgY
        Sby7MYkRpIhZoIFJ4tq9c2BzhQXiJM5cO8gOURQvsXvRUaAdHGANx1tkQcIsAqoS2/ZPZAGx
        eQVMJRZfP8QMUsIp4CBx64QKSJhRQEzi+6k1TCA2s4C4xK0n85kgrhaUWDR7DzOELSbxb9dD
        NghbUeL+95fsEPV6EjemTmGDsO0kbk2dBWVrSyxb+JoZYq2gxMmZT1ggeiUlDq64AQ4JCYEr
        HBK/drRAg8hF4tyvmawQtrTE1etTwe6UEEiWWPWRCyKcIzF/yRaoOdYSC/+sZ5rAqDILydmz
        kJw0C8lJs5CcNAvJSQsYWVcxipcWF+empxYb56WW6xUn5haX5qXrJefnbmIEpqTT/w4X7GC8
        deuj3iFGJg7GQ4wSHMxKIrwlh/6mCPGmJFZWpRblxxeV5qQWH2KU5mBREuc1tD2ZLCSQnliS
        mp2aWpBaBJNl4uCUamDa9jw7j3mZWUTH1jVT3Zf96N/SaVXhrPHmtCfT9f1vHu4r/MjMdius
        duuplb7vD+2337S+Z4b+7ffzl9dpbb/bbrqtKZ9zHs+lpFVe06V1/fYEcJhukJEykv53KUX2
        6baWCVeyLbvD7tjX596zsIjeJ7fEOGN63II1mV3fdJet4zEOnFfLyn3WI9TasGBhM+d/zr07
        1nNkbW1Zv73oSWbKGz6W1RHcSzz/zq0pb7K7c2VRxSwJt9lLggU6d96IFIy+oSwtpvXLlLl+
        wZuYWYtOB02aX5uyiZf7zyPuZat3e07ma9vG4bpCc8es+ECx77POTNn6bLteXl9qlhR3zx2l
        WP3w6D3/523ZsijGov6PEktxRqKhFnNRcSIAsXt9J7gDAAA=
X-Brightmail-Tracker: H4sIAAAAAAAAA+NgFjrMIsWRmVeSWpSXmKPExsWS2cA0SbewjyHVYMNfWYtVC6+xWZyfdYrF
        4vDGM0wW/3+9YrVYs0LY4njvDhYHNo+WI29ZPe5c28Pm8eTaZiaP9/uusnl83iQXwBrFZZOS
        mpNZllqkb5fAlXHq5GmWgpUiFR2tn9gbGA/wdzFyckgImEjMaNjB0sXIxSEksJpRYvnNWewQ
        zidGiQ99k5khnGWMEvsvPGcBaWETUJTY17WdDcQWETCSeHdjEiNIEbNAA5NE672jjCAJYYE4
        iTPXDrJDFMVL/HszGaiZA6zheIssSJhFQFVi2/6JYDN5BUwlFl8/xAxiCwmUSqzavogNpJxT
        wEHi1gkVkDCjgJjE91NrmEBsZgFxiVtP5jNBfCAgsWTPeWYIW1Ti5eN/rBC2osT97y/ZIer1
        JG5MncIGYdtJ3Jo6C8rWlli28DUzxAmCEidnPmGB6JWUOLjiBssERolZSNbNQjJqFpJRs5CM
        moVk1AJG1lWM4qXFxbnpFcWGeanlesWJucWleel6yfm5mxiB8Xz63+HIHYxHb33UO8TIxMF4
        iFGCg1lJhLfk0N8UId6UxMqq1KL8+KLSnNTiQ4zSHCxK4rw7plxMERJITyxJzU5NLUgtgsky
        cXBKNTCderpq88OVMsyOfhxXpT6yRPVmnEjfP+nGefYzu/Ztf6Qh9sko53uBlPaJj/6fvO/8
        EE7fks718fWftS1Z8zamFWSsiFnw4s/Gjx1m/NyVrXfDNqo3zjy5xJhz/5a5FlOvNpbrrTiY
        mbYsVFk3PTP/udBfRiWOgNPSxuI26VfPrnzNGDNJ2fNUi5nC27Dba4X5Ot7xXk38bfVuvVIx
        76HHYQxH/mRrLr9xqbjyhLFsy+bDrRGhh7tv+7244XYwoCg096fSUQ+WgIiGdFYbrZ4ogeDY
        l0UBPhHzKgLtP57+d7nhG+fH38GBLPvPHeH7ebclq10wkl8yKm+y5NOlcnp3ZkV/Xvj6oLRC
        iK/Jrr1KLMUZiYZazEXFiQDx5aYWVgMAAA==
X-CMS-MailID: 20230912161441uscas1p11618b32cdd50462c8267f12e1518e590
CMS-TYPE: 301P
X-CMS-RootMailID: 20230912161441uscas1p11618b32cdd50462c8267f12e1518e590
References: <20230911114313.6144-1-Jonathan.Cameron@huawei.com>
        <20230911114313.6144-2-Jonathan.Cameron@huawei.com>
        <CGME20230912161441uscas1p11618b32cdd50462c8267f12e1518e590@uscas1p1.samsung.com>
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

On Mon, Sep 11, 2023 at 12:43:10PM +0100, Jonathan Cameron wrote:

> There is no strong justification for keeping these in the header
> so push them down into the associated cxl-component-utils.c file.
>=20
> Suggested-by: Philippe Mathieu-Daud=E9 <philmd@linaro.org>
> Reviewed-by: Philippe Mathieu-Daud=E9 <philmd@linaro.org>
> Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
> ---

Reviewed-by: Fan Ni <fan.ni@samsung.com>

>  include/hw/cxl/cxl_component.h | 18 ++----------------
>  hw/cxl/cxl-component-utils.c   | 18 ++++++++++++++++++
>  2 files changed, 20 insertions(+), 16 deletions(-)
>=20
> diff --git a/include/hw/cxl/cxl_component.h b/include/hw/cxl/cxl_componen=
t.h
> index 42c7e581a7..bdb3881a6b 100644
> --- a/include/hw/cxl/cxl_component.h
> +++ b/include/hw/cxl/cxl_component.h
> @@ -225,26 +225,12 @@ void cxl_component_create_dvsec(CXLComponentState *=
cxl_cstate,
>                                  enum reg_type cxl_dev_type, uint16_t len=
gth,
>                                  uint16_t type, uint8_t rev, uint8_t *bod=
y);
> =20
> -static inline int cxl_decoder_count_enc(int count)
> -{
> -    switch (count) {
> -    case 1: return 0;
> -    case 2: return 1;
> -    case 4: return 2;
> -    case 6: return 3;
> -    case 8: return 4;
> -    case 10: return 5;
> -    }
> -    return 0;
> -}
> +int cxl_decoder_count_enc(int count);
> =20
>  uint8_t cxl_interleave_ways_enc(int iw, Error **errp);
>  uint8_t cxl_interleave_granularity_enc(uint64_t gran, Error **errp);
> =20
> -static inline hwaddr cxl_decode_ig(int ig)
> -{
> -    return 1ULL << (ig + 8);
> -}
> +hwaddr cxl_decode_ig(int ig);
> =20
>  CXLComponentState *cxl_get_hb_cstate(PCIHostState *hb);
>  bool cxl_get_hb_passthrough(PCIHostState *hb);
> diff --git a/hw/cxl/cxl-component-utils.c b/hw/cxl/cxl-component-utils.c
> index 378f1082ce..ea2d4770ec 100644
> --- a/hw/cxl/cxl-component-utils.c
> +++ b/hw/cxl/cxl-component-utils.c
> @@ -13,6 +13,24 @@
>  #include "hw/pci/pci.h"
>  #include "hw/cxl/cxl.h"
> =20
> +int cxl_decoder_count_enc(int count)
> +{
> +    switch (count) {
> +    case 1: return 0;
> +    case 2: return 1;
> +    case 4: return 2;
> +    case 6: return 3;
> +    case 8: return 4;
> +    case 10: return 5;
> +    }
> +    return 0;
> +}
> +
> +hwaddr cxl_decode_ig(int ig)
> +{
> +    return 1ULL << (ig + 8);
> +}
> +
>  static uint64_t cxl_cache_mem_read_reg(void *opaque, hwaddr offset,
>                                         unsigned size)
>  {
> --=20
> 2.39.2
>=20
> =

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id A17A2CA0EF9
	for <linux-cxl@archiver.kernel.org>; Tue, 12 Sep 2023 17:20:09 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S233220AbjILRUM (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 12 Sep 2023 13:20:12 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:59256 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S232252AbjILRUM (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 12 Sep 2023 13:20:12 -0400
Received: from mailout1.w2.samsung.com (mailout1.w2.samsung.com [211.189.100.11])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 18AC710D9
        for <linux-cxl@vger.kernel.org>; Tue, 12 Sep 2023 10:20:08 -0700 (PDT)
Received: from uscas1p2.samsung.com (unknown [182.198.245.207])
        by mailout1.w2.samsung.com (KnoxPortal) with ESMTP id 20230912172007usoutp017f77180f11ab4977ba470917a73b2389~ENm5GsvY43050830508usoutp01z;
        Tue, 12 Sep 2023 17:20:07 +0000 (GMT)
DKIM-Filter: OpenDKIM Filter v2.11.0 mailout1.w2.samsung.com 20230912172007usoutp017f77180f11ab4977ba470917a73b2389~ENm5GsvY43050830508usoutp01z
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=samsung.com;
        s=mail20170921; t=1694539207;
        bh=CIxYPRTkuFpoAChnuA/tH4z8/j7yUnW2sG8f8hgyxeA=;
        h=From:To:CC:Subject:Date:In-Reply-To:References:From;
        b=Puiukjuz7onofxesLN4m45RcUQFHb1vfY6Ye86b3FSicjBIqUkM0thX79TbPwp3Qu
         7HG+I1qmoM3avcPPb8Ya4pAG1eskazJV+8JiWwH2tZXK2XjK1DbqFvG4v4LSwFE5ew
         5wNAcZ2ZYlcfFfdqabMp1RibCPx9jJVbc3V4T1Pc=
Received: from ussmges1new.samsung.com (u109.gpu85.samsung.co.kr
        [203.254.195.109]) by uscas1p2.samsung.com (KnoxPortal) with ESMTP id
        20230912172006uscas1p2dfc0c64b49b2e7d42ccb360058282069~ENm4-EeSk0315503155uscas1p2I;
        Tue, 12 Sep 2023 17:20:06 +0000 (GMT)
Received: from uscas1p2.samsung.com ( [182.198.245.207]) by
        ussmges1new.samsung.com (USCPEMTA) with SMTP id C0.D1.50148.6CD90056; Tue,
        12 Sep 2023 13:20:06 -0400 (EDT)
Received: from ussmgxs2new.samsung.com (u91.gpu85.samsung.co.kr
        [203.254.195.91]) by uscas1p1.samsung.com (KnoxPortal) with ESMTP id
        20230912172006uscas1p1f48a880aeaf7fad3400929d4bc919ae5~ENm4vrGDb3162831628uscas1p1u;
        Tue, 12 Sep 2023 17:20:06 +0000 (GMT)
X-AuditID: cbfec36d-7bdff7000002c3e4-f8-65009dc68c57
Received: from SSI-EX1.ssi.samsung.com ( [105.128.2.146]) by
        ussmgxs2new.samsung.com (USCPEXMTA) with SMTP id E7.D8.31200.6CD90056; Tue,
        12 Sep 2023 13:20:06 -0400 (EDT)
Received: from SSI-EX2.ssi.samsung.com (105.128.2.227) by
        SSI-EX1.ssi.samsung.com (105.128.2.226) with Microsoft SMTP Server
        (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384) id
        15.1.2375.24; Tue, 12 Sep 2023 10:20:05 -0700
Received: from SSI-EX2.ssi.samsung.com ([105.128.2.227]) by
        SSI-EX2.ssi.samsung.com ([105.128.2.227]) with mapi id 15.01.2375.024; Tue,
        12 Sep 2023 10:20:05 -0700
From: Fan Ni <fan.ni@samsung.com>
To: Jonathan Cameron <Jonathan.Cameron@huawei.com>
CC: "qemu-devel@nongnu.org" <qemu-devel@nongnu.org>,
        Michael Tsirkin <mst@redhat.com>,
        =?iso-8859-1?Q?Philippe_Mathieu-Daud=E9?= <philmd@linaro.org>,
        "linux-cxl@vger.kernel.org" <linux-cxl@vger.kernel.org>,
        "linuxarm@huawei.com" <linuxarm@huawei.com>
Subject: Re: [PATCH v3 2/4] hw/cxl: Add utility functions decoder interleave
 ways and target count.
Thread-Topic: [PATCH v3 2/4] hw/cxl: Add utility functions decoder
        interleave ways and target count.
Thread-Index: AQHZ5KVVRlx6CQB570OdfIT+NsNCjbAX5syA
Date: Tue, 12 Sep 2023 17:20:05 +0000
Message-ID: <20230912172005.GB319114@bgt-140510-bm03>
In-Reply-To: <20230911114313.6144-3-Jonathan.Cameron@huawei.com>
Accept-Language: en-US
Content-Language: en-US
X-MS-Has-Attach: 
X-MS-TNEF-Correlator: 
x-originating-ip: [105.128.2.176]
Content-Type: text/plain; charset="iso-8859-1"
Content-ID: <53B52ADF7766A545881FFEF2F17B3A21@ssi.samsung.com>
Content-Transfer-Encoding: quoted-printable
MIME-Version: 1.0
X-CFilter-Loop: Reflected
X-Brightmail-Tracker: H4sIAAAAAAAAA+NgFlrKKsWRmVeSWpSXmKPExsWy7djX87rH5jKkGqycaWqxauE1Novzs06x
        WBzeeIbJ4v+vV6wWa1YIWxzv3cHiwObRcuQtq8eda3vYPJ5c28zk8X7fVTaPz5vkAlijuGxS
        UnMyy1KL9O0SuDIOfn3GWjBBqeLB3W+MDYxXJLsYOTgkBEwk9m1P72Lk4hASWMko0fOtnQXC
        aWWS+DLlN3sXIydY0ePTbxghEmsZJX6+eckE4XxilPjbtRkqs4xR4tfxFjaQFjYBRYl9XdvB
        bBEBI4l3NyaBFTELNDBJXLt3DmyusECqxNu53Wwgh4gIpEncOx4CU/9z6VUWEJtFQFXi24KT
        YOW8AqYSvVe3MYLYnAIOEucn/mcGsRkFxCS+n1rDBGIzC4hL3HoynwnibEGJRbP3MEPYYhL/
        dj1kg7AVJe5/f8kOUa8ncWPqFDYI207i/KJ7zBC2tsSyha+ZIfYKSpyc+YQFoldS4uCKG+Aw
        khA4wyGxrmMT1DIXicfrTkMtk5b4e3cZEySAkyVWfeSCCOdIzF+yBWqOtcTCP+uZJjCqzEJy
        9iwkJ81CctIsJCfNQnLSAkbWVYzipcXFuempxYZ5qeV6xYm5xaV56XrJ+bmbGIEp6fS/w7k7
        GHfc+qh3iJGJg/EQowQHs5IIb8mhvylCvCmJlVWpRfnxRaU5qcWHGKU5WJTEeQ1tTyYLCaQn
        lqRmp6YWpBbBZJk4OKUamLZrPMpdJ7U05lDqDWGJ1Cqe469XX+rc7iCxSfd4r1/KiUt9WQF7
        Z03zLr77/jWv4nT9xX9tVivy/zsfM1emX32mb8dr72DlPQ5XVjUIM15+eEev92jDkXifSPWz
        ApucbGOkfp64l6M1t/zZFgWO8peefzk++Wz5JRxd/1R5eurEd992NE7lvnLy+Y0dziKaqz8e
        9Z8UeehfgW53n6vNx7KovAunll0VVN+eXvB+lctb+U83HBtCDapf2z57zfc96+jvp99VLuuc
        DeWW6pyd79ZSu/TZ7nyLC06ryrw2r83d81v+s3kfz2OBZY+yZvE/uHp9dsTrTWcPvd3dbrz7
        7RSLk1PPPZe+unGnzyLnZJMwJZbijERDLeai4kQAS5yqo7gDAAA=
X-Brightmail-Tracker: H4sIAAAAAAAAA+NgFjrMIsWRmVeSWpSXmKPExsWS2cA0SffYXIZUg81T5SxWLbzGZnF+1ikW
        i8MbzzBZ/P/1itVizQphi+O9O1gc2Dxajrxl9bhzbQ+bx5Nrm5k83u+7yubxeZNcAGsUl01K
        ak5mWWqRvl0CV8bBr89YCyYoVTy4+42xgfGKZBcjJ4eEgInE49NvGEFsIYHVjBLvzhVC2J8Y
        JdZd0uxi5AKylzFKzJ7UzQSSYBNQlNjXtZ0NxBYRMJJ4d2MSI0gRs0ADk0TrvaNgk4QFUiXe
        zu2GKkqT2DL1ATtMw8+lV1lAbBYBVYlvC06CxXkFTCV6r26DuqJUYubkz2A2p4CDxPmJ/5lB
        bEYBMYnvp9aAHcEsIC5x68l8JogPBCSW7DnPDGGLSrx8/I8VwlaUuP/9JTtEvZ7EjalT2CBs
        O4nzi+4xQ9jaEssWvmaGuEFQ4uTMJywQvZISB1fcYJnAKDELybpZSEbNQjJqFpJRs5CMWsDI
        uopRvLS4ODe9otgoL7Vcrzgxt7g0L10vOT93EyMwnk//Oxy9g/H2rY96hxiZOBgPMUpwMCuJ
        8JYc+psixJuSWFmVWpQfX1Sak1p8iFGag0VJnHfHlIspQgLpiSWp2ampBalFMFkmDk6pBqae
        /8zdb7+mfZz6Z9Hc9taTUivUGY8Lf+k5teGHw4t037X9RpJHLJMePXpjo/k1JvnA9YtZfXvM
        uI2mqCjln7AQOfRh9XY1rk0f1gk117z983360eDO7GlKuxbJKZRN8ih9vqnnukNloeyxU/d2
        vJfebDjJLML+tzKLz/VdVfxbn5o12e8pKTd9ZBqRMFVmqkznlVOqkyQP7E+c1X5bcs7egESf
        TjlRpueT4nTL3Ts6e85UP7v55ZtOlsprhYP7gh3q09Ye2WwRndezntlbbpH/p2dBxvxywbIv
        28//e7LK9t/9lbFWTNc0PLX/NzxiFg5elPAr+FT1ga1zSrWP3/JJO2d1637ujbzepTP+/2NU
        YinOSDTUYi4qTgQAWqBrnVYDAAA=
X-CMS-MailID: 20230912172006uscas1p1f48a880aeaf7fad3400929d4bc919ae5
CMS-TYPE: 301P
X-CMS-RootMailID: 20230912172006uscas1p1f48a880aeaf7fad3400929d4bc919ae5
References: <20230911114313.6144-1-Jonathan.Cameron@huawei.com>
        <20230911114313.6144-3-Jonathan.Cameron@huawei.com>
        <CGME20230912172006uscas1p1f48a880aeaf7fad3400929d4bc919ae5@uscas1p1.samsung.com>
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

On Mon, Sep 11, 2023 at 12:43:11PM +0100, Jonathan Cameron wrote:

> As an encoded version of these key configuration parameters is available
> in a register, provide functions to extract it again so as to avoid
> the need for duplicating the storage.
>=20
> Whilst here update the _enc() function to include additional values
> as defined in the CXL 3.0 specification. Whilst they are not
> currently used in the emulation, they may be in future and it is
> easier to compare with the specification if all values are covered.
>=20
> Reviewed-by: Philippe Mathieu-Daud=E9 <philmd@linaro.org>
> Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
> ---

LGTM. Only one minor comment inline.

Reviewed-by: Fan Ni <fan.ni@samsung.com>


> v3: No changes, picked up tags.
> v2: Thanks to Philippe Mathieu-Daud=E9
>  - Expand both enc() and dec() functions to include full set of values
>    defined in CXL r3.0
>  - Pushed implementation down into the .c file.
> ---
>  include/hw/cxl/cxl_component.h |  2 ++
>  hw/cxl/cxl-component-utils.c   | 59 ++++++++++++++++++++++++++++++----
>  2 files changed, 55 insertions(+), 6 deletions(-)
>=20
> diff --git a/include/hw/cxl/cxl_component.h b/include/hw/cxl/cxl_componen=
t.h
> index bdb3881a6b..ef9e033919 100644
> --- a/include/hw/cxl/cxl_component.h
> +++ b/include/hw/cxl/cxl_component.h
> @@ -226,8 +226,10 @@ void cxl_component_create_dvsec(CXLComponentState *c=
xl_cstate,
>                                  uint16_t type, uint8_t rev, uint8_t *bod=
y);
> =20
>  int cxl_decoder_count_enc(int count);
> +int cxl_decoder_count_dec(int enc_cnt);
> =20
>  uint8_t cxl_interleave_ways_enc(int iw, Error **errp);
> +int cxl_interleave_ways_dec(uint8_t iw_enc, Error **errp);
>  uint8_t cxl_interleave_granularity_enc(uint64_t gran, Error **errp);
> =20
>  hwaddr cxl_decode_ig(int ig);
> diff --git a/hw/cxl/cxl-component-utils.c b/hw/cxl/cxl-component-utils.c
> index ea2d4770ec..352d0dace2 100644
> --- a/hw/cxl/cxl-component-utils.c
> +++ b/hw/cxl/cxl-component-utils.c
> @@ -13,15 +13,45 @@
>  #include "hw/pci/pci.h"
>  #include "hw/cxl/cxl.h"
> =20
> +/* CXL r3.0 Section 8.2.4.19.1 CXL HDM Decoder Capability Register */
>  int cxl_decoder_count_enc(int count)
>  {
>      switch (count) {
> -    case 1: return 0;
> -    case 2: return 1;
> -    case 4: return 2;
> -    case 6: return 3;
> -    case 8: return 4;
> -    case 10: return 5;
> +    case 1: return 0x0;
> +    case 2: return 0x1;
> +    case 4: return 0x2;
> +    case 6: return 0x3;
> +    case 8: return 0x4;
> +    case 10: return 0x5;
> +    /* Switches and Host Bridges may have more than 10 decoders */
> +    case 12: return 0x6;
> +    case 14: return 0x7;
> +    case 16: return 0x8;
> +    case 20: return 0x9;
> +    case 24: return 0xa;
> +    case 28: return 0xb;
> +    case 32: return 0xc;
> +    }
> +    return 0;
> +}
> +
> +int cxl_decoder_count_dec(int enc_cnt)
> +{
> +    switch (enc_cnt) {
> +    case 0x0: return 1;
> +    case 0x1: return 2;
> +    case 0x2: return 4;
> +    case 0x3: return 6;
> +    case 0x4: return 8;
> +    case 0x5: return 10;
> +    /* Switches and Host Bridges may have more than 10 decoders */
> +    case 0x6: return 12;
> +    case 0x7: return 14;
> +    case 0x8: return 16;
> +    case 0x9: return 20;
> +    case 0xa: return 24;
> +    case 0xb: return 28;
> +    case 0xc: return 32;
>      }
>      return 0;
>  }
> @@ -410,6 +440,23 @@ uint8_t cxl_interleave_ways_enc(int iw, Error **errp=
)
>      }
>  }
> =20

Similar as decoder count dec/enc, maybe we want to add a line of comment be=
low.
/* CXL r3.0 Section 8.2.4.19.7 CXL HDM Decoder n Control Register */

Fan
> +int cxl_interleave_ways_dec(uint8_t iw_enc, Error **errp)
> +{
> +    switch (iw_enc) {
> +    case 0x0: return 1;
> +    case 0x1: return 2;
> +    case 0x2: return 4;
> +    case 0x3: return 8;
> +    case 0x4: return 16;
> +    case 0x8: return 3;
> +    case 0x9: return 6;
> +    case 0xa: return 12;
> +    default:
> +        error_setg(errp, "Encoded interleave ways: %d not supported", iw=
_enc);
> +        return 0;
> +    }
> +}
> +
>  uint8_t cxl_interleave_granularity_enc(uint64_t gran, Error **errp)
>  {
>      switch (gran) {
> --=20
> 2.39.2
>=20
> =

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 3E9C4EE3F08
	for <linux-cxl@archiver.kernel.org>; Tue, 12 Sep 2023 17:44:02 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S233429AbjILRoE (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 12 Sep 2023 13:44:04 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:53090 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S233821AbjILRoD (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 12 Sep 2023 13:44:03 -0400
Received: from mailout2.w2.samsung.com (mailout2.w2.samsung.com [211.189.100.12])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 555EAC1
        for <linux-cxl@vger.kernel.org>; Tue, 12 Sep 2023 10:43:59 -0700 (PDT)
Received: from uscas1p1.samsung.com (unknown [182.198.245.206])
        by mailout2.w2.samsung.com (KnoxPortal) with ESMTP id 20230912174358usoutp0217327d70e0e1eacd2f2aee0db990881a~EN7t0-oFJ3242932429usoutp02O;
        Tue, 12 Sep 2023 17:43:58 +0000 (GMT)
DKIM-Filter: OpenDKIM Filter v2.11.0 mailout2.w2.samsung.com 20230912174358usoutp0217327d70e0e1eacd2f2aee0db990881a~EN7t0-oFJ3242932429usoutp02O
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=samsung.com;
        s=mail20170921; t=1694540638;
        bh=pjtU60jdClyj/IR3qbP5jqlP3UIfwh7Pe57qJKVtXIE=;
        h=From:To:CC:Subject:Date:In-Reply-To:References:From;
        b=aUMSwAO4hRdTgdDM3XP7tB6olJuCXU6LiNCj4/VcbSgg3+f1T/U9epxsKEFVYSnA2
         asy/c2xSeUUd8oFUolb7FGBdIMq3mAGQrL/R9eMJVZmzJxlfzVVPau87F8HSQeimNT
         rL3GNmL9cEZD/YdfdVT/Lnm7o820LhlLAUVX15Nc=
Received: from ussmges1new.samsung.com (u109.gpu85.samsung.co.kr
        [203.254.195.109]) by uscas1p2.samsung.com (KnoxPortal) with ESMTP id
        20230912174357uscas1p2fef12c143ae31f60d73908c1ddc90b1b~EN7twJw7z2852828528uscas1p21;
        Tue, 12 Sep 2023 17:43:57 +0000 (GMT)
Received: from uscas1p2.samsung.com ( [182.198.245.207]) by
        ussmges1new.samsung.com (USCPEMTA) with SMTP id 25.A5.50148.D53A0056; Tue,
        12 Sep 2023 13:43:57 -0400 (EDT)
Received: from ussmgxs2new.samsung.com (u91.gpu85.samsung.co.kr
        [203.254.195.91]) by uscas1p2.samsung.com (KnoxPortal) with ESMTP id
        20230912174357uscas1p23b767b0b88830d2b8a7179439d224a9e~EN7tiusFJ2537225372uscas1p2f;
        Tue, 12 Sep 2023 17:43:57 +0000 (GMT)
X-AuditID: cbfec36d-559ff7000002c3e4-c9-6500a35d2045
Received: from SSI-EX1.ssi.samsung.com ( [105.128.2.145]) by
        ussmgxs2new.samsung.com (USCPEXMTA) with SMTP id 6B.E9.31200.D53A0056; Tue,
        12 Sep 2023 13:43:57 -0400 (EDT)
Received: from SSI-EX2.ssi.samsung.com (105.128.2.227) by
        SSI-EX1.ssi.samsung.com (105.128.2.226) with Microsoft SMTP Server
        (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384) id
        15.1.2375.24; Tue, 12 Sep 2023 10:43:56 -0700
Received: from SSI-EX2.ssi.samsung.com ([105.128.2.227]) by
        SSI-EX2.ssi.samsung.com ([105.128.2.227]) with mapi id 15.01.2375.024; Tue,
        12 Sep 2023 10:43:56 -0700
From: Fan Ni <fan.ni@samsung.com>
To: Jonathan Cameron <Jonathan.Cameron@huawei.com>
CC: "qemu-devel@nongnu.org" <qemu-devel@nongnu.org>,
        Michael Tsirkin <mst@redhat.com>,
        =?iso-8859-1?Q?Philippe_Mathieu-Daud=E9?= <philmd@linaro.org>,
        "linux-cxl@vger.kernel.org" <linux-cxl@vger.kernel.org>,
        "linuxarm@huawei.com" <linuxarm@huawei.com>
Subject: Re: [PATCH v3 3/4] hw/cxl: Fix and use same calculation for HDM
 decoder block size everywhere
Thread-Topic: [PATCH v3 3/4] hw/cxl: Fix and use same calculation for HDM
        decoder block size everywhere
Thread-Index: AQHZ5KVhms968H7ZBUqB98KAVSv4jbAX7XUA
Date: Tue, 12 Sep 2023 17:43:56 +0000
Message-ID: <20230912174356.GC319114@bgt-140510-bm03>
In-Reply-To: <20230911114313.6144-4-Jonathan.Cameron@huawei.com>
Accept-Language: en-US
Content-Language: en-US
X-MS-Has-Attach: 
X-MS-TNEF-Correlator: 
x-originating-ip: [105.128.2.176]
Content-Type: text/plain; charset="iso-8859-1"
Content-ID: <F3A2C2B986F95543BF772050D163E002@ssi.samsung.com>
Content-Transfer-Encoding: quoted-printable
MIME-Version: 1.0
X-CFilter-Loop: Reflected
X-Brightmail-Tracker: H4sIAAAAAAAAA+NgFlrGKsWRmVeSWpSXmKPExsWy7djX87qxixlSDfb1WlqsWniNzeL8rFMs
        Foc3nmGy+P/rFavFmhXCFsd7d7A4sHm0HHnL6nHn2h42jyfXNjN5vN93lc3j8ya5ANYoLpuU
        1JzMstQifbsEroytfV9YCppdKiadaGVuYNxn0sXIySEhYCIx6eJX1i5GLg4hgZWMEqvfXWKH
        cFqZJKbufs0GU3Vv6l8WiMRaRol5Hf+hnE+MEss7lkO1LGOU+HF8OyNIC5uAosS+ru1g7SIC
        RhLvbkxiBCliFmhgkrh27xw7SEJYIEPi8eK/TBBFmRI9f3azwDQcudEKNohFQFXi0v6TYPW8
        AqYS87b+Bqrn4OAUcJC4ND8GJMwoICbx/dQasDHMAuISt57MZ4I4W1Bi0ew9zBC2mMS/XQ+h
        3lGUuP/9JTtEvZ7EjalT2CBsO4l1b6exQtjaEssWvmaGWCsocXLmExaIXkmJgytugH0vIXCF
        Q+LStF2sEAkXiY69XVALpCX+3l0GdqeEQLLEqo9cEOEciflLtkDNsZZY+Gc90wRGlVlIzp6F
        5KRZSE6aheSkWUhOWsDIuopRvLS4ODc9tdgwL7Vcrzgxt7g0L10vOT93EyMwKZ3+dzh3B+OO
        Wx/1DjEycTAeYpTgYFYS4S059DdFiDclsbIqtSg/vqg0J7X4EKM0B4uSOK+h7clkIYH0xJLU
        7NTUgtQimCwTB6dUA5OTWsP+VYoxR8Uk9/S1M3LytbLflRTfdbv/V4FpTDzv+TbVc2+Onkv+
        67Hk63cl+yUVnxguTf5VNNk1wCLhviB/Hl/iy9auXY/1L7aWT+K7dpeT4ec/9pk6pYdexD74
        lSX5WVj1YK6mTWDIpqVLX09+n/Cw3K1z8vsCq9mnr+1oyCifkT9dqSLu1OSmU7e9uViW72uU
        qv36OrUos2a7/9IqfuG5fjHvr4idPzT/+IPOMEY+w5fXLFfF7Mm4cVrxRNCSU/KxF7pTftuJ
        7lEUi2yyVjBzjp/AUszOFDpzGkNimIOL1lXbD2677q1/cy41ZPZR9gn123Q+/9K9sSHKdOJ2
        +TC9LYuUtxz8bDvD/YISS3FGoqEWc1FxIgD95vZiuQMAAA==
X-Brightmail-Tracker: H4sIAAAAAAAAA+NgFjrCIsWRmVeSWpSXmKPExsWS2cA0UTd2MUOqwZsWdYtVC6+xWZyfdYrF
        4vDGM0wW/3+9YrVYs0LY4njvDhYHNo+WI29ZPe5c28Pm8eTaZiaP9/uusnl83iQXwBrFZZOS
        mpNZllqkb5fAlbG17wtLQbNLxaQTrcwNjPtMuhg5OSQETCTuTf3L0sXIxSEksJpRovPfZiYI
        5xOjxMO/j9kgnGWMEp8/fmcBaWETUJTY17WdDcQWETCSeHdjEiNIEbNAA5NE672jjCAJYYEM
        iceL/zJBFGVKPH72kAWm4ciNVrAaFgFViUv7T7KD2LwCphLztv4GqxcSKJVofTQTKM7BwSng
        IHFpfgxImFFATOL7qTVgJcwC4hK3nsxngnhBQGLJnvPMELaoxMvH/1ghbEWJ+99fskPU60nc
        mDqFDcK2k1j3dhorhK0tsWzha2aIEwQlTs58wgLRKylxcMUNlgmMErOQrJuFZNQsJKNmIRk1
        C8moBYysqxjFS4uLc9Mrio3yUsv1ihNzi0vz0vWS83M3MQIj+vS/w9E7GG/f+qh3iJGJg/EQ
        owQHs5IIb8mhvylCvCmJlVWpRfnxRaU5qcWHGKU5WJTEeXdMuZgiJJCeWJKanZpakFoEk2Xi
        4JRqYMr49+V5C1+2sLy27cfko20G0+SX3F3C+/L7vEYe36/n1t3y5lbreO47ITLfSuB/7RRN
        rVLruO4Vq7yz/24PTbK9J33p8ZuPgrMc3y/3Tl8SteuOvkL43ISpBRUL6tXvs+d0L7j3eHVE
        UMyBHbPnWN5uym7eVnxobkvxufo1OXq/hB+liE691ajU/Pf8pTf9HoesnTlf6S77pnIh5g9/
        oyt/9UE7LYcfG/cr33347amzzCLuc+vilhXOdJnR42gZePVx+A2X3XGmHu2dn5KOKsxRPf9i
        5U2LF2UWxx91vApcobJDvMI9NWrdSz7uSFYt/9ulW6yKfjzbE7Ddb/GDha9ZEzd0VS89bh37
        qMxqyUolluKMREMt5qLiRAAUlFkoVwMAAA==
X-CMS-MailID: 20230912174357uscas1p23b767b0b88830d2b8a7179439d224a9e
CMS-TYPE: 301P
X-CMS-RootMailID: 20230912174357uscas1p23b767b0b88830d2b8a7179439d224a9e
References: <20230911114313.6144-1-Jonathan.Cameron@huawei.com>
        <20230911114313.6144-4-Jonathan.Cameron@huawei.com>
        <CGME20230912174357uscas1p23b767b0b88830d2b8a7179439d224a9e@uscas1p2.samsung.com>
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

On Mon, Sep 11, 2023 at 12:43:12PM +0100, Jonathan Cameron wrote:

> In order to avoid having the size of the per HDM decoder register block
> repeated in lots of places, create the register definitions for HDM
> decoder 1 and use the offset between the first registers in HDM decoder 0=
 and
> HDM decoder 1 to establish the offset.
>=20
> Calculate in each function as this is more obvious and leads to shorter
> line lengths than a single #define which would need a long name
> to be specific enough.
>=20
> Note that the code currently only supports one decoder, so the bugs this
> fixes don't actually affect anything. Previously the offset didn't
> take into account that the write_msk etc are 4 byte fields.
>=20
> Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
>=20

Reviewed-by: Fan Ni <fan.ni@samsung.com>

> --
> v3:
> New patch to separate this out from the addition of HDM decoders.
> ---
>  include/hw/cxl/cxl_component.h |  2 ++
>  hw/cxl/cxl-component-utils.c   | 19 +++++++++++--------
>  hw/cxl/cxl-host.c              |  4 +++-
>  hw/mem/cxl_type3.c             | 24 +++++++++++++++---------
>  4 files changed, 31 insertions(+), 18 deletions(-)
>=20
> diff --git a/include/hw/cxl/cxl_component.h b/include/hw/cxl/cxl_componen=
t.h
> index ef9e033919..7c864d2044 100644
> --- a/include/hw/cxl/cxl_component.h
> +++ b/include/hw/cxl/cxl_component.h
> @@ -148,6 +148,8 @@ REG32(CXL_HDM_DECODER_GLOBAL_CONTROL, CXL_HDM_REGISTE=
RS_OFFSET + 4)
>      FIELD(CXL_HDM_DECODER_GLOBAL_CONTROL, HDM_DECODER_ENABLE, 1, 1)
> =20
>  HDM_DECODER_INIT(0);
> +/* Only used for HDM decoder registers block address increment */
> +HDM_DECODER_INIT(1);
> =20
>  /* 8.2.5.13 - CXL Extended Security Capability Structure (Root complex o=
nly) */
>  #define EXTSEC_ENTRY_MAX        256
> diff --git a/hw/cxl/cxl-component-utils.c b/hw/cxl/cxl-component-utils.c
> index 352d0dace2..aa011a8f34 100644
> --- a/hw/cxl/cxl-component-utils.c
> +++ b/hw/cxl/cxl-component-utils.c
> @@ -210,6 +210,7 @@ static void hdm_init_common(uint32_t *reg_state, uint=
32_t *write_msk,
>                              enum reg_type type)
>  {
>      int decoder_count =3D 1;
> +    int hdm_inc =3D R_CXL_HDM_DECODER1_BASE_LO - R_CXL_HDM_DECODER0_BASE=
_LO;
>      int i;
> =20
>      ARRAY_FIELD_DP32(reg_state, CXL_HDM_DECODER_CAPABILITY, DECODER_COUN=
T,
> @@ -222,19 +223,21 @@ static void hdm_init_common(uint32_t *reg_state, ui=
nt32_t *write_msk,
>                       HDM_DECODER_ENABLE, 0);
>      write_msk[R_CXL_HDM_DECODER_GLOBAL_CONTROL] =3D 0x3;
>      for (i =3D 0; i < decoder_count; i++) {
> -        write_msk[R_CXL_HDM_DECODER0_BASE_LO + i * 0x20] =3D 0xf0000000;
> -        write_msk[R_CXL_HDM_DECODER0_BASE_HI + i * 0x20] =3D 0xffffffff;
> -        write_msk[R_CXL_HDM_DECODER0_SIZE_LO + i * 0x20] =3D 0xf0000000;
> -        write_msk[R_CXL_HDM_DECODER0_SIZE_HI + i * 0x20] =3D 0xffffffff;
> -        write_msk[R_CXL_HDM_DECODER0_CTRL + i * 0x20] =3D 0x13ff;
> +        write_msk[R_CXL_HDM_DECODER0_BASE_LO + i * hdm_inc] =3D 0xf00000=
00;
> +        write_msk[R_CXL_HDM_DECODER0_BASE_HI + i * hdm_inc] =3D 0xffffff=
ff;
> +        write_msk[R_CXL_HDM_DECODER0_SIZE_LO + i * hdm_inc] =3D 0xf00000=
00;
> +        write_msk[R_CXL_HDM_DECODER0_SIZE_HI + i * hdm_inc] =3D 0xffffff=
ff;
> +        write_msk[R_CXL_HDM_DECODER0_CTRL + i * hdm_inc] =3D 0x13ff;
>          if (type =3D=3D CXL2_DEVICE ||
>              type =3D=3D CXL2_TYPE3_DEVICE ||
>              type =3D=3D CXL2_LOGICAL_DEVICE) {
> -            write_msk[R_CXL_HDM_DECODER0_TARGET_LIST_LO + i * 0x20] =3D =
0xf0000000;
> +            write_msk[R_CXL_HDM_DECODER0_TARGET_LIST_LO + i * hdm_inc] =
=3D
> +                0xf0000000;
>          } else {
> -            write_msk[R_CXL_HDM_DECODER0_TARGET_LIST_LO + i * 0x20] =3D =
0xffffffff;
> +            write_msk[R_CXL_HDM_DECODER0_TARGET_LIST_LO + i * hdm_inc] =
=3D
> +                0xffffffff;
>          }
> -        write_msk[R_CXL_HDM_DECODER0_TARGET_LIST_HI + i * 0x20] =3D 0xff=
ffffff;
> +        write_msk[R_CXL_HDM_DECODER0_TARGET_LIST_HI + i * hdm_inc] =3D 0=
xffffffff;
>      }
>  }
> =20
> diff --git a/hw/cxl/cxl-host.c b/hw/cxl/cxl-host.c
> index f0920da956..73c5426476 100644
> --- a/hw/cxl/cxl-host.c
> +++ b/hw/cxl/cxl-host.c
> @@ -101,12 +101,14 @@ void cxl_fmws_link_targets(CXLState *cxl_state, Err=
or **errp)
>  static bool cxl_hdm_find_target(uint32_t *cache_mem, hwaddr addr,
>                                  uint8_t *target)
>  {
> +    int hdm_inc =3D R_CXL_HDM_DECODER1_BASE_LO - R_CXL_HDM_DECODER0_BASE=
_LO;
>      uint32_t ctrl;
>      uint32_t ig_enc;
>      uint32_t iw_enc;
>      uint32_t target_idx;
> +    int i =3D 0;
> =20
> -    ctrl =3D cache_mem[R_CXL_HDM_DECODER0_CTRL];
> +    ctrl =3D cache_mem[R_CXL_HDM_DECODER0_CTRL + i * hdm_inc];
>      if (!FIELD_EX32(ctrl, CXL_HDM_DECODER0_CTRL, COMMITTED)) {
>          return false;
>      }
> diff --git a/hw/mem/cxl_type3.c b/hw/mem/cxl_type3.c
> index 4e314748d3..cd92813436 100644
> --- a/hw/mem/cxl_type3.c
> +++ b/hw/mem/cxl_type3.c
> @@ -377,34 +377,36 @@ static void build_dvsecs(CXLType3Dev *ct3d)
> =20
>  static void hdm_decoder_commit(CXLType3Dev *ct3d, int which)
>  {
> +    int hdm_inc =3D R_CXL_HDM_DECODER1_BASE_LO - R_CXL_HDM_DECODER0_BASE=
_LO;
>      ComponentRegisters *cregs =3D &ct3d->cxl_cstate.crb;
>      uint32_t *cache_mem =3D cregs->cache_mem_registers;
>      uint32_t ctrl;
> =20
>      assert(which =3D=3D 0);
> =20
> -    ctrl =3D ldl_le_p(cache_mem + R_CXL_HDM_DECODER0_CTRL);
> +    ctrl =3D ldl_le_p(cache_mem + R_CXL_HDM_DECODER0_CTRL + which * hdm_=
inc);
>      /* TODO: Sanity checks that the decoder is possible */
>      ctrl =3D FIELD_DP32(ctrl, CXL_HDM_DECODER0_CTRL, ERR, 0);
>      ctrl =3D FIELD_DP32(ctrl, CXL_HDM_DECODER0_CTRL, COMMITTED, 1);
> =20
> -    stl_le_p(cache_mem + R_CXL_HDM_DECODER0_CTRL, ctrl);
> +    stl_le_p(cache_mem + R_CXL_HDM_DECODER0_CTRL + which * hdm_inc, ctrl=
);
>  }
> =20
>  static void hdm_decoder_uncommit(CXLType3Dev *ct3d, int which)
>  {
> +    int hdm_inc =3D R_CXL_HDM_DECODER1_BASE_LO - R_CXL_HDM_DECODER0_BASE=
_LO;
>      ComponentRegisters *cregs =3D &ct3d->cxl_cstate.crb;
>      uint32_t *cache_mem =3D cregs->cache_mem_registers;
>      uint32_t ctrl;
> =20
>      assert(which =3D=3D 0);
> =20
> -    ctrl =3D ldl_le_p(cache_mem + R_CXL_HDM_DECODER0_CTRL);
> +    ctrl =3D ldl_le_p(cache_mem + R_CXL_HDM_DECODER0_CTRL + which * hdm_=
inc);
> =20
>      ctrl =3D FIELD_DP32(ctrl, CXL_HDM_DECODER0_CTRL, ERR, 0);
>      ctrl =3D FIELD_DP32(ctrl, CXL_HDM_DECODER0_CTRL, COMMITTED, 0);
> =20
> -    stl_le_p(cache_mem + R_CXL_HDM_DECODER0_CTRL, ctrl);
> +    stl_le_p(cache_mem + R_CXL_HDM_DECODER0_CTRL + which * hdm_inc, ctrl=
);
>  }
> =20
>  static int ct3d_qmp_uncor_err_to_cxl(CxlUncorErrorType qmp_err)
> @@ -761,26 +763,30 @@ static void ct3_exit(PCIDevice *pci_dev)
>  /* TODO: Support multiple HDM decoders and DPA skip */
>  static bool cxl_type3_dpa(CXLType3Dev *ct3d, hwaddr host_addr, uint64_t =
*dpa)
>  {
> +    int hdm_inc =3D R_CXL_HDM_DECODER1_BASE_LO - R_CXL_HDM_DECODER0_BASE=
_LO;
>      uint32_t *cache_mem =3D ct3d->cxl_cstate.crb.cache_mem_registers;
>      uint64_t decoder_base, decoder_size, hpa_offset;
>      uint32_t hdm0_ctrl;
>      int ig, iw;
> +    int i =3D 0;
> =20
> -    decoder_base =3D (((uint64_t)cache_mem[R_CXL_HDM_DECODER0_BASE_HI] <=
< 32) |
> -                    cache_mem[R_CXL_HDM_DECODER0_BASE_LO]);
> +    decoder_base =3D
> +        (((uint64_t)cache_mem[R_CXL_HDM_DECODER0_BASE_HI + i * hdm_inc] =
<< 32) |
> +                    cache_mem[R_CXL_HDM_DECODER0_BASE_LO + i * hdm_inc])=
;
>      if ((uint64_t)host_addr < decoder_base) {
>          return false;
>      }
> =20
>      hpa_offset =3D (uint64_t)host_addr - decoder_base;
> =20
> -    decoder_size =3D ((uint64_t)cache_mem[R_CXL_HDM_DECODER0_SIZE_HI] <<=
 32) |
> -        cache_mem[R_CXL_HDM_DECODER0_SIZE_LO];
> +    decoder_size =3D
> +        ((uint64_t)cache_mem[R_CXL_HDM_DECODER0_SIZE_HI + i * hdm_inc] <=
< 32) |
> +        cache_mem[R_CXL_HDM_DECODER0_SIZE_LO + i * hdm_inc];
>      if (hpa_offset >=3D decoder_size) {
>          return false;
>      }
> =20
> -    hdm0_ctrl =3D cache_mem[R_CXL_HDM_DECODER0_CTRL];
> +    hdm0_ctrl =3D cache_mem[R_CXL_HDM_DECODER0_CTRL + i * hdm_inc];
>      iw =3D FIELD_EX32(hdm0_ctrl, CXL_HDM_DECODER0_CTRL, IW);
>      ig =3D FIELD_EX32(hdm0_ctrl, CXL_HDM_DECODER0_CTRL, IG);
> =20
> --=20
> 2.39.2
>=20
> =

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 3476AEE3F00
	for <linux-cxl@archiver.kernel.org>; Tue, 12 Sep 2023 18:08:49 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S231754AbjILSIw (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 12 Sep 2023 14:08:52 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:54792 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S237345AbjILSIv (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 12 Sep 2023 14:08:51 -0400
Received: from mailout2.w2.samsung.com (mailout2.w2.samsung.com [211.189.100.12])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 07AA710E6
        for <linux-cxl@vger.kernel.org>; Tue, 12 Sep 2023 11:08:47 -0700 (PDT)
Received: from uscas1p2.samsung.com (unknown [182.198.245.207])
        by mailout2.w2.samsung.com (KnoxPortal) with ESMTP id 20230912180846usoutp02505cce85f3ca7c010b2383ad857c1896~EORXmK49D2333423334usoutp02E;
        Tue, 12 Sep 2023 18:08:46 +0000 (GMT)
DKIM-Filter: OpenDKIM Filter v2.11.0 mailout2.w2.samsung.com 20230912180846usoutp02505cce85f3ca7c010b2383ad857c1896~EORXmK49D2333423334usoutp02E
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=samsung.com;
        s=mail20170921; t=1694542126;
        bh=jv0LV8utv1i7ApfFwqwNk7q1AKUz3NnBOj9mV7cQ+x0=;
        h=From:To:CC:Subject:Date:In-Reply-To:References:From;
        b=hhOEgC2eVqGIoksPFw/7FDhSaebjeLTfVRKH5ruDh/7trA7KZfU1QiKAgIXE6mhmB
         OpScjnTggTrhFXMmGixP93FmbithuohN3LS8B7wXcvkxYxSV5w08nVvOyoeP0boH5f
         8BIamPuV3Tj7e8bNG1c/o5eDnklHzIjFE1YGu3TI=
Received: from ussmges2new.samsung.com (u111.gpu85.samsung.co.kr
        [203.254.195.111]) by uscas1p2.samsung.com (KnoxPortal) with ESMTP id
        20230912180845uscas1p254803e01094846b2579cb1772dd47b15~EORXeX8ON0142701427uscas1p2B;
        Tue, 12 Sep 2023 18:08:45 +0000 (GMT)
Received: from uscas1p1.samsung.com ( [182.198.245.206]) by
        ussmges2new.samsung.com (USCPEMTA) with SMTP id 70.9B.40279.D29A0056; Tue,
        12 Sep 2023 14:08:45 -0400 (EDT)
Received: from ussmgxs3new.samsung.com (u92.gpu85.samsung.co.kr
        [203.254.195.92]) by uscas1p2.samsung.com (KnoxPortal) with ESMTP id
        20230912180845uscas1p28e989eaff6b92939cfdb85886137354b~EORXQMVzD3243332433uscas1p2M;
        Tue, 12 Sep 2023 18:08:45 +0000 (GMT)
X-AuditID: cbfec36f-4cbfe70000009d57-b1-6500a92d93f4
Received: from SSI-EX1.ssi.samsung.com ( [105.128.2.145]) by
        ussmgxs3new.samsung.com (USCPEXMTA) with SMTP id F8.B9.31410.D29A0056; Tue,
        12 Sep 2023 14:08:45 -0400 (EDT)
Received: from SSI-EX2.ssi.samsung.com (105.128.2.227) by
        SSI-EX1.ssi.samsung.com (105.128.2.226) with Microsoft SMTP Server
        (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384) id
        15.1.2375.24; Tue, 12 Sep 2023 11:08:44 -0700
Received: from SSI-EX2.ssi.samsung.com ([105.128.2.227]) by
        SSI-EX2.ssi.samsung.com ([105.128.2.227]) with mapi id 15.01.2375.024; Tue,
        12 Sep 2023 11:08:44 -0700
From: Fan Ni <fan.ni@samsung.com>
To: Jonathan Cameron <Jonathan.Cameron@huawei.com>
CC: "qemu-devel@nongnu.org" <qemu-devel@nongnu.org>,
        Michael Tsirkin <mst@redhat.com>,
        =?iso-8859-1?Q?Philippe_Mathieu-Daud=E9?= <philmd@linaro.org>,
        "linux-cxl@vger.kernel.org" <linux-cxl@vger.kernel.org>,
        "linuxarm@huawei.com" <linuxarm@huawei.com>
Subject: Re: [PATCH v3 4/4] hw/cxl: Support 4 HDM decoders at all levels of
 topology
Thread-Topic: [PATCH v3 4/4] hw/cxl: Support 4 HDM decoders at all levels of
        topology
Thread-Index: AQHZ5KVz5ehTY0A1Q0y1rQVyt8XI/bAX9GMA
Date: Tue, 12 Sep 2023 18:08:44 +0000
Message-ID: <20230912180844.GD319114@bgt-140510-bm03>
In-Reply-To: <20230911114313.6144-5-Jonathan.Cameron@huawei.com>
Accept-Language: en-US
Content-Language: en-US
X-MS-Has-Attach: 
X-MS-TNEF-Correlator: 
x-originating-ip: [105.128.2.176]
Content-Type: text/plain; charset="iso-8859-1"
Content-ID: <5B1F8F0FB6CBEA4F930CE02189990A2A@ssi.samsung.com>
Content-Transfer-Encoding: quoted-printable
MIME-Version: 1.0
X-CFilter-Loop: Reflected
X-Brightmail-Tracker: H4sIAAAAAAAAA+NgFlrOKsWRmVeSWpSXmKPExsWy7djXc7q6KxlSDdq/GlisWniNzeL8rFMs
        Foc3nmGy+P/rFavFmhXCFsd7d7A4sHm0HHnL6nHn2h42jyfXNjN5vN93lc3j8ya5ANYoLpuU
        1JzMstQifbsErozV6+4wF5zIrni0v4WlgXG/TxcjJ4eEgIlE29T9LF2MXBxCAisZJc51v2SF
        cFqZJC4/7WWFqVrbf58dIrGWUeLz5V+MEM4nRoneNaugnGWMEkfuHgdrYRNQlNjXtZ0NxBYR
        MJJ4d2MSWBGzQAOTxLV759hBEsICYRI93QuZIIrCJX5MaWSEaWiZuZwFxGYRUJV4dXcWWA2v
        gKlEy7XpYL2cAg4SZ161MIPYjAJiEt9PrQGrYRYQl7j1ZD4TxN2CEotm72GGsMUk/u16yAZh
        K0rc//6SHaJeT+LG1ClsELadxMv1y1khbG2JZQtfM0PsFZQ4OfMJC0SvpMTBFTfAISYhcIFD
        4lzbBmgguUgcufUbqkhaYvqay0A2B5CdLLHqIxdEOEdi/pItUCXWEgv/rGeawKgyC8nZs5Cc
        NAvJSbOQnDQLyUkLGFlXMYqXFhfnpqcWG+WllusVJ+YWl+al6yXn525iBKal0/8O5+9gvH7r
        o94hRiYOxkOMEhzMSiK8JYf+pgjxpiRWVqUW5ccXleakFh9ilOZgURLnNbQ9mSwkkJ5Ykpqd
        mlqQWgSTZeLglGpg4gxy8/JlNVzKciTtyNFYhfTgjcIquZvfFLi9MzrwOPaw16Svqinrj2uu
        7/vc/b/TbNK6mz6pOz5mGzRVbH4sJy7ldDvVouLFhLjQX48nSZvXHX7sXf8zzHDq9h/1/ZpL
        NWLuH3D0sL7Pz3ovu3VJ4QTrDJ2znKfV1Td80njhOjNLIz5NRHh6XKIow6kFvAt8eUu+zHlr
        rrF+5q/FBYpWFwONXy7zL2Wq/JfH5ZKXv4j38KvMZVI7lso8Pb1e9n6Fb+EjTbajEV5bX6j5
        ZZS/yKtv+8Z7WlRONSajMyLy/DbnuXYMm38tKqyTl5TeIfZ9a4Bghq3siad5Uk6Vjp0M/5Iq
        xRezykj4PAmdqKbEUpyRaKjFXFScCAAB8awPugMAAA==
X-Brightmail-Tracker: H4sIAAAAAAAAA+NgFjrCIsWRmVeSWpSXmKPExsWS2cA0UVd3JUOqwb5f8harFl5jszg/6xSL
        xeGNZ5gs/v96xWqxZoWwxfHeHSwObB4tR96yety5tofN48m1zUwe7/ddZfP4vEkugDWKyyYl
        NSezLLVI3y6BK2P1ujvMBSeyKx7tb2FpYNzv08XIySEhYCKxtv8+excjF4eQwGpGibbj8xgh
        nE+MErfPNkA5yxgl9v6eygrSwiagKLGvazsbiC0iYCTx7sYksCJmgQYmidZ7RxlBEsICYRI9
        3QuZIIrCJX7dX8YO09AyczkLiM0ioCrx6u4ssBpeAVOJlmvTgWo4gLaVShzYHQ8S5hRwkDjz
        qoUZxGYUEJP4fmoNWDmzgLjErSfzmSBeEJBYsuc8M4QtKvHy8T9WCFtR4v73l+wQ9XoSN6ZO
        YYOw7SRerl/OCmFrSyxb+JoZ4gRBiZMzn7BA9EpKHFxxg2UCo8QsJOtmIRk1C8moWUhGzUIy
        agEj6ypG8dLi4tz0imLjvNRyveLE3OLSvHS95PzcTYzAiD7973DMDsZ7tz7qHWJk4mA8xCjB
        wawkwlty6G+KEG9KYmVValF+fFFpTmrxIUZpDhYlcd4dUy6mCAmkJ5akZqemFqQWwWSZODil
        GphEWot89n54djB8qvA/Lq4J1us+mLk0/j4vvHz6IeXM+/ct72qqmb+3vLVLadse0UuBknt2
        xYpX7Ux713stScLNUmXvAbubaw6Hi3Ve5p3z6vE3lbea9bK5fgw8WwOmvmJeprtsy8WG1JOC
        j314P5musZ73xvGbS/Ne/id3xSf/tJ7lu3iV59lP1/xe5CgWRZcv2/Ph8Jk3fFYRpmkfJtwN
        tLvC8Ouia8rTqNyzZ9UeT+Hz/PxASuzOhzvvL7TbGJncf+jzKX6389F5XtfPfP0mPaPuVpi2
        +FzF1EKV+jPzInx27P96f+d5bosjguWS3q//sm8Ib9OX+BfCoSYm5Wq1fr3buxfFZxk0NzRK
        ns3LVGIpzkg01GIuKk4EACBYQOhXAwAA
X-CMS-MailID: 20230912180845uscas1p28e989eaff6b92939cfdb85886137354b
CMS-TYPE: 301P
X-CMS-RootMailID: 20230912180845uscas1p28e989eaff6b92939cfdb85886137354b
References: <20230911114313.6144-1-Jonathan.Cameron@huawei.com>
        <20230911114313.6144-5-Jonathan.Cameron@huawei.com>
        <CGME20230912180845uscas1p28e989eaff6b92939cfdb85886137354b@uscas1p2.samsung.com>
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

On Mon, Sep 11, 2023 at 12:43:13PM +0100, Jonathan Cameron wrote:

> Support these decoders in CXL host bridges (pxb-cxl), CXL Switch USP
> and CXL Type 3 end points.
>=20
> Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
>=20
> ---

One comment inline, other than that, looks good to me.


> v3: Factor out the hdm_inc changes to previous patch.
>     Fix use of encoded hdm count as if it were decoded in cxl-host.
>     Minor refactoring to make that path and one in cxl_type3.c
>     look more similar.
> ---
>  include/hw/cxl/cxl_component.h | 10 +++-
>  hw/cxl/cxl-component-utils.c   |  7 ++-
>  hw/cxl/cxl-host.c              | 67 ++++++++++++++++--------
>  hw/mem/cxl_type3.c             | 96 +++++++++++++++++++++++-----------
>  4 files changed, 124 insertions(+), 56 deletions(-)
>=20
> diff --git a/include/hw/cxl/cxl_component.h b/include/hw/cxl/cxl_componen=
t.h
> index 7c864d2044..3c795a6278 100644
> --- a/include/hw/cxl/cxl_component.h
> +++ b/include/hw/cxl/cxl_component.h
> @@ -135,6 +135,10 @@ REG32(CXL_RAS_ERR_HEADER0, CXL_RAS_REGISTERS_OFFSET =
+ 0x18)
>    REG32(CXL_HDM_DECODER##n##_TARGET_LIST_LO,                            =
       \
>          CXL_HDM_REGISTERS_OFFSET + (0x20 * n) + 0x24)                   =
       \
>    REG32(CXL_HDM_DECODER##n##_TARGET_LIST_HI,                            =
       \
> +        CXL_HDM_REGISTERS_OFFSET + (0x20 * n) + 0x28)                   =
       \
> +  REG32(CXL_HDM_DECODER##n##_DPA_SKIP_LO,                               =
       \
> +        CXL_HDM_REGISTERS_OFFSET + (0x20 * n) + 0x24)                   =
       \
> +  REG32(CXL_HDM_DECODER##n##_DPA_SKIP_HI,                               =
       \
>          CXL_HDM_REGISTERS_OFFSET + (0x20 * n) + 0x28)
> =20
>  REG32(CXL_HDM_DECODER_CAPABILITY, CXL_HDM_REGISTERS_OFFSET)
> @@ -147,9 +151,13 @@ REG32(CXL_HDM_DECODER_GLOBAL_CONTROL, CXL_HDM_REGIST=
ERS_OFFSET + 4)
>      FIELD(CXL_HDM_DECODER_GLOBAL_CONTROL, POISON_ON_ERR_EN, 0, 1)
>      FIELD(CXL_HDM_DECODER_GLOBAL_CONTROL, HDM_DECODER_ENABLE, 1, 1)
> =20
> +/* Support 4 decoders at all levels of topology */
> +#define CXL_HDM_DECODER_COUNT 4
> +
>  HDM_DECODER_INIT(0);
> -/* Only used for HDM decoder registers block address increment */
>  HDM_DECODER_INIT(1);
> +HDM_DECODER_INIT(2);
> +HDM_DECODER_INIT(3);
> =20
>  /* 8.2.5.13 - CXL Extended Security Capability Structure (Root complex o=
nly) */
>  #define EXTSEC_ENTRY_MAX        256
> diff --git a/hw/cxl/cxl-component-utils.c b/hw/cxl/cxl-component-utils.c
> index aa011a8f34..3ecdad4a5e 100644
> --- a/hw/cxl/cxl-component-utils.c
> +++ b/hw/cxl/cxl-component-utils.c
> @@ -90,6 +90,9 @@ static void dumb_hdm_handler(CXLComponentState *cxl_cst=
ate, hwaddr offset,
> =20
>      switch (offset) {
>      case A_CXL_HDM_DECODER0_CTRL:
> +    case A_CXL_HDM_DECODER1_CTRL:
> +    case A_CXL_HDM_DECODER2_CTRL:
> +    case A_CXL_HDM_DECODER3_CTRL:
>          should_commit =3D FIELD_EX32(value, CXL_HDM_DECODER0_CTRL, COMMI=
T);
>          should_uncommit =3D !should_commit;

So for the commit/uncommit flag, we always check decoder 0 control
register? Or i read it wrong? I thought the commit bit is per control regis=
ter
thing?

Fan

>          break;
> @@ -129,7 +132,7 @@ static void cxl_cache_mem_write_reg(void *opaque, hwa=
ddr offset, uint64_t value,
>      }
> =20
>      if (offset >=3D A_CXL_HDM_DECODER_CAPABILITY &&
> -        offset <=3D A_CXL_HDM_DECODER0_TARGET_LIST_HI) {
> +        offset <=3D A_CXL_HDM_DECODER3_TARGET_LIST_HI) {
>          dumb_hdm_handler(cxl_cstate, offset, value);
>      } else {
>          cregs->cache_mem_registers[offset / sizeof(*cregs->cache_mem_reg=
isters)] =3D value;
> @@ -209,7 +212,7 @@ static void ras_init_common(uint32_t *reg_state, uint=
32_t *write_msk)
>  static void hdm_init_common(uint32_t *reg_state, uint32_t *write_msk,
>                              enum reg_type type)
>  {
> -    int decoder_count =3D 1;
> +    int decoder_count =3D CXL_HDM_DECODER_COUNT;
>      int hdm_inc =3D R_CXL_HDM_DECODER1_BASE_LO - R_CXL_HDM_DECODER0_BASE=
_LO;
>      int i;
> =20
> diff --git a/hw/cxl/cxl-host.c b/hw/cxl/cxl-host.c
> index 73c5426476..2aa776c79c 100644
> --- a/hw/cxl/cxl-host.c
> +++ b/hw/cxl/cxl-host.c
> @@ -97,35 +97,58 @@ void cxl_fmws_link_targets(CXLState *cxl_state, Error=
 **errp)
>      }
>  }
> =20
> -/* TODO: support, multiple hdm decoders */
>  static bool cxl_hdm_find_target(uint32_t *cache_mem, hwaddr addr,
>                                  uint8_t *target)
>  {
>      int hdm_inc =3D R_CXL_HDM_DECODER1_BASE_LO - R_CXL_HDM_DECODER0_BASE=
_LO;
> -    uint32_t ctrl;
> -    uint32_t ig_enc;
> -    uint32_t iw_enc;
> -    uint32_t target_idx;
> -    int i =3D 0;
> -
> -    ctrl =3D cache_mem[R_CXL_HDM_DECODER0_CTRL + i * hdm_inc];
> -    if (!FIELD_EX32(ctrl, CXL_HDM_DECODER0_CTRL, COMMITTED)) {
> -        return false;
> -    }
> -
> -    ig_enc =3D FIELD_EX32(ctrl, CXL_HDM_DECODER0_CTRL, IG);
> -    iw_enc =3D FIELD_EX32(ctrl, CXL_HDM_DECODER0_CTRL, IW);
> -    target_idx =3D (addr / cxl_decode_ig(ig_enc)) % (1 << iw_enc);
> +    unsigned int hdm_count;
> +    bool found =3D false;
> +    int i;
> +    uint32_t cap;
> +
> +    cap =3D ldl_le_p(cache_mem + R_CXL_HDM_DECODER_CAPABILITY);
> +    hdm_count =3D cxl_decoder_count_dec(FIELD_EX32(cap,
> +                                                 CXL_HDM_DECODER_CAPABIL=
ITY,
> +                                                 DECODER_COUNT));
> +    for (i =3D 0; i < hdm_count; i++) {
> +        uint32_t ctrl, ig_enc, iw_enc, target_idx;
> +        uint32_t low, high;
> +        uint64_t base, size;
> +
> +        low =3D ldl_le_p(cache_mem + R_CXL_HDM_DECODER0_BASE_LO + i * hd=
m_inc);
> +        high =3D ldl_le_p(cache_mem + R_CXL_HDM_DECODER0_BASE_HI + i * h=
dm_inc);
> +        base =3D (low & 0xf0000000) | ((uint64_t)high << 32);
> +        low =3D ldl_le_p(cache_mem + R_CXL_HDM_DECODER0_SIZE_LO + i * hd=
m_inc);
> +        high =3D ldl_le_p(cache_mem + R_CXL_HDM_DECODER0_SIZE_HI + i * h=
dm_inc);
> +        size =3D (low & 0xf0000000) | ((uint64_t)high << 32);
> +        if (addr < base || addr >=3D base + size) {
> +            continue;
> +        }
> =20
> -    if (target_idx < 4) {
> -        *target =3D extract32(cache_mem[R_CXL_HDM_DECODER0_TARGET_LIST_L=
O],
> -                            target_idx * 8, 8);
> -    } else {
> -        *target =3D extract32(cache_mem[R_CXL_HDM_DECODER0_TARGET_LIST_H=
I],
> -                            (target_idx - 4) * 8, 8);
> +        ctrl =3D ldl_le_p(cache_mem + R_CXL_HDM_DECODER0_CTRL + i * hdm_=
inc);
> +        if (!FIELD_EX32(ctrl, CXL_HDM_DECODER0_CTRL, COMMITTED)) {
> +            return false;
> +        }
> +        found =3D true;
> +        ig_enc =3D FIELD_EX32(ctrl, CXL_HDM_DECODER0_CTRL, IG);
> +        iw_enc =3D FIELD_EX32(ctrl, CXL_HDM_DECODER0_CTRL, IW);
> +        target_idx =3D (addr / cxl_decode_ig(ig_enc)) % (1 << iw_enc);
> +
> +        if (target_idx < 4) {
> +            uint32_t val =3D ldl_le_p(cache_mem +
> +                                    R_CXL_HDM_DECODER0_TARGET_LIST_LO +
> +                                    i * hdm_inc);
> +            *target =3D extract32(val, target_idx * 8, 8);
> +        } else {
> +            uint32_t val =3D ldl_le_p(cache_mem +
> +                                    R_CXL_HDM_DECODER0_TARGET_LIST_HI +
> +                                    i * hdm_inc);
> +            *target =3D extract32(val, (target_idx - 4) * 8, 8);
> +        }
> +        break;
>      }
> =20
> -    return true;
> +    return found;
>  }
> =20
>  static PCIDevice *cxl_cfmws_find_device(CXLFixedWindow *fw, hwaddr addr)
> diff --git a/hw/mem/cxl_type3.c b/hw/mem/cxl_type3.c
> index cd92813436..1658e0cc59 100644
> --- a/hw/mem/cxl_type3.c
> +++ b/hw/mem/cxl_type3.c
> @@ -382,8 +382,6 @@ static void hdm_decoder_commit(CXLType3Dev *ct3d, int=
 which)
>      uint32_t *cache_mem =3D cregs->cache_mem_registers;
>      uint32_t ctrl;
> =20
> -    assert(which =3D=3D 0);
> -
>      ctrl =3D ldl_le_p(cache_mem + R_CXL_HDM_DECODER0_CTRL + which * hdm_=
inc);
>      /* TODO: Sanity checks that the decoder is possible */
>      ctrl =3D FIELD_DP32(ctrl, CXL_HDM_DECODER0_CTRL, ERR, 0);
> @@ -399,8 +397,6 @@ static void hdm_decoder_uncommit(CXLType3Dev *ct3d, i=
nt which)
>      uint32_t *cache_mem =3D cregs->cache_mem_registers;
>      uint32_t ctrl;
> =20
> -    assert(which =3D=3D 0);
> -
>      ctrl =3D ldl_le_p(cache_mem + R_CXL_HDM_DECODER0_CTRL + which * hdm_=
inc);
> =20
>      ctrl =3D FIELD_DP32(ctrl, CXL_HDM_DECODER0_CTRL, ERR, 0);
> @@ -489,6 +485,21 @@ static void ct3d_reg_write(void *opaque, hwaddr offs=
et, uint64_t value,
>          should_uncommit =3D !should_commit;
>          which_hdm =3D 0;
>          break;
> +    case A_CXL_HDM_DECODER1_CTRL:
> +        should_commit =3D FIELD_EX32(value, CXL_HDM_DECODER0_CTRL, COMMI=
T);
> +        should_uncommit =3D !should_commit;
> +        which_hdm =3D 1;
> +        break;
> +    case A_CXL_HDM_DECODER2_CTRL:
> +        should_commit =3D FIELD_EX32(value, CXL_HDM_DECODER0_CTRL, COMMI=
T);
> +        should_uncommit =3D !should_commit;
> +        which_hdm =3D 2;
> +        break;
> +    case A_CXL_HDM_DECODER3_CTRL:
> +        should_commit =3D FIELD_EX32(value, CXL_HDM_DECODER0_CTRL, COMMI=
T);
> +        should_uncommit =3D !should_commit;
> +        which_hdm =3D 3;
> +        break;
>      case A_CXL_RAS_UNC_ERR_STATUS:
>      {
>          uint32_t capctrl =3D ldl_le_p(cache_mem + R_CXL_RAS_ERR_CAP_CTRL=
);
> @@ -760,40 +771,63 @@ static void ct3_exit(PCIDevice *pci_dev)
>      }
>  }
> =20
> -/* TODO: Support multiple HDM decoders and DPA skip */
>  static bool cxl_type3_dpa(CXLType3Dev *ct3d, hwaddr host_addr, uint64_t =
*dpa)
>  {
>      int hdm_inc =3D R_CXL_HDM_DECODER1_BASE_LO - R_CXL_HDM_DECODER0_BASE=
_LO;
>      uint32_t *cache_mem =3D ct3d->cxl_cstate.crb.cache_mem_registers;
> -    uint64_t decoder_base, decoder_size, hpa_offset;
> -    uint32_t hdm0_ctrl;
> -    int ig, iw;
> -    int i =3D 0;
> -
> -    decoder_base =3D
> -        (((uint64_t)cache_mem[R_CXL_HDM_DECODER0_BASE_HI + i * hdm_inc] =
<< 32) |
> -                    cache_mem[R_CXL_HDM_DECODER0_BASE_LO + i * hdm_inc])=
;
> -    if ((uint64_t)host_addr < decoder_base) {
> -        return false;
> -    }
> -
> -    hpa_offset =3D (uint64_t)host_addr - decoder_base;
> -
> -    decoder_size =3D
> -        ((uint64_t)cache_mem[R_CXL_HDM_DECODER0_SIZE_HI + i * hdm_inc] <=
< 32) |
> -        cache_mem[R_CXL_HDM_DECODER0_SIZE_LO + i * hdm_inc];
> -    if (hpa_offset >=3D decoder_size) {
> -        return false;
> -    }
> +    unsigned int hdm_count;
> +    uint32_t cap;
> +    uint64_t dpa_base =3D 0;
> +    int i;
> =20
> -    hdm0_ctrl =3D cache_mem[R_CXL_HDM_DECODER0_CTRL + i * hdm_inc];
> -    iw =3D FIELD_EX32(hdm0_ctrl, CXL_HDM_DECODER0_CTRL, IW);
> -    ig =3D FIELD_EX32(hdm0_ctrl, CXL_HDM_DECODER0_CTRL, IG);
> +    cap =3D ldl_le_p(cache_mem + R_CXL_HDM_DECODER_CAPABILITY);
> +    hdm_count =3D cxl_decoder_count_dec(FIELD_EX32(cap,
> +                                                 CXL_HDM_DECODER_CAPABIL=
ITY,
> +                                                 DECODER_COUNT));
> +
> +    for (i =3D 0; i < hdm_count; i++) {
> +        uint64_t decoder_base, decoder_size, hpa_offset, skip;
> +        uint32_t hdm_ctrl, low, high;
> +        int ig, iw;
> +
> +        low =3D ldl_le_p(cache_mem + R_CXL_HDM_DECODER0_BASE_LO + i * hd=
m_inc);
> +        high =3D ldl_le_p(cache_mem + R_CXL_HDM_DECODER0_BASE_HI + i * h=
dm_inc);
> +        decoder_base =3D ((uint64_t)high << 32) | (low & 0xf0000000);
> +
> +        low =3D ldl_le_p(cache_mem + R_CXL_HDM_DECODER0_SIZE_LO + i * hd=
m_inc);
> +        high =3D ldl_le_p(cache_mem + R_CXL_HDM_DECODER0_SIZE_HI + i * h=
dm_inc);
> +        decoder_size =3D ((uint64_t)high << 32) | (low & 0xf0000000);
> +
> +        low =3D ldl_le_p(cache_mem + R_CXL_HDM_DECODER0_DPA_SKIP_LO +
> +                       i * hdm_inc);
> +        high =3D ldl_le_p(cache_mem + R_CXL_HDM_DECODER0_DPA_SKIP_HI +
> +                        i * hdm_inc);
> +        skip =3D ((uint64_t)high << 32) | (low & 0xf0000000);
> +        dpa_base +=3D skip;
> +
> +        hpa_offset =3D (uint64_t)host_addr - decoder_base;
> +
> +        hdm_ctrl =3D ldl_le_p(cache_mem + R_CXL_HDM_DECODER0_CTRL + i * =
hdm_inc);
> +        iw =3D FIELD_EX32(hdm_ctrl, CXL_HDM_DECODER0_CTRL, IW);
> +        ig =3D FIELD_EX32(hdm_ctrl, CXL_HDM_DECODER0_CTRL, IG);
> +        if (!FIELD_EX32(hdm_ctrl, CXL_HDM_DECODER0_CTRL, COMMITTED)) {
> +            return false;
> +        }
> +        if (((uint64_t)host_addr < decoder_base) ||
> +            (hpa_offset >=3D decoder_size)) {
> +            dpa_base +=3D decoder_size /
> +                cxl_interleave_ways_dec(iw, &error_fatal);
> +            continue;
> +        }
> =20
> -    *dpa =3D (MAKE_64BIT_MASK(0, 8 + ig) & hpa_offset) |
> -        ((MAKE_64BIT_MASK(8 + ig + iw, 64 - 8 - ig - iw) & hpa_offset) >=
> iw);
> +        *dpa =3D dpa_base +
> +            ((MAKE_64BIT_MASK(0, 8 + ig) & hpa_offset) |
> +             ((MAKE_64BIT_MASK(8 + ig + iw, 64 - 8 - ig - iw) & hpa_offs=
et)
> +              >> iw));
> =20
> -    return true;
> +        return true;
> +    }
> +    return false;
>  }
> =20
>  static int cxl_type3_hpa_to_as_and_dpa(CXLType3Dev *ct3d,
> --=20
> 2.39.2
>=20
> =

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 128BDEEB596
	for <linux-cxl@archiver.kernel.org>; Wed, 13 Sep 2023 06:54:03 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S236309AbjIMGyF (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Wed, 13 Sep 2023 02:54:05 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:58092 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S233786AbjIMGyE (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Wed, 13 Sep 2023 02:54:04 -0400
Received: from mail-lj1-x236.google.com (mail-lj1-x236.google.com [IPv6:2a00:1450:4864:20::236])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id D40E8173E
        for <linux-cxl@vger.kernel.org>; Tue, 12 Sep 2023 23:53:59 -0700 (PDT)
Received: by mail-lj1-x236.google.com with SMTP id 38308e7fff4ca-2b9c907bc68so110696111fa.2
        for <linux-cxl@vger.kernel.org>; Tue, 12 Sep 2023 23:53:59 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=linaro.org; s=google; t=1694588038; x=1695192838; darn=vger.kernel.org;
        h=content-transfer-encoding:in-reply-to:from:references:cc:to
         :content-language:subject:user-agent:mime-version:date:message-id
         :from:to:cc:subject:date:message-id:reply-to;
        bh=211zCmIv+vPEaED+Sp4DjaXx7DIucvF6focw/AbqiiQ=;
        b=GqROLa+CqK/z6C9tX0I4A6tU3rtxckW0394nQKfHojT5ZeVUZJ3mN81YZmevD8WCc4
         oZ+B0cn1lGf1IcVCeAK1krkNMH+UndFBihg++ROiIl9XcwY0+KRN5kOXkW+kexNv4EBR
         SP4lq0ktgPqLnv/66VJWR7BtWmB7cYp6XeQea7IO9SRzjCSBpLQbVcgy5Zur7wQL4BI+
         A5d15cy0SHzC/gm92OIGlx+k0Wn6YY812uZttPkmnE8vps7XyZJJShkytSpGfnJCw0Pd
         rD/20SrFx0AJ8zeNCv4Xk1ZYo/e61o5Necb4/ovX0ksOQ4ZKGoeweIUMzu397WN7Urad
         xBGg==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20230601; t=1694588038; x=1695192838;
        h=content-transfer-encoding:in-reply-to:from:references:cc:to
         :content-language:subject:user-agent:mime-version:date:message-id
         :x-gm-message-state:from:to:cc:subject:date:message-id:reply-to;
        bh=211zCmIv+vPEaED+Sp4DjaXx7DIucvF6focw/AbqiiQ=;
        b=Z9IltPholNVAssUwACLIkqx59WDmf8GCeuSvXUxId2Q9RbtzZ1tUh9X8UJULKqoIqM
         So5vyHm0Brjzcbg3P82IIAE7DRbun+W+wQ3NS8jMPE6hDehgVJdwGYyc4H3dSORmjrF7
         szEN9civYE4E765YeOUR+U66kbCfMGvJpmeIoDBjVnvz5uW5swr6CEJolpEKE8XYkuZ3
         zu7gUcZm+DDReS2wIEbDs+SFXd1I76wVw0eu+MfwqIT4+A/gsgzrG0N5D+WsAuSqlTXQ
         zkMCNl47xSTmYMtAQ56xssI7wG8JQZyKXRMMMejEcd8LSV2fXSzbvnGqPwHdmVJNJNT0
         VUJw==
X-Gm-Message-State: AOJu0YxTqtdJmHTTOXT7VumUosA/iY2FRKpB/NZ1WWt5ebFbb8z3giw2
        OcBD9S3f8F3YANidw2eZlOnY4A==
X-Google-Smtp-Source: AGHT+IGmXzrN8RrPxven59mFGJOecTiXK/ZGzWoT1Ckaqo3J3rB7nwndwTMyl6V015x3eVQaTTa/4w==
X-Received: by 2002:a2e:a28d:0:b0:2b7:33b9:8809 with SMTP id k13-20020a2ea28d000000b002b733b98809mr1235791lja.16.1694588038119;
        Tue, 12 Sep 2023 23:53:58 -0700 (PDT)
Received: from [192.168.69.115] (176-131-211-241.abo.bbox.fr. [176.131.211.241])
        by smtp.gmail.com with ESMTPSA id l21-20020a170906939500b00985ed2f1584sm7845653ejx.187.2023.09.12.23.53.56
        (version=TLS1_3 cipher=TLS_AES_128_GCM_SHA256 bits=128/128);
        Tue, 12 Sep 2023 23:53:57 -0700 (PDT)
Message-ID: <b4ad0199-2df5-05ee-dde4-eb85ffb0a2b0@linaro.org>
Date: Wed, 13 Sep 2023 08:53:55 +0200
MIME-Version: 1.0
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:102.0)
 Gecko/20100101 Thunderbird/102.15.0
Subject: Re: [PATCH v3 3/4] hw/cxl: Fix and use same calculation for HDM
 decoder block size everywhere
Content-Language: en-US
To: Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        qemu-devel@nongnu.org, Michael Tsirkin <mst@redhat.com>,
        Fan Ni <fan.ni@samsung.com>, linux-cxl@vger.kernel.org
Cc: linuxarm@huawei.com
References: <20230911114313.6144-1-Jonathan.Cameron@huawei.com>
 <20230911114313.6144-4-Jonathan.Cameron@huawei.com>
From: =?UTF-8?Q?Philippe_Mathieu-Daud=c3=a9?= <philmd@linaro.org>
In-Reply-To: <20230911114313.6144-4-Jonathan.Cameron@huawei.com>
Content-Type: text/plain; charset=UTF-8; format=flowed
Content-Transfer-Encoding: 8bit
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

On 11/9/23 13:43, Jonathan Cameron wrote:
> In order to avoid having the size of the per HDM decoder register block
> repeated in lots of places, create the register definitions for HDM
> decoder 1 and use the offset between the first registers in HDM decoder 0 and
> HDM decoder 1 to establish the offset.
> 
> Calculate in each function as this is more obvious and leads to shorter
> line lengths than a single #define which would need a long name
> to be specific enough.
> 
> Note that the code currently only supports one decoder, so the bugs this
> fixes don't actually affect anything. Previously the offset didn't
> take into account that the write_msk etc are 4 byte fields.
> 
> Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
> 
> --
> v3:
> New patch to separate this out from the addition of HDM decoders.
> ---
>   include/hw/cxl/cxl_component.h |  2 ++
>   hw/cxl/cxl-component-utils.c   | 19 +++++++++++--------
>   hw/cxl/cxl-host.c              |  4 +++-
>   hw/mem/cxl_type3.c             | 24 +++++++++++++++---------
>   4 files changed, 31 insertions(+), 18 deletions(-)


> @@ -761,26 +763,30 @@ static void ct3_exit(PCIDevice *pci_dev)
>   /* TODO: Support multiple HDM decoders and DPA skip */
>   static bool cxl_type3_dpa(CXLType3Dev *ct3d, hwaddr host_addr, uint64_t *dpa)
>   {
> +    int hdm_inc = R_CXL_HDM_DECODER1_BASE_LO - R_CXL_HDM_DECODER0_BASE_LO;
>       uint32_t *cache_mem = ct3d->cxl_cstate.crb.cache_mem_registers;
>       uint64_t decoder_base, decoder_size, hpa_offset;
>       uint32_t hdm0_ctrl;
>       int ig, iw;
> +    int i = 0;
>   
> -    decoder_base = (((uint64_t)cache_mem[R_CXL_HDM_DECODER0_BASE_HI] << 32) |
> -                    cache_mem[R_CXL_HDM_DECODER0_BASE_LO]);
> +    decoder_base =
> +        (((uint64_t)cache_mem[R_CXL_HDM_DECODER0_BASE_HI + i * hdm_inc] << 32) |
> +                    cache_mem[R_CXL_HDM_DECODER0_BASE_LO + i * hdm_inc]);

Alternatively easier to review as (matter of taste ?):

decoder_base = deposit64(cache_mem[R_CXL_HDM_DECODER0_BASE_LO + i * 
hdm_inc], 32, 32,
                          cache_mem[R_CXL_HDM_DECODER0_BASE_HI + i * 
hdm_inc]);

Regardless:

Reviewed-by: Philippe Mathieu-Daudé <philmd@linaro.org>


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 5220ECA5511
	for <linux-cxl@archiver.kernel.org>; Wed, 13 Sep 2023 08:58:12 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S239096AbjIMI6P convert rfc822-to-8bit (ORCPT
        <rfc822;linux-cxl@archiver.kernel.org>);
        Wed, 13 Sep 2023 04:58:15 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:33522 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S238884AbjIMI6P (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Wed, 13 Sep 2023 04:58:15 -0400
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 28B9C1993
        for <linux-cxl@vger.kernel.org>; Wed, 13 Sep 2023 01:58:11 -0700 (PDT)
Received: from lhrpeml500005.china.huawei.com (unknown [172.18.147.201])
        by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4RlvV85Tj0z6H7HS;
        Wed, 13 Sep 2023 16:57:36 +0800 (CST)
Received: from localhost (10.202.227.76) by lhrpeml500005.china.huawei.com
 (7.191.163.240) with Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id 15.1.2507.31; Wed, 13 Sep
 2023 09:58:09 +0100
Date: Wed, 13 Sep 2023 09:58:08 +0100
From: Jonathan Cameron <Jonathan.Cameron@Huawei.com>
To: Fan Ni <fan.ni@samsung.com>
CC: "qemu-devel@nongnu.org" <qemu-devel@nongnu.org>,
        Michael Tsirkin <mst@redhat.com>,
        Philippe =?ISO-8859-1?Q?Mathieu-Daud=E9?= <philmd@linaro.org>,
        "linux-cxl@vger.kernel.org" <linux-cxl@vger.kernel.org>,
        "linuxarm@huawei.com" <linuxarm@huawei.com>
Subject: Re: [PATCH v3 2/4] hw/cxl: Add utility functions decoder interleave
 ways and target count.
Message-ID: <20230913095808.00000df4@Huawei.com>
In-Reply-To: <20230912172005.GB319114@bgt-140510-bm03>
References: <20230911114313.6144-1-Jonathan.Cameron@huawei.com>
        <20230911114313.6144-3-Jonathan.Cameron@huawei.com>
        <CGME20230912172006uscas1p1f48a880aeaf7fad3400929d4bc919ae5@uscas1p1.samsung.com>
        <20230912172005.GB319114@bgt-140510-bm03>
Organization: Huawei Technologies Research and Development (UK) Ltd.
X-Mailer: Claws Mail 4.1.0 (GTK 3.24.33; x86_64-w64-mingw32)
MIME-Version: 1.0
Content-Type: text/plain; charset="ISO-8859-1"
Content-Transfer-Encoding: 8BIT
X-Originating-IP: [10.202.227.76]
X-ClientProxiedBy: lhrpeml100001.china.huawei.com (7.191.160.183) To
 lhrpeml500005.china.huawei.com (7.191.163.240)
X-CFilter-Loop: Reflected
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

On Tue, 12 Sep 2023 17:20:05 +0000
Fan Ni <fan.ni@samsung.com> wrote:

> On Mon, Sep 11, 2023 at 12:43:11PM +0100, Jonathan Cameron wrote:
> 
> > As an encoded version of these key configuration parameters is available
> > in a register, provide functions to extract it again so as to avoid
> > the need for duplicating the storage.
> > 
> > Whilst here update the _enc() function to include additional values
> > as defined in the CXL 3.0 specification. Whilst they are not
> > currently used in the emulation, they may be in future and it is
> > easier to compare with the specification if all values are covered.
> > 
> > Reviewed-by: Philippe Mathieu-Daud <philmd@linaro.org>
> > Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
> > ---  
> 
> LGTM. Only one minor comment inline.
> 
> Reviewed-by: Fan Ni <fan.ni@samsung.com>
Thanks!

> > +
> > +int cxl_decoder_count_dec(int enc_cnt)
> > +{
> > +    switch (enc_cnt) {
> > +    case 0x0: return 1;
> > +    case 0x1: return 2;
> > +    case 0x2: return 4;
> > +    case 0x3: return 6;
> > +    case 0x4: return 8;
> > +    case 0x5: return 10;
> > +    /* Switches and Host Bridges may have more than 10 decoders */
> > +    case 0x6: return 12;
> > +    case 0x7: return 14;
> > +    case 0x8: return 16;
> > +    case 0x9: return 20;
> > +    case 0xa: return 24;
> > +    case 0xb: return 28;
> > +    case 0xc: return 32;
> >      }
> >      return 0;
> >  }
> > @@ -410,6 +440,23 @@ uint8_t cxl_interleave_ways_enc(int iw, Error **errp)
> >      }
> >  }
> >    
> 
> Similar as decoder count dec/enc, maybe we want to add a line of comment below.
> /* CXL r3.0 Section 8.2.4.19.7 CXL HDM Decoder n Control Register */

I'll do it before cxl_interleave_ways_enc() - one function up in the file
as applies equally well there.
> 
> Fan
> > +int cxl_interleave_ways_dec(uint8_t iw_enc, Error **errp)
> > +{
> > +    switch (iw_enc) {
> > +    case 0x0: return 1;
> > +    case 0x1: return 2;
> > +    case 0x2: return 4;
> > +    case 0x3: return 8;
> > +    case 0x4: return 16;
> > +    case 0x8: return 3;
> > +    case 0x9: return 6;
> > +    case 0xa: return 12;
> > +    default:
> > +        error_setg(errp, "Encoded interleave ways: %d not supported", iw_enc);
> > +        return 0;
> > +    }
> > +}
> > +
> >  uint8_t cxl_interleave_granularity_enc(uint64_t gran, Error **errp)
> >  {
> >      switch (gran) {
> > -- 
> > 2.39.2
> > 
> >  


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id DD4E0CA550A
	for <linux-cxl@archiver.kernel.org>; Wed, 13 Sep 2023 09:01:18 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S235999AbjIMJBW convert rfc822-to-8bit (ORCPT
        <rfc822;linux-cxl@archiver.kernel.org>);
        Wed, 13 Sep 2023 05:01:22 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:33714 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S239200AbjIMJBT (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Wed, 13 Sep 2023 05:01:19 -0400
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 233381999
        for <linux-cxl@vger.kernel.org>; Wed, 13 Sep 2023 02:01:15 -0700 (PDT)
Received: from lhrpeml500005.china.huawei.com (unknown [172.18.147.207])
        by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4RlvXM0Vvyz6HJcx;
        Wed, 13 Sep 2023 16:59:31 +0800 (CST)
Received: from localhost (10.202.227.76) by lhrpeml500005.china.huawei.com
 (7.191.163.240) with Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id 15.1.2507.31; Wed, 13 Sep
 2023 10:01:13 +0100
Date: Wed, 13 Sep 2023 10:01:12 +0100
From: Jonathan Cameron <Jonathan.Cameron@Huawei.com>
To: Philippe =?ISO-8859-1?Q?Mathieu-Daud=E9?= <philmd@linaro.org>
CC: <qemu-devel@nongnu.org>, Michael Tsirkin <mst@redhat.com>,
        Fan Ni <fan.ni@samsung.com>, <linux-cxl@vger.kernel.org>,
        <linuxarm@huawei.com>
Subject: Re: [PATCH v3 3/4] hw/cxl: Fix and use same calculation for HDM
 decoder block size everywhere
Message-ID: <20230913100112.000031a8@Huawei.com>
In-Reply-To: <b4ad0199-2df5-05ee-dde4-eb85ffb0a2b0@linaro.org>
References: <20230911114313.6144-1-Jonathan.Cameron@huawei.com>
        <20230911114313.6144-4-Jonathan.Cameron@huawei.com>
        <b4ad0199-2df5-05ee-dde4-eb85ffb0a2b0@linaro.org>
Organization: Huawei Technologies Research and Development (UK) Ltd.
X-Mailer: Claws Mail 4.1.0 (GTK 3.24.33; x86_64-w64-mingw32)
MIME-Version: 1.0
Content-Type: text/plain; charset="ISO-8859-1"
Content-Transfer-Encoding: 8BIT
X-Originating-IP: [10.202.227.76]
X-ClientProxiedBy: lhrpeml100001.china.huawei.com (7.191.160.183) To
 lhrpeml500005.china.huawei.com (7.191.163.240)
X-CFilter-Loop: Reflected
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

On Wed, 13 Sep 2023 08:53:55 +0200
Philippe Mathieu-Daud <philmd@linaro.org> wrote:

> On 11/9/23 13:43, Jonathan Cameron wrote:
> > In order to avoid having the size of the per HDM decoder register block
> > repeated in lots of places, create the register definitions for HDM
> > decoder 1 and use the offset between the first registers in HDM decoder 0 and
> > HDM decoder 1 to establish the offset.
> > 
> > Calculate in each function as this is more obvious and leads to shorter
> > line lengths than a single #define which would need a long name
> > to be specific enough.
> > 
> > Note that the code currently only supports one decoder, so the bugs this
> > fixes don't actually affect anything. Previously the offset didn't
> > take into account that the write_msk etc are 4 byte fields.
> > 
> > Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
> > 
> > --
> > v3:
> > New patch to separate this out from the addition of HDM decoders.
> > ---
> >   include/hw/cxl/cxl_component.h |  2 ++
> >   hw/cxl/cxl-component-utils.c   | 19 +++++++++++--------
> >   hw/cxl/cxl-host.c              |  4 +++-
> >   hw/mem/cxl_type3.c             | 24 +++++++++++++++---------
> >   4 files changed, 31 insertions(+), 18 deletions(-)  
> 
> 
> > @@ -761,26 +763,30 @@ static void ct3_exit(PCIDevice *pci_dev)
> >   /* TODO: Support multiple HDM decoders and DPA skip */
> >   static bool cxl_type3_dpa(CXLType3Dev *ct3d, hwaddr host_addr, uint64_t *dpa)
> >   {
> > +    int hdm_inc = R_CXL_HDM_DECODER1_BASE_LO - R_CXL_HDM_DECODER0_BASE_LO;
> >       uint32_t *cache_mem = ct3d->cxl_cstate.crb.cache_mem_registers;
> >       uint64_t decoder_base, decoder_size, hpa_offset;
> >       uint32_t hdm0_ctrl;
> >       int ig, iw;
> > +    int i = 0;
> >   
> > -    decoder_base = (((uint64_t)cache_mem[R_CXL_HDM_DECODER0_BASE_HI] << 32) |
> > -                    cache_mem[R_CXL_HDM_DECODER0_BASE_LO]);
> > +    decoder_base =
> > +        (((uint64_t)cache_mem[R_CXL_HDM_DECODER0_BASE_HI + i * hdm_inc] << 32) |
> > +                    cache_mem[R_CXL_HDM_DECODER0_BASE_LO + i * hdm_inc]);  
> 
> Alternatively easier to review as (matter of taste ?):
> 
> decoder_base = deposit64(cache_mem[R_CXL_HDM_DECODER0_BASE_LO + i * 
> hdm_inc], 32, 32,
>                           cache_mem[R_CXL_HDM_DECODER0_BASE_HI + i * 
> hdm_inc]);

I'll leave if for now for consistency in the CXL code.  Might make
sense to consider this as a cross subsystem cleanup at some point though!
Thanks for the suggestion.

> 
> Regardless:
> 
> Reviewed-by: Philippe Mathieu-Daud <philmd@linaro.org>
Thanks.

Jonathan

> 
> 


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 18BC6CA550A
	for <linux-cxl@archiver.kernel.org>; Wed, 13 Sep 2023 09:03:44 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S239189AbjIMJDr (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Wed, 13 Sep 2023 05:03:47 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:47770 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S236929AbjIMJDq (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Wed, 13 Sep 2023 05:03:46 -0400
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 61F921999
        for <linux-cxl@vger.kernel.org>; Wed, 13 Sep 2023 02:03:42 -0700 (PDT)
Received: from lhrpeml500005.china.huawei.com (unknown [172.18.147.201])
        by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4Rlvb93q9Cz6HJbM;
        Wed, 13 Sep 2023 17:01:57 +0800 (CST)
Received: from localhost (10.202.227.76) by lhrpeml500005.china.huawei.com
 (7.191.163.240) with Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id 15.1.2507.31; Wed, 13 Sep
 2023 10:03:39 +0100
Date: Wed, 13 Sep 2023 10:03:38 +0100
From: Jonathan Cameron <Jonathan.Cameron@Huawei.com>
To: Fan Ni <fan.ni@samsung.com>
CC: "qemu-devel@nongnu.org" <qemu-devel@nongnu.org>,
        Michael Tsirkin <mst@redhat.com>,
        Philippe =?ISO-8859-1?Q?Mathieu-Daud=E9?= <philmd@linaro.org>,
        "linux-cxl@vger.kernel.org" <linux-cxl@vger.kernel.org>,
        "linuxarm@huawei.com" <linuxarm@huawei.com>
Subject: Re: [PATCH v3 4/4] hw/cxl: Support 4 HDM decoders at all levels of
 topology
Message-ID: <20230913100338.000006c2@Huawei.com>
In-Reply-To: <20230912180844.GD319114@bgt-140510-bm03>
References: <20230911114313.6144-1-Jonathan.Cameron@huawei.com>
        <20230911114313.6144-5-Jonathan.Cameron@huawei.com>
        <CGME20230912180845uscas1p28e989eaff6b92939cfdb85886137354b@uscas1p2.samsung.com>
        <20230912180844.GD319114@bgt-140510-bm03>
Organization: Huawei Technologies Research and Development (UK) Ltd.
X-Mailer: Claws Mail 4.1.0 (GTK 3.24.33; x86_64-w64-mingw32)
MIME-Version: 1.0
Content-Type: text/plain; charset="US-ASCII"
Content-Transfer-Encoding: 7bit
X-Originating-IP: [10.202.227.76]
X-ClientProxiedBy: lhrpeml100001.china.huawei.com (7.191.160.183) To
 lhrpeml500005.china.huawei.com (7.191.163.240)
X-CFilter-Loop: Reflected
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

On Tue, 12 Sep 2023 18:08:44 +0000
Fan Ni <fan.ni@samsung.com> wrote:

> On Mon, Sep 11, 2023 at 12:43:13PM +0100, Jonathan Cameron wrote:
> 
> > Support these decoders in CXL host bridges (pxb-cxl), CXL Switch USP
> > and CXL Type 3 end points.
> > 
> > Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
> > 
> > ---  
> 
> One comment inline, other than that, looks good to me.

I think we are fine, but also possible I'm missing something :)

> >  
> >  /* 8.2.5.13 - CXL Extended Security Capability Structure (Root complex only) */
> >  #define EXTSEC_ENTRY_MAX        256
> > diff --git a/hw/cxl/cxl-component-utils.c b/hw/cxl/cxl-component-utils.c
> > index aa011a8f34..3ecdad4a5e 100644
> > --- a/hw/cxl/cxl-component-utils.c
> > +++ b/hw/cxl/cxl-component-utils.c
> > @@ -90,6 +90,9 @@ static void dumb_hdm_handler(CXLComponentState *cxl_cstate, hwaddr offset,
> >  
> >      switch (offset) {
> >      case A_CXL_HDM_DECODER0_CTRL:
> > +    case A_CXL_HDM_DECODER1_CTRL:
> > +    case A_CXL_HDM_DECODER2_CTRL:
> > +    case A_CXL_HDM_DECODER3_CTRL:
> >          should_commit = FIELD_EX32(value, CXL_HDM_DECODER0_CTRL, COMMIT);
> >          should_uncommit = !should_commit;  
> 
> So for the commit/uncommit flag, we always check decoder 0 control
> register? Or i read it wrong? I thought the commit bit is per control register
> thing?

This is in the write handler and the value passed in that we are looking at is
for whichever of the _CTRL registers is being written.

I could have coded this as separate entries for each register as
FIELD_EX32(value, CXL_HDM_DECODER[X]_CTRL, COMMIT)
but as this only figures out the field offset and mask, it is the same for X=0,1,2,3

Jonathan




