From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id CC7CD4C9F;
	Fri, 23 Feb 2024 14:37:41 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=none smtp.client-ip=185.176.79.56
ARC-Seal: i=1; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1708699064; cv=none; b=bq3Y1Nx1dgIEguszRsfh4716v5BAqqTc6DVOMsSjlaR1/o+ttYzzcdbRTOe7UiQJgkuNTKsbi0/ypz7Y1ejXbTjmzorNQsFUpa2jk9MKuZIYHLGn+QY/31SXcWx/88YQjLOUQzOnOigpaWQP3RjNMUqucHHgM2mgIq6Wk7EqQa4=
ARC-Message-Signature: i=1; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1708699064; c=relaxed/simple;
	bh=lvbjD2z9NHzDWPv/TQz12bdxnv+pmG3sMvEDkHDpAKQ=;
	h=From:To:CC:Subject:Date:Message-ID:In-Reply-To:References:
	 MIME-Version:Content-Type; b=r/jjZRjO3rDSky6fbTPJlZo2Vq+kn0tiXgLuvB+6JTiF7MK+4GfpBWf6rH1NlPg2PfW2DbRuf2D2deKJacX3I4eZLaQxJNZ/r+p1qB7kGvuh80UEpddA8cnbwuTH4VBJh1irlHbld+0cR3f7aswcme5ngSWu4mooMwzcrYC28pc=
ARC-Authentication-Results: i=1; smtp.subspace.kernel.org; dmarc=pass (p=quarantine dis=none) header.from=huawei.com; spf=pass smtp.mailfrom=huawei.com; arc=none smtp.client-ip=185.176.79.56
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=quarantine dis=none) header.from=huawei.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=huawei.com
Received: from mail.maildlp.com (unknown [172.18.186.216])
	by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4ThCF44XpBz6K8d2;
	Fri, 23 Feb 2024 22:34:00 +0800 (CST)
Received: from lhrpeml500006.china.huawei.com (unknown [7.191.161.198])
	by mail.maildlp.com (Postfix) with ESMTPS id B5B62140D26;
	Fri, 23 Feb 2024 22:37:39 +0800 (CST)
Received: from SecurePC30232.china.huawei.com (10.122.247.234) by
 lhrpeml500006.china.huawei.com (7.191.161.198) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.35; Fri, 23 Feb 2024 14:37:38 +0000
From: <shiju.jose@huawei.com>
To: <linux-cxl@vger.kernel.org>, <linux-acpi@vger.kernel.org>,
	<linux-mm@kvack.org>, <dan.j.williams@intel.com>, <dave@stgolabs.net>,
	<jonathan.cameron@huawei.com>, <dave.jiang@intel.com>,
	<alison.schofield@intel.com>, <vishal.l.verma@intel.com>,
	<ira.weiny@intel.com>
CC: <linux-edac@vger.kernel.org>, <linux-kernel@vger.kernel.org>,
	<david@redhat.com>, <Vilas.Sridharan@amd.com>, <leo.duran@amd.com>,
	<Yazen.Ghannam@amd.com>, <rientjes@google.com>, <jiaqiyan@google.com>,
	<tony.luck@intel.com>, <Jon.Grimm@amd.com>, <dave.hansen@linux.intel.com>,
	<rafael@kernel.org>, <lenb@kernel.org>, <naoya.horiguchi@nec.com>,
	<james.morse@arm.com>, <jthoughton@google.com>, <somasundaram.a@hpe.com>,
	<erdemaktas@google.com>, <pgonda@google.com>, <duenwen@google.com>,
	<mike.malvestuto@intel.com>, <gthelen@google.com>,
	<wschwartz@amperecomputing.com>, <dferguson@amperecomputing.com>,
	<tanxiaofei@huawei.com>, <prime.zeng@hisilicon.com>,
	<kangkang.shen@futurewei.com>, <wanghuiqiang@huawei.com>,
	<linuxarm@huawei.com>, <shiju.jose@huawei.com>
Subject: [RFC PATCH v7 02/12] cxl/mbox: Add GET_FEATURE mailbox command
Date: Fri, 23 Feb 2024 22:37:13 +0800
Message-ID: <20240223143723.1574-3-shiju.jose@huawei.com>
X-Mailer: git-send-email 2.35.1.windows.2
In-Reply-To: <20240223143723.1574-1-shiju.jose@huawei.com>
References: <20240223143723.1574-1-shiju.jose@huawei.com>
Precedence: bulk
X-Mailing-List: linux-kernel@vger.kernel.org
List-Id: <linux-kernel.vger.kernel.org>
List-Subscribe: <mailto:linux-kernel+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:linux-kernel+unsubscribe@vger.kernel.org>
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
Content-Type: text/plain
X-ClientProxiedBy: lhrpeml500003.china.huawei.com (7.191.162.67) To
 lhrpeml500006.china.huawei.com (7.191.161.198)

From: Shiju Jose <shiju.jose@huawei.com>

Add support for GET_FEATURE mailbox command.

CXL spec 3.1 section 8.2.9.6 describes optional device specific features.
The settings of a feature can be retrieved using Get Feature command.

Signed-off-by: Shiju Jose <shiju.jose@huawei.com>
---
 drivers/cxl/core/mbox.c | 49 +++++++++++++++++++++++++++++++++++++++++
 drivers/cxl/cxlmem.h    | 25 +++++++++++++++++++++
 2 files changed, 74 insertions(+)

diff --git a/drivers/cxl/core/mbox.c b/drivers/cxl/core/mbox.c
index 79cc7fd433aa..c078e62ea194 100644
--- a/drivers/cxl/core/mbox.c
+++ b/drivers/cxl/core/mbox.c
@@ -1317,6 +1317,55 @@ int cxl_get_supported_features(struct cxl_memdev_state *mds,
 }
 EXPORT_SYMBOL_NS_GPL(cxl_get_supported_features, CXL);
 
+size_t cxl_get_feature(struct cxl_memdev_state *mds,
+		       const uuid_t feat_uuid, void *feat_out,
+		       size_t feat_out_size,
+		       size_t feat_out_min_size,
+		       enum cxl_get_feat_selection selection)
+{
+	struct cxl_dev_state *cxlds = &mds->cxlds;
+	struct cxl_mbox_get_feat_in pi;
+	struct cxl_mbox_cmd mbox_cmd;
+	size_t data_rcvd_size = 0;
+	size_t data_to_rd_size;
+	int rc;
+
+	if (feat_out_size < feat_out_min_size) {
+		dev_err(cxlds->dev,
+			"%s: feature out buffer size(%lu) is not big enough\n",
+			__func__, feat_out_size);
+		return 0;
+	}
+
+	pi.uuid = feat_uuid;
+	pi.selection = selection;
+	do {
+		if ((feat_out_min_size - data_rcvd_size) <= mds->payload_size)
+			data_to_rd_size = feat_out_min_size - data_rcvd_size;
+		else
+			data_to_rd_size = mds->payload_size;
+
+		pi.offset = cpu_to_le16(data_rcvd_size);
+		pi.count = cpu_to_le16(data_to_rd_size);
+
+		mbox_cmd = (struct cxl_mbox_cmd) {
+			.opcode = CXL_MBOX_OP_GET_FEATURE,
+			.size_in = sizeof(pi),
+			.payload_in = &pi,
+			.size_out = data_to_rd_size,
+			.payload_out = feat_out + data_rcvd_size,
+			.min_out = data_to_rd_size,
+		};
+		rc = cxl_internal_send_cmd(mds, &mbox_cmd);
+		if (rc < 0 || mbox_cmd.size_out == 0)
+			return 0;
+		data_rcvd_size += mbox_cmd.size_out;
+	} while (data_rcvd_size < feat_out_min_size);
+
+	return data_rcvd_size;
+}
+EXPORT_SYMBOL_NS_GPL(cxl_get_feature, CXL);
+
 int cxl_mem_get_poison(struct cxl_memdev *cxlmd, u64 offset, u64 len,
 		       struct cxl_region *cxlr)
 {
diff --git a/drivers/cxl/cxlmem.h b/drivers/cxl/cxlmem.h
index dd66523cd96a..bcfefff062a6 100644
--- a/drivers/cxl/cxlmem.h
+++ b/drivers/cxl/cxlmem.h
@@ -530,6 +530,7 @@ enum cxl_opcode {
 	CXL_MBOX_OP_GET_SUPPORTED_LOGS	= 0x0400,
 	CXL_MBOX_OP_GET_LOG		= 0x0401,
 	CXL_MBOX_OP_GET_SUPPORTED_FEATURES	= 0x0500,
+	CXL_MBOX_OP_GET_FEATURE		= 0x0501,
 	CXL_MBOX_OP_IDENTIFY		= 0x4000,
 	CXL_MBOX_OP_GET_PARTITION_INFO	= 0x4100,
 	CXL_MBOX_OP_SET_PARTITION_INFO	= 0x4101,
@@ -753,6 +754,25 @@ struct cxl_mbox_get_supp_feats_out {
 	struct cxl_mbox_supp_feat_entry feat_entries[];
 } __packed;
 
+/* Get Feature CXL 3.1 Spec 8.2.9.6.2 */
+/*
+ * Get Feature input payload
+ * CXL rev 3.1 section 8.2.9.6.2 Table 8-99
+ */
+enum cxl_get_feat_selection {
+	CXL_GET_FEAT_SEL_CURRENT_VALUE,
+	CXL_GET_FEAT_SEL_DEFAULT_VALUE,
+	CXL_GET_FEAT_SEL_SAVED_VALUE,
+	CXL_GET_FEAT_SEL_MAX
+};
+
+struct cxl_mbox_get_feat_in {
+	uuid_t uuid;
+	__le16 offset;
+	__le16 count;
+	u8 selection;
+}  __packed;
+
 /* Get Poison List  CXL 3.0 Spec 8.2.9.8.4.1 */
 struct cxl_mbox_poison_in {
 	__le64 offset;
@@ -887,6 +907,11 @@ int cxl_set_timestamp(struct cxl_memdev_state *mds);
 int cxl_get_supported_features(struct cxl_memdev_state *mds,
 			       u32 count, u16 start_index,
 			       struct cxl_mbox_get_supp_feats_out *feats_out);
+size_t cxl_get_feature(struct cxl_memdev_state *mds,
+		       const uuid_t feat_uuid, void *feat_out,
+		       size_t feat_out_size,
+		       size_t feat_out_min_size,
+		       enum cxl_get_feat_selection selection);
 int cxl_poison_state_init(struct cxl_memdev_state *mds);
 int cxl_mem_get_poison(struct cxl_memdev *cxlmd, u64 offset, u64 len,
 		       struct cxl_region *cxlr);
-- 
2.34.1


From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id 623434A3D;
	Fri, 23 Feb 2024 14:37:41 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=none smtp.client-ip=185.176.79.56
ARC-Seal: i=1; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1708699064; cv=none; b=ufDWq/EN4b1LcYhaPc9/9h9Bc+ZWfa+hG86AMQSzI7faU/f7aN6/5Ot8/q5/nxtwoHHFxChEZDiSuYnIdxMWPx+UIkg2sEnmqIjfsaEGDoBCoYbFMzS/htd5p3wzeeRS8gEYiOGdUHM7lF3ZG3MTb2SebrNNp7NvFMNNZwk0uWY=
ARC-Message-Signature: i=1; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1708699064; c=relaxed/simple;
	bh=wKUshStoYB0Xav71MEjOTZeeWMu1t3L3F5o+vhJerHY=;
	h=From:To:CC:Subject:Date:Message-ID:In-Reply-To:References:
	 MIME-Version:Content-Type; b=kukLwTvvbIZII734QLnOqfAn95wo8LT0VqZM6dmEtKYzhaPMLyXyTtGfcLyoqqC8ENRIE6V8h+nc6IBLHuCCrA+3BQFhBHo2PHtOT/u/ZcvruzLmhh2r9mZ2+yplyppaD6R2PZPawnDksjSUzE8vVVN3SBVRFUd7195O3dRJo9k=
ARC-Authentication-Results: i=1; smtp.subspace.kernel.org; dmarc=pass (p=quarantine dis=none) header.from=huawei.com; spf=pass smtp.mailfrom=huawei.com; arc=none smtp.client-ip=185.176.79.56
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=quarantine dis=none) header.from=huawei.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=huawei.com
Received: from mail.maildlp.com (unknown [172.18.186.31])
	by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4ThCF34jntz6K8yQ;
	Fri, 23 Feb 2024 22:33:59 +0800 (CST)
Received: from lhrpeml500006.china.huawei.com (unknown [7.191.161.198])
	by mail.maildlp.com (Postfix) with ESMTPS id B9533140DE3;
	Fri, 23 Feb 2024 22:37:38 +0800 (CST)
Received: from SecurePC30232.china.huawei.com (10.122.247.234) by
 lhrpeml500006.china.huawei.com (7.191.161.198) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.35; Fri, 23 Feb 2024 14:37:37 +0000
From: <shiju.jose@huawei.com>
To: <linux-cxl@vger.kernel.org>, <linux-acpi@vger.kernel.org>,
	<linux-mm@kvack.org>, <dan.j.williams@intel.com>, <dave@stgolabs.net>,
	<jonathan.cameron@huawei.com>, <dave.jiang@intel.com>,
	<alison.schofield@intel.com>, <vishal.l.verma@intel.com>,
	<ira.weiny@intel.com>
CC: <linux-edac@vger.kernel.org>, <linux-kernel@vger.kernel.org>,
	<david@redhat.com>, <Vilas.Sridharan@amd.com>, <leo.duran@amd.com>,
	<Yazen.Ghannam@amd.com>, <rientjes@google.com>, <jiaqiyan@google.com>,
	<tony.luck@intel.com>, <Jon.Grimm@amd.com>, <dave.hansen@linux.intel.com>,
	<rafael@kernel.org>, <lenb@kernel.org>, <naoya.horiguchi@nec.com>,
	<james.morse@arm.com>, <jthoughton@google.com>, <somasundaram.a@hpe.com>,
	<erdemaktas@google.com>, <pgonda@google.com>, <duenwen@google.com>,
	<mike.malvestuto@intel.com>, <gthelen@google.com>,
	<wschwartz@amperecomputing.com>, <dferguson@amperecomputing.com>,
	<tanxiaofei@huawei.com>, <prime.zeng@hisilicon.com>,
	<kangkang.shen@futurewei.com>, <wanghuiqiang@huawei.com>,
	<linuxarm@huawei.com>, <shiju.jose@huawei.com>
Subject: [RFC PATCH v7 01/12] cxl/mbox: Add GET_SUPPORTED_FEATURES mailbox command
Date: Fri, 23 Feb 2024 22:37:12 +0800
Message-ID: <20240223143723.1574-2-shiju.jose@huawei.com>
X-Mailer: git-send-email 2.35.1.windows.2
In-Reply-To: <20240223143723.1574-1-shiju.jose@huawei.com>
References: <20240223143723.1574-1-shiju.jose@huawei.com>
Precedence: bulk
X-Mailing-List: linux-kernel@vger.kernel.org
List-Id: <linux-kernel.vger.kernel.org>
List-Subscribe: <mailto:linux-kernel+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:linux-kernel+unsubscribe@vger.kernel.org>
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
Content-Type: text/plain
X-ClientProxiedBy: lhrpeml500003.china.huawei.com (7.191.162.67) To
 lhrpeml500006.china.huawei.com (7.191.161.198)

From: Shiju Jose <shiju.jose@huawei.com>

Add support for GET_SUPPORTED_FEATURES mailbox command.

CXL spec 3.1 section 8.2.9.6 describes optional device specific features.
CXL devices supports features with changeable attributes.
Get Supported Features retrieves the list of supported device specific
features. The settings of a feature can be retrieved using Get Feature
and optionally modified using Set Feature.

Signed-off-by: Shiju Jose <shiju.jose@huawei.com>
---
 drivers/cxl/core/mbox.c | 27 +++++++++++++++++++
 drivers/cxl/cxlmem.h    | 58 +++++++++++++++++++++++++++++++++++++++++
 2 files changed, 85 insertions(+)

diff --git a/drivers/cxl/core/mbox.c b/drivers/cxl/core/mbox.c
index 27166a411705..79cc7fd433aa 100644
--- a/drivers/cxl/core/mbox.c
+++ b/drivers/cxl/core/mbox.c
@@ -1290,6 +1290,33 @@ int cxl_set_timestamp(struct cxl_memdev_state *mds)
 }
 EXPORT_SYMBOL_NS_GPL(cxl_set_timestamp, CXL);
 
+int cxl_get_supported_features(struct cxl_memdev_state *mds,
+			       u32 count, u16 start_index,
+			       struct cxl_mbox_get_supp_feats_out *feats_out)
+{
+	struct cxl_mbox_get_supp_feats_in pi;
+	struct cxl_mbox_cmd mbox_cmd;
+	int rc;
+
+	pi.count = cpu_to_le32(count);
+	pi.start_index = cpu_to_le16(start_index);
+
+	mbox_cmd = (struct cxl_mbox_cmd) {
+		.opcode = CXL_MBOX_OP_GET_SUPPORTED_FEATURES,
+		.size_in = sizeof(pi),
+		.payload_in = &pi,
+		.size_out = count,
+		.payload_out = feats_out,
+		.min_out = sizeof(*feats_out),
+	};
+	rc = cxl_internal_send_cmd(mds, &mbox_cmd);
+	if (rc < 0)
+		return rc;
+
+	return 0;
+}
+EXPORT_SYMBOL_NS_GPL(cxl_get_supported_features, CXL);
+
 int cxl_mem_get_poison(struct cxl_memdev *cxlmd, u64 offset, u64 len,
 		       struct cxl_region *cxlr)
 {
diff --git a/drivers/cxl/cxlmem.h b/drivers/cxl/cxlmem.h
index 5303d6942b88..dd66523cd96a 100644
--- a/drivers/cxl/cxlmem.h
+++ b/drivers/cxl/cxlmem.h
@@ -529,6 +529,7 @@ enum cxl_opcode {
 	CXL_MBOX_OP_SET_TIMESTAMP	= 0x0301,
 	CXL_MBOX_OP_GET_SUPPORTED_LOGS	= 0x0400,
 	CXL_MBOX_OP_GET_LOG		= 0x0401,
+	CXL_MBOX_OP_GET_SUPPORTED_FEATURES	= 0x0500,
 	CXL_MBOX_OP_IDENTIFY		= 0x4000,
 	CXL_MBOX_OP_GET_PARTITION_INFO	= 0x4100,
 	CXL_MBOX_OP_SET_PARTITION_INFO	= 0x4101,
@@ -698,6 +699,60 @@ struct cxl_mbox_set_timestamp_in {
 
 } __packed;
 
+/* Get Supported Features CXL 3.1 Spec 8.2.9.6.1 */
+/*
+ * Get Supported Features input payload
+ * CXL rev 3.1 section 8.2.9.6.1 Table 8-95
+ */
+struct cxl_mbox_get_supp_feats_in {
+	__le32 count;
+	__le16 start_index;
+	u8 rsvd[2];
+} __packed;
+
+/*
+ * Get Supported Features Supported Feature Entry
+ * CXL rev 3.1 section 8.2.9.6.1 Table 8-97
+ */
+/* Supported Feature Entry : Payload out attribute flags */
+#define CXL_FEAT_ENTRY_FLAG_CHANGABLE	BIT(0)
+#define CXL_FEAT_ENTRY_FLAG_DEEPEST_RESET_PERSISTENCE_MASK	GENMASK(3, 1)
+#define CXL_FEAT_ENTRY_FLAG_PERSIST_ACROSS_FIRMWARE_UPDATE	BIT(4)
+#define CXL_FEAT_ENTRY_FLAG_SUPPORT_DEFAULT_SELECTION	BIT(5)
+#define CXL_FEAT_ENTRY_FLAG_SUPPORT_SAVED_SELECTION	BIT(6)
+
+enum cxl_feat_attr_value_persistence {
+	CXL_FEAT_ATTR_VALUE_PERSISTENCE_NONE,
+	CXL_FEAT_ATTR_VALUE_PERSISTENCE_CXL_RESET,
+	CXL_FEAT_ATTR_VALUE_PERSISTENCE_HOT_RESET,
+	CXL_FEAT_ATTR_VALUE_PERSISTENCE_WARM_RESET,
+	CXL_FEAT_ATTR_VALUE_PERSISTENCE_COLD_RESET,
+	CXL_FEAT_ATTR_VALUE_PERSISTENCE_MAX
+};
+
+struct cxl_mbox_supp_feat_entry {
+	uuid_t uuid;
+	__le16 index;
+	__le16 get_size;
+	__le16 set_size;
+	__le32 attr_flags;
+	u8 get_version;
+	u8 set_version;
+	__le16 set_effects;
+	u8 rsvd[18];
+}  __packed;
+
+/*
+ * Get Supported Features output payload
+ * CXL rev 3.1 section 8.2.9.6.1 Table 8-96
+ */
+struct cxl_mbox_get_supp_feats_out {
+	__le16 nr_entries;
+	__le16 nr_supported;
+	u8 rsvd[4];
+	struct cxl_mbox_supp_feat_entry feat_entries[];
+} __packed;
+
 /* Get Poison List  CXL 3.0 Spec 8.2.9.8.4.1 */
 struct cxl_mbox_poison_in {
 	__le64 offset;
@@ -829,6 +884,9 @@ void cxl_event_trace_record(const struct cxl_memdev *cxlmd,
 			    enum cxl_event_type event_type,
 			    const uuid_t *uuid, union cxl_event *evt);
 int cxl_set_timestamp(struct cxl_memdev_state *mds);
+int cxl_get_supported_features(struct cxl_memdev_state *mds,
+			       u32 count, u16 start_index,
+			       struct cxl_mbox_get_supp_feats_out *feats_out);
 int cxl_poison_state_init(struct cxl_memdev_state *mds);
 int cxl_mem_get_poison(struct cxl_memdev *cxlmd, u64 offset, u64 len,
 		       struct cxl_region *cxlr);
-- 
2.34.1


From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id 07255469D;
	Fri, 23 Feb 2024 14:37:38 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=none smtp.client-ip=185.176.79.56
ARC-Seal: i=1; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1708699063; cv=none; b=Fz2HPxzh+gq050UtTGk1yrpQBJ27F7jRvRuVGp9/xjSNbjPnGQ+GtQ87ni1TyPV5aIbpL1ELozEtfCzZephicul8l12hQAfW4d1u/WkssxdO7ykhZIOckipr9cc3/n1tyKRRsVZSFJqJS7JzoGusjud2kEiMvm3mp8mSJbQf5aE=
ARC-Message-Signature: i=1; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1708699063; c=relaxed/simple;
	bh=B8tmKlM2SuEwWy8ZSsDEye6G44FSjeSZYQxZwkll2q4=;
	h=From:To:CC:Subject:Date:Message-ID:MIME-Version:Content-Type; b=ZbTway0UUe5pgD8zDtkeQdkTuw2lO4chxaLpXiVw1AqUsOT6pmLsaoT47jLfaEi5PkImoe3lXAeLbnjEhB1YvkeK+XfUuUPjYpXhGuEUCLGI6IMSxE1izISmIJnMXWFbGnE5LuYlHzpEwTZ2KnuAo5nXX2LntlXXD9Xw2VY6Hcs=
ARC-Authentication-Results: i=1; smtp.subspace.kernel.org; dmarc=pass (p=quarantine dis=none) header.from=huawei.com; spf=pass smtp.mailfrom=huawei.com; arc=none smtp.client-ip=185.176.79.56
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=quarantine dis=none) header.from=huawei.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=huawei.com
Received: from mail.maildlp.com (unknown [172.18.186.231])
	by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4ThCD5296xz6J9yc;
	Fri, 23 Feb 2024 22:33:09 +0800 (CST)
Received: from lhrpeml500006.china.huawei.com (unknown [7.191.161.198])
	by mail.maildlp.com (Postfix) with ESMTPS id E8E88140B33;
	Fri, 23 Feb 2024 22:37:34 +0800 (CST)
Received: from SecurePC30232.china.huawei.com (10.122.247.234) by
 lhrpeml500006.china.huawei.com (7.191.161.198) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.35; Fri, 23 Feb 2024 14:37:33 +0000
From: <shiju.jose@huawei.com>
To: <linux-cxl@vger.kernel.org>, <linux-acpi@vger.kernel.org>,
	<linux-mm@kvack.org>, <dan.j.williams@intel.com>, <dave@stgolabs.net>,
	<jonathan.cameron@huawei.com>, <dave.jiang@intel.com>,
	<alison.schofield@intel.com>, <vishal.l.verma@intel.com>,
	<ira.weiny@intel.com>
CC: <linux-edac@vger.kernel.org>, <linux-kernel@vger.kernel.org>,
	<david@redhat.com>, <Vilas.Sridharan@amd.com>, <leo.duran@amd.com>,
	<Yazen.Ghannam@amd.com>, <rientjes@google.com>, <jiaqiyan@google.com>,
	<tony.luck@intel.com>, <Jon.Grimm@amd.com>, <dave.hansen@linux.intel.com>,
	<rafael@kernel.org>, <lenb@kernel.org>, <naoya.horiguchi@nec.com>,
	<james.morse@arm.com>, <jthoughton@google.com>, <somasundaram.a@hpe.com>,
	<erdemaktas@google.com>, <pgonda@google.com>, <duenwen@google.com>,
	<mike.malvestuto@intel.com>, <gthelen@google.com>,
	<wschwartz@amperecomputing.com>, <dferguson@amperecomputing.com>,
	<tanxiaofei@huawei.com>, <prime.zeng@hisilicon.com>,
	<kangkang.shen@futurewei.com>, <wanghuiqiang@huawei.com>,
	<linuxarm@huawei.com>, <shiju.jose@huawei.com>
Subject: [RFC PATCH v7 00/12] memory: scrub: introduce subsystem + CXL/ACPI-RAS2 drivers
Date: Fri, 23 Feb 2024 22:37:11 +0800
Message-ID: <20240223143723.1574-1-shiju.jose@huawei.com>
X-Mailer: git-send-email 2.35.1.windows.2
Precedence: bulk
X-Mailing-List: linux-kernel@vger.kernel.org
List-Id: <linux-kernel.vger.kernel.org>
List-Subscribe: <mailto:linux-kernel+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:linux-kernel+unsubscribe@vger.kernel.org>
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
Content-Type: text/plain
X-ClientProxiedBy: lhrpeml500003.china.huawei.com (7.191.162.67) To
 lhrpeml500006.china.huawei.com (7.191.161.198)

From: Shiju Jose <shiju.jose@huawei.com>

'Previously known as: cxl: Add support for CXL feature commands,
 CXL device patrol scrub control and DDR5 ECS control features'
https://lore.kernel.org/lkml/20240215111455.1462-1-shiju.jose@huawei.com/

Introduce generic memory scrub subsystem which allows user to
control underlying memory scrubbers in the system via the sysfs
scrub control interface.

Memory scrub is a feature where an ECC engine reads data from
each memory media location, corrects with an ECC if necessary and
writes the corrected data back to the same memory media location.
More details can be found in Reference [1].

CXL patrol scrub and DDR5 ECS and ACPI RAS2 HW based memory
patrol scrub features are added as use cases for the scrub
subsystem to expose the scrub controls to the user.

CXL device patrol scrub and DDR5 ECS features needs support for
the CXL feature mail box commands. CXL device scrub driver
registers with the memory scrub subsystem to expose the scrub
controls for CXL device patrol and ECS scrubs to the user.

RAS2 HW based memory patrol scrub needs RAS2 PCC interfaces
and ACPI RAS2 driver for communication b/w kernel and firmware.
ACPI RAS2 Driver adds platform device, for each memory feature,
which binds to the RAS2 memory driver.
Memory RAS2 driver registers with the memory scrub subsystem to
expose the RAS2 scrub controls to the user.

Series adds,
1. scrub subsystem driver supports configuring memory scrubs
   in the system.
2. support for CXL feature mailbox commands.
3. CXL device scrub driver supporting patrol scrub control and
   ECS control features.
4. register CXL device patrol scrub and ECS with scrub subsystem.
5. common library for RAS2 PCC interfaces.
6. ACPI RAS2 driver for ACPI RAS2 feature table (RAS2).
7. memory RAS2 driver and registers with scrub subsystem.

The QEMU series to support the CXL specific scrub features is
available here,
https://lore.kernel.org/qemu-devel/20240223085902.1549-1-shiju.jose@huawei.com/

References:
1. Discussions on kernel support of memory error detection and
   patrol scrubber can be found here.
   https://lore.kernel.org/all/20221103155029.2451105-1-jiaqiyan@google.com/

2. Discussions on RASF:
   https://lore.kernel.org/lkml/20230915172818.761-1-shiju.jose@huawei.com/#r 
   https://patchwork.kernel.org/project/linux-arm-kernel/patch/CS1PR84MB0038718F49DBC0FF03919E1184390@CS1PR84MB0038.NAMPRD84.PROD.OUTLOOK.COM/

Changes
v6 -> v7:
1. Main changes for comments from Jonathan.
1.1. CXL
 - Changes for deal with small mail box and supporting multipart
   feature data transfers.
 - Provide more specific parameters to mbox supported/get/set features
   interface functions.
 - kvmalloc -> kmalloc in CXL scrub mem allocation for feature commands.
 - Changed the way using __free(kfree)
 - Removed readback and verify for setting CXL scrub patrol and ECS
   parameters. Could be added later if needed.
 - In is_visible() callback functions for scrub control sysfs attrs
   changed to writeback the default attribute mode value instead of
   setting per attrs.
 - Add documentation for sysfs interfaces for CXL ECS scrub control. 
1.2. RAS2
 - In rasf common code, rename rasf to ras2 because RASF seems obselete.
 - Replace pr_* with dev_* log function calls from ACPI RAS2 and
   memory RAS2 drivers.
 - In rasf common code, rename rasf to ras2.
 - Removed including unnecessary .h file from memory RAS2 driver.
 - In is_visible() callback functions for scrub control sysfs attrs
   changed to writeback the default attribute mode value instead of
   setting per attribute.

2. Changes for comments from Fan.
 - Add debug message if cxl patrol scrub and ecs init function
   calls fail.
3. Updated cover letter for feedback from Dan Williams. 
   
v5 -> v6:
1. Changes for comments from Davidlohr, Thanks.
 - Update CXL feature code based on spec 3.1.
 - attrb -> attr
 - Use enums with default counting.  
2. Rebased to the latest kernel.

v4 -> v5:
1. Following are the main changes made based on the feedback from Dan Williams on v4.
1.1. In the scrub subsystem the common scrub control attributes are statically defined
     instead of dynamically created.
1.2. Add scrub subsystem support externally defined attribute group.
     Add CXL ECS driver define ECS specific attribute group and pass to
	 the scrub subsystem.
1.3. Move cxl_mem_ecs_init() to cxl/core/region.c so that the CXL region_id
     is used in the registration with the scrub subsystem. 	 
1.4. Add previously posted RASF common and RAS2 patches to this scrub series.
	 
2. Add support for the 'enable_background_scrub' attribute
   for RAS2, on request from Bill Schwartz(wschwartz@amperecomputing.com).

v3 -> v4:
1. Fixes for the warnings/errors reported by kernel test robot.
2. Add support for reading the 'enable' attribute of CXL patrol scrub.

Changes
v2 -> v3:
1. Changes for comments from Davidlohr, Thanks.
 - Updated cxl scrub kconfig
 - removed usage of the flag is_support_feature from
   the function cxl_mem_get_supported_feature_entry().
 - corrected spelling error.
 - removed unnecessary debug message.
 - removed export feature commands to the userspace.
2. Possible fix for the warnings/errors reported by kernel
   test robot.
3. Add documentation for the common scrub configure atrributes.

v1 -> v2:
1. Changes for comments from Dave Jiang, Thanks.
 - Split patches.
 - reversed xmas tree declarations.
 - declared flags as enums.
 - removed few unnecessary variable initializations.
 - replaced PTR_ERR_OR_ZERO() with IS_ERR() and PTR_ERR().
 - add auto clean declarations.
 - replaced while loop with for loop.
 - Removed allocation from cxl_get_supported_features() and
   cxl_get_feature() and make change to take allocated memory
   pointer from the caller.
 - replaced if/else with switch case.
 - replaced sprintf() with sysfs_emit() in 2 places.
 - replaced goto label with return in few functions.
2. removed unused code for supported attributes from ecs.
3. Included following common patch for scrub configure driver
   to this series.
   "memory: scrub: Add scrub driver supports configuring memory scrubbers
    in the system"

A Somasundaram (1):
  ACPI:RAS2: Add common library for RAS2 PCC interfaces

Shiju Jose (11):
  cxl/mbox: Add GET_SUPPORTED_FEATURES mailbox command
  cxl/mbox: Add GET_FEATURE mailbox command
  cxl/mbox: Add SET_FEATURE mailbox command
  cxl/memscrub: Add CXL device patrol scrub control feature
  cxl/memscrub: Add CXL device ECS control feature
  memory: scrub: Add scrub subsystem driver supports configuring memory
    scrubs in the system
  cxl/memscrub: Register CXL device patrol scrub with scrub subsystem
    driver
  cxl/memscrub: Register CXL device ECS with scrub subsystem driver
  ACPICA: ACPI 6.5: Add support for RAS2 table
  ACPI:RAS2: Add driver for ACPI RAS2 feature table (RAS2)
  memory: RAS2: Add memory RAS2 driver

 .../ABI/testing/sysfs-class-cxl-ecs-configure |  79 ++
 .../ABI/testing/sysfs-class-scrub-configure   |  91 ++
 drivers/acpi/Kconfig                          |  14 +
 drivers/acpi/Makefile                         |   1 +
 drivers/acpi/ras2_acpi.c                      |  97 ++
 drivers/acpi/ras2_acpi_common.c               | 272 +++++
 drivers/cxl/Kconfig                           |  21 +
 drivers/cxl/core/Makefile                     |   1 +
 drivers/cxl/core/mbox.c                       | 143 +++
 drivers/cxl/core/memscrub.c                   | 954 ++++++++++++++++++
 drivers/cxl/core/region.c                     |   3 +
 drivers/cxl/cxlmem.h                          | 124 +++
 drivers/cxl/pci.c                             |   4 +
 drivers/memory/Kconfig                        |  15 +
 drivers/memory/Makefile                       |   3 +
 drivers/memory/ras2.c                         | 364 +++++++
 drivers/memory/ras2_common.c                  | 282 ++++++
 drivers/memory/scrub/Kconfig                  |  11 +
 drivers/memory/scrub/Makefile                 |   6 +
 drivers/memory/scrub/memory-scrub.c           | 369 +++++++
 include/acpi/actbl2.h                         | 137 +++
 include/acpi/ras2_acpi.h                      |  59 ++
 include/memory/memory-scrub.h                 |  79 ++
 include/memory/ras2.h                         |  88 ++
 24 files changed, 3217 insertions(+)
 create mode 100644 Documentation/ABI/testing/sysfs-class-cxl-ecs-configure
 create mode 100644 Documentation/ABI/testing/sysfs-class-scrub-configure
 create mode 100755 drivers/acpi/ras2_acpi.c
 create mode 100755 drivers/acpi/ras2_acpi_common.c
 create mode 100644 drivers/cxl/core/memscrub.c
 create mode 100644 drivers/memory/ras2.c
 create mode 100644 drivers/memory/ras2_common.c
 create mode 100644 drivers/memory/scrub/Kconfig
 create mode 100644 drivers/memory/scrub/Makefile
 create mode 100755 drivers/memory/scrub/memory-scrub.c
 create mode 100644 include/acpi/ras2_acpi.h
 create mode 100755 include/memory/memory-scrub.h
 create mode 100755 include/memory/ras2.h

-- 
2.34.1


From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id DAA3D524F;
	Fri, 23 Feb 2024 14:37:42 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=none smtp.client-ip=185.176.79.56
ARC-Seal: i=1; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1708699065; cv=none; b=gXYJUWhlQ3ofD7K1uih8Fy7gt22F/S0GqOH/zPlsjGFIDSeaIJdgVoLs4beYsCQPzkxXHDUTVRdYdBRXMGNROW87/K6nZXT7c+17or3jnuzv0L0tNsR0K9zn0QTB91dFQbC0juf0Ye3ccQRT46aZ1yvzm0SGmkNHn+n/EdWy8Co=
ARC-Message-Signature: i=1; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1708699065; c=relaxed/simple;
	bh=8fFHbASJ7cdTEXIAbqPeXlnxFauqATtEpaY2ZD+dZpE=;
	h=From:To:CC:Subject:Date:Message-ID:In-Reply-To:References:
	 MIME-Version:Content-Type; b=AjMQEDIZP3mTf92MD2TsgzBfC+lF03eyaz3WowJRR1waquDedGwMvHJLn9u/fk6QNt7KOqoKbDOFV38BNt1pPlsrDwgSX1U435R2BfCSrCIKIoCLvDGPvaB5iG5Q4kNxc4uxWDX1LQMZ7cLNM4SvmnRmq2/mLsI3apvCCip5S6c=
ARC-Authentication-Results: i=1; smtp.subspace.kernel.org; dmarc=pass (p=quarantine dis=none) header.from=huawei.com; spf=pass smtp.mailfrom=huawei.com; arc=none smtp.client-ip=185.176.79.56
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=quarantine dis=none) header.from=huawei.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=huawei.com
Received: from mail.maildlp.com (unknown [172.18.186.216])
	by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4ThCF54nwwz6K6hC;
	Fri, 23 Feb 2024 22:34:01 +0800 (CST)
Received: from lhrpeml500006.china.huawei.com (unknown [7.191.161.198])
	by mail.maildlp.com (Postfix) with ESMTPS id BE6E1140119;
	Fri, 23 Feb 2024 22:37:40 +0800 (CST)
Received: from SecurePC30232.china.huawei.com (10.122.247.234) by
 lhrpeml500006.china.huawei.com (7.191.161.198) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.35; Fri, 23 Feb 2024 14:37:39 +0000
From: <shiju.jose@huawei.com>
To: <linux-cxl@vger.kernel.org>, <linux-acpi@vger.kernel.org>,
	<linux-mm@kvack.org>, <dan.j.williams@intel.com>, <dave@stgolabs.net>,
	<jonathan.cameron@huawei.com>, <dave.jiang@intel.com>,
	<alison.schofield@intel.com>, <vishal.l.verma@intel.com>,
	<ira.weiny@intel.com>
CC: <linux-edac@vger.kernel.org>, <linux-kernel@vger.kernel.org>,
	<david@redhat.com>, <Vilas.Sridharan@amd.com>, <leo.duran@amd.com>,
	<Yazen.Ghannam@amd.com>, <rientjes@google.com>, <jiaqiyan@google.com>,
	<tony.luck@intel.com>, <Jon.Grimm@amd.com>, <dave.hansen@linux.intel.com>,
	<rafael@kernel.org>, <lenb@kernel.org>, <naoya.horiguchi@nec.com>,
	<james.morse@arm.com>, <jthoughton@google.com>, <somasundaram.a@hpe.com>,
	<erdemaktas@google.com>, <pgonda@google.com>, <duenwen@google.com>,
	<mike.malvestuto@intel.com>, <gthelen@google.com>,
	<wschwartz@amperecomputing.com>, <dferguson@amperecomputing.com>,
	<tanxiaofei@huawei.com>, <prime.zeng@hisilicon.com>,
	<kangkang.shen@futurewei.com>, <wanghuiqiang@huawei.com>,
	<linuxarm@huawei.com>, <shiju.jose@huawei.com>
Subject: [RFC PATCH v7 03/12] cxl/mbox: Add SET_FEATURE mailbox command
Date: Fri, 23 Feb 2024 22:37:14 +0800
Message-ID: <20240223143723.1574-4-shiju.jose@huawei.com>
X-Mailer: git-send-email 2.35.1.windows.2
In-Reply-To: <20240223143723.1574-1-shiju.jose@huawei.com>
References: <20240223143723.1574-1-shiju.jose@huawei.com>
Precedence: bulk
X-Mailing-List: linux-kernel@vger.kernel.org
List-Id: <linux-kernel.vger.kernel.org>
List-Subscribe: <mailto:linux-kernel+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:linux-kernel+unsubscribe@vger.kernel.org>
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
Content-Type: text/plain
X-ClientProxiedBy: lhrpeml500003.china.huawei.com (7.191.162.67) To
 lhrpeml500006.china.huawei.com (7.191.161.198)

From: Shiju Jose <shiju.jose@huawei.com>

Add support for SET_FEATURE mailbox command.

CXL spec 3.1 section 8.2.9.6 describes optional device specific features.
CXL devices supports features with changeable attributes.
The settings of a feature can be optionally modified using Set Feature
command.

Signed-off-by: Shiju Jose <shiju.jose@huawei.com>
---
 drivers/cxl/core/mbox.c | 67 +++++++++++++++++++++++++++++++++++++++++
 drivers/cxl/cxlmem.h    | 30 ++++++++++++++++++
 2 files changed, 97 insertions(+)

diff --git a/drivers/cxl/core/mbox.c b/drivers/cxl/core/mbox.c
index c078e62ea194..d1660bd20bdb 100644
--- a/drivers/cxl/core/mbox.c
+++ b/drivers/cxl/core/mbox.c
@@ -1366,6 +1366,73 @@ size_t cxl_get_feature(struct cxl_memdev_state *mds,
 }
 EXPORT_SYMBOL_NS_GPL(cxl_get_feature, CXL);
 
+int cxl_set_feature(struct cxl_memdev_state *mds,
+		    const uuid_t feat_uuid, u8 feat_version,
+		    void *feat_data, size_t feat_data_size,
+		    u8 feat_flag)
+{
+	struct cxl_memdev_set_feat_pi {
+		struct cxl_mbox_set_feat_hdr hdr;
+		u8 feat_data[];
+	}  __packed;
+	size_t data_in_size, data_sent_size = 0;
+	struct cxl_mbox_cmd mbox_cmd;
+	size_t hdr_size;
+	int rc = 0;
+
+	struct cxl_memdev_set_feat_pi *pi __free(kfree) =
+					kmalloc(mds->payload_size, GFP_KERNEL);
+	pi->hdr.uuid = feat_uuid;
+	pi->hdr.version = feat_version;
+	feat_flag &= ~CXL_SET_FEAT_FLAG_DATA_TRANSFER_MASK;
+	hdr_size = sizeof(pi->hdr);
+	/*
+	 * Check minimum mbox payload size is available for
+	 * the feature data transfer.
+	 */
+	if (hdr_size + 10 > mds->payload_size)
+		return -ENOMEM;
+
+	if ((hdr_size + feat_data_size) <= mds->payload_size) {
+		pi->hdr.flags = cpu_to_le32(feat_flag |
+				       CXL_SET_FEAT_FLAG_FULL_DATA_TRANSFER);
+		data_in_size = feat_data_size;
+	} else {
+		pi->hdr.flags = cpu_to_le32(feat_flag |
+				       CXL_SET_FEAT_FLAG_INITIATE_DATA_TRANSFER);
+		data_in_size = mds->payload_size - hdr_size;
+	}
+
+	do {
+		pi->hdr.offset = cpu_to_le16(data_sent_size);
+		memcpy(pi->feat_data, feat_data + data_sent_size, data_in_size);
+		mbox_cmd = (struct cxl_mbox_cmd) {
+			.opcode = CXL_MBOX_OP_SET_FEATURE,
+			.size_in = hdr_size + data_in_size,
+			.payload_in = pi,
+		};
+		rc = cxl_internal_send_cmd(mds, &mbox_cmd);
+		if (rc < 0)
+			return rc;
+
+		data_sent_size += data_in_size;
+		if (data_sent_size >= feat_data_size)
+			return 0;
+
+		if ((feat_data_size - data_sent_size) <= (mds->payload_size - hdr_size)) {
+			data_in_size = feat_data_size - data_sent_size;
+			pi->hdr.flags = cpu_to_le32(feat_flag |
+					       CXL_SET_FEAT_FLAG_FINISH_DATA_TRANSFER);
+		} else {
+			pi->hdr.flags = cpu_to_le32(feat_flag |
+					       CXL_SET_FEAT_FLAG_CONTINUE_DATA_TRANSFER);
+		}
+	} while (true);
+
+	return rc;
+}
+EXPORT_SYMBOL_NS_GPL(cxl_set_feature, CXL);
+
 int cxl_mem_get_poison(struct cxl_memdev *cxlmd, u64 offset, u64 len,
 		       struct cxl_region *cxlr)
 {
diff --git a/drivers/cxl/cxlmem.h b/drivers/cxl/cxlmem.h
index bcfefff062a6..a8d4104afa53 100644
--- a/drivers/cxl/cxlmem.h
+++ b/drivers/cxl/cxlmem.h
@@ -531,6 +531,7 @@ enum cxl_opcode {
 	CXL_MBOX_OP_GET_LOG		= 0x0401,
 	CXL_MBOX_OP_GET_SUPPORTED_FEATURES	= 0x0500,
 	CXL_MBOX_OP_GET_FEATURE		= 0x0501,
+	CXL_MBOX_OP_SET_FEATURE		= 0x0502,
 	CXL_MBOX_OP_IDENTIFY		= 0x4000,
 	CXL_MBOX_OP_GET_PARTITION_INFO	= 0x4100,
 	CXL_MBOX_OP_SET_PARTITION_INFO	= 0x4101,
@@ -773,6 +774,31 @@ struct cxl_mbox_get_feat_in {
 	u8 selection;
 }  __packed;
 
+/* Set Feature CXL 3.1 Spec 8.2.9.6.3 */
+/*
+ * Set Feature input payload
+ * CXL rev 3.1 section 8.2.9.6.3 Table 8-101
+ */
+/* Set Feature : Payload in flags */
+#define CXL_SET_FEAT_FLAG_DATA_TRANSFER_MASK	GENMASK(2, 0)
+enum cxl_set_feat_flag_data_transfer {
+	CXL_SET_FEAT_FLAG_FULL_DATA_TRANSFER,
+	CXL_SET_FEAT_FLAG_INITIATE_DATA_TRANSFER,
+	CXL_SET_FEAT_FLAG_CONTINUE_DATA_TRANSFER,
+	CXL_SET_FEAT_FLAG_FINISH_DATA_TRANSFER,
+	CXL_SET_FEAT_FLAG_ABORT_DATA_TRANSFER,
+	CXL_SET_FEAT_FLAG_DATA_TRANSFER_MAX
+};
+#define CXL_SET_FEAT_FLAG_DATA_SAVED_ACROSS_RESET	BIT(3)
+
+struct cxl_mbox_set_feat_hdr {
+	uuid_t uuid;
+	__le32 flags;
+	__le16 offset;
+	u8 version;
+	u8 rsvd[9];
+}  __packed;
+
 /* Get Poison List  CXL 3.0 Spec 8.2.9.8.4.1 */
 struct cxl_mbox_poison_in {
 	__le64 offset;
@@ -912,6 +938,10 @@ size_t cxl_get_feature(struct cxl_memdev_state *mds,
 		       size_t feat_out_size,
 		       size_t feat_out_min_size,
 		       enum cxl_get_feat_selection selection);
+int cxl_set_feature(struct cxl_memdev_state *mds,
+		    const uuid_t feat_uuid, u8 feat_version,
+		    void *feat_data, size_t feat_data_size,
+		    u8 feat_flag);
 int cxl_poison_state_init(struct cxl_memdev_state *mds);
 int cxl_mem_get_poison(struct cxl_memdev *cxlmd, u64 offset, u64 len,
 		       struct cxl_region *cxlr);
-- 
2.34.1


From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id E1EAB6FAD;
	Fri, 23 Feb 2024 14:37:43 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=none smtp.client-ip=185.176.79.56
ARC-Seal: i=1; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1708699065; cv=none; b=nw83OWSgZBtg9SG7oSMFwARztDrcJmsCCLrvJiz6AP7aXi/mF5s+o9kV7UPzfQYgR3TX7jJY38jhiqT47sBe5FWagXhHFu6NF+0oYIIc/QlFX0hUWDCNTtyp+mqsCMQ9B4MQ7dZ8PpN2QXmHCxOHgk8Kwqom/VBrO2s8MCrUcHg=
ARC-Message-Signature: i=1; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1708699065; c=relaxed/simple;
	bh=JYvf2mzdsavpXHHzWLpT3tNpeCaGw7lin4/Xgp0ChKU=;
	h=From:To:CC:Subject:Date:Message-ID:In-Reply-To:References:
	 MIME-Version:Content-Type; b=mLtLI0nMIaRUyUfo20iWy66/0dXYIeOexgsg2BDG3KTRBHqBxaGf6cWD55Sw7rwTN+xff+PtvDZkeyzlSH3y8p0hg0PE1sPy5nYOVLNh7AoJ+7nWonBSOA3kGnuor4KE2o4JItfMY983/86uOrJcxlIN8GjcLoVOQd8tQIgBHq0=
ARC-Authentication-Results: i=1; smtp.subspace.kernel.org; dmarc=pass (p=quarantine dis=none) header.from=huawei.com; spf=pass smtp.mailfrom=huawei.com; arc=none smtp.client-ip=185.176.79.56
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=quarantine dis=none) header.from=huawei.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=huawei.com
Received: from mail.maildlp.com (unknown [172.18.186.231])
	by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4ThCF64b6jz6K8yZ;
	Fri, 23 Feb 2024 22:34:02 +0800 (CST)
Received: from lhrpeml500006.china.huawei.com (unknown [7.191.161.198])
	by mail.maildlp.com (Postfix) with ESMTPS id B2F83140B54;
	Fri, 23 Feb 2024 22:37:41 +0800 (CST)
Received: from SecurePC30232.china.huawei.com (10.122.247.234) by
 lhrpeml500006.china.huawei.com (7.191.161.198) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.35; Fri, 23 Feb 2024 14:37:40 +0000
From: <shiju.jose@huawei.com>
To: <linux-cxl@vger.kernel.org>, <linux-acpi@vger.kernel.org>,
	<linux-mm@kvack.org>, <dan.j.williams@intel.com>, <dave@stgolabs.net>,
	<jonathan.cameron@huawei.com>, <dave.jiang@intel.com>,
	<alison.schofield@intel.com>, <vishal.l.verma@intel.com>,
	<ira.weiny@intel.com>
CC: <linux-edac@vger.kernel.org>, <linux-kernel@vger.kernel.org>,
	<david@redhat.com>, <Vilas.Sridharan@amd.com>, <leo.duran@amd.com>,
	<Yazen.Ghannam@amd.com>, <rientjes@google.com>, <jiaqiyan@google.com>,
	<tony.luck@intel.com>, <Jon.Grimm@amd.com>, <dave.hansen@linux.intel.com>,
	<rafael@kernel.org>, <lenb@kernel.org>, <naoya.horiguchi@nec.com>,
	<james.morse@arm.com>, <jthoughton@google.com>, <somasundaram.a@hpe.com>,
	<erdemaktas@google.com>, <pgonda@google.com>, <duenwen@google.com>,
	<mike.malvestuto@intel.com>, <gthelen@google.com>,
	<wschwartz@amperecomputing.com>, <dferguson@amperecomputing.com>,
	<tanxiaofei@huawei.com>, <prime.zeng@hisilicon.com>,
	<kangkang.shen@futurewei.com>, <wanghuiqiang@huawei.com>,
	<linuxarm@huawei.com>, <shiju.jose@huawei.com>
Subject: [RFC PATCH v7 04/12] cxl/memscrub: Add CXL device patrol scrub control feature
Date: Fri, 23 Feb 2024 22:37:15 +0800
Message-ID: <20240223143723.1574-5-shiju.jose@huawei.com>
X-Mailer: git-send-email 2.35.1.windows.2
In-Reply-To: <20240223143723.1574-1-shiju.jose@huawei.com>
References: <20240223143723.1574-1-shiju.jose@huawei.com>
Precedence: bulk
X-Mailing-List: linux-kernel@vger.kernel.org
List-Id: <linux-kernel.vger.kernel.org>
List-Subscribe: <mailto:linux-kernel+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:linux-kernel+unsubscribe@vger.kernel.org>
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
Content-Type: text/plain
X-ClientProxiedBy: lhrpeml500003.china.huawei.com (7.191.162.67) To
 lhrpeml500006.china.huawei.com (7.191.161.198)

From: Shiju Jose <shiju.jose@huawei.com>

CXL spec 3.1 section 8.2.9.9.11.1 describes the device patrol scrub control
feature. The device patrol scrub proactively locates and makes corrections
to errors in regular cycle. The patrol scrub control allows the request to
configure patrol scrub input configurations.

The patrol scrub control allows the requester to specify the number of
hours for which the patrol scrub cycles must be completed, provided that
the requested number is not less than the minimum number of hours for the
patrol scrub cycle that the device is capable of. In addition, the patrol
scrub controls allow the host to disable and enable the feature in case
disabling of the feature is needed for other purposes such as
performance-aware operations which require the background operations to be
turned off.

Signed-off-by: Shiju Jose <shiju.jose@huawei.com>
---
 drivers/cxl/Kconfig         |  15 +++
 drivers/cxl/core/Makefile   |   1 +
 drivers/cxl/core/memscrub.c | 248 ++++++++++++++++++++++++++++++++++++
 drivers/cxl/cxlmem.h        |   8 ++
 drivers/cxl/pci.c           |   4 +
 5 files changed, 276 insertions(+)
 create mode 100644 drivers/cxl/core/memscrub.c

diff --git a/drivers/cxl/Kconfig b/drivers/cxl/Kconfig
index 67998dbd1d46..e61c69fa7bf5 100644
--- a/drivers/cxl/Kconfig
+++ b/drivers/cxl/Kconfig
@@ -157,4 +157,19 @@ config CXL_PMU
 	  monitoring units and provide standard perf based interfaces.
 
 	  If unsure say 'm'.
+
+config CXL_SCRUB
+	bool "CXL: Memory scrub feature"
+	depends on CXL_PCI
+	depends on CXL_MEM
+	help
+	  The CXL memory scrub control is an optional feature allows host to
+	  control the scrub configurations of CXL Type 3 devices, which
+	  support patrol scrub and/or DDR5 ECS(Error Check Scrub).
+
+	  Say 'y/n' to enable/disable the CXL memory scrub driver that will
+	  attach to CXL.mem devices for memory scrub control feature. See
+	  sections 8.2.9.9.11.1 and 8.2.9.9.11.2 in the CXL 3.1 specification
+	  for a detailed description of CXL memory scrub control features.
+
 endif
diff --git a/drivers/cxl/core/Makefile b/drivers/cxl/core/Makefile
index 9259bcc6773c..e0fc814c3983 100644
--- a/drivers/cxl/core/Makefile
+++ b/drivers/cxl/core/Makefile
@@ -16,3 +16,4 @@ cxl_core-y += pmu.o
 cxl_core-y += cdat.o
 cxl_core-$(CONFIG_TRACING) += trace.o
 cxl_core-$(CONFIG_CXL_REGION) += region.o
+cxl_core-$(CONFIG_CXL_SCRUB) += memscrub.o
diff --git a/drivers/cxl/core/memscrub.c b/drivers/cxl/core/memscrub.c
new file mode 100644
index 000000000000..2079498719fe
--- /dev/null
+++ b/drivers/cxl/core/memscrub.c
@@ -0,0 +1,248 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * CXL memory scrub driver.
+ *
+ * Copyright (c) 2024 HiSilicon Limited.
+ *
+ *  - Provides functions to configure patrol scrub feature of the
+ *    CXL memory devices.
+ */
+
+#define pr_fmt(fmt)	"CXL_MEM_SCRUB: " fmt
+
+#include <cxlmem.h>
+
+/* CXL memory scrub feature common definitions */
+#define CXL_SCRUB_MAX_ATTR_RANGE_LENGTH	128
+
+static int cxl_mem_get_supported_feature_entry(struct cxl_memdev *cxlmd, const uuid_t *feat_uuid,
+					       struct cxl_mbox_supp_feat_entry *feat_entry_out)
+{
+	struct cxl_mbox_supp_feat_entry *feat_entry;
+	struct cxl_dev_state *cxlds = cxlmd->cxlds;
+	struct cxl_memdev_state *mds = to_cxl_memdev_state(cxlds);
+	int feat_index, feats_out_size;
+	int nentries, count;
+	int ret;
+
+	feat_index = 0;
+	feats_out_size = sizeof(struct cxl_mbox_get_supp_feats_out) +
+			  sizeof(struct cxl_mbox_supp_feat_entry);
+	struct cxl_mbox_get_supp_feats_out *feats_out __free(kfree) =
+					kmalloc(feats_out_size, GFP_KERNEL);
+	if (!feats_out)
+		return -ENOMEM;
+
+	do {
+		memset(feats_out, 0, feats_out_size);
+		ret = cxl_get_supported_features(mds, feats_out_size,
+						 feat_index, feats_out);
+		if (ret)
+			return ret;
+
+		nentries = feats_out->nr_entries;
+		if (!nentries)
+			return -EOPNOTSUPP;
+
+		/* Check CXL memdev supports the feature */
+		feat_entry = feats_out->feat_entries;
+		for (count = 0; count < nentries; count++, feat_entry++) {
+			if (uuid_equal(&feat_entry->uuid, feat_uuid)) {
+				memcpy(feat_entry_out, feat_entry,
+				       sizeof(*feat_entry_out));
+				return 0;
+			}
+		}
+		feat_index += nentries;
+	} while (true);
+
+	return -EOPNOTSUPP;
+}
+
+/* CXL memory patrol scrub control definitions */
+#define CXL_MEMDEV_PS_GET_FEAT_VERSION	0x01
+#define CXL_MEMDEV_PS_SET_FEAT_VERSION	0x01
+
+static const uuid_t cxl_patrol_scrub_uuid =
+	UUID_INIT(0x96dad7d6, 0xfde8, 0x482b, 0xa7, 0x33, 0x75, 0x77, 0x4e,     \
+		  0x06, 0xdb, 0x8a);
+
+/* CXL memory patrol scrub control functions */
+struct cxl_patrol_scrub_context {
+	struct device *dev;
+	u16 get_feat_size;
+	u16 set_feat_size;
+	bool scrub_cycle_changeable;
+};
+
+/**
+ * struct cxl_memdev_ps_params - CXL memory patrol scrub parameter data structure.
+ * @enable:     [IN & OUT] enable(1)/disable(0) patrol scrub.
+ * @scrub_cycle_changeable: [OUT] scrub cycle attribute of patrol scrub is changeable.
+ * @rate:       [IN] Requested patrol scrub cycle in hours.
+ *              [OUT] Current patrol scrub cycle in hours.
+ * @min_rate:[OUT] minimum patrol scrub cycle, in hours, supported.
+ * @rate_avail:[OUT] Supported patrol scrub cycle in hours.
+ */
+struct cxl_memdev_ps_params {
+	bool enable;
+	bool scrub_cycle_changeable;
+	u16 rate;
+	u16 min_rate;
+	char rate_avail[CXL_SCRUB_MAX_ATTR_RANGE_LENGTH];
+};
+
+enum {
+	CXL_MEMDEV_PS_PARAM_ENABLE,
+	CXL_MEMDEV_PS_PARAM_RATE,
+};
+
+#define	CXL_MEMDEV_PS_SCRUB_CYCLE_CHANGE_CAP_MASK	BIT(0)
+#define	CXL_MEMDEV_PS_SCRUB_CYCLE_REALTIME_REPORT_CAP_MASK	BIT(1)
+#define	CXL_MEMDEV_PS_CUR_SCRUB_CYCLE_MASK	GENMASK(7, 0)
+#define	CXL_MEMDEV_PS_MIN_SCRUB_CYCLE_MASK	GENMASK(15, 8)
+#define	CXL_MEMDEV_PS_FLAG_ENABLED_MASK	BIT(0)
+
+struct cxl_memdev_ps_rd_attrs {
+	u8 scrub_cycle_cap;
+	__le16 scrub_cycle;
+	u8 scrub_flags;
+}  __packed;
+
+struct cxl_memdev_ps_wr_attrs {
+	u8 scrub_cycle_hr;
+	u8 scrub_flags;
+}  __packed;
+
+static int cxl_mem_ps_get_attrs(struct device *dev,
+				struct cxl_memdev_ps_params *params)
+{
+	struct cxl_memdev *cxlmd = to_cxl_memdev(dev);
+	struct cxl_dev_state *cxlds = cxlmd->cxlds;
+	struct cxl_memdev_state *mds = to_cxl_memdev_state(cxlds);
+	size_t rd_data_size = sizeof(struct cxl_memdev_ps_rd_attrs);
+	size_t data_size;
+
+	if (!mds)
+		return -EFAULT;
+
+	struct cxl_memdev_ps_rd_attrs *rd_attrs __free(kfree) =
+						kmalloc(rd_data_size, GFP_KERNEL);
+	if (!rd_attrs)
+		return -ENOMEM;
+
+	params->scrub_cycle_changeable = 0;
+	params->enable = 0;
+	params->rate = 0;
+	params->min_rate = 0;
+	data_size = cxl_get_feature(mds, cxl_patrol_scrub_uuid, rd_attrs,
+				    rd_data_size, rd_data_size,
+				    CXL_GET_FEAT_SEL_CURRENT_VALUE);
+	if (!data_size) {
+		snprintf(params->rate_avail, CXL_SCRUB_MAX_ATTR_RANGE_LENGTH,
+			"Unavailable");
+		return -EIO;
+	}
+	params->scrub_cycle_changeable = FIELD_GET(CXL_MEMDEV_PS_SCRUB_CYCLE_CHANGE_CAP_MASK,
+						   rd_attrs->scrub_cycle_cap);
+	params->enable = FIELD_GET(CXL_MEMDEV_PS_FLAG_ENABLED_MASK,
+				   rd_attrs->scrub_flags);
+	params->rate = FIELD_GET(CXL_MEMDEV_PS_CUR_SCRUB_CYCLE_MASK,
+				 rd_attrs->scrub_cycle);
+	params->min_rate  = FIELD_GET(CXL_MEMDEV_PS_MIN_SCRUB_CYCLE_MASK,
+				      rd_attrs->scrub_cycle);
+	snprintf(params->rate_avail, CXL_SCRUB_MAX_ATTR_RANGE_LENGTH,
+		 "Minimum scrub cycle = %d hour", params->min_rate);
+
+	return 0;
+}
+
+static int __maybe_unused
+cxl_mem_ps_set_attrs(struct device *dev, struct cxl_memdev_ps_params *params,
+		     u8 param_type)
+{
+	struct cxl_memdev_ps_wr_attrs wr_attrs;
+	struct cxl_memdev *cxlmd = to_cxl_memdev(dev);
+	struct cxl_dev_state *cxlds = cxlmd->cxlds;
+	struct cxl_memdev_state *mds = to_cxl_memdev_state(cxlds);
+	struct cxl_memdev_ps_params rd_params;
+	int ret;
+
+	if (!mds)
+		return -EFAULT;
+
+	ret = cxl_mem_ps_get_attrs(dev, &rd_params);
+	if (ret) {
+		dev_err(dev, "Get cxlmemdev patrol scrub params failed ret=%d\n",
+			ret);
+		return ret;
+	}
+
+	switch (param_type) {
+	case CXL_MEMDEV_PS_PARAM_ENABLE:
+		wr_attrs.scrub_flags = FIELD_PREP(CXL_MEMDEV_PS_FLAG_ENABLED_MASK,
+						   params->enable);
+		wr_attrs.scrub_cycle_hr = FIELD_PREP(CXL_MEMDEV_PS_CUR_SCRUB_CYCLE_MASK,
+						      rd_params.rate);
+		break;
+	case CXL_MEMDEV_PS_PARAM_RATE:
+		if (params->rate < rd_params.min_rate) {
+			dev_err(dev, "Invalid CXL patrol scrub cycle(%d) to set\n",
+				params->rate);
+			dev_err(dev, "Minimum supported CXL patrol scrub cycle in hour %d\n",
+			       params->min_rate);
+			return -EINVAL;
+		}
+		wr_attrs.scrub_cycle_hr = FIELD_PREP(CXL_MEMDEV_PS_CUR_SCRUB_CYCLE_MASK,
+						      params->rate);
+		wr_attrs.scrub_flags = FIELD_PREP(CXL_MEMDEV_PS_FLAG_ENABLED_MASK,
+						   rd_params.enable);
+		break;
+	default:
+		dev_err(dev, "Invalid CXL patrol scrub parameter to set\n");
+		return -EINVAL;
+	}
+
+	ret = cxl_set_feature(mds, cxl_patrol_scrub_uuid, CXL_MEMDEV_PS_SET_FEAT_VERSION,
+			      &wr_attrs, sizeof(wr_attrs),
+			      CXL_SET_FEAT_FLAG_DATA_SAVED_ACROSS_RESET);
+	if (ret) {
+		dev_err(dev, "CXL patrol scrub set feature failed ret=%d\n",
+			ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+int cxl_mem_patrol_scrub_init(struct cxl_memdev *cxlmd)
+{
+	struct cxl_patrol_scrub_context *cxl_ps_ctx;
+	struct cxl_mbox_supp_feat_entry feat_entry;
+	struct cxl_memdev_ps_params params;
+	int ret;
+
+	ret = cxl_mem_get_supported_feature_entry(cxlmd, &cxl_patrol_scrub_uuid,
+						  &feat_entry);
+	if (ret < 0)
+		return ret;
+
+	if (!(feat_entry.attr_flags & CXL_FEAT_ENTRY_FLAG_CHANGABLE))
+		return -EOPNOTSUPP;
+
+	ret = cxl_mem_ps_get_attrs(&cxlmd->dev, &params);
+	if (ret)
+		return dev_err_probe(&cxlmd->dev, ret,
+				     "Get CXL patrol scrub params failed\n");
+
+	cxl_ps_ctx = devm_kzalloc(&cxlmd->dev, sizeof(*cxl_ps_ctx), GFP_KERNEL);
+	if (!cxl_ps_ctx)
+		return -ENOMEM;
+
+	cxl_ps_ctx->get_feat_size = feat_entry.get_size;
+	cxl_ps_ctx->set_feat_size = feat_entry.set_size;
+	cxl_ps_ctx->scrub_cycle_changeable =  params.scrub_cycle_changeable;
+
+	return 0;
+}
+EXPORT_SYMBOL_NS_GPL(cxl_mem_patrol_scrub_init, CXL);
diff --git a/drivers/cxl/cxlmem.h b/drivers/cxl/cxlmem.h
index a8d4104afa53..e6a709a0e168 100644
--- a/drivers/cxl/cxlmem.h
+++ b/drivers/cxl/cxlmem.h
@@ -949,6 +949,14 @@ int cxl_trigger_poison_list(struct cxl_memdev *cxlmd);
 int cxl_inject_poison(struct cxl_memdev *cxlmd, u64 dpa);
 int cxl_clear_poison(struct cxl_memdev *cxlmd, u64 dpa);
 
+/* cxl memory scrub functions */
+#ifdef CONFIG_CXL_SCRUB
+int cxl_mem_patrol_scrub_init(struct cxl_memdev *cxlmd);
+#else
+static inline int cxl_mem_patrol_scrub_init(struct cxl_memdev *cxlmd)
+{ return -EOPNOTSUPP; }
+#endif
+
 #ifdef CONFIG_CXL_SUSPEND
 void cxl_mem_active_inc(void);
 void cxl_mem_active_dec(void);
diff --git a/drivers/cxl/pci.c b/drivers/cxl/pci.c
index 233e7c42c161..371c3abcf2fe 100644
--- a/drivers/cxl/pci.c
+++ b/drivers/cxl/pci.c
@@ -886,6 +886,10 @@ static int cxl_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	if (rc)
 		return rc;
 
+	rc = cxl_mem_patrol_scrub_init(cxlmd);
+	if (rc)
+		dev_dbg(&pdev->dev, "CXL patrol scrub init failed\n");
+
 	rc = devm_cxl_sanitize_setup_notifier(&pdev->dev, cxlmd);
 	if (rc)
 		return rc;
-- 
2.34.1


From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id DD13718AED;
	Fri, 23 Feb 2024 14:37:44 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=none smtp.client-ip=185.176.79.56
ARC-Seal: i=1; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1708699067; cv=none; b=KJIhb6d+uNEcAYngkr/KtKfO66Lhp8JaY67gwAR8RTlGCpMXGPGB5vVB8ogDe5x3VhfTK+bgK735BETnIz2f/ISZB7//G2QLiguOyd/l3FDC3tMldsmPJTYvR7NV+Ff+tAgyhEfl55JdZ9C+VIjAfwpHRf7VZOojpcJpzRH92QM=
ARC-Message-Signature: i=1; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1708699067; c=relaxed/simple;
	bh=p+5VjVK2wbz/hMLbSbCrt0caDnmfLv+hXTfvW4v5JuI=;
	h=From:To:CC:Subject:Date:Message-ID:In-Reply-To:References:
	 MIME-Version:Content-Type; b=ZJpPNG1Zp3elerwGT+gng2UPnAcPUoYbnxl4BNlDbhNE6jouLRmdkDvzwgO+x0/G54PLUkfBYr5/EW1+8aIpsleeocqlM68xphnm91ck849nJtbBmxwv/8JX0Oe+t2wlgeGpwqoOMntkNsDrWmO4OqdjlLf4bOVJSS3HKNuRAgw=
ARC-Authentication-Results: i=1; smtp.subspace.kernel.org; dmarc=pass (p=quarantine dis=none) header.from=huawei.com; spf=pass smtp.mailfrom=huawei.com; arc=none smtp.client-ip=185.176.79.56
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=quarantine dis=none) header.from=huawei.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=huawei.com
Received: from mail.maildlp.com (unknown [172.18.186.31])
	by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4ThCDF0mVBz6JB0k;
	Fri, 23 Feb 2024 22:33:17 +0800 (CST)
Received: from lhrpeml500006.china.huawei.com (unknown [7.191.161.198])
	by mail.maildlp.com (Postfix) with ESMTPS id B8D831410B3;
	Fri, 23 Feb 2024 22:37:42 +0800 (CST)
Received: from SecurePC30232.china.huawei.com (10.122.247.234) by
 lhrpeml500006.china.huawei.com (7.191.161.198) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.35; Fri, 23 Feb 2024 14:37:41 +0000
From: <shiju.jose@huawei.com>
To: <linux-cxl@vger.kernel.org>, <linux-acpi@vger.kernel.org>,
	<linux-mm@kvack.org>, <dan.j.williams@intel.com>, <dave@stgolabs.net>,
	<jonathan.cameron@huawei.com>, <dave.jiang@intel.com>,
	<alison.schofield@intel.com>, <vishal.l.verma@intel.com>,
	<ira.weiny@intel.com>
CC: <linux-edac@vger.kernel.org>, <linux-kernel@vger.kernel.org>,
	<david@redhat.com>, <Vilas.Sridharan@amd.com>, <leo.duran@amd.com>,
	<Yazen.Ghannam@amd.com>, <rientjes@google.com>, <jiaqiyan@google.com>,
	<tony.luck@intel.com>, <Jon.Grimm@amd.com>, <dave.hansen@linux.intel.com>,
	<rafael@kernel.org>, <lenb@kernel.org>, <naoya.horiguchi@nec.com>,
	<james.morse@arm.com>, <jthoughton@google.com>, <somasundaram.a@hpe.com>,
	<erdemaktas@google.com>, <pgonda@google.com>, <duenwen@google.com>,
	<mike.malvestuto@intel.com>, <gthelen@google.com>,
	<wschwartz@amperecomputing.com>, <dferguson@amperecomputing.com>,
	<tanxiaofei@huawei.com>, <prime.zeng@hisilicon.com>,
	<kangkang.shen@futurewei.com>, <wanghuiqiang@huawei.com>,
	<linuxarm@huawei.com>, <shiju.jose@huawei.com>
Subject: [RFC PATCH v7 05/12] cxl/memscrub: Add CXL device ECS control feature
Date: Fri, 23 Feb 2024 22:37:16 +0800
Message-ID: <20240223143723.1574-6-shiju.jose@huawei.com>
X-Mailer: git-send-email 2.35.1.windows.2
In-Reply-To: <20240223143723.1574-1-shiju.jose@huawei.com>
References: <20240223143723.1574-1-shiju.jose@huawei.com>
Precedence: bulk
X-Mailing-List: linux-kernel@vger.kernel.org
List-Id: <linux-kernel.vger.kernel.org>
List-Subscribe: <mailto:linux-kernel+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:linux-kernel+unsubscribe@vger.kernel.org>
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
Content-Type: text/plain
X-ClientProxiedBy: lhrpeml500003.china.huawei.com (7.191.162.67) To
 lhrpeml500006.china.huawei.com (7.191.161.198)

From: Shiju Jose <shiju.jose@huawei.com>

CXL spec 3.1 section 8.2.9.9.11.2 describes the DDR5 Error Check
Scrub (ECS) control feature.

The Error Check Scrub (ECS) is a feature defined in JEDEC DDR5 SDRAM
Specification (JESD79-5) and allows the DRAM to internally read, correct
single-bit errors, and write back corrected data bits to the DRAM array
while providing transparency to error counts. The ECS control feature
allows the request to configure ECS input configurations during system
boot or at run-time.

The ECS control allows the requester to change the log entry type, the ECS
threshold count provided that the request is within the definition
specified in DDR5 mode registers, change mode between codeword mode and
row count mode, and reset the ECS counter.

Open Question:
Is cxl_mem_ecs_init() invoked in the right function in cxl/core/region.c?

Signed-off-by: Shiju Jose <shiju.jose@huawei.com>
---
 drivers/cxl/core/memscrub.c | 272 +++++++++++++++++++++++++++++++++++-
 drivers/cxl/core/region.c   |   3 +
 drivers/cxl/cxlmem.h        |   3 +
 3 files changed, 276 insertions(+), 2 deletions(-)

diff --git a/drivers/cxl/core/memscrub.c b/drivers/cxl/core/memscrub.c
index 2079498719fe..61a77fabca13 100644
--- a/drivers/cxl/core/memscrub.c
+++ b/drivers/cxl/core/memscrub.c
@@ -4,8 +4,8 @@
  *
  * Copyright (c) 2024 HiSilicon Limited.
  *
- *  - Provides functions to configure patrol scrub feature of the
- *    CXL memory devices.
+ *  - Provides functions to configure patrol scrub and DDR5 ECS features
+ *    of the CXL memory devices.
  */
 
 #define pr_fmt(fmt)	"CXL_MEM_SCRUB: " fmt
@@ -246,3 +246,271 @@ int cxl_mem_patrol_scrub_init(struct cxl_memdev *cxlmd)
 	return 0;
 }
 EXPORT_SYMBOL_NS_GPL(cxl_mem_patrol_scrub_init, CXL);
+
+/* CXL DDR5 ECS control definitions */
+#define CXL_MEMDEV_ECS_GET_FEAT_VERSION	0x01
+#define CXL_MEMDEV_ECS_SET_FEAT_VERSION	0x01
+
+static const uuid_t cxl_ecs_uuid =
+	UUID_INIT(0xe5b13f22, 0x2328, 0x4a14, 0xb8, 0xba, 0xb9, 0x69, 0x1e,     \
+		  0x89, 0x33, 0x86);
+
+struct cxl_ecs_context {
+	struct device *dev;
+	u16 nregions;
+	int region_id;
+	u16 get_feat_size;
+	u16 set_feat_size;
+};
+
+/**
+ * struct cxl_memdev_ecs_params - CXL memory DDR5 ECS parameter data structure.
+ * @log_entry_type: ECS log entry type, per DRAM or per memory media FRU.
+ * @threshold: ECS threshold count per GB of memory cells.
+ * @mode:	codeword/row count mode
+ *		0 : ECS counts rows with errors
+ *		1 : ECS counts codeword with errors
+ * @reset_counter: [IN] reset ECC counter to default value.
+ */
+struct cxl_memdev_ecs_params {
+	u8 log_entry_type;
+	u16 threshold;
+	u8 mode;
+	bool reset_counter;
+};
+
+enum {
+	CXL_MEMDEV_ECS_PARAM_LOG_ENTRY_TYPE,
+	CXL_MEMDEV_ECS_PARAM_THRESHOLD,
+	CXL_MEMDEV_ECS_PARAM_MODE,
+	CXL_MEMDEV_ECS_PARAM_RESET_COUNTER,
+};
+
+#define	CXL_MEMDEV_ECS_LOG_ENTRY_TYPE_MASK	GENMASK(1, 0)
+#define	CXL_MEMDEV_ECS_REALTIME_REPORT_CAP_MASK	BIT(0)
+#define	CXL_MEMDEV_ECS_THRESHOLD_COUNT_MASK	GENMASK(2, 0)
+#define	CXL_MEMDEV_ECS_MODE_MASK	BIT(3)
+#define	CXL_MEMDEV_ECS_RESET_COUNTER_MASK	BIT(4)
+
+static const u16 ecs_supp_threshold[] = { 0, 0, 0, 256, 1024, 4096 };
+
+enum {
+	ECS_LOG_ENTRY_TYPE_DRAM = 0x0,
+	ECS_LOG_ENTRY_TYPE_MEM_MEDIA_FRU = 0x1,
+};
+
+enum {
+	ECS_THRESHOLD_256 = 3,
+	ECS_THRESHOLD_1024 = 4,
+	ECS_THRESHOLD_4096 = 5,
+};
+
+enum {
+	ECS_MODE_COUNTS_ROWS = 0,
+	ECS_MODE_COUNTS_CODEWORDS = 1,
+};
+
+struct cxl_memdev_ecs_rd_attrs {
+	u8 ecs_log_cap;
+	u8 ecs_cap;
+	__le16 ecs_config;
+	u8 ecs_flags;
+}  __packed;
+
+struct cxl_memdev_ecs_wr_attrs {
+	u8 ecs_log_cap;
+	__le16 ecs_config;
+}  __packed;
+
+/* CXL DDR5 ECS control functions */
+static int __maybe_unused
+cxl_mem_ecs_get_attrs(struct device *scrub_dev, int fru_id,
+		      struct cxl_memdev_ecs_params *params)
+{
+	struct cxl_memdev *cxlmd = to_cxl_memdev(scrub_dev->parent);
+	struct cxl_dev_state *cxlds = cxlmd->cxlds;
+	struct cxl_memdev_state *mds = to_cxl_memdev_state(cxlds);
+	struct cxl_ecs_context *cxl_ecs_ctx;
+	size_t rd_data_size;
+	u8 threshold_index;
+	size_t data_size;
+
+	if (!mds)
+		return -EFAULT;
+	cxl_ecs_ctx = dev_get_drvdata(scrub_dev);
+	rd_data_size = cxl_ecs_ctx->get_feat_size;
+
+	struct cxl_memdev_ecs_rd_attrs *rd_attrs __free(kfree) =
+					kmalloc(rd_data_size, GFP_KERNEL);
+	if (!rd_attrs)
+		return -ENOMEM;
+
+	params->log_entry_type = 0;
+	params->threshold = 0;
+	params->mode = 0;
+	data_size = cxl_get_feature(mds, cxl_ecs_uuid, rd_attrs,
+				    rd_data_size, rd_data_size,
+				    CXL_GET_FEAT_SEL_CURRENT_VALUE);
+	if (!data_size)
+		return -EIO;
+
+	params->log_entry_type = FIELD_GET(CXL_MEMDEV_ECS_LOG_ENTRY_TYPE_MASK,
+					   rd_attrs[fru_id].ecs_log_cap);
+	threshold_index = FIELD_GET(CXL_MEMDEV_ECS_THRESHOLD_COUNT_MASK,
+				    rd_attrs[fru_id].ecs_config);
+	params->threshold = ecs_supp_threshold[threshold_index];
+	params->mode = FIELD_GET(CXL_MEMDEV_ECS_MODE_MASK,
+				 rd_attrs[fru_id].ecs_config);
+
+	return 0;
+}
+
+static int __maybe_unused
+cxl_mem_ecs_set_attrs(struct device *scrub_dev, int fru_id,
+		      struct cxl_memdev_ecs_params *params, u8 param_type)
+{
+	struct cxl_memdev *cxlmd = to_cxl_memdev(scrub_dev->parent);
+	struct cxl_dev_state *cxlds = cxlmd->cxlds;
+	struct cxl_memdev_state *mds = to_cxl_memdev_state(cxlds);
+	struct cxl_ecs_context *cxl_ecs_ctx;
+	struct device *dev = scrub_dev->parent;
+	size_t rd_data_size, wr_data_size;
+	u16 nmedia_frus, count;
+	size_t data_size;
+	int ret;
+
+	if (!mds)
+		return -EFAULT;
+
+	cxl_ecs_ctx = dev_get_drvdata(scrub_dev);
+	nmedia_frus = cxl_ecs_ctx->nregions;
+	rd_data_size = cxl_ecs_ctx->get_feat_size;
+	wr_data_size = cxl_ecs_ctx->set_feat_size;
+	struct cxl_memdev_ecs_rd_attrs *rd_attrs __free(kfree) =
+				kmalloc(rd_data_size, GFP_KERNEL);
+	if (!rd_attrs)
+		return -ENOMEM;
+
+	data_size = cxl_get_feature(mds, cxl_ecs_uuid, rd_attrs,
+				    rd_data_size, rd_data_size,
+				    CXL_GET_FEAT_SEL_CURRENT_VALUE);
+	if (!data_size)
+		return -EIO;
+	struct cxl_memdev_ecs_wr_attrs *wr_attrs __free(kfree) =
+					kmalloc(wr_data_size, GFP_KERNEL);
+	if (!wr_attrs)
+		return -ENOMEM;
+
+	/* Fill writable attributes from the current attributes read for all the media FRUs */
+	for (count = 0; count < nmedia_frus; count++) {
+		wr_attrs[count].ecs_log_cap = rd_attrs[count].ecs_log_cap;
+		wr_attrs[count].ecs_config = rd_attrs[count].ecs_config;
+	}
+
+	/* Fill attribute to be set for the media FRU */
+	switch (param_type) {
+	case CXL_MEMDEV_ECS_PARAM_LOG_ENTRY_TYPE:
+		if (params->log_entry_type != ECS_LOG_ENTRY_TYPE_DRAM &&
+		    params->log_entry_type != ECS_LOG_ENTRY_TYPE_MEM_MEDIA_FRU) {
+			dev_err(dev,
+				"Invalid CXL ECS scrub log entry type(%d) to set\n",
+			       params->log_entry_type);
+			dev_err(dev,
+				"Log Entry Type 0: per DRAM  1: per Memory Media FRU\n");
+			return -EINVAL;
+		}
+		wr_attrs[fru_id].ecs_log_cap = FIELD_PREP(CXL_MEMDEV_ECS_LOG_ENTRY_TYPE_MASK,
+							  params->log_entry_type);
+		break;
+	case CXL_MEMDEV_ECS_PARAM_THRESHOLD:
+		wr_attrs[fru_id].ecs_config &= ~CXL_MEMDEV_ECS_THRESHOLD_COUNT_MASK;
+		switch (params->threshold) {
+		case 256:
+			wr_attrs[fru_id].ecs_config |= FIELD_PREP(
+						CXL_MEMDEV_ECS_THRESHOLD_COUNT_MASK,
+						ECS_THRESHOLD_256);
+			break;
+		case 1024:
+			wr_attrs[fru_id].ecs_config |= FIELD_PREP(
+						CXL_MEMDEV_ECS_THRESHOLD_COUNT_MASK,
+						ECS_THRESHOLD_1024);
+			break;
+		case 4096:
+			wr_attrs[fru_id].ecs_config |= FIELD_PREP(
+						CXL_MEMDEV_ECS_THRESHOLD_COUNT_MASK,
+						ECS_THRESHOLD_4096);
+			break;
+		default:
+			dev_err(dev,
+				"Invalid CXL ECS scrub threshold count(%d) to set\n",
+				params->threshold);
+			dev_err(dev,
+				"Supported scrub threshold count: 256,1024,4096\n");
+			return -EINVAL;
+		}
+		break;
+	case CXL_MEMDEV_ECS_PARAM_MODE:
+		if (params->mode != ECS_MODE_COUNTS_ROWS &&
+		    params->mode != ECS_MODE_COUNTS_CODEWORDS) {
+			dev_err(dev,
+				"Invalid CXL ECS scrub mode(%d) to set\n",
+				params->mode);
+			dev_err(dev,
+				"Mode 0: ECS counts rows with errors"
+				" 1: ECS counts codewords with errors\n");
+			return -EINVAL;
+		}
+		wr_attrs[fru_id].ecs_config &= ~CXL_MEMDEV_ECS_MODE_MASK;
+		wr_attrs[fru_id].ecs_config |= FIELD_PREP(CXL_MEMDEV_ECS_MODE_MASK,
+							  params->mode);
+		break;
+	case CXL_MEMDEV_ECS_PARAM_RESET_COUNTER:
+		wr_attrs[fru_id].ecs_config &= ~CXL_MEMDEV_ECS_RESET_COUNTER_MASK;
+		wr_attrs[fru_id].ecs_config |= FIELD_PREP(CXL_MEMDEV_ECS_RESET_COUNTER_MASK,
+							  params->reset_counter);
+		break;
+	default:
+		dev_err(dev, "Invalid CXL ECS parameter to set\n");
+		return -EINVAL;
+	}
+	ret = cxl_set_feature(mds, cxl_ecs_uuid, CXL_MEMDEV_ECS_SET_FEAT_VERSION,
+			      wr_attrs, wr_data_size,
+			      CXL_SET_FEAT_FLAG_DATA_SAVED_ACROSS_RESET);
+	if (ret) {
+		dev_err(dev, "CXL ECS set feature failed ret=%d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+int cxl_mem_ecs_init(struct cxl_memdev *cxlmd, int region_id)
+{
+	struct cxl_mbox_supp_feat_entry feat_entry;
+	struct cxl_ecs_context *cxl_ecs_ctx;
+	int nr_media_frus;
+	int ret;
+
+	ret = cxl_mem_get_supported_feature_entry(cxlmd, &cxl_ecs_uuid, &feat_entry);
+	if (ret < 0)
+		return ret;
+
+	if (!(feat_entry.attr_flags & CXL_FEAT_ENTRY_FLAG_CHANGABLE))
+		return -EOPNOTSUPP;
+	nr_media_frus = feat_entry.get_size/
+				sizeof(struct cxl_memdev_ecs_rd_attrs);
+	if (!nr_media_frus)
+		return -ENODEV;
+
+	cxl_ecs_ctx = devm_kzalloc(&cxlmd->dev, sizeof(*cxl_ecs_ctx), GFP_KERNEL);
+	if (!cxl_ecs_ctx)
+		return -ENOMEM;
+
+	cxl_ecs_ctx->nregions = nr_media_frus;
+	cxl_ecs_ctx->get_feat_size = feat_entry.get_size;
+	cxl_ecs_ctx->set_feat_size = feat_entry.set_size;
+	cxl_ecs_ctx->region_id = region_id;
+
+	return 0;
+}
+EXPORT_SYMBOL_NS_GPL(cxl_mem_ecs_init, CXL);
diff --git a/drivers/cxl/core/region.c b/drivers/cxl/core/region.c
index ce0e2d82bb2b..8b81c47801fc 100644
--- a/drivers/cxl/core/region.c
+++ b/drivers/cxl/core/region.c
@@ -2913,6 +2913,9 @@ int cxl_add_to_region(struct cxl_port *root, struct cxl_endpoint_decoder *cxled)
 			dev_err(&cxlr->dev, "failed to enable, range: %pr\n",
 				p->res);
 	}
+	rc = cxl_mem_ecs_init(cxlmd, atomic_read(&cxlrd->region_id));
+	if (rc)
+		dev_dbg(&cxlr->dev, "CXL memory ECS init failed\n");
 
 	put_device(region_dev);
 out:
diff --git a/drivers/cxl/cxlmem.h b/drivers/cxl/cxlmem.h
index e6a709a0e168..88a5c21e087e 100644
--- a/drivers/cxl/cxlmem.h
+++ b/drivers/cxl/cxlmem.h
@@ -952,9 +952,12 @@ int cxl_clear_poison(struct cxl_memdev *cxlmd, u64 dpa);
 /* cxl memory scrub functions */
 #ifdef CONFIG_CXL_SCRUB
 int cxl_mem_patrol_scrub_init(struct cxl_memdev *cxlmd);
+int cxl_mem_ecs_init(struct cxl_memdev *cxlmd, int region_id);
 #else
 static inline int cxl_mem_patrol_scrub_init(struct cxl_memdev *cxlmd)
 { return -EOPNOTSUPP; }
+static inline int cxl_mem_ecs_init(struct cxl_memdev *cxlmd, int region_id)
+{ return -EOPNOTSUPP; }
 #endif
 
 #ifdef CONFIG_CXL_SUSPEND
-- 
2.34.1


From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id 41B407BAFD;
	Fri, 23 Feb 2024 14:37:47 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=none smtp.client-ip=185.176.79.56
ARC-Seal: i=1; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1708699069; cv=none; b=ZbC4LzPMEuMRKenSqBP3qIiOgLJchwqKjRjnwdGD0uVdGgHjlyhjMqUas2NPBbXsu3C3drmFCTldWoeLktMpmvUm+ON3oHCmaap1WwDZ6VafESglyj02d4oDZDDjvAjjdymSGf3suVVkzfnpK00s1C+6nK66PwTut1+Mmfl+4Ds=
ARC-Message-Signature: i=1; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1708699069; c=relaxed/simple;
	bh=8cGsSvfUZ9ecxlFhWZPPuPn8TOgCRhs193A2vjRRb54=;
	h=From:To:CC:Subject:Date:Message-ID:In-Reply-To:References:
	 MIME-Version:Content-Type; b=VJK5yjKjMjA7N5O9sxx5JamroJ6r8Y84spDz+EKrA4NBGBdf8CX6HBPar1G+7X/4ei6Rq9Gojnti0ZPvFSNotixQxb4blyTIgYnLxEflrlMRkdqfXmenj4IzDCMuN7udKGK5zlRO5vqdK15l2w0AVJ8Fdu/zJRMrZat4U9rlUzo=
ARC-Authentication-Results: i=1; smtp.subspace.kernel.org; dmarc=pass (p=quarantine dis=none) header.from=huawei.com; spf=pass smtp.mailfrom=huawei.com; arc=none smtp.client-ip=185.176.79.56
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=quarantine dis=none) header.from=huawei.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=huawei.com
Received: from mail.maildlp.com (unknown [172.18.186.31])
	by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4ThCF94lsDz6K8xl;
	Fri, 23 Feb 2024 22:34:05 +0800 (CST)
Received: from lhrpeml500006.china.huawei.com (unknown [7.191.161.198])
	by mail.maildlp.com (Postfix) with ESMTPS id B8F98141B80;
	Fri, 23 Feb 2024 22:37:44 +0800 (CST)
Received: from SecurePC30232.china.huawei.com (10.122.247.234) by
 lhrpeml500006.china.huawei.com (7.191.161.198) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.35; Fri, 23 Feb 2024 14:37:43 +0000
From: <shiju.jose@huawei.com>
To: <linux-cxl@vger.kernel.org>, <linux-acpi@vger.kernel.org>,
	<linux-mm@kvack.org>, <dan.j.williams@intel.com>, <dave@stgolabs.net>,
	<jonathan.cameron@huawei.com>, <dave.jiang@intel.com>,
	<alison.schofield@intel.com>, <vishal.l.verma@intel.com>,
	<ira.weiny@intel.com>
CC: <linux-edac@vger.kernel.org>, <linux-kernel@vger.kernel.org>,
	<david@redhat.com>, <Vilas.Sridharan@amd.com>, <leo.duran@amd.com>,
	<Yazen.Ghannam@amd.com>, <rientjes@google.com>, <jiaqiyan@google.com>,
	<tony.luck@intel.com>, <Jon.Grimm@amd.com>, <dave.hansen@linux.intel.com>,
	<rafael@kernel.org>, <lenb@kernel.org>, <naoya.horiguchi@nec.com>,
	<james.morse@arm.com>, <jthoughton@google.com>, <somasundaram.a@hpe.com>,
	<erdemaktas@google.com>, <pgonda@google.com>, <duenwen@google.com>,
	<mike.malvestuto@intel.com>, <gthelen@google.com>,
	<wschwartz@amperecomputing.com>, <dferguson@amperecomputing.com>,
	<tanxiaofei@huawei.com>, <prime.zeng@hisilicon.com>,
	<kangkang.shen@futurewei.com>, <wanghuiqiang@huawei.com>,
	<linuxarm@huawei.com>, <shiju.jose@huawei.com>
Subject: [RFC PATCH v7 07/12] cxl/memscrub: Register CXL device patrol scrub with scrub subsystem driver
Date: Fri, 23 Feb 2024 22:37:18 +0800
Message-ID: <20240223143723.1574-8-shiju.jose@huawei.com>
X-Mailer: git-send-email 2.35.1.windows.2
In-Reply-To: <20240223143723.1574-1-shiju.jose@huawei.com>
References: <20240223143723.1574-1-shiju.jose@huawei.com>
Precedence: bulk
X-Mailing-List: linux-kernel@vger.kernel.org
List-Id: <linux-kernel.vger.kernel.org>
List-Subscribe: <mailto:linux-kernel+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:linux-kernel+unsubscribe@vger.kernel.org>
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
Content-Type: text/plain
X-ClientProxiedBy: lhrpeml500003.china.huawei.com (7.191.162.67) To
 lhrpeml500006.china.huawei.com (7.191.161.198)

From: Shiju Jose <shiju.jose@huawei.com>

Register with the scrub subsystem driver to expose the sysfs attributes
to the user for configuring the CXL device memory patrol scrub.
Add the callback functions to support configuring the CXL memory device
patrol scrub.

Signed-off-by: Shiju Jose <shiju.jose@huawei.com>
---
 drivers/cxl/Kconfig         |   6 ++
 drivers/cxl/core/memscrub.c | 199 +++++++++++++++++++++++++++++++++++-
 2 files changed, 202 insertions(+), 3 deletions(-)

diff --git a/drivers/cxl/Kconfig b/drivers/cxl/Kconfig
index e61c69fa7bf5..a0fe68b83cd0 100644
--- a/drivers/cxl/Kconfig
+++ b/drivers/cxl/Kconfig
@@ -162,11 +162,17 @@ config CXL_SCRUB
 	bool "CXL: Memory scrub feature"
 	depends on CXL_PCI
 	depends on CXL_MEM
+	depends on SCRUB
 	help
 	  The CXL memory scrub control is an optional feature allows host to
 	  control the scrub configurations of CXL Type 3 devices, which
 	  support patrol scrub and/or DDR5 ECS(Error Check Scrub).
 
+	  Register with the scrub configure driver to expose sysfs attributes
+	  to the user for configuring the CXL device memory patrol and DDR5 ECS
+	  scrubs. Provides the interface functions to support configuring the
+	  CXL memory device patrol and ECS scrubs.
+
 	  Say 'y/n' to enable/disable the CXL memory scrub driver that will
 	  attach to CXL.mem devices for memory scrub control feature. See
 	  sections 8.2.9.9.11.1 and 8.2.9.9.11.2 in the CXL 3.1 specification
diff --git a/drivers/cxl/core/memscrub.c b/drivers/cxl/core/memscrub.c
index 61a77fabca13..b053dcb9197e 100644
--- a/drivers/cxl/core/memscrub.c
+++ b/drivers/cxl/core/memscrub.c
@@ -6,14 +6,19 @@
  *
  *  - Provides functions to configure patrol scrub and DDR5 ECS features
  *    of the CXL memory devices.
+ *  - Registers with the scrub subsystem driver to expose the sysfs attributes
+ *    to the user for configuring the memory patrol scrub and DDR5 ECS features.
+
  */
 
 #define pr_fmt(fmt)	"CXL_MEM_SCRUB: " fmt
 
 #include <cxlmem.h>
+#include <memory/memory-scrub.h>
 
 /* CXL memory scrub feature common definitions */
 #define CXL_SCRUB_MAX_ATTR_RANGE_LENGTH	128
+#define CXL_MEMDEV_MAX_NAME_LENGTH     128
 
 static int cxl_mem_get_supported_feature_entry(struct cxl_memdev *cxlmd, const uuid_t *feat_uuid,
 					       struct cxl_mbox_supp_feat_entry *feat_entry_out)
@@ -157,9 +162,8 @@ static int cxl_mem_ps_get_attrs(struct device *dev,
 	return 0;
 }
 
-static int __maybe_unused
-cxl_mem_ps_set_attrs(struct device *dev, struct cxl_memdev_ps_params *params,
-		     u8 param_type)
+static int cxl_mem_ps_set_attrs(struct device *dev, struct cxl_memdev_ps_params *params,
+				u8 param_type)
 {
 	struct cxl_memdev_ps_wr_attrs wr_attrs;
 	struct cxl_memdev *cxlmd = to_cxl_memdev(dev);
@@ -215,11 +219,192 @@ cxl_mem_ps_set_attrs(struct device *dev, struct cxl_memdev_ps_params *params,
 	return 0;
 }
 
+static int cxl_mem_ps_enable_read(struct device *dev, u64 *val)
+{
+	struct cxl_memdev_ps_params params;
+	int ret;
+
+	ret = cxl_mem_ps_get_attrs(dev, &params);
+	if (ret) {
+		dev_err(dev, "Get CXL patrol scrub params failed ret=%d\n", ret);
+		return ret;
+	}
+	*val = params.enable;
+
+	return 0;
+}
+
+static int cxl_mem_ps_enable_write(struct device *dev, long val)
+{
+	struct cxl_memdev_ps_params params;
+	int ret;
+
+	params.enable = val;
+	ret = cxl_mem_ps_set_attrs(dev, &params, CXL_MEMDEV_PS_PARAM_ENABLE);
+	if (ret) {
+		dev_err(dev, "CXL patrol scrub enable failed, enable=%d ret=%d\n",
+		       params.enable, ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int cxl_mem_ps_rate_read(struct device *dev, u64 *val)
+{
+	struct cxl_memdev_ps_params params;
+	int ret;
+
+	ret = cxl_mem_ps_get_attrs(dev, &params);
+	if (ret) {
+		dev_err(dev, "Get CXL patrol scrub params failed ret=%d\n", ret);
+		return ret;
+	}
+	*val = params.rate;
+
+	return 0;
+}
+
+static int cxl_mem_ps_rate_write(struct device *dev, long val)
+{
+	struct cxl_memdev_ps_params params;
+	int ret;
+
+	params.rate = val;
+	ret = cxl_mem_ps_set_attrs(dev, &params, CXL_MEMDEV_PS_PARAM_RATE);
+	if (ret) {
+		dev_err(dev, "Set CXL patrol scrub params for rate failed ret=%d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int cxl_mem_ps_rate_available_read(struct device *dev, char *buf)
+{
+	struct cxl_memdev_ps_params params;
+	int ret;
+
+	ret = cxl_mem_ps_get_attrs(dev, &params);
+	if (ret) {
+		dev_err(dev, "Get CXL patrol scrub params failed ret=%d\n", ret);
+		return ret;
+	}
+
+	sysfs_emit(buf, "%s\n", params.rate_avail);
+
+	return 0;
+}
+
+/**
+ * cxl_mem_patrol_scrub_is_visible() - Callback to return attribute visibility
+ * @dev: Pointer to scrub device
+ * @attr: Scrub attribute
+ * @mode: attribute's mode
+ * @region_id: ID of the memory region
+ *
+ * Returns: 0 on success, an error otherwise
+ */
+static umode_t cxl_mem_patrol_scrub_is_visible(struct device *dev, u32 attr_id,
+					       umode_t mode, int region_id)
+{
+	const struct cxl_patrol_scrub_context *cxl_ps_ctx = dev_get_drvdata(dev);
+
+	if (attr_id == scrub_rate_available ||
+	    attr_id == scrub_rate) {
+		if (!cxl_ps_ctx->scrub_cycle_changeable)
+			return 0;
+	}
+
+	switch (attr_id) {
+	case scrub_rate_available:
+	case scrub_enable:
+	case scrub_rate:
+		return mode;
+	default:
+		return 0;
+	}
+}
+
+/**
+ * cxl_mem_patrol_scrub_read() - Read callback for data attributes
+ * @dev: Pointer to scrub device
+ * @attr: Scrub attribute
+ * @region_id: ID of the memory region
+ * @val: Pointer to the returned data
+ *
+ * Returns: 0 on success, an error otherwise
+ */
+static int cxl_mem_patrol_scrub_read(struct device *dev, u32 attr,
+				     int region_id, u64 *val)
+{
+
+	switch (attr) {
+	case scrub_enable:
+		return cxl_mem_ps_enable_read(dev->parent, val);
+	case scrub_rate:
+		return cxl_mem_ps_rate_read(dev->parent, val);
+	default:
+		return -EOPNOTSUPP;
+	}
+}
+
+/**
+ * cxl_mem_patrol_scrub_write() - Write callback for data attributes
+ * @dev: Pointer to scrub device
+ * @attr: Scrub attribute
+ * @region_id: ID of the memory region
+ * @val: Value to write
+ *
+ * Returns: 0 on success, an error otherwise
+ */
+static int cxl_mem_patrol_scrub_write(struct device *dev, u32 attr,
+				      int region_id, u64 val)
+{
+	switch (attr) {
+	case scrub_enable:
+		return cxl_mem_ps_enable_write(dev->parent, val);
+	case scrub_rate:
+		return cxl_mem_ps_rate_write(dev->parent, val);
+	default:
+		return -EOPNOTSUPP;
+	}
+}
+
+/**
+ * cxl_mem_patrol_scrub_read_strings() - Read callback for string attributes
+ * @dev: Pointer to scrub device
+ * @attr: Scrub attribute
+ * @region_id: ID of the memory region
+ * @buf: Pointer to the buffer for copying returned string
+ *
+ * Returns: 0 on success, an error otherwise
+ */
+static int cxl_mem_patrol_scrub_read_strings(struct device *dev, u32 attr,
+					     int region_id, char *buf)
+{
+	switch (attr) {
+	case scrub_rate_available:
+		return cxl_mem_ps_rate_available_read(dev->parent, buf);
+	default:
+		return -EOPNOTSUPP;
+	}
+}
+
+static const struct scrub_ops cxl_ps_scrub_ops = {
+	.is_visible = cxl_mem_patrol_scrub_is_visible,
+	.read = cxl_mem_patrol_scrub_read,
+	.write = cxl_mem_patrol_scrub_write,
+	.read_string = cxl_mem_patrol_scrub_read_strings,
+};
+
 int cxl_mem_patrol_scrub_init(struct cxl_memdev *cxlmd)
 {
+	char scrub_name[CXL_MEMDEV_MAX_NAME_LENGTH];
 	struct cxl_patrol_scrub_context *cxl_ps_ctx;
 	struct cxl_mbox_supp_feat_entry feat_entry;
 	struct cxl_memdev_ps_params params;
+	struct device *cxl_scrub_dev;
 	int ret;
 
 	ret = cxl_mem_get_supported_feature_entry(cxlmd, &cxl_patrol_scrub_uuid,
@@ -243,6 +428,14 @@ int cxl_mem_patrol_scrub_init(struct cxl_memdev *cxlmd)
 	cxl_ps_ctx->set_feat_size = feat_entry.set_size;
 	cxl_ps_ctx->scrub_cycle_changeable =  params.scrub_cycle_changeable;
 
+	snprintf(scrub_name, sizeof(scrub_name), "%s_%s",
+		 "cxl_patrol_scrub", dev_name(&cxlmd->dev));
+	cxl_scrub_dev = devm_scrub_device_register(&cxlmd->dev, scrub_name,
+						   cxl_ps_ctx, &cxl_ps_scrub_ops,
+						   0, NULL);
+	if (IS_ERR(cxl_scrub_dev))
+		return PTR_ERR(cxl_scrub_dev);
+
 	return 0;
 }
 EXPORT_SYMBOL_NS_GPL(cxl_mem_patrol_scrub_init, CXL);
-- 
2.34.1


From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id BEB568BE7;
	Fri, 23 Feb 2024 14:37:48 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=none smtp.client-ip=185.176.79.56
ARC-Seal: i=1; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1708699070; cv=none; b=uIyaFTmQBBuFifsUg2MrhVoHYRzzCnpGVD+LAPtO4/G6EJa8mjjSRBCem71c8UOuI+p3RW6mNJPX3MfKl3iUyo/QB/VBDsnRIlJoRo+8AywyJBxMwYZ1O2orOcUqtDLckFph0gqMaLf0LnrPAb10w5//0WFA381mUKkWHA3bm3c=
ARC-Message-Signature: i=1; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1708699070; c=relaxed/simple;
	bh=QQVv86g7bqybHD9Ctz5R/WPEsgeUAAHVHhIcWKBXBZc=;
	h=From:To:CC:Subject:Date:Message-ID:In-Reply-To:References:
	 MIME-Version:Content-Type; b=lgt2cxfVv7tXWrn3ld2HjF+u/e+VIbP00DuSXQZ5Pg/d5slaCGrMPSFP5EV1cqp6prgI8i3wMMOpjCm07HlkmKw/+6GoWlQGzDdNyLV0qvTuLUFrOLTkY9g1b5a/shBTFHdv3duXITbizW7YXPEX1bWojLkfJmKvFWsBPzKZoeM=
ARC-Authentication-Results: i=1; smtp.subspace.kernel.org; dmarc=pass (p=quarantine dis=none) header.from=huawei.com; spf=pass smtp.mailfrom=huawei.com; arc=none smtp.client-ip=185.176.79.56
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=quarantine dis=none) header.from=huawei.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=huawei.com
Received: from mail.maildlp.com (unknown [172.18.186.31])
	by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4ThCDK00m9z6JB2X;
	Fri, 23 Feb 2024 22:33:21 +0800 (CST)
Received: from lhrpeml500006.china.huawei.com (unknown [7.191.161.198])
	by mail.maildlp.com (Postfix) with ESMTPS id A21C21410B3;
	Fri, 23 Feb 2024 22:37:46 +0800 (CST)
Received: from SecurePC30232.china.huawei.com (10.122.247.234) by
 lhrpeml500006.china.huawei.com (7.191.161.198) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.35; Fri, 23 Feb 2024 14:37:45 +0000
From: <shiju.jose@huawei.com>
To: <linux-cxl@vger.kernel.org>, <linux-acpi@vger.kernel.org>,
	<linux-mm@kvack.org>, <dan.j.williams@intel.com>, <dave@stgolabs.net>,
	<jonathan.cameron@huawei.com>, <dave.jiang@intel.com>,
	<alison.schofield@intel.com>, <vishal.l.verma@intel.com>,
	<ira.weiny@intel.com>
CC: <linux-edac@vger.kernel.org>, <linux-kernel@vger.kernel.org>,
	<david@redhat.com>, <Vilas.Sridharan@amd.com>, <leo.duran@amd.com>,
	<Yazen.Ghannam@amd.com>, <rientjes@google.com>, <jiaqiyan@google.com>,
	<tony.luck@intel.com>, <Jon.Grimm@amd.com>, <dave.hansen@linux.intel.com>,
	<rafael@kernel.org>, <lenb@kernel.org>, <naoya.horiguchi@nec.com>,
	<james.morse@arm.com>, <jthoughton@google.com>, <somasundaram.a@hpe.com>,
	<erdemaktas@google.com>, <pgonda@google.com>, <duenwen@google.com>,
	<mike.malvestuto@intel.com>, <gthelen@google.com>,
	<wschwartz@amperecomputing.com>, <dferguson@amperecomputing.com>,
	<tanxiaofei@huawei.com>, <prime.zeng@hisilicon.com>,
	<kangkang.shen@futurewei.com>, <wanghuiqiang@huawei.com>,
	<linuxarm@huawei.com>, <shiju.jose@huawei.com>
Subject: [RFC PATCH v7 09/12] ACPICA: ACPI 6.5: Add support for RAS2 table
Date: Fri, 23 Feb 2024 22:37:20 +0800
Message-ID: <20240223143723.1574-10-shiju.jose@huawei.com>
X-Mailer: git-send-email 2.35.1.windows.2
In-Reply-To: <20240223143723.1574-1-shiju.jose@huawei.com>
References: <20240223143723.1574-1-shiju.jose@huawei.com>
Precedence: bulk
X-Mailing-List: linux-kernel@vger.kernel.org
List-Id: <linux-kernel.vger.kernel.org>
List-Subscribe: <mailto:linux-kernel+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:linux-kernel+unsubscribe@vger.kernel.org>
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
Content-Type: text/plain
X-ClientProxiedBy: lhrpeml500003.china.huawei.com (7.191.162.67) To
 lhrpeml500006.china.huawei.com (7.191.161.198)

From: Shiju Jose <shiju.jose@huawei.com>

Add support for ACPI RAS2 feature table(RAS2) defined in the ACPI 6.5
Specification & upwards revision, section 5.2.21.

The RAS2 table provides interfaces for platform RAS features. RAS2 offers
the same services as RASF, but is more scalable than the latter.
RAS2 supports independent RAS controls and capabilities for a given RAS
feature for multiple instances of the same component in a given system.
The platform can support either RAS2 or RASF but not both.

Link: https://github.com/acpica/acpica/pull/899

Signed-off-by: Shiju Jose <shiju.jose@huawei.com>
---
 include/acpi/actbl2.h | 137 ++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 137 insertions(+)

diff --git a/include/acpi/actbl2.h b/include/acpi/actbl2.h
index 9775384d61c6..15c271657f9f 100644
--- a/include/acpi/actbl2.h
+++ b/include/acpi/actbl2.h
@@ -47,6 +47,7 @@
 #define ACPI_SIG_PPTT           "PPTT"	/* Processor Properties Topology Table */
 #define ACPI_SIG_PRMT           "PRMT"	/* Platform Runtime Mechanism Table */
 #define ACPI_SIG_RASF           "RASF"	/* RAS Feature table */
+#define ACPI_SIG_RAS2           "RAS2"	/* RAS2 Feature table */
 #define ACPI_SIG_RGRT           "RGRT"	/* Regulatory Graphics Resource Table */
 #define ACPI_SIG_RHCT           "RHCT"	/* RISC-V Hart Capabilities Table */
 #define ACPI_SIG_SBST           "SBST"	/* Smart Battery Specification Table */
@@ -2751,6 +2752,142 @@ enum acpi_rasf_status {
 #define ACPI_RASF_ERROR                 (1<<2)
 #define ACPI_RASF_STATUS                (0x1F<<3)
 
+/*******************************************************************************
+ *
+ * RAS2 - RAS2 Feature Table (ACPI 6.5)
+ *        Version 2
+ *
+ *
+ ******************************************************************************/
+
+struct acpi_table_ras2 {
+	struct acpi_table_header header;        /* Common ACPI table header */
+	u16 reserved;
+	u16 num_pcc_descs;
+};
+
+/*
+ * RAS2 Platform Communication Channel Descriptor
+ */
+
+struct acpi_ras2_pcc_desc {
+	u8 channel_id;
+	u16 reserved;
+	u8 feature_type;
+	u32 instance;
+};
+
+/*
+ * RAS2 Platform Communication Channel Shared Memory Region
+ */
+
+struct acpi_ras2_shared_memory {
+	u32 signature;
+	u16 command;
+	u16 status;
+	u16 version;
+	u8 features[16];
+	u8 set_capabilities[16];
+	u16 num_parameter_blocks;
+	u32 set_capabilities_status;
+};
+
+/* RAS2 Parameter Block Structure Header */
+
+struct acpi_ras2_parameter_block {
+	u16 type;
+	u16 version;
+	u16 length;
+};
+
+/*
+ * RAS2 Parameter Block Structure for PATROL_SCRUB
+ */
+
+struct acpi_ras2_patrol_scrub_parameter {
+	struct acpi_ras2_parameter_block header;
+	u16 patrol_scrub_command;
+	u64 requested_address_range[2];
+	u64 actual_address_range[2];
+	u32 flags;
+	u32 scrub_params_out;
+	u32 scrub_params_in;
+};
+
+/* Masks for Flags field above */
+
+#define ACPI_RAS2_SCRUBBER_RUNNING      1
+
+/*
+ * RAS2 Parameter Block Structure for LA2PA_TRANSLATION
+ */
+
+struct acpi_ras2_la2pa_translation_parameter {
+	struct acpi_ras2_parameter_block header;
+	u16 addr_translation_command;
+	u64 sub_instance_id;
+	u64 logical_address;
+	u64 physical_address;
+	u32 status;
+};
+
+/* Channel Commands */
+
+enum acpi_ras2_commands {
+	ACPI_RAS2_EXECUTE_RAS2_COMMAND = 1
+};
+
+/* Platform RAS2 Features */
+
+enum acpi_ras2_features {
+	ACPI_RAS2_PATROL_SCRUB_SUPPORTED = 0,
+	ACPI_RAS2_LA2PA_TRANSLATION = 1
+};
+
+/* RAS2 Patrol Scrub Commands */
+
+enum acpi_ras2_patrol_scrub_commands {
+	ACPI_RAS2_GET_PATROL_PARAMETERS = 1,
+	ACPI_RAS2_START_PATROL_SCRUBBER = 2,
+	ACPI_RAS2_STOP_PATROL_SCRUBBER = 3
+};
+
+/* RAS2 LA2PA Translation Commands */
+
+enum acpi_ras2_la2pa_translation_commands {
+	ACPI_RAS2_GET_LA2PA_TRANSLATION = 1
+};
+
+/* RAS2 LA2PA Translation Status values */
+
+enum acpi_ras2_la2pa_translation_status {
+	ACPI_RAS2_LA2PA_TRANSLATION_SUCCESS = 0,
+	ACPI_RAS2_LA2PA_TRANSLATION_FAIL = 1
+};
+
+/* Channel Command flags */
+
+#define ACPI_RAS2_GENERATE_SCI          (1<<15)
+
+/* Status values */
+
+enum acpi_ras2_status {
+	ACPI_RAS2_SUCCESS = 0,
+	ACPI_RAS2_NOT_VALID  = 1,
+	ACPI_RAS2_NOT_SUPPORTED = 2,
+	ACPI_RAS2_BUSY = 3,
+	ACPI_RAS2_FAILED = 4,
+	ACPI_RAS2_ABORTED = 5,
+	ACPI_RAS2_INVALID_DATA = 6
+};
+
+/* Status flags */
+
+#define ACPI_RAS2_COMMAND_COMPLETE      (1)
+#define ACPI_RAS2_SCI_DOORBELL          (1<<1)
+#define ACPI_RAS2_ERROR                 (1<<2)
+#define ACPI_RAS2_STATUS                (0x1F<<3)
+
 /*******************************************************************************
  *
  * RGRT - Regulatory Graphics Resource Table
-- 
2.34.1


From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id CE783224CE;
	Fri, 23 Feb 2024 14:37:45 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=none smtp.client-ip=185.176.79.56
ARC-Seal: i=1; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1708699068; cv=none; b=o71kfP3xvwVPbjZgYWwffPIDBLel68PbGEyGGbUtOd08MZeL6khGDYMidFoy3gz6XYI74mAOys9BqA45vlO/FXiEN8k58Fg8Un1p5zYAS5nlAkzMXCHxzZjqQRnsle3/42DSL5jRtAvh+/lhWXB4teGz66x4T1O1oZJt6N7yO0g=
ARC-Message-Signature: i=1; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1708699068; c=relaxed/simple;
	bh=XVi0maVuiogDBDfKVbIQ89BIxmQt5lblSNwWWLxTDH8=;
	h=From:To:CC:Subject:Date:Message-ID:In-Reply-To:References:
	 MIME-Version:Content-Type; b=MSaGRLHEKUXGnGD7p1zTwA98Te5IoQtgUkLzUpc+lxz8XbxD/kCVqE6/26pvN5Z/O8CpwSKNJ3i05I1uAeLNnQDokWVxKkPAKAp84uYQWYji0vGmPvc4iCRyKFcBlKf0HcmsmgnIg5PqjPvwwmst1vNBmismUp5ZJoNO7E1H2bM=
ARC-Authentication-Results: i=1; smtp.subspace.kernel.org; dmarc=pass (p=quarantine dis=none) header.from=huawei.com; spf=pass smtp.mailfrom=huawei.com; arc=none smtp.client-ip=185.176.79.56
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=quarantine dis=none) header.from=huawei.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=huawei.com
Received: from mail.maildlp.com (unknown [172.18.186.231])
	by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4ThCDG0Hlcz6JB0V;
	Fri, 23 Feb 2024 22:33:18 +0800 (CST)
Received: from lhrpeml500006.china.huawei.com (unknown [7.191.161.198])
	by mail.maildlp.com (Postfix) with ESMTPS id AA539140B33;
	Fri, 23 Feb 2024 22:37:43 +0800 (CST)
Received: from SecurePC30232.china.huawei.com (10.122.247.234) by
 lhrpeml500006.china.huawei.com (7.191.161.198) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.35; Fri, 23 Feb 2024 14:37:42 +0000
From: <shiju.jose@huawei.com>
To: <linux-cxl@vger.kernel.org>, <linux-acpi@vger.kernel.org>,
	<linux-mm@kvack.org>, <dan.j.williams@intel.com>, <dave@stgolabs.net>,
	<jonathan.cameron@huawei.com>, <dave.jiang@intel.com>,
	<alison.schofield@intel.com>, <vishal.l.verma@intel.com>,
	<ira.weiny@intel.com>
CC: <linux-edac@vger.kernel.org>, <linux-kernel@vger.kernel.org>,
	<david@redhat.com>, <Vilas.Sridharan@amd.com>, <leo.duran@amd.com>,
	<Yazen.Ghannam@amd.com>, <rientjes@google.com>, <jiaqiyan@google.com>,
	<tony.luck@intel.com>, <Jon.Grimm@amd.com>, <dave.hansen@linux.intel.com>,
	<rafael@kernel.org>, <lenb@kernel.org>, <naoya.horiguchi@nec.com>,
	<james.morse@arm.com>, <jthoughton@google.com>, <somasundaram.a@hpe.com>,
	<erdemaktas@google.com>, <pgonda@google.com>, <duenwen@google.com>,
	<mike.malvestuto@intel.com>, <gthelen@google.com>,
	<wschwartz@amperecomputing.com>, <dferguson@amperecomputing.com>,
	<tanxiaofei@huawei.com>, <prime.zeng@hisilicon.com>,
	<kangkang.shen@futurewei.com>, <wanghuiqiang@huawei.com>,
	<linuxarm@huawei.com>, <shiju.jose@huawei.com>
Subject: [RFC PATCH v7 06/12] memory: scrub: Add scrub subsystem driver supports configuring memory scrubs in the system
Date: Fri, 23 Feb 2024 22:37:17 +0800
Message-ID: <20240223143723.1574-7-shiju.jose@huawei.com>
X-Mailer: git-send-email 2.35.1.windows.2
In-Reply-To: <20240223143723.1574-1-shiju.jose@huawei.com>
References: <20240223143723.1574-1-shiju.jose@huawei.com>
Precedence: bulk
X-Mailing-List: linux-kernel@vger.kernel.org
List-Id: <linux-kernel.vger.kernel.org>
List-Subscribe: <mailto:linux-kernel+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:linux-kernel+unsubscribe@vger.kernel.org>
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
Content-Type: text/plain
X-ClientProxiedBy: lhrpeml500003.china.huawei.com (7.191.162.67) To
 lhrpeml500006.china.huawei.com (7.191.161.198)

From: Shiju Jose <shiju.jose@huawei.com>

Add scrub driver supports configuring the memory scrubs in the system.
The scrub driver provides the interface for registering the scrub devices
and supports configuring memory scrubs in the system.
Driver exposes the sysfs scrub control attributes to the user in
/sys/class/scrub/scrubX/regionN/

ToDo: The unit of the scrub rate may vary depends on the scrub
      devices, feedback is to either standardise it or provide
      an interface for it to the userspace. 

Signed-off-by: Shiju Jose <shiju.jose@huawei.com>
---
 .../ABI/testing/sysfs-class-scrub-configure   |  91 +++++
 drivers/memory/Kconfig                        |   1 +
 drivers/memory/Makefile                       |   1 +
 drivers/memory/scrub/Kconfig                  |  11 +
 drivers/memory/scrub/Makefile                 |   6 +
 drivers/memory/scrub/memory-scrub.c           | 369 ++++++++++++++++++
 include/memory/memory-scrub.h                 |  79 ++++
 7 files changed, 558 insertions(+)
 create mode 100644 Documentation/ABI/testing/sysfs-class-scrub-configure
 create mode 100644 drivers/memory/scrub/Kconfig
 create mode 100644 drivers/memory/scrub/Makefile
 create mode 100755 drivers/memory/scrub/memory-scrub.c
 create mode 100755 include/memory/memory-scrub.h

diff --git a/Documentation/ABI/testing/sysfs-class-scrub-configure b/Documentation/ABI/testing/sysfs-class-scrub-configure
new file mode 100644
index 000000000000..d2d422b667cf
--- /dev/null
+++ b/Documentation/ABI/testing/sysfs-class-scrub-configure
@@ -0,0 +1,91 @@
+What:		/sys/class/scrub/
+Date:		January 2024
+KernelVersion:	6.8
+Contact:	linux-kernel@vger.kernel.org
+Description:
+		The scrub/ class subdirectory belongs to the
+		scrubber subsystem.
+
+What:		/sys/class/scrub/scrubX/
+Date:		January 2024
+KernelVersion:	6.8
+Contact:	linux-kernel@vger.kernel.org
+Description:
+		The /sys/class/scrub/scrub{0,1,2,3,...} directories
+		correspond to each scrub device.
+
+What:		/sys/class/scrub/scrubX/name
+Date:		January 2024
+KernelVersion:	6.8
+Contact:	linux-kernel@vger.kernel.org
+Description:
+		(RO) name of the memory scrub device
+
+What:		/sys/class/scrub/scrubX/regionN/
+Date:		January 2024
+KernelVersion:	6.8
+Contact:	linux-kernel@vger.kernel.org
+Description:
+		The /sys/class/scrub/scrubX/region{0,1,2,3,...}
+		directories correspond to each scrub region under a scrub device.
+		Scrub region is a physical address range for which scrub may be
+		separately controlled. Regions may overlap in which case the
+		scrubbing rate of the overlapped memory will be at least that
+		expected due to each overlapping region.
+
+What:		/sys/class/scrub/scrubX/regionN/addr_base
+Date:		January 2024
+KernelVersion:	6.8
+Contact:	linux-kernel@vger.kernel.org
+Description:
+		(RW) The base of the address range of the memory region
+		to be scrubbed.
+		On reading, returns the base of the memory region for
+		the actual address range(The platform calculates
+		the nearest patrol scrub boundary address from where
+		it can start scrub).
+
+What:		/sys/class/scrub/scrubX/regionN/addr_size
+Date:		January 2024
+KernelVersion:	6.8
+Contact:	linux-kernel@vger.kernel.org
+Description:
+		(RW) The size of the address range to be scrubbed.
+		On reading, returns the size of the memory region for
+		the actual address range.
+
+What:		/sys/class/scrub/scrubX/regionN/enable
+Date:		January 2024
+KernelVersion:	6.8
+Contact:	linux-kernel@vger.kernel.org
+Description:
+		(WO) Enable/Disable scrub the memory region.
+		1 - enable the memory scrub.
+		0 - disable the memory scrub.
+
+What:		/sys/class/scrub/scrubX/regionN/enable_background_scrub
+Date:		January 2024
+KernelVersion:	6.8
+Contact:	linux-kernel@vger.kernel.org
+Description:
+		(WO) Enable/Disable background scrubbing if supported.
+		1 - enable background scrubbing.
+		0 - disable background scrubbing.
+
+What:		/sys/class/scrub/scrubX/regionN/rate_available
+Date:		January 2024
+KernelVersion:	6.8
+Contact:	linux-kernel@vger.kernel.org
+Description:
+		(RO) Supported range for the scrub rate)
+		by the scrubber for a memory region.
+		The unit of the scrub rate vary depends on the scrub.
+
+What:		/sys/class/scrub/scrubX/regionN/rate
+Date:		January 2024
+KernelVersion:	6.8
+Contact:	linux-kernel@vger.kernel.org
+Description:
+		(RW) The scrub rate in the memory region specified
+		and it must be with in the supported range by the scrub.
+		The unit of the scrub rate vary depends on the scrub.
diff --git a/drivers/memory/Kconfig b/drivers/memory/Kconfig
index 8efdd1f97139..d2e015c09d83 100644
--- a/drivers/memory/Kconfig
+++ b/drivers/memory/Kconfig
@@ -227,5 +227,6 @@ config STM32_FMC2_EBI
 
 source "drivers/memory/samsung/Kconfig"
 source "drivers/memory/tegra/Kconfig"
+source "drivers/memory/scrub/Kconfig"
 
 endif
diff --git a/drivers/memory/Makefile b/drivers/memory/Makefile
index d2e6ca9abbe0..4b37312cb342 100644
--- a/drivers/memory/Makefile
+++ b/drivers/memory/Makefile
@@ -27,6 +27,7 @@ obj-$(CONFIG_STM32_FMC2_EBI)	+= stm32-fmc2-ebi.o
 
 obj-$(CONFIG_SAMSUNG_MC)	+= samsung/
 obj-$(CONFIG_TEGRA_MC)		+= tegra/
+obj-$(CONFIG_SCRUB)		+= scrub/
 obj-$(CONFIG_TI_EMIF_SRAM)	+= ti-emif-sram.o
 obj-$(CONFIG_FPGA_DFL_EMIF)	+= dfl-emif.o
 
diff --git a/drivers/memory/scrub/Kconfig b/drivers/memory/scrub/Kconfig
new file mode 100644
index 000000000000..fa7d68f53a69
--- /dev/null
+++ b/drivers/memory/scrub/Kconfig
@@ -0,0 +1,11 @@
+# SPDX-License-Identifier: GPL-2.0-only
+#
+# Memory scrub driver configurations
+#
+
+config SCRUB
+	bool "Memory scrub driver"
+	help
+	  This option selects the memory scrub subsystem, supports
+	  configuring the parameters of underlying scrubbers in the
+	  system for the DRAM memories.
diff --git a/drivers/memory/scrub/Makefile b/drivers/memory/scrub/Makefile
new file mode 100644
index 000000000000..1b677132ca13
--- /dev/null
+++ b/drivers/memory/scrub/Makefile
@@ -0,0 +1,6 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Makefile for memory scrub drivers
+#
+
+obj-$(CONFIG_SCRUB)		+= memory-scrub.o
diff --git a/drivers/memory/scrub/memory-scrub.c b/drivers/memory/scrub/memory-scrub.c
new file mode 100755
index 000000000000..99ecc784baa1
--- /dev/null
+++ b/drivers/memory/scrub/memory-scrub.c
@@ -0,0 +1,369 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Memory scrub driver supports configuring
+ * the memory scrubs.
+ *
+ * Copyright (c) 2023 HiSilicon Limited.
+ */
+
+#define pr_fmt(fmt)     "MEM SCRUB: " fmt
+
+#include <linux/acpi.h>
+#include <linux/bitops.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/kfifo.h>
+#include <linux/spinlock.h>
+#include <memory/memory-scrub.h>
+
+/* memory scrubber config definitions */
+#define SCRUB_ID_PREFIX "scrub"
+#define SCRUB_ID_FORMAT SCRUB_ID_PREFIX "%d"
+#define SCRUB_DEV_MAX_NAME_LENGTH	128
+#define SCRUB_MAX_SYSFS_ATTR_NAME_LENGTH	64
+
+static DEFINE_IDA(scrub_ida);
+
+struct scrub_device {
+	char name[SCRUB_DEV_MAX_NAME_LENGTH];
+	int id;
+	struct device dev;
+	char region_name[SCRUB_MAX_SYSFS_ATTR_NAME_LENGTH];
+	int region_id;
+	struct attribute_group group;
+	const struct attribute_group *groups[2];
+	const struct scrub_ops *ops;
+};
+
+#define to_scrub_device(d) container_of(d, struct scrub_device, dev)
+
+static ssize_t name_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%s\n", to_scrub_device(dev)->name);
+}
+static DEVICE_ATTR_RO(name);
+
+static struct attribute *scrub_dev_attrs[] = {
+	&dev_attr_name.attr,
+	NULL
+};
+
+static umode_t scrub_dev_attr_is_visible(struct kobject *kobj,
+					 struct attribute *attr, int n)
+{
+	if (attr != &dev_attr_name.attr)
+		return 0;
+
+	return attr->mode;
+}
+
+static const struct attribute_group scrub_dev_attr_group = {
+	.attrs		= scrub_dev_attrs,
+	.is_visible	= scrub_dev_attr_is_visible,
+};
+
+static const struct attribute_group *scrub_dev_attr_groups[] = {
+	&scrub_dev_attr_group,
+	NULL
+};
+
+static void scrub_dev_release(struct device *dev)
+{
+	struct scrub_device *scrub_dev = to_scrub_device(dev);
+
+	ida_free(&scrub_ida, scrub_dev->id);
+	kfree(scrub_dev);
+}
+
+static struct class scrub_class = {
+	.name = "scrub",
+	.dev_groups = scrub_dev_attr_groups,
+	.dev_release = scrub_dev_release,
+};
+
+static umode_t scrub_attr_visible(struct kobject *kobj,
+				  struct attribute *a, int attr_id)
+{
+	struct device *dev = kobj_to_dev(kobj);
+	struct scrub_device *scrub_dev = to_scrub_device(dev);
+	int region_id = scrub_dev->region_id;
+
+	if (!scrub_dev->ops)
+		return 0;
+
+	return scrub_dev->ops->is_visible(dev, attr_id, a->mode, region_id);
+}
+
+static ssize_t scrub_attr_show(struct device *dev, int attr_id,
+			       char *buf)
+{
+	struct scrub_device *scrub_dev = to_scrub_device(dev);
+	int region_id = scrub_dev->region_id;
+	int ret;
+	u64 val;
+
+	ret = scrub_dev->ops->read(dev, attr_id, region_id, &val);
+	if (ret < 0)
+		return ret;
+
+	return sprintf(buf, "%lld\n", val);
+}
+
+static ssize_t scrub_attr_show_hex(struct device *dev, int attr_id,
+				   char *buf)
+{
+	struct scrub_device *scrub_dev = to_scrub_device(dev);
+	int region_id = scrub_dev->region_id;
+	int ret;
+	u64 val;
+
+	ret = scrub_dev->ops->read(dev, attr_id, region_id, &val);
+	if (ret < 0)
+		return ret;
+
+	return sprintf(buf, "0x%llx\n", val);
+}
+
+static ssize_t scrub_attr_show_string(struct device *dev, int attr_id,
+				      char *buf)
+{
+	struct scrub_device *scrub_dev = to_scrub_device(dev);
+	int region_id = scrub_dev->region_id;
+	int ret;
+
+	ret = scrub_dev->ops->read_string(dev, attr_id, region_id, buf);
+	if (ret < 0)
+		return ret;
+
+	return strlen(buf);
+}
+
+static ssize_t scrub_attr_store(struct device *dev, int attr_id,
+				const char *buf, size_t count)
+{
+	struct scrub_device *scrub_dev = to_scrub_device(dev);
+	int region_id = scrub_dev->region_id;
+	long val;
+	int ret;
+
+	ret = kstrtol(buf, 10, &val);
+	if (ret < 0)
+		return ret;
+
+	ret = scrub_dev->ops->write(dev, attr_id, region_id, val);
+	if (ret < 0)
+		return ret;
+
+	return count;
+}
+
+static ssize_t scrub_attr_store_hex(struct device *dev, int attr_id,
+				    const char *buf, size_t count)
+{
+	struct scrub_device *scrub_dev = to_scrub_device(dev);
+	int region_id = scrub_dev->region_id;
+	int ret;
+	u64 val;
+
+	ret = kstrtou64(buf, 16, &val);
+	if (ret < 0)
+		return ret;
+
+	ret = scrub_dev->ops->write(dev, attr_id, region_id, val);
+	if (ret < 0)
+		return ret;
+
+	return count;
+}
+
+static ssize_t show_scrub_attr(struct device *dev, char *buf, int attr_id)
+{
+	switch (attr_id) {
+	case scrub_addr_base:
+	case scrub_addr_size:
+		return scrub_attr_show_hex(dev, attr_id, buf);
+	case scrub_enable:
+	case scrub_rate:
+		return scrub_attr_show(dev, attr_id, buf);
+	case scrub_rate_available:
+		return scrub_attr_show_string(dev, attr_id, buf);
+	}
+
+	return -EOPNOTSUPP;
+}
+
+static ssize_t store_scrub_attr(struct device *dev, const char *buf,
+				size_t count, int attr_id)
+{
+	switch (attr_id) {
+	case scrub_addr_base:
+	case scrub_addr_size:
+		return scrub_attr_store_hex(dev, attr_id, buf, count);
+	case scrub_enable:
+	case scrub_enable_background_scrub:
+	case scrub_rate:
+		return scrub_attr_store(dev, attr_id, buf, count);
+	}
+
+	return -EOPNOTSUPP;
+}
+
+#define SCRUB_ATTR_RW(attr)						\
+static ssize_t attr##_show(struct device *dev,				\
+			   struct device_attribute *attr, char *buf)	\
+{									\
+	return show_scrub_attr(dev, buf, (scrub_##attr));	\
+}									\
+static ssize_t attr##_store(struct device *dev,			\
+			    struct device_attribute *attr,		\
+			    const char *buf, size_t count)		\
+{									\
+	return store_scrub_attr(dev, buf, count, (scrub_##attr));\
+}									\
+static DEVICE_ATTR_RW(attr)
+
+#define SCRUB_ATTR_RO(attr)						\
+static ssize_t attr##_show(struct device *dev,				\
+			   struct device_attribute *attr, char *buf)	\
+{									\
+	return show_scrub_attr(dev, buf, (scrub_##attr));	\
+}									\
+static DEVICE_ATTR_RO(attr)
+
+#define SCRUB_ATTR_WO(attr)						\
+static ssize_t attr##_store(struct device *dev,			\
+			    struct device_attribute *attr,		\
+			    const char *buf, size_t count)		\
+{									\
+	return store_scrub_attr(dev, buf, count, (scrub_##attr));\
+}									\
+static DEVICE_ATTR_WO(attr)
+
+SCRUB_ATTR_RW(addr_base);
+SCRUB_ATTR_RW(addr_size);
+SCRUB_ATTR_RW(enable);
+SCRUB_ATTR_RW(enable_background_scrub);
+SCRUB_ATTR_RW(rate);
+SCRUB_ATTR_RO(rate_available);
+
+static struct attribute *scrub_attrs[] = {
+	&dev_attr_addr_base.attr,
+	&dev_attr_addr_size.attr,
+	&dev_attr_enable.attr,
+	&dev_attr_enable_background_scrub.attr,
+	&dev_attr_rate.attr,
+	&dev_attr_rate_available.attr,
+	NULL
+};
+
+static struct device *
+scrub_device_register(struct device *dev, const char *name, void *drvdata,
+		      const struct scrub_ops *ops,
+		      int region_id,
+		      struct attribute_group *attr_group)
+{
+	struct scrub_device *scrub_dev;
+	struct device *hdev;
+	int err;
+
+	scrub_dev = kzalloc(sizeof(*scrub_dev), GFP_KERNEL);
+	if (!scrub_dev)
+		return ERR_PTR(-ENOMEM);
+	hdev = &scrub_dev->dev;
+
+	scrub_dev->id = ida_alloc(&scrub_ida, GFP_KERNEL);
+	if (scrub_dev->id < 0) {
+		kfree(scrub_dev);
+		return ERR_PTR(-ENOMEM);
+	}
+
+	snprintf((char *)scrub_dev->region_name, SCRUB_MAX_SYSFS_ATTR_NAME_LENGTH,
+		 "region%d", region_id);
+
+	/* attr_group - external scrub attribute group if the scrub control
+	 * attributes of the scrub device are different from the common
+	 * 'scrub_attrs' defined here.
+	 */
+	if (attr_group) {
+		attr_group->name = (char *)scrub_dev->region_name;
+		scrub_dev->groups[0] = attr_group;
+	} else {
+		scrub_dev->group.name = (char *)scrub_dev->region_name;
+		scrub_dev->group.attrs = scrub_attrs;
+		scrub_dev->group.is_visible = scrub_attr_visible;
+		scrub_dev->groups[0] = &scrub_dev->group;
+		scrub_dev->ops = ops;
+	}
+	scrub_dev->region_id = region_id;
+
+	hdev->groups = scrub_dev->groups;
+	hdev->class = &scrub_class;
+	hdev->parent = dev;
+	dev_set_drvdata(hdev, drvdata);
+	dev_set_name(hdev, SCRUB_ID_FORMAT, scrub_dev->id);
+	snprintf(scrub_dev->name, SCRUB_DEV_MAX_NAME_LENGTH, "%s", name);
+	err = device_register(hdev);
+	if (err) {
+		put_device(hdev);
+		return ERR_PTR(err);
+	}
+
+	return hdev;
+}
+
+static void devm_scrub_release(void *dev)
+{
+	device_unregister(dev);
+}
+
+/**
+ * devm_scrub_device_register - register hw scrubber device
+ * @dev: the parent device
+ * @name: hw scrubber name attribute
+ * @drvdata: driver data to attach to created device
+ * @ops: pointer to scrub_ops structure (optional)
+ * @region_id: region ID
+ * @attr_group: input attribute group (optional)
+ *
+ * Returns the pointer to the new device. The new device is automatically
+ * unregistered with the parent device.
+ */
+struct device *
+devm_scrub_device_register(struct device *dev, const char *name,
+			   void *drvdata,
+			   const struct scrub_ops *ops,
+			   int region_id,
+			   struct attribute_group *attr_group)
+{
+	struct device *hdev;
+	int ret;
+
+	if (!dev || !name)
+		return ERR_PTR(-EINVAL);
+
+	hdev = scrub_device_register(dev, name, drvdata, ops,
+				     region_id, attr_group);
+	if (IS_ERR(hdev))
+		return hdev;
+
+	ret = devm_add_action_or_reset(dev, devm_scrub_release, hdev);
+	if (ret)
+		return ERR_PTR(ret);
+
+	return hdev;
+}
+EXPORT_SYMBOL_GPL(devm_scrub_device_register);
+
+static int __init memory_scrub_control_init(void)
+{
+	int err;
+
+	err = class_register(&scrub_class);
+	if (err) {
+		pr_err("couldn't register memory scrub control sysfs class\n");
+		return err;
+	}
+
+	return 0;
+}
+subsys_initcall(memory_scrub_control_init);
diff --git a/include/memory/memory-scrub.h b/include/memory/memory-scrub.h
new file mode 100755
index 000000000000..1bb139d16042
--- /dev/null
+++ b/include/memory/memory-scrub.h
@@ -0,0 +1,79 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Memory scrub controller driver support to configure
+ * the controls of the memory scrub and enable.
+ *
+ * Copyright (c) 2023 HiSilicon Limited.
+ */
+
+#ifndef __MEMORY_SCRUB_H
+#define __MEMORY_SCRUB_H
+
+#include <linux/types.h>
+
+enum scrub_types {
+	scrub_common,
+	scrub_max
+};
+
+enum scrub_attributes {
+	scrub_addr_base,
+	scrub_addr_size,
+	scrub_enable,
+	scrub_enable_background_scrub,
+	scrub_rate,
+	scrub_rate_available,
+	max_attrs
+};
+
+/**
+ * struct scrub_ops - scrub device operations
+ * @is_visible: Callback to return attribute visibility. Mandatory.
+ *		Parameters are:
+ *		@dev:	pointer to hardware scrub device
+ *		@attr:	scrub attribute
+ *		@mode:  default attr mode
+ *		@region_id: memory region id
+ *		The function returns the file permissions.
+ *		If the return value is 0, no attribute will be created.
+ * @read:	Read callback for data attributes. Mandatory if readable
+ *		data attributes are present.
+ *		Parameters are:
+ *		@dev:	pointer to hardware scrub device
+ *		@attr:	scrub attribute
+ *		@region_id:
+ *			memory region id
+ *		@val:	pointer to returned value
+ *		The function returns 0 on success or a negative error number.
+ * @read_string: Read callback for string attributes. Mandatory if string
+ *		attributes are present.
+ *		Parameters are:
+ *		@dev:	pointer to hardware scrub device
+ *		@attr:	scrub attribute
+ *		@region_id:
+ *			memory region id
+ *		@buf:	pointer to buffer to copy string
+ *		The function returns 0 on success or a negative error number.
+ * @write:	Write callback for data attributes. Mandatory if writeable
+ *		data attributes are present.
+ *		Parameters are:
+ *		@dev:	pointer to hardware scrub device
+ *		@attr:	scrub attribute
+ *		@region_id:
+ *			memory region id
+ *		@val:	value to write
+ *		The function returns 0 on success or a negative error number.
+ */
+struct scrub_ops {
+	umode_t (*is_visible)(struct device *dev, u32 attr, umode_t mode, int region_id);
+	int (*read)(struct device *dev, u32 attr, int region_id, u64 *val);
+	int (*read_string)(struct device *dev, u32 attr, int region_id, char *buf);
+	int (*write)(struct device *dev, u32 attr, int region_id, u64 val);
+};
+
+struct device *
+devm_scrub_device_register(struct device *dev, const char *name,
+			   void *drvdata, const struct scrub_ops *ops,
+			   int region_id,
+			   struct attribute_group *attr_group);
+#endif /* __MEMORY_SCRUB_H */
-- 
2.34.1


From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id E2C2F80C0E;
	Fri, 23 Feb 2024 14:37:47 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=none smtp.client-ip=185.176.79.56
ARC-Seal: i=1; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1708699070; cv=none; b=XLEzDCsMD+xz2kZEjFxv9BzHZ6O1X5QlNQ1Kzo0h1/p+DnITgeI3fcfqGhesoWaB1Mc+yPKJTXf/gIPI/YoLigieOTQC8mSB/UwlCw1evCPhxsIbHyZbfkmlW+nonhH6GdDKUdtjjK+XiGLNRKM99xZO+GJsUYJNxOHORu2gj10=
ARC-Message-Signature: i=1; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1708699070; c=relaxed/simple;
	bh=HjRjQJjpaGOU/Bd4AZEvaexaL9/hGrjKwCHKesdEaNM=;
	h=From:To:CC:Subject:Date:Message-ID:In-Reply-To:References:
	 MIME-Version:Content-Type; b=erdQyr8EtObNdY0tFZbh4BPvOgI80x5H8whhA3CzuxRcC8p2xDE+jI0Ytj+HzYcBVj4SLWBEmgGMTszK3Tq9q8pMnZ+i8voxTTzdcipf2DRO9b1ELGBiNKXPibpT3bOvQLK9M3GJ8pc6Ktf8eAlBs8dW4FTlpQwwG2I/iX04pIE=
ARC-Authentication-Results: i=1; smtp.subspace.kernel.org; dmarc=pass (p=quarantine dis=none) header.from=huawei.com; spf=pass smtp.mailfrom=huawei.com; arc=none smtp.client-ip=185.176.79.56
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=quarantine dis=none) header.from=huawei.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=huawei.com
Received: from mail.maildlp.com (unknown [172.18.186.231])
	by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4ThCDc2NQZz6K5p5;
	Fri, 23 Feb 2024 22:33:36 +0800 (CST)
Received: from lhrpeml500006.china.huawei.com (unknown [7.191.161.198])
	by mail.maildlp.com (Postfix) with ESMTPS id A657C140B33;
	Fri, 23 Feb 2024 22:37:45 +0800 (CST)
Received: from SecurePC30232.china.huawei.com (10.122.247.234) by
 lhrpeml500006.china.huawei.com (7.191.161.198) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.35; Fri, 23 Feb 2024 14:37:44 +0000
From: <shiju.jose@huawei.com>
To: <linux-cxl@vger.kernel.org>, <linux-acpi@vger.kernel.org>,
	<linux-mm@kvack.org>, <dan.j.williams@intel.com>, <dave@stgolabs.net>,
	<jonathan.cameron@huawei.com>, <dave.jiang@intel.com>,
	<alison.schofield@intel.com>, <vishal.l.verma@intel.com>,
	<ira.weiny@intel.com>
CC: <linux-edac@vger.kernel.org>, <linux-kernel@vger.kernel.org>,
	<david@redhat.com>, <Vilas.Sridharan@amd.com>, <leo.duran@amd.com>,
	<Yazen.Ghannam@amd.com>, <rientjes@google.com>, <jiaqiyan@google.com>,
	<tony.luck@intel.com>, <Jon.Grimm@amd.com>, <dave.hansen@linux.intel.com>,
	<rafael@kernel.org>, <lenb@kernel.org>, <naoya.horiguchi@nec.com>,
	<james.morse@arm.com>, <jthoughton@google.com>, <somasundaram.a@hpe.com>,
	<erdemaktas@google.com>, <pgonda@google.com>, <duenwen@google.com>,
	<mike.malvestuto@intel.com>, <gthelen@google.com>,
	<wschwartz@amperecomputing.com>, <dferguson@amperecomputing.com>,
	<tanxiaofei@huawei.com>, <prime.zeng@hisilicon.com>,
	<kangkang.shen@futurewei.com>, <wanghuiqiang@huawei.com>,
	<linuxarm@huawei.com>, <shiju.jose@huawei.com>
Subject: [RFC PATCH v7 08/12] cxl/memscrub: Register CXL device ECS with scrub subsystem driver
Date: Fri, 23 Feb 2024 22:37:19 +0800
Message-ID: <20240223143723.1574-9-shiju.jose@huawei.com>
X-Mailer: git-send-email 2.35.1.windows.2
In-Reply-To: <20240223143723.1574-1-shiju.jose@huawei.com>
References: <20240223143723.1574-1-shiju.jose@huawei.com>
Precedence: bulk
X-Mailing-List: linux-kernel@vger.kernel.org
List-Id: <linux-kernel.vger.kernel.org>
List-Subscribe: <mailto:linux-kernel+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:linux-kernel+unsubscribe@vger.kernel.org>
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
Content-Type: text/plain
X-ClientProxiedBy: lhrpeml500003.china.huawei.com (7.191.162.67) To
 lhrpeml500006.china.huawei.com (7.191.161.198)

From: Shiju Jose <shiju.jose@huawei.com>

Register with the scrub subsystem driver to expose the sysfs attributes
to the user for configuring the CXL memory device's ECS feature.
Add the static CXL ECS specific attributes to support configuring the
CXL memory device ECS feature.

Signed-off-by: Shiju Jose <shiju.jose@huawei.com>
---
 .../ABI/testing/sysfs-class-cxl-ecs-configure |  79 ++++++
 drivers/cxl/core/memscrub.c                   | 251 +++++++++++++++++-
 2 files changed, 327 insertions(+), 3 deletions(-)
 create mode 100644 Documentation/ABI/testing/sysfs-class-cxl-ecs-configure

diff --git a/Documentation/ABI/testing/sysfs-class-cxl-ecs-configure b/Documentation/ABI/testing/sysfs-class-cxl-ecs-configure
new file mode 100644
index 000000000000..541b150db71c
--- /dev/null
+++ b/Documentation/ABI/testing/sysfs-class-cxl-ecs-configure
@@ -0,0 +1,79 @@
+See `Documentation/ABI/testing/sysfs-class-scrub-configure` for the
+documentation of common scrub configure directory layout (/sys/class/scrub/),
+including the attributes used for configuring the CXL patrol scrub.
+Following are the attributes defined for configuring the CXL ECS.
+
+What:		/sys/class/scrub/scrubX/regionN/ecs_log_entry_type
+Date:		February 2024
+KernelVersion:	6.8
+Contact:	linux-kernel@vger.kernel.org
+Description:
+		(RW) The log entry type of how the DDR5 ECS log is
+		reported.
+		00b - per DRAM.
+		01b - per memory media FRU.
+
+What:		/sys/class/scrub/scrubX/regionN/ecs_log_entry_type_per_dram
+Date:		February 2024
+KernelVersion:	6.8
+Contact:	linux-kernel@vger.kernel.org
+Description:
+		(RO) Returns true if current log entry type of DDR5 ECS
+		region is per DRAM.
+
+What:		/sys/class/scrub/scrubX/regionN/ecs_log_entry_type_per_memory_media
+Date:		February 2024
+KernelVersion:	6.8
+Contact:	linux-kernel@vger.kernel.org
+Description:
+		(RO) Returns true if current log entry type of DDR5 ECS
+		region is per memory media FRU.
+
+What:		/sys/class/scrub/scrubX/regionN/mode
+Date:		February 2024
+KernelVersion:	6.8
+Contact:	linux-kernel@vger.kernel.org
+Description:
+		(RW) The mode of how the DDR5 ECS counts the errors.
+		0 - ECS counts rows with errors.
+		1 - ECS counts codewords with errors.
+
+What:		/sys/class/scrub/scrubX/regionN/mode_counts_rows
+Date:		February 2024
+KernelVersion:	6.8
+Contact:	linux-kernel@vger.kernel.org
+Description:
+		(RO) Returns true if current mode of DDR5 ECS region
+		is counts rows with errors.
+
+What:		/sys/class/scrub/scrubX/regionN/mode_counts_codewords
+Date:		February 2024
+KernelVersion:	6.8
+Contact:	linux-kernel@vger.kernel.org
+Description:
+		(RO) Returns true if current mode of DDR5 ECS region
+		is counts codewords with errors.
+
+What:		/sys/class/scrub/scrubX/regionN/reset_counter
+Date:		February 2024
+KernelVersion:	6.8
+Contact:	linux-kernel@vger.kernel.org
+Description:
+		(WO) DDR5 ECS reset ECC counter.
+		0 - normal, ECC counter running actively.
+		1 - reset ECC counter to the default value.
+
+What:		/sys/class/scrub/scrubX/regionN/threshold
+Date:		February 2024
+KernelVersion:	6.8
+Contact:	linux-kernel@vger.kernel.org
+Description:
+		(RW) DDR5 ECS threshold count per GB of memory cells.
+
+What:		/sys/class/scrub/scrubX/regionN/threshold_available
+Date:		February 2024
+KernelVersion:	6.8
+Contact:	linux-kernel@vger.kernel.org
+Description:
+		(RO) Supported list of DDR5 ECS threshold count per GB of
+		memory cells.
diff --git a/drivers/cxl/core/memscrub.c b/drivers/cxl/core/memscrub.c
index b053dcb9197e..e227ea2f1508 100644
--- a/drivers/cxl/core/memscrub.c
+++ b/drivers/cxl/core/memscrub.c
@@ -558,9 +558,9 @@ cxl_mem_ecs_get_attrs(struct device *scrub_dev, int fru_id,
 	return 0;
 }
 
-static int __maybe_unused
-cxl_mem_ecs_set_attrs(struct device *scrub_dev, int fru_id,
-		      struct cxl_memdev_ecs_params *params, u8 param_type)
+static int cxl_mem_ecs_set_attrs(struct device *scrub_dev, int fru_id,
+				 struct cxl_memdev_ecs_params *params,
+				 u8 param_type)
 {
 	struct cxl_memdev *cxlmd = to_cxl_memdev(scrub_dev->parent);
 	struct cxl_dev_state *cxlds = cxlmd->cxlds;
@@ -677,8 +677,243 @@ cxl_mem_ecs_set_attrs(struct device *scrub_dev, int fru_id,
 	return 0;
 }
 
+static int cxl_mem_ecs_log_entry_type_write(struct device *dev, int region_id, long val)
+{
+	struct cxl_memdev_ecs_params params;
+	int ret;
+
+	params.log_entry_type = val;
+	ret = cxl_mem_ecs_set_attrs(dev, region_id, &params,
+				    CXL_MEMDEV_ECS_PARAM_LOG_ENTRY_TYPE);
+	if (ret) {
+		dev_err(dev->parent, "Set CXL ECS params for log entry type failed ret=%d\n",
+			ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int cxl_mem_ecs_threshold_write(struct device *dev, int region_id, long val)
+{
+	struct cxl_memdev_ecs_params params;
+	int ret;
+
+	params.threshold = val;
+	ret = cxl_mem_ecs_set_attrs(dev, region_id, &params,
+				    CXL_MEMDEV_ECS_PARAM_THRESHOLD);
+	if (ret) {
+		dev_err(dev->parent, "Set CXL ECS params for threshold failed ret=%d\n",
+			ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int cxl_mem_ecs_mode_write(struct device *dev, int region_id, long val)
+{
+	struct cxl_memdev_ecs_params params;
+	int ret;
+
+	params.mode = val;
+	ret = cxl_mem_ecs_set_attrs(dev, region_id, &params,
+				    CXL_MEMDEV_ECS_PARAM_MODE);
+	if (ret) {
+		dev_err(dev->parent, "Set CXL ECS params for mode failed ret=%d\n",
+			ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int cxl_mem_ecs_reset_counter_write(struct device *dev, int region_id, long val)
+{
+	struct cxl_memdev_ecs_params params;
+	int ret;
+
+	params.reset_counter = val;
+	ret = cxl_mem_ecs_set_attrs(dev, region_id, &params,
+				    CXL_MEMDEV_ECS_PARAM_RESET_COUNTER);
+	if (ret) {
+		dev_err(dev->parent, "Set CXL ECS params for reset ECC counter failed ret=%d\n",
+			ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+enum cxl_mem_ecs_scrub_attributes {
+	cxl_ecs_log_entry_type,
+	cxl_ecs_log_entry_type_per_dram,
+	cxl_ecs_log_entry_type_per_memory_media,
+	cxl_ecs_mode,
+	cxl_ecs_mode_counts_codewords,
+	cxl_ecs_mode_counts_rows,
+	cxl_ecs_reset,
+	cxl_ecs_threshold,
+	cxl_ecs_threshold_available,
+	cxl_ecs_max_attrs
+};
+
+static ssize_t cxl_mem_ecs_show_scrub_attr(struct device *dev, char *buf,
+					   int attr_id)
+{
+	struct cxl_ecs_context *cxl_ecs_ctx = dev_get_drvdata(dev);
+	int region_id = cxl_ecs_ctx->region_id;
+	struct cxl_memdev_ecs_params params;
+	int ret;
+
+	if (attr_id == cxl_ecs_log_entry_type ||
+	    attr_id == cxl_ecs_log_entry_type_per_dram ||
+	    attr_id == cxl_ecs_log_entry_type_per_memory_media ||
+	    attr_id == cxl_ecs_mode ||
+	    attr_id == cxl_ecs_mode_counts_codewords ||
+	    attr_id == cxl_ecs_mode_counts_rows ||
+	    attr_id == cxl_ecs_threshold) {
+		ret = cxl_mem_ecs_get_attrs(dev, region_id, &params);
+		if (ret) {
+			dev_err(dev->parent, "Get CXL ECS params failed ret=%d\n", ret);
+			return ret;
+		}
+	}
+	switch (attr_id) {
+	case cxl_ecs_log_entry_type:
+		return sprintf(buf, "%d\n", params.log_entry_type);
+	case cxl_ecs_log_entry_type_per_dram:
+		if (params.log_entry_type == ECS_LOG_ENTRY_TYPE_DRAM)
+			return sysfs_emit(buf, "1\n");
+		else
+			return sysfs_emit(buf, "0\n");
+	case cxl_ecs_log_entry_type_per_memory_media:
+		if (params.log_entry_type == ECS_LOG_ENTRY_TYPE_MEM_MEDIA_FRU)
+			return sysfs_emit(buf, "1\n");
+		else
+			return sysfs_emit(buf, "0\n");
+	case cxl_ecs_mode:
+		return sprintf(buf, "%d\n", params.mode);
+	case cxl_ecs_mode_counts_codewords:
+		if (params.mode == ECS_MODE_COUNTS_CODEWORDS)
+			return sysfs_emit(buf, "1\n");
+		else
+			return sysfs_emit(buf, "0\n");
+	case cxl_ecs_mode_counts_rows:
+		if (params.mode == ECS_MODE_COUNTS_ROWS)
+			return sysfs_emit(buf, "1\n");
+		else
+			return sysfs_emit(buf, "0\n");
+	case cxl_ecs_threshold:
+		return sprintf(buf, "%d\n", params.threshold);
+	case cxl_ecs_threshold_available:
+		return sysfs_emit(buf, "256,1024,4096\n");
+	}
+
+	return -EOPNOTSUPP;
+}
+
+static ssize_t cxl_mem_ecs_store_scrub_attr(struct device *dev, const char *buf,
+					    size_t count, int attr_id)
+{
+	struct cxl_ecs_context *cxl_ecs_ctx = dev_get_drvdata(dev);
+	int region_id = cxl_ecs_ctx->region_id;
+	long val;
+	int ret;
+
+	ret = kstrtol(buf, 10, &val);
+	if (ret < 0)
+		return ret;
+
+	switch (attr_id) {
+	case cxl_ecs_log_entry_type:
+		ret = cxl_mem_ecs_log_entry_type_write(dev, region_id, val);
+		if (ret)
+			return -EOPNOTSUPP;
+		break;
+	case cxl_ecs_mode:
+		ret = cxl_mem_ecs_mode_write(dev, region_id, val);
+		if (ret)
+			return -EOPNOTSUPP;
+		break;
+	case cxl_ecs_reset:
+		ret = cxl_mem_ecs_reset_counter_write(dev, region_id, val);
+		if (ret)
+			return -EOPNOTSUPP;
+		break;
+	case cxl_ecs_threshold:
+		ret = cxl_mem_ecs_threshold_write(dev, region_id, val);
+		if (ret)
+			return -EOPNOTSUPP;
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return count;
+}
+
+#define CXL_ECS_SCRUB_ATTR_RW(attr)						\
+static ssize_t attr##_show(struct device *dev,				\
+			   struct device_attribute *attr, char *buf)	\
+{									\
+	return cxl_mem_ecs_show_scrub_attr(dev, buf, (cxl_ecs_##attr));	\
+}									\
+static ssize_t attr##_store(struct device *dev,			\
+			    struct device_attribute *attr,		\
+			    const char *buf, size_t count)		\
+{									\
+	return cxl_mem_ecs_store_scrub_attr(dev, buf, count, (cxl_ecs_##attr));\
+}									\
+static DEVICE_ATTR_RW(attr)
+
+#define CXL_ECS_SCRUB_ATTR_RO(attr)						\
+static ssize_t attr##_show(struct device *dev,				\
+			   struct device_attribute *attr, char *buf)	\
+{									\
+	return cxl_mem_ecs_show_scrub_attr(dev, buf, (cxl_ecs_##attr));	\
+}									\
+static DEVICE_ATTR_RO(attr)
+
+#define CXL_ECS_SCRUB_ATTR_WO(attr)						\
+static ssize_t attr##_store(struct device *dev,			\
+			    struct device_attribute *attr,		\
+			    const char *buf, size_t count)		\
+{									\
+	return cxl_mem_ecs_store_scrub_attr(dev, buf, count, (cxl_ecs_##attr));\
+}									\
+static DEVICE_ATTR_WO(attr)
+
+CXL_ECS_SCRUB_ATTR_RW(log_entry_type);
+CXL_ECS_SCRUB_ATTR_RO(log_entry_type_per_dram);
+CXL_ECS_SCRUB_ATTR_RO(log_entry_type_per_memory_media);
+CXL_ECS_SCRUB_ATTR_RW(mode);
+CXL_ECS_SCRUB_ATTR_RO(mode_counts_codewords);
+CXL_ECS_SCRUB_ATTR_RO(mode_counts_rows);
+CXL_ECS_SCRUB_ATTR_WO(reset);
+CXL_ECS_SCRUB_ATTR_RW(threshold);
+CXL_ECS_SCRUB_ATTR_RO(threshold_available);
+
+static struct attribute *cxl_mem_ecs_scrub_attrs[] = {
+	&dev_attr_log_entry_type.attr,
+	&dev_attr_log_entry_type_per_dram.attr,
+	&dev_attr_log_entry_type_per_memory_media.attr,
+	&dev_attr_mode.attr,
+	&dev_attr_mode_counts_codewords.attr,
+	&dev_attr_mode_counts_rows.attr,
+	&dev_attr_reset.attr,
+	&dev_attr_threshold.attr,
+	&dev_attr_threshold_available.attr,
+	NULL
+};
+
+static struct attribute_group cxl_mem_ecs_attr_group = {
+	.attrs = cxl_mem_ecs_scrub_attrs
+};
+
 int cxl_mem_ecs_init(struct cxl_memdev *cxlmd, int region_id)
 {
+	char scrub_name[CXL_MEMDEV_MAX_NAME_LENGTH];
 	struct cxl_mbox_supp_feat_entry feat_entry;
 	struct cxl_ecs_context *cxl_ecs_ctx;
 	int nr_media_frus;
@@ -704,6 +939,16 @@ int cxl_mem_ecs_init(struct cxl_memdev *cxlmd, int region_id)
 	cxl_ecs_ctx->set_feat_size = feat_entry.set_size;
 	cxl_ecs_ctx->region_id = region_id;
 
+	snprintf(scrub_name, sizeof(scrub_name), "%s_%s_region%d",
+		 "cxl_ecs", dev_name(&cxlmd->dev), cxl_ecs_ctx->region_id);
+	struct device *cxl_scrub_dev = devm_scrub_device_register(&cxlmd->dev,
+							scrub_name,
+							cxl_ecs_ctx, NULL,
+							cxl_ecs_ctx->region_id,
+							&cxl_mem_ecs_attr_group);
+	if (IS_ERR(cxl_scrub_dev))
+		return PTR_ERR(cxl_scrub_dev);
+
 	return 0;
 }
 EXPORT_SYMBOL_NS_GPL(cxl_mem_ecs_init, CXL);
-- 
2.34.1


From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id DAB0D82871;
	Fri, 23 Feb 2024 14:37:50 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=none smtp.client-ip=185.176.79.56
ARC-Seal: i=1; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1708699072; cv=none; b=OEX5OHqRNueLtMvOifRYStVaAxEiaT+lro3MzRFnazHkUNJj+bNpYYG69L1AZE/H4ztAs/0DnfNEQx3x6wWfQTP63qHHVdML9IVOpMtF93yzCblis8AptD814ITxbhAI82rBrkpLV7dDwmTu/9utYa7S3AVVMeIgnox1yUVq8l4=
ARC-Message-Signature: i=1; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1708699072; c=relaxed/simple;
	bh=raPgUodaldD9KuFpvmwyvYiVBzI0yurRJQDZ5oEOQ7c=;
	h=From:To:CC:Subject:Date:Message-ID:In-Reply-To:References:
	 MIME-Version:Content-Type; b=Vp4w78HU2ebm/aVoVqUpABPskFDNk9MeM2VaXyb30FvQOdGKSEwbPosM+MLQJa3bG3r/MJiNaRD1NB+nRhOO79eMmIM/2gfqU7TOhFtGmQYYKNk/R6DiwFU06YnIdvU+VNJiwinqlkZXqGYy4IgEWLiWqC9A3dk+O5O09DQLE48=
ARC-Authentication-Results: i=1; smtp.subspace.kernel.org; dmarc=pass (p=quarantine dis=none) header.from=huawei.com; spf=pass smtp.mailfrom=huawei.com; arc=none smtp.client-ip=185.176.79.56
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=quarantine dis=none) header.from=huawei.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=huawei.com
Received: from mail.maildlp.com (unknown [172.18.186.216])
	by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4ThCDg2Jg0z6K5ts;
	Fri, 23 Feb 2024 22:33:39 +0800 (CST)
Received: from lhrpeml500006.china.huawei.com (unknown [7.191.161.198])
	by mail.maildlp.com (Postfix) with ESMTPS id A19ED140D26;
	Fri, 23 Feb 2024 22:37:48 +0800 (CST)
Received: from SecurePC30232.china.huawei.com (10.122.247.234) by
 lhrpeml500006.china.huawei.com (7.191.161.198) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.35; Fri, 23 Feb 2024 14:37:47 +0000
From: <shiju.jose@huawei.com>
To: <linux-cxl@vger.kernel.org>, <linux-acpi@vger.kernel.org>,
	<linux-mm@kvack.org>, <dan.j.williams@intel.com>, <dave@stgolabs.net>,
	<jonathan.cameron@huawei.com>, <dave.jiang@intel.com>,
	<alison.schofield@intel.com>, <vishal.l.verma@intel.com>,
	<ira.weiny@intel.com>
CC: <linux-edac@vger.kernel.org>, <linux-kernel@vger.kernel.org>,
	<david@redhat.com>, <Vilas.Sridharan@amd.com>, <leo.duran@amd.com>,
	<Yazen.Ghannam@amd.com>, <rientjes@google.com>, <jiaqiyan@google.com>,
	<tony.luck@intel.com>, <Jon.Grimm@amd.com>, <dave.hansen@linux.intel.com>,
	<rafael@kernel.org>, <lenb@kernel.org>, <naoya.horiguchi@nec.com>,
	<james.morse@arm.com>, <jthoughton@google.com>, <somasundaram.a@hpe.com>,
	<erdemaktas@google.com>, <pgonda@google.com>, <duenwen@google.com>,
	<mike.malvestuto@intel.com>, <gthelen@google.com>,
	<wschwartz@amperecomputing.com>, <dferguson@amperecomputing.com>,
	<tanxiaofei@huawei.com>, <prime.zeng@hisilicon.com>,
	<kangkang.shen@futurewei.com>, <wanghuiqiang@huawei.com>,
	<linuxarm@huawei.com>, <shiju.jose@huawei.com>
Subject: [RFC PATCH v7 11/12] ACPI:RAS2: Add driver for ACPI RAS2 feature table (RAS2)
Date: Fri, 23 Feb 2024 22:37:22 +0800
Message-ID: <20240223143723.1574-12-shiju.jose@huawei.com>
X-Mailer: git-send-email 2.35.1.windows.2
In-Reply-To: <20240223143723.1574-1-shiju.jose@huawei.com>
References: <20240223143723.1574-1-shiju.jose@huawei.com>
Precedence: bulk
X-Mailing-List: linux-kernel@vger.kernel.org
List-Id: <linux-kernel.vger.kernel.org>
List-Subscribe: <mailto:linux-kernel+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:linux-kernel+unsubscribe@vger.kernel.org>
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
Content-Type: text/plain
X-ClientProxiedBy: lhrpeml500003.china.huawei.com (7.191.162.67) To
 lhrpeml500006.china.huawei.com (7.191.161.198)

From: Shiju Jose <shiju.jose@huawei.com>

Add support for ACPI RAS2 feature table (RAS2) defined in the ACPI 6.5
Specification, section 5.2.21.
This driver contains RAS2 Init, which extracts the RAS2 table.
Driver adds platform device, for each memory feature, which binds
to the RAS2 memory driver.

Signed-off-by: Shiju Jose <shiju.jose@huawei.com>
---
 drivers/acpi/Makefile    |  2 +-
 drivers/acpi/ras2_acpi.c | 97 ++++++++++++++++++++++++++++++++++++++++
 2 files changed, 98 insertions(+), 1 deletion(-)
 create mode 100755 drivers/acpi/ras2_acpi.c

diff --git a/drivers/acpi/Makefile b/drivers/acpi/Makefile
index b12fba9cff06..e3fd6feb3e54 100644
--- a/drivers/acpi/Makefile
+++ b/drivers/acpi/Makefile
@@ -105,7 +105,7 @@ obj-$(CONFIG_ACPI_CUSTOM_METHOD)+= custom_method.o
 obj-$(CONFIG_ACPI_BGRT)		+= bgrt.o
 obj-$(CONFIG_ACPI_CPPC_LIB)	+= cppc_acpi.o
 obj-$(CONFIG_ACPI_SPCR_TABLE)	+= spcr.o
-obj-$(CONFIG_ACPI_RAS2)		+= ras2_acpi_common.o
+obj-$(CONFIG_ACPI_RAS2)		+= ras2_acpi_common.o ras2_acpi.o
 obj-$(CONFIG_ACPI_DEBUGGER_USER) += acpi_dbg.o
 obj-$(CONFIG_ACPI_PPTT) 	+= pptt.o
 obj-$(CONFIG_ACPI_PFRUT)	+= pfr_update.o pfr_telemetry.o
diff --git a/drivers/acpi/ras2_acpi.c b/drivers/acpi/ras2_acpi.c
new file mode 100755
index 000000000000..cd2e8f5ad253
--- /dev/null
+++ b/drivers/acpi/ras2_acpi.c
@@ -0,0 +1,97 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * ras2_acpi.c - Implementation of ACPI RAS2 feature table processing
+ * functions.
+ *
+ * Copyright (c) 2023 HiSilicon Limited.
+ *
+ * Support for
+ * RAS2 - ACPI 6.5 Specification, section 5.2.21
+ *
+ * Driver contains RAS2 init, which extracts the RAS2 table and
+ * registers the PCC channel for communicating with the ACPI compliant
+ * platform that contains RAS2 command support in hardware.Driver adds
+ * platform device which binds to the RAS2 memory driver.
+ */
+
+#define pr_fmt(fmt)	"ACPI RAS2: " fmt
+
+#include <linux/export.h>
+#include <linux/delay.h>
+#include <linux/ktime.h>
+#include <linux/platform_device.h>
+#include <acpi/ras2_acpi.h>
+#include <acpi/acpixf.h>
+
+#define RAS2_FEATURE_TYPE_MEMORY        0x00
+
+static int __init ras2_acpi_init(void)
+{
+	u8 count;
+	acpi_status status;
+	acpi_size ras2_size;
+	int pcc_subspace_idx;
+	struct platform_device *pdev;
+	struct acpi_table_ras2 *pRas2Table;
+	struct acpi_ras2_pcc_desc *pcc_desc_list;
+	struct platform_device **pdev_list = NULL;
+	struct acpi_table_header *pAcpiTable = NULL;
+
+	status = acpi_get_table("RAS2", 0, &pAcpiTable);
+	if (ACPI_FAILURE(status) || !pAcpiTable) {
+		pr_err("ACPI RAS2 driver failed to initialize, get table failed\n");
+		return RAS2_FAILURE;
+	}
+
+	ras2_size = pAcpiTable->length;
+	if (ras2_size < sizeof(struct acpi_table_ras2)) {
+		pr_err("ACPI RAS2 table present but broken (too short #1)\n");
+		goto free_ras2_table;
+	}
+
+	pRas2Table = (struct acpi_table_ras2 *)pAcpiTable;
+
+	if (pRas2Table->num_pcc_descs <= 0) {
+		pr_err("ACPI RAS2 table does not contain PCC descriptors\n");
+		goto free_ras2_table;
+	}
+
+	pdev_list = kzalloc((pRas2Table->num_pcc_descs * sizeof(struct platform_device *)),
+			     GFP_KERNEL);
+	if (!pdev_list)
+		goto free_ras2_table;
+
+	pcc_desc_list = (struct acpi_ras2_pcc_desc *)
+				((void *)pRas2Table + sizeof(struct acpi_table_ras2));
+	count = 0;
+	while (count < pRas2Table->num_pcc_descs) {
+		if (pcc_desc_list->feature_type == RAS2_FEATURE_TYPE_MEMORY) {
+			pcc_subspace_idx = pcc_desc_list->channel_id;
+			/* Add the platform device and bind ras2 memory driver */
+			pdev = ras2_add_platform_device("ras2", &pcc_subspace_idx,
+							sizeof(pcc_subspace_idx));
+			if (!pdev)
+				goto free_ras2_pdev;
+			pdev_list[count] = pdev;
+		}
+		count++;
+		pcc_desc_list = pcc_desc_list + sizeof(struct acpi_ras2_pcc_desc);
+	}
+
+	acpi_put_table(pAcpiTable);
+	return RAS2_SUCCESS;
+
+free_ras2_pdev:
+	count = 0;
+	while (count < pRas2Table->num_pcc_descs) {
+		if (pcc_desc_list->feature_type ==
+				RAS2_FEATURE_TYPE_MEMORY)
+			platform_device_put(pdev_list[count++]);
+	}
+	kfree(pdev_list);
+
+free_ras2_table:
+	acpi_put_table(pAcpiTable);
+	return RAS2_FAILURE;
+}
+late_initcall(ras2_acpi_init)
-- 
2.34.1


From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id D2B432E412;
	Fri, 23 Feb 2024 14:37:49 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=none smtp.client-ip=185.176.79.56
ARC-Seal: i=1; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1708699072; cv=none; b=SQWuZpBSHNOGMIiYqYM4ChO0yoBuXRF7ma3H9PKa43wBs+eLDVUIoyHKcz8KcMU44vzrxjgEw2U74m1KsRcUwhIk4htIJzuJfR6cxJNqQFGBjbDYBqeXZ7fbb96q30vFIQ3Pm/KLZeu5yeKKo91mU8SKlKK4dlm5oxyB//i5piQ=
ARC-Message-Signature: i=1; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1708699072; c=relaxed/simple;
	bh=T0q+t3x/VkaVnw8IvMEZVDZKcyC74OoGTeGcfhG78jw=;
	h=From:To:CC:Subject:Date:Message-ID:In-Reply-To:References:
	 MIME-Version:Content-Type; b=Xhtj0zU3ZqpFz1hk8tmmwDb0HP2HiHugi0J0inbtCL/V8c6QZMbOEBGY1RBUZGKRZSEJqGNnjwATXaKEyat5yY4qYkTG3ywiogxpBUUfMQpNZqpjKX1qg+lCUbR5HCfxEH57CmwX3ygLpa29PXj8QdwZ3y9f6mfwd3VRfsNT0D4=
ARC-Authentication-Results: i=1; smtp.subspace.kernel.org; dmarc=pass (p=quarantine dis=none) header.from=huawei.com; spf=pass smtp.mailfrom=huawei.com; arc=none smtp.client-ip=185.176.79.56
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=quarantine dis=none) header.from=huawei.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=huawei.com
Received: from mail.maildlp.com (unknown [172.18.186.31])
	by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4ThCDf2QDJz6K611;
	Fri, 23 Feb 2024 22:33:38 +0800 (CST)
Received: from lhrpeml500006.china.huawei.com (unknown [7.191.161.198])
	by mail.maildlp.com (Postfix) with ESMTPS id A378F14149E;
	Fri, 23 Feb 2024 22:37:47 +0800 (CST)
Received: from SecurePC30232.china.huawei.com (10.122.247.234) by
 lhrpeml500006.china.huawei.com (7.191.161.198) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.35; Fri, 23 Feb 2024 14:37:46 +0000
From: <shiju.jose@huawei.com>
To: <linux-cxl@vger.kernel.org>, <linux-acpi@vger.kernel.org>,
	<linux-mm@kvack.org>, <dan.j.williams@intel.com>, <dave@stgolabs.net>,
	<jonathan.cameron@huawei.com>, <dave.jiang@intel.com>,
	<alison.schofield@intel.com>, <vishal.l.verma@intel.com>,
	<ira.weiny@intel.com>
CC: <linux-edac@vger.kernel.org>, <linux-kernel@vger.kernel.org>,
	<david@redhat.com>, <Vilas.Sridharan@amd.com>, <leo.duran@amd.com>,
	<Yazen.Ghannam@amd.com>, <rientjes@google.com>, <jiaqiyan@google.com>,
	<tony.luck@intel.com>, <Jon.Grimm@amd.com>, <dave.hansen@linux.intel.com>,
	<rafael@kernel.org>, <lenb@kernel.org>, <naoya.horiguchi@nec.com>,
	<james.morse@arm.com>, <jthoughton@google.com>, <somasundaram.a@hpe.com>,
	<erdemaktas@google.com>, <pgonda@google.com>, <duenwen@google.com>,
	<mike.malvestuto@intel.com>, <gthelen@google.com>,
	<wschwartz@amperecomputing.com>, <dferguson@amperecomputing.com>,
	<tanxiaofei@huawei.com>, <prime.zeng@hisilicon.com>,
	<kangkang.shen@futurewei.com>, <wanghuiqiang@huawei.com>,
	<linuxarm@huawei.com>, <shiju.jose@huawei.com>
Subject: [RFC PATCH v7 10/12] ACPI:RAS2: Add common library for RAS2 PCC interfaces
Date: Fri, 23 Feb 2024 22:37:21 +0800
Message-ID: <20240223143723.1574-11-shiju.jose@huawei.com>
X-Mailer: git-send-email 2.35.1.windows.2
In-Reply-To: <20240223143723.1574-1-shiju.jose@huawei.com>
References: <20240223143723.1574-1-shiju.jose@huawei.com>
Precedence: bulk
X-Mailing-List: linux-kernel@vger.kernel.org
List-Id: <linux-kernel.vger.kernel.org>
List-Subscribe: <mailto:linux-kernel+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:linux-kernel+unsubscribe@vger.kernel.org>
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
Content-Type: text/plain
X-ClientProxiedBy: lhrpeml500003.china.huawei.com (7.191.162.67) To
 lhrpeml500006.china.huawei.com (7.191.161.198)

From: A Somasundaram <somasundaram.a@hpe.com>

The code contains PCC interfaces for RAS2 table, functions to send
RAS2 commands as per ACPI 6.5 & upwards revision.

References for this implementation,
ACPI specification 6.5 section 5.2.21 for RAS2 table and chapter 14
for PCC (Platform Communication Channel).

Driver uses PCC interfaces to communicate to the ACPI HW. This code
implements PCC interfaces and the functions to send the RAS2 commands
to be used by OSPM.

Signed-off-by: A Somasundaram <somasundaram.a@hpe.com>
Co-developed-by: Shiju Jose <shiju.jose@huawei.com>
Signed-off-by: Shiju Jose <shiju.jose@huawei.com>
---
 drivers/acpi/Kconfig            |  14 ++
 drivers/acpi/Makefile           |   1 +
 drivers/acpi/ras2_acpi_common.c | 272 ++++++++++++++++++++++++++++++++
 include/acpi/ras2_acpi.h        |  59 +++++++
 4 files changed, 346 insertions(+)
 create mode 100755 drivers/acpi/ras2_acpi_common.c
 create mode 100644 include/acpi/ras2_acpi.h

diff --git a/drivers/acpi/Kconfig b/drivers/acpi/Kconfig
index 3c3f8037ebed..6f69c9976c4f 100644
--- a/drivers/acpi/Kconfig
+++ b/drivers/acpi/Kconfig
@@ -284,6 +284,20 @@ config ACPI_CPPC_LIB
 	  If your platform does not support CPPC in firmware,
 	  leave this option disabled.
 
+config ACPI_RAS2
+	bool "ACPI RAS2 driver"
+	depends on ACPI_PROCESSOR
+	select MAILBOX
+	select PCC
+	help
+	  The driver adds support for PCC (platform communication
+	  channel) interfaces to communicate with the ACPI complaint
+	  hardware platform supports RAS2(RAS2 Feature table).
+	  The driver adds support for RAS2(extraction of RAS2
+	  tables from OS system table), PCC interfaces and OSPM interfaces
+	  to send RAS2 commands. Driver adds platform device which
+	  binds to the RAS2 memory driver.
+
 config ACPI_PROCESSOR
 	tristate "Processor"
 	depends on X86 || ARM64 || LOONGARCH
diff --git a/drivers/acpi/Makefile b/drivers/acpi/Makefile
index 12ef8180d272..b12fba9cff06 100644
--- a/drivers/acpi/Makefile
+++ b/drivers/acpi/Makefile
@@ -105,6 +105,7 @@ obj-$(CONFIG_ACPI_CUSTOM_METHOD)+= custom_method.o
 obj-$(CONFIG_ACPI_BGRT)		+= bgrt.o
 obj-$(CONFIG_ACPI_CPPC_LIB)	+= cppc_acpi.o
 obj-$(CONFIG_ACPI_SPCR_TABLE)	+= spcr.o
+obj-$(CONFIG_ACPI_RAS2)		+= ras2_acpi_common.o
 obj-$(CONFIG_ACPI_DEBUGGER_USER) += acpi_dbg.o
 obj-$(CONFIG_ACPI_PPTT) 	+= pptt.o
 obj-$(CONFIG_ACPI_PFRUT)	+= pfr_update.o pfr_telemetry.o
diff --git a/drivers/acpi/ras2_acpi_common.c b/drivers/acpi/ras2_acpi_common.c
new file mode 100755
index 000000000000..c6e4ed96cd81
--- /dev/null
+++ b/drivers/acpi/ras2_acpi_common.c
@@ -0,0 +1,272 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * ACPI RAS2 table processing common functions
+ *
+ * (C) Copyright 2014, 2015 Hewlett-Packard Enterprises.
+ *
+ * Copyright (c) 2024 HiSilicon Limited.
+ *
+ * Support for
+ * RAS2 - ACPI 6.5 Specification, section 5.2.21
+ * PCC(Platform Communications Channel) - ACPI 6.5 Specification,
+ * chapter 14.
+ *
+ * Code contains common functions for RAS2.
+ * PCC(Platform communication channel) interfaces for the RAS2
+ * and the functions for sending RAS2 commands to the ACPI HW.
+ */
+
+#include <linux/export.h>
+#include <linux/delay.h>
+#include <linux/ktime.h>
+#include <linux/platform_device.h>
+#include <acpi/ras2_acpi.h>
+#include <acpi/acpixf.h>
+
+static int ras2_check_pcc_chan(struct ras2_context *ras2_ctx)
+{
+	struct acpi_ras2_shared_memory  __iomem *generic_comm_base = ras2_ctx->pcc_comm_addr;
+	ktime_t next_deadline = ktime_add(ktime_get(), ras2_ctx->deadline);
+
+	while (!ktime_after(ktime_get(), next_deadline)) {
+		/*
+		 * As per ACPI spec, the PCC space wil be initialized by
+		 * platform and should have set the command completion bit when
+		 * PCC can be used by OSPM
+		 */
+		if (readw_relaxed(&generic_comm_base->status) & RAS2_PCC_CMD_COMPLETE)
+			return 0;
+		/*
+		 * Reducing the bus traffic in case this loop takes longer than
+		 * a few retries.
+		 */
+		udelay(10);
+	}
+
+	return -EIO;
+}
+
+/**
+ * ras2_send_pcc_cmd() - Send RAS2 command via PCC channel
+ * @ras2_ctx:	pointer to the ras2 context structure
+ * @cmd:	command to send
+ *
+ * Returns: 0 on success, an error otherwise
+ */
+int ras2_send_pcc_cmd(struct ras2_context *ras2_ctx, u16 cmd)
+{
+	int ret;
+	struct acpi_ras2_shared_memory  *generic_comm_base =
+		(struct acpi_ras2_shared_memory *)ras2_ctx->pcc_comm_addr;
+	static ktime_t last_cmd_cmpl_time, last_mpar_reset;
+	struct mbox_chan *pcc_channel;
+	static int mpar_count;
+	unsigned int time_delta;
+
+	if (cmd == RAS2_PCC_CMD_EXEC) {
+		ret = ras2_check_pcc_chan(ras2_ctx);
+		if (ret)
+			return ret;
+	}
+	pcc_channel = ras2_ctx->pcc_chan->mchan;
+
+	/*
+	 * Handle the Minimum Request Turnaround Time(MRTT)
+	 * "The minimum amount of time that OSPM must wait after the completion
+	 * of a command before issuing the next command, in microseconds"
+	 */
+	if (ras2_ctx->pcc_mrtt) {
+		time_delta = ktime_us_delta(ktime_get(), last_cmd_cmpl_time);
+		if (ras2_ctx->pcc_mrtt > time_delta)
+			udelay(ras2_ctx->pcc_mrtt - time_delta);
+	}
+
+	/*
+	 * Handle the non-zero Maximum Periodic Access Rate(MPAR)
+	 * "The maximum number of periodic requests that the subspace channel can
+	 * support, reported in commands per minute. 0 indicates no limitation."
+	 *
+	 * This parameter should be ideally zero or large enough so that it can
+	 * handle maximum number of requests that all the cores in the system can
+	 * collectively generate. If it is not, we will follow the spec and just
+	 * not send the request to the platform after hitting the MPAR limit in
+	 * any 60s window
+	 */
+	if (ras2_ctx->pcc_mpar) {
+		if (mpar_count == 0) {
+			time_delta = ktime_ms_delta(ktime_get(), last_mpar_reset);
+			if (time_delta < 60 * MSEC_PER_SEC) {
+				dev_dbg(ras2_ctx->dev,
+					"PCC cmd not sent due to MPAR limit");
+				return -EIO;
+			}
+			last_mpar_reset = ktime_get();
+			mpar_count = ras2_ctx->pcc_mpar;
+		}
+		mpar_count--;
+	}
+
+	/* Write to the shared comm region. */
+	writew_relaxed(cmd, &generic_comm_base->command);
+
+	/* Flip CMD COMPLETE bit */
+	writew_relaxed(0, &generic_comm_base->status);
+
+	/* Ring doorbell */
+	ret = mbox_send_message(pcc_channel, &cmd);
+	if (ret < 0) {
+		dev_err(ras2_ctx->dev,
+			"Err sending PCC mbox message. cmd:%d, ret:%d\n",
+			cmd, ret);
+		return ret;
+	}
+
+	/*
+	 * For READs we need to ensure the cmd completed to ensure
+	 * the ensuing read()s can proceed. For WRITEs we dont care
+	 * because the actual write()s are done before coming here
+	 * and the next READ or WRITE will check if the channel
+	 * is busy/free at the entry of this call.
+	 *
+	 * If Minimum Request Turnaround Time is non-zero, we need
+	 * to record the completion time of both READ and WRITE
+	 * command for proper handling of MRTT, so we need to check
+	 * for pcc_mrtt in addition to CMD_READ
+	 */
+	if (cmd == RAS2_PCC_CMD_EXEC || ras2_ctx->pcc_mrtt) {
+		ret = ras2_check_pcc_chan(ras2_ctx);
+		if (ras2_ctx->pcc_mrtt)
+			last_cmd_cmpl_time = ktime_get();
+	}
+
+	if (pcc_channel->mbox->txdone_irq)
+		mbox_chan_txdone(pcc_channel, ret);
+	else
+		mbox_client_txdone(pcc_channel, ret);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(ras2_send_pcc_cmd);
+
+/**
+ * ras2_register_pcc_channel() - Register PCC channel
+ * @ras2_ctx:	pointer to the ras2 context structure
+ *
+ * Returns: 0 on success, an error otherwise
+ */
+int ras2_register_pcc_channel(struct ras2_context *ras2_ctx)
+{
+	u64 usecs_lat;
+	unsigned int len;
+	struct pcc_mbox_chan *pcc_chan;
+	struct mbox_client *ras2_mbox_cl;
+	struct acpi_pcct_hw_reduced *ras2_ss;
+
+	ras2_mbox_cl = &ras2_ctx->mbox_client;
+	if (!ras2_mbox_cl || ras2_ctx->pcc_subspace_idx < 0)
+		return -EINVAL;
+
+	pcc_chan = pcc_mbox_request_channel(ras2_mbox_cl,
+					    ras2_ctx->pcc_subspace_idx);
+
+	if (IS_ERR(pcc_chan)) {
+		dev_err(ras2_ctx->dev,
+			"Failed to find PCC channel for subspace %d\n",
+			ras2_ctx->pcc_subspace_idx);
+		return -ENODEV;
+	}
+	ras2_ctx->pcc_chan = pcc_chan;
+	/*
+	 * The PCC mailbox controller driver should
+	 * have parsed the PCCT (global table of all
+	 * PCC channels) and stored pointers to the
+	 * subspace communication region in con_priv.
+	 */
+	ras2_ss = pcc_chan->mchan->con_priv;
+
+	if (!ras2_ss) {
+		dev_err(ras2_ctx->dev, "No PCC subspace found for RAS2\n");
+		pcc_mbox_free_channel(ras2_ctx->pcc_chan);
+		return -ENODEV;
+	}
+
+	/*
+	 * This is the shared communication region
+	 * for the OS and Platform to communicate over.
+	 */
+	ras2_ctx->comm_base_addr = ras2_ss->base_address;
+	len = ras2_ss->length;
+	dev_dbg(ras2_ctx->dev, "PCC subspace for RAS2=0x%llx len=%d\n",
+		ras2_ctx->comm_base_addr, len);
+
+	/*
+	 * ras2_ss->latency is just a Nominal value. In reality
+	 * the remote processor could be much slower to reply.
+	 * So add an arbitrary amount of wait on top of Nominal.
+	 */
+	usecs_lat = RAS2_NUM_RETRIES * ras2_ss->latency;
+	ras2_ctx->deadline = ns_to_ktime(usecs_lat * NSEC_PER_USEC);
+	ras2_ctx->pcc_mrtt = ras2_ss->min_turnaround_time;
+	ras2_ctx->pcc_mpar = ras2_ss->max_access_rate;
+	ras2_ctx->pcc_comm_addr = acpi_os_ioremap(ras2_ctx->comm_base_addr,
+						  len);
+	dev_dbg(ras2_ctx->dev, "pcc_comm_addr=%p\n",
+		ras2_ctx->pcc_comm_addr);
+
+	/* Set flag so that we dont come here for each CPU. */
+	ras2_ctx->pcc_channel_acquired = true;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ras2_register_pcc_channel);
+
+/**
+ * ras2_unregister_pcc_channel() - Unregister PCC channel
+ * @ras2_ctx:	pointer to the ras2 context structure
+ *
+ * Returns: 0 on success, an error otherwise
+ */
+int ras2_unregister_pcc_channel(struct ras2_context *ras2_ctx)
+{
+	if (!ras2_ctx->pcc_chan)
+		return -EINVAL;
+
+	pcc_mbox_free_channel(ras2_ctx->pcc_chan);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ras2_unregister_pcc_channel);
+
+/**
+ * ras2_add_platform_device() - Add a platform device for RAS2
+ * @name:	name of the device we're adding
+ * @data:	platform specific data for this platform device
+ * @size:	size of platform specific data
+ *
+ * Returns: pointer to platform device on success, an error otherwise
+ */
+struct platform_device *ras2_add_platform_device(char *name, const void *data,
+						 size_t size)
+{
+	int ret;
+	struct platform_device *pdev;
+
+	pdev = platform_device_alloc(name, PLATFORM_DEVID_AUTO);
+	if (!pdev)
+		return NULL;
+
+	ret = platform_device_add_data(pdev, data, size);
+	if (ret)
+		goto dev_put;
+
+	ret = platform_device_add(pdev);
+	if (ret)
+		goto dev_put;
+
+	return pdev;
+
+dev_put:
+	platform_device_put(pdev);
+
+	return ERR_PTR(ret);
+}
diff --git a/include/acpi/ras2_acpi.h b/include/acpi/ras2_acpi.h
new file mode 100644
index 000000000000..5e9ac788670a
--- /dev/null
+++ b/include/acpi/ras2_acpi.h
@@ -0,0 +1,59 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * RAS2 ACPI driver header file
+ *
+ * (C) Copyright 2014, 2015 Hewlett-Packard Enterprises
+ *
+ * Copyright (c) 2024 HiSilicon Limited
+ */
+
+#ifndef _RAS2_ACPI_H
+#define _RAS2_ACPI_H
+
+#include <linux/acpi.h>
+#include <linux/mailbox_client.h>
+#include <linux/mailbox_controller.h>
+#include <linux/types.h>
+#include <acpi/pcc.h>
+
+#define RAS2_PCC_CMD_COMPLETE 1
+
+/* RAS2 specific PCC commands */
+#define RAS2_PCC_CMD_EXEC 0x01
+
+#define RAS2_FAILURE 0
+#define RAS2_SUCCESS 1
+
+/*
+ * Arbitrary Retries for PCC commands because the
+ * remote processor could be much slower to reply.
+ */
+#define RAS2_NUM_RETRIES 600
+
+/*
+ * Data structures for PCC communication and RAS2 table
+ */
+struct ras2_context {
+	struct device *dev;
+	int id;
+	struct mbox_client mbox_client;
+	struct pcc_mbox_chan *pcc_chan;
+	void __iomem *pcc_comm_addr;
+	u64 comm_base_addr;
+	int pcc_subspace_idx;
+	bool pcc_channel_acquired;
+	ktime_t deadline;
+	unsigned int pcc_mpar;
+	unsigned int pcc_mrtt;
+	/* Lock to provide mutually exclusive access to PCC channel */
+	spinlock_t spinlock;
+	struct device *scrub_dev;
+	const struct ras2_hw_scrub_ops *ops;
+};
+
+struct platform_device *ras2_add_platform_device(char *name, const void *data,
+						 size_t size);
+int ras2_send_pcc_cmd(struct ras2_context *ras2_ctx, u16 cmd);
+int ras2_register_pcc_channel(struct ras2_context *ras2_ctx);
+int ras2_unregister_pcc_channel(struct ras2_context *ras2_ctx);
+#endif /* _RAS2_ACPI_H */
-- 
2.34.1


From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id E93F182C88;
	Fri, 23 Feb 2024 14:37:51 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=none smtp.client-ip=185.176.79.56
ARC-Seal: i=1; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1708699074; cv=none; b=QbyUcVQpiGEP4LCDVjWVOwce6VegbVnzWRx47wBHVsQzJhc5XyOlXF1owGcPnONsy2LaqSw9WZ44g1nEbbKycJimySvWU3sVRhfXJkRZqNhKRRzMrmPGeMlQTPz+xT1woBTFWbUCXf9eeK37JYYZFmc7lobmo1e5pQvinwnS+ms=
ARC-Message-Signature: i=1; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1708699074; c=relaxed/simple;
	bh=ng2+xCoimxTpUqvHJna0QOOSNJ2dtvt8TT9sWrKV3SM=;
	h=From:To:CC:Subject:Date:Message-ID:In-Reply-To:References:
	 MIME-Version:Content-Type; b=RafnPp6svR7A22A4RSoE7GGFowB0a3rUiQ5Bb8TS5CqGQ+grX0LsgISnjPhQOSNf05vKV2xKheSGjXDCvOnN8KhaIckyhxYX+2OfQ4Q7vl9qAQWmaeHFMoWV2PCoH5vjXm7JWxzvdQr+wmKZKJCOWoNWyGoC4VYfTTjCSrbuBak=
ARC-Authentication-Results: i=1; smtp.subspace.kernel.org; dmarc=pass (p=quarantine dis=none) header.from=huawei.com; spf=pass smtp.mailfrom=huawei.com; arc=none smtp.client-ip=185.176.79.56
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=quarantine dis=none) header.from=huawei.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=huawei.com
Received: from mail.maildlp.com (unknown [172.18.186.231])
	by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4ThCDh2YZGz6K5tV;
	Fri, 23 Feb 2024 22:33:40 +0800 (CST)
Received: from lhrpeml500006.china.huawei.com (unknown [7.191.161.198])
	by mail.maildlp.com (Postfix) with ESMTPS id A53EA140B33;
	Fri, 23 Feb 2024 22:37:49 +0800 (CST)
Received: from SecurePC30232.china.huawei.com (10.122.247.234) by
 lhrpeml500006.china.huawei.com (7.191.161.198) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.35; Fri, 23 Feb 2024 14:37:48 +0000
From: <shiju.jose@huawei.com>
To: <linux-cxl@vger.kernel.org>, <linux-acpi@vger.kernel.org>,
	<linux-mm@kvack.org>, <dan.j.williams@intel.com>, <dave@stgolabs.net>,
	<jonathan.cameron@huawei.com>, <dave.jiang@intel.com>,
	<alison.schofield@intel.com>, <vishal.l.verma@intel.com>,
	<ira.weiny@intel.com>
CC: <linux-edac@vger.kernel.org>, <linux-kernel@vger.kernel.org>,
	<david@redhat.com>, <Vilas.Sridharan@amd.com>, <leo.duran@amd.com>,
	<Yazen.Ghannam@amd.com>, <rientjes@google.com>, <jiaqiyan@google.com>,
	<tony.luck@intel.com>, <Jon.Grimm@amd.com>, <dave.hansen@linux.intel.com>,
	<rafael@kernel.org>, <lenb@kernel.org>, <naoya.horiguchi@nec.com>,
	<james.morse@arm.com>, <jthoughton@google.com>, <somasundaram.a@hpe.com>,
	<erdemaktas@google.com>, <pgonda@google.com>, <duenwen@google.com>,
	<mike.malvestuto@intel.com>, <gthelen@google.com>,
	<wschwartz@amperecomputing.com>, <dferguson@amperecomputing.com>,
	<tanxiaofei@huawei.com>, <prime.zeng@hisilicon.com>,
	<kangkang.shen@futurewei.com>, <wanghuiqiang@huawei.com>,
	<linuxarm@huawei.com>, <shiju.jose@huawei.com>
Subject: [RFC PATCH v7 12/12] memory: RAS2: Add memory RAS2 driver
Date: Fri, 23 Feb 2024 22:37:23 +0800
Message-ID: <20240223143723.1574-13-shiju.jose@huawei.com>
X-Mailer: git-send-email 2.35.1.windows.2
In-Reply-To: <20240223143723.1574-1-shiju.jose@huawei.com>
References: <20240223143723.1574-1-shiju.jose@huawei.com>
Precedence: bulk
X-Mailing-List: linux-kernel@vger.kernel.org
List-Id: <linux-kernel.vger.kernel.org>
List-Subscribe: <mailto:linux-kernel+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:linux-kernel+unsubscribe@vger.kernel.org>
MIME-Version: 1.0
Content-Type: text/plain; charset="UTF-8"
Content-Transfer-Encoding: 8bit
X-ClientProxiedBy: lhrpeml500003.china.huawei.com (7.191.162.67) To
 lhrpeml500006.china.huawei.com (7.191.161.198)

From: Shiju Jose <shiju.jose@huawei.com>

Memory RAS2 driver binds to the platform device add by the ACPI RAS2
driver.
Driver registers the PCC channel for communicating with the ACPI compliant
platform that contains RAS2 command support in the hardware.

Add interface functions to support configuring the parameters of HW patrol
scrubs in the system, which exposed to the kernel via the RAS2 and PCC,
using the RAS2 commands.

Add support for RAS2 platform devices to register with scrub subsystem
driver. This enables user to configure the parameters of HW patrol scrubs,
which exposed to the kernel via the RAS2 table, through the scrub sysfs
attributes.

Open Question:
Sysfs scrub control attribute "enable_background_scrub" is added for RAS2,
based on the feedback from Bill Schwartz <wschwartz@amperecomputing.com
on v4 to enable/disable the background_scrubbing in the platform as defined in the
Configure Scrub Parameters [INPUT] field  in RAS2 Table 5.87: Parameter Block
Structure for PATROL_SCRUB.
Is it a right approach to support "enable_background_scrub" in the sysfs
scrub control?

Signed-off-by: Shiju Jose <shiju.jose@huawei.com>
---
 drivers/memory/Kconfig       |  14 ++
 drivers/memory/Makefile      |   2 +
 drivers/memory/ras2.c        | 364 +++++++++++++++++++++++++++++++++++
 drivers/memory/ras2_common.c | 282 +++++++++++++++++++++++++++
 include/memory/ras2.h        |  88 +++++++++
 5 files changed, 750 insertions(+)
 create mode 100644 drivers/memory/ras2.c
 create mode 100644 drivers/memory/ras2_common.c
 create mode 100755 include/memory/ras2.h

diff --git a/drivers/memory/Kconfig b/drivers/memory/Kconfig
index d2e015c09d83..705f346f23de 100644
--- a/drivers/memory/Kconfig
+++ b/drivers/memory/Kconfig
@@ -225,6 +225,20 @@ config STM32_FMC2_EBI
 	  devices (like SRAM, ethernet adapters, FPGAs, LCD displays, ...) on
 	  SOCs containing the FMC2 External Bus Interface.
 
+config MEM_RAS2
+	bool "Memory RAS2 driver"
+	depends on ACPI_RAS2
+	depends on SCRUB
+	help
+	  The driver bound to the platform device added by the ACPI RAS2
+	  driver. Driver registers the PCC channel for communicating with
+	  the ACPI compliant platform that contains RAS2 command support
+	  in the hardware.
+	  Registers with the scrub configure driver to provide sysfs interfaces
+	  for configuring the hw patrol scrubber in the system, which exposed
+	  via the ACPI RAS2 table and PCC. Provides the interface functions
+	  support configuring the HW patrol scrubbers in the system.
+
 source "drivers/memory/samsung/Kconfig"
 source "drivers/memory/tegra/Kconfig"
 source "drivers/memory/scrub/Kconfig"
diff --git a/drivers/memory/Makefile b/drivers/memory/Makefile
index 4b37312cb342..52afd9d2259a 100644
--- a/drivers/memory/Makefile
+++ b/drivers/memory/Makefile
@@ -7,6 +7,8 @@ obj-$(CONFIG_DDR)		+= jedec_ddr_data.o
 ifeq ($(CONFIG_DDR),y)
 obj-$(CONFIG_OF)		+= of_memory.o
 endif
+obj-$(CONFIG_MEM_RAS2)		+= ras2_common.o ras2.o
+
 obj-$(CONFIG_ARM_PL172_MPMC)	+= pl172.o
 obj-$(CONFIG_ATMEL_EBI)		+= atmel-ebi.o
 obj-$(CONFIG_BRCMSTB_DPFE)	+= brcmstb_dpfe.o
diff --git a/drivers/memory/ras2.c b/drivers/memory/ras2.c
new file mode 100644
index 000000000000..12fd1f4580d4
--- /dev/null
+++ b/drivers/memory/ras2.c
@@ -0,0 +1,364 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * ras2.c - ACPI RAS2 memory driver
+ *
+ * Copyright (c) 2023 HiSilicon Limited.
+ *
+ *  - Registers the PCC channel for communicating with the
+ *    ACPI compliant platform that contains RAS2 command
+ *    support in the hardware.
+ *  - Provides functions to configure HW patrol scrubs
+ *    in the system.
+ *  - Registers with the scrub configure driver for the
+ *    hw patrol scrub in the system, which exposed via
+ *    the ACPI RAS2 table and PCC.
+ */
+
+#define pr_fmt(fmt)	"MEMORY RAS2: " fmt
+
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/cleanup.h>
+
+#include <acpi/ras2_acpi.h>
+#include <memory/ras2.h>
+
+/* RAS2 specific definitions. */
+#define RAS2_SCRUB	"ras2_scrub"
+#define RAS2_ID_FORMAT RAS2_SCRUB "%d"
+#define RAS2_SUPPORT_HW_PARTOL_SCRUB	BIT(0)
+#define RAS2_TYPE_PATROL_SCRUB	0x0000
+
+#define RAS2_GET_PATROL_PARAMETERS	0x01
+#define	RAS2_START_PATROL_SCRUBBER	0x02
+#define	RAS2_STOP_PATROL_SCRUBBER	0x03
+
+#define RAS2_PATROL_SCRUB_RATE_VALID	BIT(0)
+#define RAS2_PATROL_SCRUB_RATE_IN_MASK	GENMASK(15, 8)
+#define RAS2_PATROL_SCRUB_EN_BACKGROUND	BIT(0)
+#define RAS2_PATROL_SCRUB_RATE_OUT_MASK	GENMASK(7, 0)
+#define RAS2_PATROL_SCRUB_MIN_RATE_OUT_MASK	GENMASK(15, 8)
+#define RAS2_PATROL_SCRUB_MAX_RATE_OUT_MASK	GENMASK(23, 16)
+
+static void ras2_tx_done(struct mbox_client *cl, void *msg, int ret)
+{
+	if (ret) {
+		dev_dbg(cl->dev, "TX did not complete: CMD sent:%x, ret:%d\n",
+			*(u16 *)msg, ret);
+	} else {
+		dev_dbg(cl->dev, "TX completed. CMD sent:%x, ret:%d\n",
+			*(u16 *)msg, ret);
+	}
+}
+
+/*
+ * The below functions are exposed to OSPM, to query, configure and
+ * initiate memory patrol scrub.
+ */
+static int ras2_is_patrol_scrub_support(struct ras2_context *ras2_ctx)
+{
+	int ret;
+	struct acpi_ras2_shared_memory  __iomem *generic_comm_base;
+
+	if (!ras2_ctx || !ras2_ctx->pcc_comm_addr)
+		return -EFAULT;
+
+	generic_comm_base = ras2_ctx->pcc_comm_addr;
+	guard(spinlock_irqsave)(&ras2_ctx->spinlock);
+	generic_comm_base->set_capabilities[0] = 0;
+
+	/* send command for reading RAS2 capabilities */
+	ret = ras2_send_pcc_cmd(ras2_ctx, RAS2_PCC_CMD_EXEC);
+	if (ret) {
+		dev_err(ras2_ctx->dev,
+			"%s: ras2_send_pcc_cmd failed\n", __func__);
+		return ret;
+	}
+
+	return generic_comm_base->features[0] & RAS2_SUPPORT_HW_PARTOL_SCRUB;
+}
+
+static int ras2_get_patrol_scrub_params(struct ras2_context *ras2_ctx,
+					struct ras2_scrub_params *params)
+{
+	int ret = 0;
+	u8  min_supp_scrub_rate, max_supp_scrub_rate;
+	struct acpi_ras2_shared_memory  __iomem *generic_comm_base;
+	struct acpi_ras2_patrol_scrub_parameter __iomem *patrol_scrub_params;
+
+	if (!ras2_ctx || !ras2_ctx->pcc_comm_addr)
+		return -EFAULT;
+
+	generic_comm_base = ras2_ctx->pcc_comm_addr;
+	patrol_scrub_params = ras2_ctx->pcc_comm_addr + sizeof(*generic_comm_base);
+
+	guard(spinlock_irqsave)(&ras2_ctx->spinlock);
+	generic_comm_base->set_capabilities[0] = RAS2_SUPPORT_HW_PARTOL_SCRUB;
+	/* send command for reading RAS2 capabilities */
+	ret = ras2_send_pcc_cmd(ras2_ctx, RAS2_PCC_CMD_EXEC);
+	if (ret) {
+		dev_err(ras2_ctx->dev,
+			"%s: ras2_send_pcc_cmd failed\n", __func__);
+		return ret;
+	}
+
+	if (!(generic_comm_base->features[0] & RAS2_SUPPORT_HW_PARTOL_SCRUB) ||
+	    !(generic_comm_base->num_parameter_blocks)) {
+		dev_err(ras2_ctx->dev,
+			"%s: Platform does not support HW Patrol Scrubber\n", __func__);
+		return -EOPNOTSUPP;
+	}
+
+	if (!patrol_scrub_params->requested_address_range[1]) {
+		dev_err(ras2_ctx->dev,
+			"%s: Invalid requested address range, \
+			requested_address_range[0]=0x%llx \
+			requested_address_range[1]=0x%llx\n",
+			__func__,
+			patrol_scrub_params->requested_address_range[0],
+			patrol_scrub_params->requested_address_range[1]);
+		return -EOPNOTSUPP;
+	}
+
+	generic_comm_base->set_capabilities[0] = RAS2_SUPPORT_HW_PARTOL_SCRUB;
+	patrol_scrub_params->header.type = RAS2_TYPE_PATROL_SCRUB;
+	patrol_scrub_params->patrol_scrub_command = RAS2_GET_PATROL_PARAMETERS;
+
+	/* send command for reading the HW patrol scrub parameters */
+	ret = ras2_send_pcc_cmd(ras2_ctx, RAS2_PCC_CMD_EXEC);
+	if (ret) {
+		dev_err(ras2_ctx->dev,
+			"%s: failed to read HW patrol scrub parameters\n",
+			__func__);
+		return ret;
+	}
+
+	/* copy output scrub parameters */
+	params->addr_base = patrol_scrub_params->actual_address_range[0];
+	params->addr_size = patrol_scrub_params->actual_address_range[1];
+	params->flags = patrol_scrub_params->flags;
+	params->rate = FIELD_GET(RAS2_PATROL_SCRUB_RATE_OUT_MASK,
+				 patrol_scrub_params->scrub_params_out);
+	min_supp_scrub_rate = FIELD_GET(RAS2_PATROL_SCRUB_MIN_RATE_OUT_MASK,
+					patrol_scrub_params->scrub_params_out);
+	max_supp_scrub_rate = FIELD_GET(RAS2_PATROL_SCRUB_MAX_RATE_OUT_MASK,
+					patrol_scrub_params->scrub_params_out);
+	snprintf(params->rate_avail, RAS2_MAX_RATE_RANGE_LENGTH,
+		 "%d-%d", min_supp_scrub_rate, max_supp_scrub_rate);
+
+	return 0;
+}
+
+static int ras2_enable_patrol_scrub(struct ras2_context *ras2_ctx, bool enable)
+{
+	int ret = 0;
+	struct ras2_scrub_params params;
+	struct acpi_ras2_shared_memory  __iomem *generic_comm_base;
+	u8 scrub_rate_to_set, min_supp_scrub_rate, max_supp_scrub_rate;
+	struct acpi_ras2_patrol_scrub_parameter __iomem *patrol_scrub_params;
+
+	if (!ras2_ctx || !ras2_ctx->pcc_comm_addr)
+		return -EFAULT;
+
+	generic_comm_base = ras2_ctx->pcc_comm_addr;
+	patrol_scrub_params = ras2_ctx->pcc_comm_addr + sizeof(*generic_comm_base);
+
+	if (enable) {
+		ret = ras2_get_patrol_scrub_params(ras2_ctx, &params);
+		if (ret)
+			return ret;
+	}
+
+	guard(spinlock_irqsave)(&ras2_ctx->spinlock);
+	generic_comm_base->set_capabilities[0] = RAS2_SUPPORT_HW_PARTOL_SCRUB;
+	patrol_scrub_params->header.type = RAS2_TYPE_PATROL_SCRUB;
+
+	if (enable) {
+		patrol_scrub_params->patrol_scrub_command = RAS2_START_PATROL_SCRUBBER;
+		patrol_scrub_params->requested_address_range[0] = params.addr_base;
+		patrol_scrub_params->requested_address_range[1] = params.addr_size;
+
+		scrub_rate_to_set = FIELD_GET(RAS2_PATROL_SCRUB_RATE_IN_MASK,
+					      patrol_scrub_params->scrub_params_in);
+		min_supp_scrub_rate = FIELD_GET(RAS2_PATROL_SCRUB_MIN_RATE_OUT_MASK,
+						patrol_scrub_params->scrub_params_out);
+		max_supp_scrub_rate = FIELD_GET(RAS2_PATROL_SCRUB_MAX_RATE_OUT_MASK,
+						patrol_scrub_params->scrub_params_out);
+		if (scrub_rate_to_set < min_supp_scrub_rate ||
+		    scrub_rate_to_set > max_supp_scrub_rate) {
+			dev_warn(ras2_ctx->dev,
+				 "patrol scrub rate to set is out of the supported range\n");
+			dev_warn(ras2_ctx->dev,
+				 "min_supp_scrub_rate=%d max_supp_scrub_rate=%d\n",
+				 min_supp_scrub_rate, max_supp_scrub_rate);
+			return -EINVAL;
+		}
+	} else {
+		patrol_scrub_params->patrol_scrub_command = RAS2_STOP_PATROL_SCRUBBER;
+	}
+
+	/* send command for enable/disable HW patrol scrub */
+	ret = ras2_send_pcc_cmd(ras2_ctx, RAS2_PCC_CMD_EXEC);
+	if (ret) {
+		pr_err("%s: failed to enable/disable the HW patrol scrub\n", __func__);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int ras2_enable_background_scrub(struct ras2_context *ras2_ctx, bool enable)
+{
+	int ret;
+	struct acpi_ras2_shared_memory  __iomem *generic_comm_base;
+	struct acpi_ras2_patrol_scrub_parameter __iomem *patrol_scrub_params;
+
+	if (!ras2_ctx || !ras2_ctx->pcc_comm_addr)
+		return -EFAULT;
+
+	generic_comm_base = ras2_ctx->pcc_comm_addr;
+	patrol_scrub_params = ras2_ctx->pcc_comm_addr + sizeof(*generic_comm_base);
+
+	guard(spinlock_irqsave)(&ras2_ctx->spinlock);
+	generic_comm_base->set_capabilities[0] = RAS2_SUPPORT_HW_PARTOL_SCRUB;
+	patrol_scrub_params->header.type = RAS2_TYPE_PATROL_SCRUB;
+	patrol_scrub_params->patrol_scrub_command = RAS2_START_PATROL_SCRUBBER;
+
+	patrol_scrub_params->scrub_params_in &= ~RAS2_PATROL_SCRUB_EN_BACKGROUND;
+	patrol_scrub_params->scrub_params_in |= FIELD_PREP(RAS2_PATROL_SCRUB_EN_BACKGROUND,
+							   enable);
+
+	/* send command for enable/disable HW patrol scrub */
+	ret = ras2_send_pcc_cmd(ras2_ctx, RAS2_PCC_CMD_EXEC);
+	if (ret) {
+		dev_err(ras2_ctx->dev,
+			"%s: failed to enable/disable background patrol scrubbing\n",
+			__func__);
+		return ret;
+	}
+
+	return 0;
+}
+static int ras2_set_patrol_scrub_params(struct ras2_context *ras2_ctx,
+					struct ras2_scrub_params *params, u8 param_type)
+{
+	struct acpi_ras2_shared_memory  __iomem *generic_comm_base;
+	struct acpi_ras2_patrol_scrub_parameter __iomem *patrol_scrub_params;
+
+	if (!ras2_ctx || !ras2_ctx->pcc_comm_addr)
+		return -EFAULT;
+
+	generic_comm_base = ras2_ctx->pcc_comm_addr;
+	patrol_scrub_params = ras2_ctx->pcc_comm_addr + sizeof(*generic_comm_base);
+
+	guard(spinlock_irqsave)(&ras2_ctx->spinlock);
+	patrol_scrub_params->header.type = RAS2_TYPE_PATROL_SCRUB;
+	if (param_type == RAS2_MEM_SCRUB_PARAM_ADDR_BASE && params->addr_base) {
+		patrol_scrub_params->requested_address_range[0] = params->addr_base;
+	} else if (param_type == RAS2_MEM_SCRUB_PARAM_ADDR_SIZE && params->addr_size) {
+		patrol_scrub_params->requested_address_range[1] = params->addr_size;
+	} else if (param_type == RAS2_MEM_SCRUB_PARAM_RATE) {
+		patrol_scrub_params->scrub_params_in &= ~RAS2_PATROL_SCRUB_RATE_IN_MASK;
+		patrol_scrub_params->scrub_params_in |= FIELD_PREP(RAS2_PATROL_SCRUB_RATE_IN_MASK,
+								   params->rate);
+	} else {
+		dev_err(ras2_ctx->dev, "Invalid patrol scrub parameter to set\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static const struct ras2_hw_scrub_ops ras2_hw_ops = {
+	.enable_scrub = ras2_enable_patrol_scrub,
+	.enable_background_scrub = ras2_enable_background_scrub,
+	.get_scrub_params = ras2_get_patrol_scrub_params,
+	.set_scrub_params = ras2_set_patrol_scrub_params,
+};
+
+static const struct scrub_ops ras2_scrub_ops = {
+	.is_visible = ras2_hw_scrub_is_visible,
+	.read = ras2_hw_scrub_read,
+	.write = ras2_hw_scrub_write,
+	.read_string = ras2_hw_scrub_read_strings,
+};
+
+static DEFINE_IDA(ras2_ida);
+
+static void devm_ras2_release(void *ctx)
+{
+	struct ras2_context *ras2_ctx = ctx;
+
+	ida_free(&ras2_ida, ras2_ctx->id);
+	ras2_unregister_pcc_channel(ras2_ctx);
+}
+
+static int ras2_probe(struct platform_device *pdev)
+{
+	int ret, id;
+	struct mbox_client *cl;
+	struct device *hw_scrub_dev;
+	struct ras2_context *ras2_ctx;
+	char scrub_name[RAS2_MAX_NAME_LENGTH];
+
+	ras2_ctx = devm_kzalloc(&pdev->dev, sizeof(*ras2_ctx), GFP_KERNEL);
+	if (!ras2_ctx)
+		return -ENOMEM;
+
+	ras2_ctx->dev = &pdev->dev;
+	ras2_ctx->ops = &ras2_hw_ops;
+	spin_lock_init(&ras2_ctx->spinlock);
+	platform_set_drvdata(pdev, ras2_ctx);
+
+	cl = &ras2_ctx->mbox_client;
+	/* Request mailbox channel */
+	cl->dev = &pdev->dev;
+	cl->tx_done = ras2_tx_done;
+	cl->knows_txdone = true;
+	ras2_ctx->pcc_subspace_idx = *((int *)pdev->dev.platform_data);
+	dev_dbg(&pdev->dev, "pcc-subspace-id=%d\n", ras2_ctx->pcc_subspace_idx);
+	ret = ras2_register_pcc_channel(ras2_ctx);
+	if (ret < 0)
+		return ret;
+
+	ret = devm_add_action_or_reset(&pdev->dev, devm_ras2_release, ras2_ctx);
+	if (ret < 0)
+		return ret;
+
+	if (ras2_is_patrol_scrub_support(ras2_ctx)) {
+		id = ida_alloc(&ras2_ida, GFP_KERNEL);
+		if (id < 0)
+			return id;
+		ras2_ctx->id = id;
+		snprintf(scrub_name, sizeof(scrub_name), "%s%d", RAS2_SCRUB, id);
+		dev_set_name(&pdev->dev, RAS2_ID_FORMAT, id);
+		hw_scrub_dev = devm_scrub_device_register(&pdev->dev, scrub_name,
+							  ras2_ctx, &ras2_scrub_ops,
+							  0, NULL);
+		if (PTR_ERR_OR_ZERO(hw_scrub_dev))
+			return PTR_ERR_OR_ZERO(hw_scrub_dev);
+	}
+	ras2_ctx->scrub_dev = hw_scrub_dev;
+
+	return 0;
+}
+
+static const struct platform_device_id ras2_id_table[] = {
+	{ .name = "ras2", },
+	{ }
+};
+MODULE_DEVICE_TABLE(platform, ras2_id_table);
+
+static struct platform_driver ras2_driver = {
+	.probe = ras2_probe,
+	.driver = {
+		.name = "ras2",
+		.suppress_bind_attrs = true,
+	},
+	.id_table = ras2_id_table,
+};
+module_driver(ras2_driver, platform_driver_register, platform_driver_unregister);
+
+MODULE_DESCRIPTION("ras2 memory driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/memory/ras2_common.c b/drivers/memory/ras2_common.c
new file mode 100644
index 000000000000..97e1852e9fd7
--- /dev/null
+++ b/drivers/memory/ras2_common.c
@@ -0,0 +1,282 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Common functions for memory RAS2 driver
+ *
+ * Copyright (c) 2024 HiSilicon Limited.
+ *
+ * This driver implements call back functions for the scrub
+ * configure driver to configure the parameters of the hw patrol
+ * scrubbers in the system, which exposed via the ACPI AS2
+ * table and PCC.
+ */
+
+#include <linux/acpi.h>
+#include <linux/io.h>
+#include <linux/interrupt.h>
+#include <linux/mailbox_controller.h>
+#include <linux/mailbox_client.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#include <acpi/ras2_acpi.h>
+#include <memory/ras2.h>
+
+static int enable_write(struct ras2_context *ras2_ctx, long val)
+{
+	int ret;
+	bool enable = val;
+
+	ret = ras2_ctx->ops->enable_scrub(ras2_ctx, enable);
+	if (ret) {
+		dev_err(ras2_ctx->dev,
+			"enable patrol scrub fail, enable=%d ret=%d\n",
+			enable, ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int enable_background_scrub_write(struct ras2_context *ras2_ctx, long val)
+{
+	int ret;
+	bool enable = val;
+
+	ret = ras2_ctx->ops->enable_background_scrub(ras2_ctx, enable);
+	if (ret) {
+		dev_err(ras2_ctx->dev,
+			"enable background patrol scrub fail, enable=%d ret=%d\n",
+			enable, ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int addr_base_read(struct ras2_context *ras2_ctx, u64 *val)
+{
+	int ret;
+	struct ras2_scrub_params params;
+
+	ret = ras2_ctx->ops->get_scrub_params(ras2_ctx, &params);
+	if (ret) {
+		dev_err(ras2_ctx->dev,
+			"get patrol scrub params fail ret=%d\n", ret);
+		return ret;
+	}
+	*val = params.addr_base;
+
+	return 0;
+}
+
+static int addr_base_write(struct ras2_context *ras2_ctx, u64 val)
+{
+	int ret;
+	struct ras2_scrub_params params;
+
+	params.addr_base = val;
+	ret = ras2_ctx->ops->set_scrub_params(ras2_ctx, &params,
+					      RAS2_MEM_SCRUB_PARAM_ADDR_BASE);
+	if (ret) {
+		dev_err(ras2_ctx->dev,
+			"set patrol scrub params for addr_base fail ret=%d\n",
+			ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int addr_size_read(struct ras2_context *ras2_ctx, u64 *val)
+{
+	int ret;
+	struct ras2_scrub_params params;
+
+	ret = ras2_ctx->ops->get_scrub_params(ras2_ctx, &params);
+	if (ret) {
+		dev_err(ras2_ctx->dev,
+			"get patrol scrub params fail ret=%d\n", ret);
+		return ret;
+	}
+	*val = params.addr_size;
+
+	return 0;
+}
+
+static int addr_size_write(struct ras2_context *ras2_ctx, u64 val)
+{
+	int ret;
+	struct ras2_scrub_params params;
+
+	params.addr_size = val;
+	ret = ras2_ctx->ops->set_scrub_params(ras2_ctx, &params,
+					      RAS2_MEM_SCRUB_PARAM_ADDR_SIZE);
+	if (ret) {
+		dev_err(ras2_ctx->dev,
+			"set patrol scrub params for addr_size fail ret=%d\n",
+			ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int rate_read(struct ras2_context *ras2_ctx, u64 *val)
+{
+	int ret;
+	struct ras2_scrub_params params;
+
+	ret = ras2_ctx->ops->get_scrub_params(ras2_ctx, &params);
+	if (ret) {
+		dev_err(ras2_ctx->dev, "get patrol scrub params fail ret=%d\n",
+			ret);
+		return ret;
+	}
+	*val = params.rate;
+
+	return 0;
+}
+
+static int rate_write(struct ras2_context *ras2_ctx, long val)
+{
+	int ret;
+	struct ras2_scrub_params params;
+
+	params.rate = val;
+	ret = ras2_ctx->ops->set_scrub_params(ras2_ctx, &params,
+					      RAS2_MEM_SCRUB_PARAM_RATE);
+	if (ret) {
+		dev_err(ras2_ctx->dev,
+			"set patrol scrub params for rate fail ret=%d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int rate_available_read(struct ras2_context *ras2_ctx, char *buf)
+{
+	int ret;
+	struct ras2_scrub_params params;
+
+	ret = ras2_ctx->ops->get_scrub_params(ras2_ctx, &params);
+	if (ret) {
+		dev_err(ras2_ctx->dev,
+			"get patrol scrub params fail ret=%d\n", ret);
+		return ret;
+	}
+
+	sprintf(buf, "%s\n", params.rate_avail);
+
+	return 0;
+}
+
+/**
+ * ras2_hw_scrub_is_visible() - Callback to return attribute visibility
+ * @drv_data: Pointer to driver-private data structure passed
+ *	      as argument to devm_scrub_device_register().
+ * @attr_id: Scrub attribute
+ * @mode: attribute's mode
+ * @region_id: ID of the memory region
+ *
+ * Returns: 0 on success, an error otherwise
+ */
+umode_t ras2_hw_scrub_is_visible(struct device *dev, u32 attr_id,
+				 umode_t mode, int region_id)
+{
+	switch (attr_id) {
+	case scrub_rate_available:
+	case scrub_enable:
+	case scrub_enable_background_scrub:
+	case scrub_addr_base:
+	case scrub_addr_size:
+	case scrub_rate:
+		return mode;
+	default:
+		return 0;
+	}
+}
+
+/**
+ * ras2_hw_scrub_read() - Read callback for data attributes
+ * @device: Pointer to scrub device
+ * @attr_id: Scrub attribute
+ * @region_id: ID of the memory region
+ * @val: Pointer to the returned data
+ *
+ * Returns: 0 on success, an error otherwise
+ */
+int ras2_hw_scrub_read(struct device *device, u32 attr_id,
+		       int region_id, u64 *val)
+{
+	struct ras2_context *ras2_ctx;
+
+	ras2_ctx = dev_get_drvdata(device);
+
+	switch (attr_id) {
+	case scrub_addr_base:
+		return addr_base_read(ras2_ctx, val);
+	case scrub_addr_size:
+		return addr_size_read(ras2_ctx, val);
+	case scrub_rate:
+		return rate_read(ras2_ctx, val);
+	default:
+		return -EOPNOTSUPP;
+	}
+}
+
+/**
+ * ras2_hw_scrub_write() - Write callback for data attributes
+ * @device: Pointer to scrub device
+ * @attr_id: Scrub attribute
+ * @region_id: ID of the memory region
+ * @val: Value to write
+ *
+ * Returns: 0 on success, an error otherwise
+ */
+int ras2_hw_scrub_write(struct device *device, u32 attr_id,
+			int region_id, u64 val)
+{
+	struct ras2_context *ras2_ctx;
+
+	ras2_ctx = dev_get_drvdata(device);
+
+	switch (attr_id) {
+	case scrub_addr_base:
+		return addr_base_write(ras2_ctx, val);
+	case scrub_addr_size:
+		return addr_size_write(ras2_ctx, val);
+	case scrub_enable:
+		return enable_write(ras2_ctx, val);
+	case scrub_enable_background_scrub:
+		return enable_background_scrub_write(ras2_ctx, val);
+	case scrub_rate:
+		return rate_write(ras2_ctx, val);
+	default:
+		return -EOPNOTSUPP;
+	}
+}
+
+/**
+ * ras2_hw_scrub_read_strings() - Read callback for string attributes
+ * @device: Pointer to scrub device
+ * @attr_id: Scrub attribute
+ * @region_id: ID of the memory region
+ * @buf: Pointer to the buffer for copying returned string
+ *
+ * Returns: 0 on success, an error otherwise
+ */
+int ras2_hw_scrub_read_strings(struct device *dev, u32 attr_id,
+			       int region_id, char *buf)
+{
+	struct ras2_context *ras2_ctx;
+
+	ras2_ctx = dev_get_drvdata(dev);
+
+	switch (attr_id) {
+	case scrub_rate_available:
+		return rate_available_read(ras2_ctx, buf);
+	default:
+		return -EOPNOTSUPP;
+	}
+}
diff --git a/include/memory/ras2.h b/include/memory/ras2.h
new file mode 100755
index 000000000000..3db1dce5dd34
--- /dev/null
+++ b/include/memory/ras2.h
@@ -0,0 +1,88 @@
+/* SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0 */
+/*
+ * Memory RAS2 driver header file
+ *
+ * Copyright (c) 2024 HiSilicon Limited
+ */
+
+#ifndef _RAS2_H
+#define _RAS2_H
+
+#include <memory/memory-scrub.h>
+
+#define RAS2_MAX_NAME_LENGTH      64
+#define RAS2_MAX_RATE_RANGE_LENGTH      64
+
+/*
+ * Data structures RAS2
+ */
+
+/**
+ * struct ras2_scrub_params- RAS2 scrub parameter data structure.
+ * @addr_base:	[IN] Base address of the address range to be patrol scrubbed.
+ *		[OUT] Base address of the actual address range.
+ * @addr_size:	[IN] Size of the address range to be patrol scrubbed.
+ *		[OUT] Size of the actual address range.
+ * @flags:	[OUT] The platform returns this value in response to
+ *		GET_PATROL_PARAMETERS.
+ *		For RAS2:
+ *		Bit [0]: Will be set if memory scrubber is already
+ *		running for address range specified in Actual Address Range.
+ * @rate:	[IN] Requested patrol scrub rate.
+ *		[OUT] Current patrol scrub rate.
+ * @rate_avail:[OUT] Supported patrol rates.
+ */
+struct ras2_scrub_params {
+	u64 addr_base;
+	u64 addr_size;
+	u16 flags;
+	u32 rate;
+	char rate_avail[RAS2_MAX_RATE_RANGE_LENGTH];
+};
+
+enum {
+	RAS2_MEM_SCRUB_PARAM_ADDR_BASE = 0,
+	RAS2_MEM_SCRUB_PARAM_ADDR_SIZE,
+	RAS2_MEM_SCRUB_PARAM_RATE,
+};
+
+/**
+ * struct ras2_hw_scrub_ops - ras2 hw scrub device operations
+ * @enable_scrub: Function to enable/disable RAS2 scrubber.
+ *		Parameters are:
+ *		@ras2_ctx: Pointer to RAS2 context structure.
+ *		@enable: enable/disable RAS2 patrol scrubber.
+ *		The function returns 0 on success or a negative error number.
+ * @enable_background_scrub: Function to enable/disable background scrubbing.
+ *		Parameters are:
+ *		@ras2_ctx: Pointer to RAS2 context structure.
+ *		@enable: enable/disable background patrol scrubbing.
+ *		The function returns 0 on success or a negative error number.
+ * @get_scrub_params:	Read scrubber parameters. Mandatory
+ *		Parameters are:
+ *		@ras2_ctx: Pointer to RAS2 context structure.
+ *		@params: Pointer to scrub params data structure.
+ *		The function returns 0 on success or a negative error number.
+ * @set_scrub_params: Set scrubber parameters. Mandatory.
+ *		Parameters are:
+ *		@ras2_ctx: Pointer to RAS2 context structure.
+ *		@params: Pointer to scrub params data structure.
+ *		@param_type: Scrub parameter type to set.
+ *		The function returns 0 on success or a negative error number.
+ */
+struct ras2_hw_scrub_ops {
+	int (*enable_scrub)(struct ras2_context *ras2_ctx, bool enable);
+	int (*enable_background_scrub)(struct ras2_context *ras2_ctx, bool enable);
+	int (*get_scrub_params)(struct ras2_context *ras2_ctx,
+				struct ras2_scrub_params *params);
+	int (*set_scrub_params)(struct ras2_context *ras2_ctx,
+				struct ras2_scrub_params *params, u8 param_type);
+};
+
+umode_t ras2_hw_scrub_is_visible(struct device *dev, u32 attr_id,
+				 umode_t mode, int region_id);
+int ras2_hw_scrub_read(struct device *dev, u32 attr_id, int region_id, u64 *val);
+int ras2_hw_scrub_write(struct device *dev, u32 attr_id, int region_id, u64 val);
+int ras2_hw_scrub_read_strings(struct device *dev, u32 attr_id,
+			       int region_id, char *buf);
+#endif /* _RAS2_H */
-- 
2.34.1


From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from mail.alien8.de (mail.alien8.de [65.109.113.108])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id 179704A3D;
	Fri, 23 Feb 2024 15:43:49 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=none smtp.client-ip=65.109.113.108
ARC-Seal: i=1; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1708703033; cv=none; b=nK1G3GbAI9ZxAvY46lPzsTpU3jPMtS3PMaqzdci4D/hMH9gXlcdxmNp/qWehMxkpQXt6aW5Ruwi8ybiDIV1zEuvbncTnxTah6NH/fpr/iZ3COopXKvoVTj1gezql7O99ANtaO/A7PdyXn5ML0N332Q5h0TE4XWeS3QNdWSl79DU=
ARC-Message-Signature: i=1; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1708703033; c=relaxed/simple;
	bh=LRbUtJsi5tFV5Td5mfsuSsDvyXVEmiUYSJKc4U9GivU=;
	h=Date:From:To:Cc:Subject:Message-ID:References:MIME-Version:
	 Content-Type:Content-Disposition:In-Reply-To; b=KeSY0aJBpbqD14J0i5nPjMvJjPiU5ttPJr8geDRk4vZwmKLb7zbzAIiiqNXO6YFxuCvCyIxPCV6EhBCF6MLGUs+1JuWuNmCbUm8vTyesJFedWrexGmIiFK8yQPC2J/e7gtZ6gjT5E+PUVmxmGNbnWKVjWWQO/1lomDof7bpuTJI=
ARC-Authentication-Results: i=1; smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=alien8.de; spf=pass smtp.mailfrom=alien8.de; dkim=pass (4096-bit key) header.d=alien8.de header.i=@alien8.de header.b=Hl77ICMb; arc=none smtp.client-ip=65.109.113.108
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=alien8.de
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=alien8.de
Authentication-Results: smtp.subspace.kernel.org;
	dkim=pass (4096-bit key) header.d=alien8.de header.i=@alien8.de header.b="Hl77ICMb"
Received: from localhost (localhost.localdomain [127.0.0.1])
	by mail.alien8.de (SuperMail on ZX Spectrum 128k) with ESMTP id 6F3D840E01A0;
	Fri, 23 Feb 2024 15:43:41 +0000 (UTC)
X-Virus-Scanned: Debian amavisd-new at mail.alien8.de
Authentication-Results: mail.alien8.de (amavisd-new); dkim=pass (4096-bit key)
	header.d=alien8.de
Received: from mail.alien8.de ([127.0.0.1])
	by localhost (mail.alien8.de [127.0.0.1]) (amavisd-new, port 10026)
	with ESMTP id YyMHoWaZT0-N; Fri, 23 Feb 2024 15:43:39 +0000 (UTC)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=alien8.de; s=alien8;
	t=1708703018; bh=vOuid2cJTRQLhiLgDF9qDITkt0o2BhRLiMIp10b+zB0=;
	h=Date:From:To:Cc:Subject:References:In-Reply-To:From;
	b=Hl77ICMbkiYiZXvnyP7l2drG6hgZ4Ocx0OmlAwmeL+3agO8UQXbkPtu9UHeYwVvCk
	 fgojY2YiA1nbEZEf3o/QUicgYfYzdqtWICyIMv7KSvpQBZUON8BAPavJgOV4yyWRcv
	 MARAP+KTuGeW3nEJjwsJTVBZoHoW0cQmbDTlKpNsxMi4tETXM7Z67ftazhCz924lQ1
	 kR7sK/Lt/UoMVj0/HlLmsmJyRD5wRSonm1Zxr+Z0T0ocdHEMwujmFl0A9GvbqbaWFv
	 mxYHZ9FGCYCyxdlOitulO/q+SeT9+QE9v4nLngN6E/5SDn4GcnAYtTrDLA3Ijjaxw3
	 B+qnh6uLPCBZ0ZBR2x9alDC6rR8Dw5DhF2xjq27dcSfTPJ7wbiYeCfZMeCXcn8CVdF
	 s0p3vfTNLM+NsPctNdMKiEz+fVGwVCLIj7JRGSJJl84Pxgg1yYi1UA2sYcoC7qzRGu
	 ul5Od0UxW1Mrr1wGg12U2ReAaZ6zizCI5AEY7EtnLAue0T2F3GE5zClHTLexscMMSV
	 uA/JiB+48CLcWxmdjFDbhZLEReZRqrpjxa4aurhC3s5Kv2P/Qr/wGwukViwrlXv0Ni
	 ouDFi0Af7q5Hwk3AExxf1tmSoAtvDC/x/asn9L0GrL/G1brZFVMVEivvo6E6FhrX66
	 YaWYc02C743bAOSmPKn5wG/0=
Received: from zn.tnic (pd953021b.dip0.t-ipconnect.de [217.83.2.27])
	(using TLSv1.3 with cipher TLS_AES_256_GCM_SHA384 (256/256 bits)
	 key-exchange ECDHE (P-256) server-signature ECDSA (P-256) server-digest SHA256)
	(No client certificate requested)
	by mail.alien8.de (SuperMail on ZX Spectrum 128k) with ESMTPSA id DDE8040E016C;
	Fri, 23 Feb 2024 15:42:57 +0000 (UTC)
Date: Fri, 23 Feb 2024 16:42:51 +0100
From: Borislav Petkov <bp@alien8.de>
To: shiju.jose@huawei.com
Cc: linux-cxl@vger.kernel.org, linux-acpi@vger.kernel.org,
	linux-mm@kvack.org, dan.j.williams@intel.com, dave@stgolabs.net,
	jonathan.cameron@huawei.com, dave.jiang@intel.com,
	alison.schofield@intel.com, vishal.l.verma@intel.com,
	ira.weiny@intel.com, linux-edac@vger.kernel.org,
	linux-kernel@vger.kernel.org, david@redhat.com,
	Vilas.Sridharan@amd.com, leo.duran@amd.com, Yazen.Ghannam@amd.com,
	rientjes@google.com, jiaqiyan@google.com, tony.luck@intel.com,
	Jon.Grimm@amd.com, dave.hansen@linux.intel.com, rafael@kernel.org,
	lenb@kernel.org, naoya.horiguchi@nec.com, james.morse@arm.com,
	jthoughton@google.com, somasundaram.a@hpe.com,
	erdemaktas@google.com, pgonda@google.com, duenwen@google.com,
	mike.malvestuto@intel.com, gthelen@google.com,
	wschwartz@amperecomputing.com, dferguson@amperecomputing.com,
	tanxiaofei@huawei.com, prime.zeng@hisilicon.com,
	kangkang.shen@futurewei.com, wanghuiqiang@huawei.com,
	linuxarm@huawei.com
Subject: Re: [RFC PATCH v7 00/12] memory: scrub: introduce subsystem +
 CXL/ACPI-RAS2 drivers
Message-ID: <20240223154251.GAZdi8--NPaMAK_ZBp@fat_crate.local>
References: <20240223143723.1574-1-shiju.jose@huawei.com>
Precedence: bulk
X-Mailing-List: linux-kernel@vger.kernel.org
List-Id: <linux-kernel.vger.kernel.org>
List-Subscribe: <mailto:linux-kernel+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:linux-kernel+unsubscribe@vger.kernel.org>
MIME-Version: 1.0
Content-Type: text/plain; charset=utf-8
Content-Disposition: inline
In-Reply-To: <20240223143723.1574-1-shiju.jose@huawei.com>

On Fri, Feb 23, 2024 at 10:37:11PM +0800, shiju.jose@huawei.com wrote:
> CXL patrol scrub and DDR5 ECS and ACPI RAS2 HW based memory
> patrol scrub features are added as use cases for the scrub
> subsystem to expose the scrub controls to the user.

WTH is a RAS2 driver and where is the RAS1 driver?

-- 
Regards/Gruss,
    Boris.

https://people.kernel.org/tglx/notes-about-netiquette

From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id 8A60A7EF06;
	Fri, 23 Feb 2024 16:25:56 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=none smtp.client-ip=185.176.79.56
ARC-Seal: i=1; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1708705559; cv=none; b=PjrXHKNt/RVU9Ev8YO3lF6jXnoaiD0Ohkpd7M/Oyi/NN/Z87Nij28MoV9gn0hLDn1ooDrOXpqiMK3B6obZ2RRbicqttr71R4xUKg/AmAQjkyA0yak+itFZv63ZoMPxXtVSU5ZoCuln1MuF6XrQauZrpup/bYrDnLDrKdEFQWBnc=
ARC-Message-Signature: i=1; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1708705559; c=relaxed/simple;
	bh=pcgLlYSZ94N8Z5tjPSaQIgYSm+pxjOpzSlJJCy147m0=;
	h=Date:From:To:CC:Subject:Message-ID:In-Reply-To:References:
	 MIME-Version:Content-Type; b=dr/4ypPYAvI5XJC3a6WWVwbAu98iHZpg/umh1TUfQhYnj8jSPZPLgVXVm6phxrusUQW4CGekIycT99PFBUptmtDc0dIGqk2myG3puN4CtSmQRC+DexMz7Gdr3hJOQ5SaHrEazQ4ocEN/UhZs386oS9JupJirmzknKANHWewklFo=
ARC-Authentication-Results: i=1; smtp.subspace.kernel.org; dmarc=pass (p=quarantine dis=none) header.from=Huawei.com; spf=pass smtp.mailfrom=huawei.com; arc=none smtp.client-ip=185.176.79.56
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=quarantine dis=none) header.from=Huawei.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=huawei.com
Received: from mail.maildlp.com (unknown [172.18.186.231])
	by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4ThFd33KWmz6JB2J;
	Sat, 24 Feb 2024 00:21:27 +0800 (CST)
Received: from lhrpeml500005.china.huawei.com (unknown [7.191.163.240])
	by mail.maildlp.com (Postfix) with ESMTPS id 51DEA140D30;
	Sat, 24 Feb 2024 00:25:53 +0800 (CST)
Received: from localhost (10.202.227.76) by lhrpeml500005.china.huawei.com
 (7.191.163.240) with Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.1.2507.35; Fri, 23 Feb
 2024 16:25:52 +0000
Date: Fri, 23 Feb 2024 16:25:51 +0000
From: Jonathan Cameron <Jonathan.Cameron@Huawei.com>
To: Borislav Petkov <bp@alien8.de>
CC: <shiju.jose@huawei.com>, <linux-cxl@vger.kernel.org>,
	<linux-acpi@vger.kernel.org>, <linux-mm@kvack.org>,
	<dan.j.williams@intel.com>, <dave@stgolabs.net>, <dave.jiang@intel.com>,
	<alison.schofield@intel.com>, <vishal.l.verma@intel.com>,
	<ira.weiny@intel.com>, <linux-edac@vger.kernel.org>,
	<linux-kernel@vger.kernel.org>, <david@redhat.com>,
	<Vilas.Sridharan@amd.com>, <leo.duran@amd.com>, <Yazen.Ghannam@amd.com>,
	<rientjes@google.com>, <jiaqiyan@google.com>, <tony.luck@intel.com>,
	<Jon.Grimm@amd.com>, <dave.hansen@linux.intel.com>, <rafael@kernel.org>,
	<lenb@kernel.org>, <naoya.horiguchi@nec.com>, <james.morse@arm.com>,
	<jthoughton@google.com>, <somasundaram.a@hpe.com>, <erdemaktas@google.com>,
	<pgonda@google.com>, <duenwen@google.com>, <mike.malvestuto@intel.com>,
	<gthelen@google.com>, <wschwartz@amperecomputing.com>,
	<dferguson@amperecomputing.com>, <tanxiaofei@huawei.com>,
	<prime.zeng@hisilicon.com>, <kangkang.shen@futurewei.com>,
	<wanghuiqiang@huawei.com>, <linuxarm@huawei.com>
Subject: Re: [RFC PATCH v7 00/12] memory: scrub: introduce subsystem +
 CXL/ACPI-RAS2 drivers
Message-ID: <20240223162551.000013ec@Huawei.com>
In-Reply-To: <20240223154251.GAZdi8--NPaMAK_ZBp@fat_crate.local>
References: <20240223143723.1574-1-shiju.jose@huawei.com>
	<20240223154251.GAZdi8--NPaMAK_ZBp@fat_crate.local>
Organization: Huawei Technologies Research and Development (UK) Ltd.
X-Mailer: Claws Mail 4.1.0 (GTK 3.24.33; x86_64-w64-mingw32)
Precedence: bulk
X-Mailing-List: linux-kernel@vger.kernel.org
List-Id: <linux-kernel.vger.kernel.org>
List-Subscribe: <mailto:linux-kernel+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:linux-kernel+unsubscribe@vger.kernel.org>
MIME-Version: 1.0
Content-Type: text/plain; charset="US-ASCII"
Content-Transfer-Encoding: 7bit
X-ClientProxiedBy: lhrpeml100004.china.huawei.com (7.191.162.219) To
 lhrpeml500005.china.huawei.com (7.191.163.240)

On Fri, 23 Feb 2024 16:42:51 +0100
Borislav Petkov <bp@alien8.de> wrote:

> On Fri, Feb 23, 2024 at 10:37:11PM +0800, shiju.jose@huawei.com wrote:
> > CXL patrol scrub and DDR5 ECS and ACPI RAS2 HW based memory
> > patrol scrub features are added as use cases for the scrub
> > subsystem to expose the scrub controls to the user.  
> 
> WTH is a RAS2 driver and where is the RAS1 driver?
> 
Odd ACPI naming.  RASF (which is very limited) was replaced by RAS2.

Both are ACPI tables that describe the Platform Communication Channels
(mailbox) + provide a definition of the protocol that is sent over
it in order to control memory scrub.  RAS2 has some other uses this
driver isn't touching on.

So in short, it's an ACPI spec defined interface for controlling 
Memory Scrub engines.

https://uefi.org/specs/ACPI/6.5/05_ACPI_Software_Programming_Model.html#acpi-ras2-feature-table-ras2

Jonathan

From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from mail.alien8.de (mail.alien8.de [65.109.113.108])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id F162713A27B;
	Fri, 23 Feb 2024 17:51:53 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=none smtp.client-ip=65.109.113.108
ARC-Seal: i=1; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1708710716; cv=none; b=eHdS36ANzjAmHa29848FylXePJjBb0NdbGnvHnllPb3cuA+n2YOYUUppKxTcJdORjuPlfkpkyB9JoOcP5GEjIPrQqtSNh0gb4xGf46RZRmqFG82GjoWBXl08OR8nddo/SBaHBQ5KvtLSZh51z2FJbbDEi190CcCqcDFVlm+3S7U=
ARC-Message-Signature: i=1; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1708710716; c=relaxed/simple;
	bh=3MtOstKPgk5E7lxshF6YUvjFhLxlyzflm8vH2Ep6Y+c=;
	h=Date:From:To:Cc:Subject:Message-ID:References:MIME-Version:
	 Content-Type:Content-Disposition:In-Reply-To; b=QbldMXqtwStEIXNBBPAS0AXnbSgKOirrdzKBqW3kQPf9tqDht+kVLpYzct2odbVNO0VVYIDY9EgHw6JcyueJxKNSVHJb93FV+QPn+ZE4AvlJpb5anDLj6btcmjEtngCv/KKaSugTHcR7C+kaRKVz2OcsGTWlTo8RWVblQRQRjzc=
ARC-Authentication-Results: i=1; smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=alien8.de; spf=pass smtp.mailfrom=alien8.de; dkim=pass (4096-bit key) header.d=alien8.de header.i=@alien8.de header.b=REvmuwwi; arc=none smtp.client-ip=65.109.113.108
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=alien8.de
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=alien8.de
Authentication-Results: smtp.subspace.kernel.org;
	dkim=pass (4096-bit key) header.d=alien8.de header.i=@alien8.de header.b="REvmuwwi"
Received: from localhost (localhost.localdomain [127.0.0.1])
	by mail.alien8.de (SuperMail on ZX Spectrum 128k) with ESMTP id CCFD840E0192;
	Fri, 23 Feb 2024 17:51:50 +0000 (UTC)
X-Virus-Scanned: Debian amavisd-new at mail.alien8.de
Authentication-Results: mail.alien8.de (amavisd-new); dkim=pass (4096-bit key)
	header.d=alien8.de
Received: from mail.alien8.de ([127.0.0.1])
	by localhost (mail.alien8.de [127.0.0.1]) (amavisd-new, port 10026)
	with ESMTP id DZ5q3Q_bndI4; Fri, 23 Feb 2024 17:51:48 +0000 (UTC)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=alien8.de; s=alien8;
	t=1708710708; bh=rkpeN08zur0iQ6scKcdTzeAW6Eskv9jZ3rMpviIPZ0U=;
	h=Date:From:To:Cc:Subject:References:In-Reply-To:From;
	b=REvmuwwiIVCNBSNUYb4BQZvSTePGuN67Jq3SwEjLRx0f+MfQ/cIibpbyRJ6SZTyS0
	 36vKn1G/RUNTHLYGa3xvAl5kCoQ3J9V8COgDQyHUy4qQHqLhc9cuVd2XdfDS7Mef0Z
	 lTMvoOhhLo24Pb/yuEL87DXMS3kECR9R+DcoshvfB38qk3uxbzscyenXhyB6JPVDWY
	 g3wcylGYqPc4fICZ7MYqhYK/EWn1ZUWvK0d+Z8Dp9lmbqCwBWHDdluKcTMpgOi+b3M
	 VMikameDf9QqMVG2zVD/2tTgJoIXfLFHsBwtbklcLTdrWj60wn19J79QkjEAJtpx8T
	 So69gS0MYPXU+QGQJRpGI4D6Awwt1HN9uppVYBQCs7PzupvccW2lfecuWblFIYHCAE
	 21A0Nv0B37601ZHjh0giIOVN+O2RoigGTqW2Azf8ZqX88umpT3RuQE15rpQlIr4lOe
	 DBhYCd1j0c1ejHlZxLxrb4NN0akDG1eTZI87AhfXlDDfG5Aa4QmkYPUY6J+wdV+2Je
	 UVzQog0zRxpaLEVmkRj4nDhND2H3Fq7HNGG+R02dz37EXYroYTU/RVs89zuDB61jmQ
	 Li4V1I/7YR44hh3U73R4cDOE4n5MG0V3xdCVwIw6O+PGuvDJ3hQUgPukerqoMqVc5Q
	 XlynR/rd6OkpptLyqAixACWE=
Received: from zn.tnic (pd953021b.dip0.t-ipconnect.de [217.83.2.27])
	(using TLSv1.3 with cipher TLS_AES_256_GCM_SHA384 (256/256 bits)
	 key-exchange ECDHE (P-256) server-signature ECDSA (P-256) server-digest SHA256)
	(No client certificate requested)
	by mail.alien8.de (SuperMail on ZX Spectrum 128k) with ESMTPSA id CE93040E016C;
	Fri, 23 Feb 2024 17:51:07 +0000 (UTC)
Date: Fri, 23 Feb 2024 18:51:00 +0100
From: Borislav Petkov <bp@alien8.de>
To: Jonathan Cameron <Jonathan.Cameron@huawei.com>
Cc: shiju.jose@huawei.com, linux-cxl@vger.kernel.org,
	linux-acpi@vger.kernel.org, linux-mm@kvack.org,
	dan.j.williams@intel.com, dave@stgolabs.net, dave.jiang@intel.com,
	alison.schofield@intel.com, vishal.l.verma@intel.com,
	ira.weiny@intel.com, linux-edac@vger.kernel.org,
	linux-kernel@vger.kernel.org, david@redhat.com,
	Vilas.Sridharan@amd.com, leo.duran@amd.com, Yazen.Ghannam@amd.com,
	rientjes@google.com, jiaqiyan@google.com, tony.luck@intel.com,
	Jon.Grimm@amd.com, dave.hansen@linux.intel.com, rafael@kernel.org,
	lenb@kernel.org, naoya.horiguchi@nec.com, james.morse@arm.com,
	jthoughton@google.com, somasundaram.a@hpe.com,
	erdemaktas@google.com, pgonda@google.com, duenwen@google.com,
	mike.malvestuto@intel.com, gthelen@google.com,
	wschwartz@amperecomputing.com, dferguson@amperecomputing.com,
	tanxiaofei@huawei.com, prime.zeng@hisilicon.com,
	kangkang.shen@futurewei.com, wanghuiqiang@huawei.com,
	linuxarm@huawei.com
Subject: Re: [RFC PATCH v7 00/12] memory: scrub: introduce subsystem +
 CXL/ACPI-RAS2 drivers
Message-ID: <20240223175100.GCZdjbBNlS0hluk3_B@fat_crate.local>
References: <20240223143723.1574-1-shiju.jose@huawei.com>
 <20240223154251.GAZdi8--NPaMAK_ZBp@fat_crate.local>
 <20240223162551.000013ec@Huawei.com>
Precedence: bulk
X-Mailing-List: linux-kernel@vger.kernel.org
List-Id: <linux-kernel.vger.kernel.org>
List-Subscribe: <mailto:linux-kernel+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:linux-kernel+unsubscribe@vger.kernel.org>
MIME-Version: 1.0
Content-Type: text/plain; charset=utf-8
Content-Disposition: inline
In-Reply-To: <20240223162551.000013ec@Huawei.com>

On Fri, Feb 23, 2024 at 04:25:51PM +0000, Jonathan Cameron wrote:
> So in short, it's an ACPI spec defined interface for controlling 
> Memory Scrub engines.

Ok, let's call it acpi_ras2 then so that it is clear. We shouldn't be
perpetuating the ACPI poor naming in the kernel. This way at least it is
namespaced and says exactly where it is coming from.

Thx.

-- 
Regards/Gruss,
    Boris.

https://people.kernel.org/tglx/notes-about-netiquette

From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from NAM10-MW2-obe.outbound.protection.outlook.com (mail-mw2nam10on2048.outbound.protection.outlook.com [40.107.94.48])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id 16E0C13EFFD;
	Fri, 23 Feb 2024 17:57:29 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=fail smtp.client-ip=40.107.94.48
ARC-Seal: i=2; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1708711052; cv=fail; b=Sk1d/W9aObCgZLgYFhbwmo13CKQ1Efjh4tVPDMir2qArIeTi9uLgoJX71+YFzs0iYnjtGBTA3vzNpOZdS3J8WjlJA5tX5iW62wQQMvKWLtEcppFCHcFztiw7o+NI+Hx+KtIxognSuYsTAfdpk1GwUd+zpE7QQkDhqAyvv0PhHkY=
ARC-Message-Signature: i=2; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1708711052; c=relaxed/simple;
	bh=9mVWq0yP/9XbO7K+XMDABC5KskEYk2FP2ijw6ykizDg=;
	h=From:To:CC:Subject:Date:Message-ID:References:In-Reply-To:
	 Content-Type:MIME-Version; b=XAtLXMwxYs8MzhKOBxLXWsBQ8Yr4jXnEwN2p4cqwETHCYr9mpXvjlx69RmvLacV/whWrbzgg8YiG9bw0yYC9JcVVhaRruQm84WmHH42UxLSh3NpRXwavv5uT79rFk6wzX6KFvoB1D+UnIgQvoxTJetmq1osfmnn3l4SvAaGqgOk=
ARC-Authentication-Results: i=2; smtp.subspace.kernel.org; dmarc=pass (p=quarantine dis=none) header.from=amd.com; spf=fail smtp.mailfrom=amd.com; dkim=pass (1024-bit key) header.d=amd.com header.i=@amd.com header.b=xVYYJoOD; arc=fail smtp.client-ip=40.107.94.48
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=quarantine dis=none) header.from=amd.com
Authentication-Results: smtp.subspace.kernel.org; spf=fail smtp.mailfrom=amd.com
Authentication-Results: smtp.subspace.kernel.org;
	dkim=pass (1024-bit key) header.d=amd.com header.i=@amd.com header.b="xVYYJoOD"
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=DEKGsJkNodKgdt21U0Jsy+qK4Ua4Nb29WXoyvHxLSu4/RnTbzbdtdXB1CbeUkbRbIsCRKeQsnokfwwrt6Mq4ry+zjhQd/AHpzgg6ck1fZrAlmbMHRTp8Fs0WariM5Jg9DHd9xBN/3GEGgM+M2Zjfw7pE9B4TFKcFRUipQYm/muCAG5muSzb5a6Y/OHsei0m/wP/lxfhD183qdb/FQ32ndO1XDaJ4smIpYEDWnumX1u8Zxkev7nJghWXTorezs52cGvIdSu6rsV/6E4mjoF/nZluMAdEBgtLOITWOno5Cv2djZ3vi0VyeAyIWqjMMxg1dw7j2em4NIwtbUzCAN5a7VQ==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=IqbdCcYyG7TN0L9rOHCSEL0hL5rJfMV5pMgeRcA2kMY=;
 b=SKfpJ2QnSiNX5NRyyj7NrH4b3p/MHjXZymyoypdkFD3FOe7roSgfVCbFlVXNa5+U0rXQJY/izR5XexRz2Ina5f+e16O/uXlhY1fPj7cevVoN+1E6q7Vja3VRYvjmIeI94DcFqrT9X8FbWdEnhjhkPFFEnqyLdAjcWgmam9rZlNUr1DqsOFsoetta/Z+YCL9aVm9C4qcJTQ9PwheRlSQVEY4yYImGY3ZT9e5LWv4m3tnaqL3HXzrTx8SW1ZmOyGGD5hfiM5LqHv8PlFQqA7MQIxzKn6Z060kwcqJvgCyvyT7gaNQP0sPHt2Nqa1gKTAh4yI2T6a6ClRl0IReui2gpPA==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=amd.com; dmarc=pass action=none header.from=amd.com; dkim=pass
 header.d=amd.com; arc=none
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=amd.com; s=selector1;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-SenderADCheck;
 bh=IqbdCcYyG7TN0L9rOHCSEL0hL5rJfMV5pMgeRcA2kMY=;
 b=xVYYJoODJVR6iFIhaWp/H3d8kzJt0nbS1fCnROcyO7eobveTIyHexNnJaPR8jRq2Bz33Vucz8Ep3qqqtxYydW8mF2DhIgF+oCDblhvv+vpw5pV/blN+44uo/A1/i5a87ZzuVEB3vLSLI5HgkpzrOpJ47O7RGpY9Xlsg8VXf3DPM=
Received: from BN7PR12MB2644.namprd12.prod.outlook.com (2603:10b6:408:2d::20)
 by PH8PR12MB7207.namprd12.prod.outlook.com (2603:10b6:510:225::14) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.7316.19; Fri, 23 Feb
 2024 17:57:26 +0000
Received: from BN7PR12MB2644.namprd12.prod.outlook.com
 ([fe80::194d:b908:f3e1:a25d]) by BN7PR12MB2644.namprd12.prod.outlook.com
 ([fe80::194d:b908:f3e1:a25d%7]) with mapi id 15.20.7316.023; Fri, 23 Feb 2024
 17:57:26 +0000
From: "Duran, Leo" <leo.duran@amd.com>
To: Jonathan Cameron <Jonathan.Cameron@Huawei.com>, Borislav Petkov
	<bp@alien8.de>
CC: "shiju.jose@huawei.com" <shiju.jose@huawei.com>,
	"linux-cxl@vger.kernel.org" <linux-cxl@vger.kernel.org>,
	"linux-acpi@vger.kernel.org" <linux-acpi@vger.kernel.org>,
	"linux-mm@kvack.org" <linux-mm@kvack.org>, "dan.j.williams@intel.com"
	<dan.j.williams@intel.com>, "dave@stgolabs.net" <dave@stgolabs.net>,
	"dave.jiang@intel.com" <dave.jiang@intel.com>, "alison.schofield@intel.com"
	<alison.schofield@intel.com>, "vishal.l.verma@intel.com"
	<vishal.l.verma@intel.com>, "ira.weiny@intel.com" <ira.weiny@intel.com>,
	"linux-edac@vger.kernel.org" <linux-edac@vger.kernel.org>,
	"linux-kernel@vger.kernel.org" <linux-kernel@vger.kernel.org>,
	"david@redhat.com" <david@redhat.com>, "Sridharan, Vilas"
	<Vilas.Sridharan@amd.com>, "Ghannam, Yazen" <Yazen.Ghannam@amd.com>,
	"rientjes@google.com" <rientjes@google.com>, "jiaqiyan@google.com"
	<jiaqiyan@google.com>, "tony.luck@intel.com" <tony.luck@intel.com>, "Grimm,
 Jon" <Jon.Grimm@amd.com>, "dave.hansen@linux.intel.com"
	<dave.hansen@linux.intel.com>, "rafael@kernel.org" <rafael@kernel.org>,
	"lenb@kernel.org" <lenb@kernel.org>, "naoya.horiguchi@nec.com"
	<naoya.horiguchi@nec.com>, "james.morse@arm.com" <james.morse@arm.com>,
	"jthoughton@google.com" <jthoughton@google.com>, "somasundaram.a@hpe.com"
	<somasundaram.a@hpe.com>, "erdemaktas@google.com" <erdemaktas@google.com>,
	"pgonda@google.com" <pgonda@google.com>, "duenwen@google.com"
	<duenwen@google.com>, "mike.malvestuto@intel.com"
	<mike.malvestuto@intel.com>, "gthelen@google.com" <gthelen@google.com>,
	"wschwartz@amperecomputing.com" <wschwartz@amperecomputing.com>,
	"dferguson@amperecomputing.com" <dferguson@amperecomputing.com>,
	"tanxiaofei@huawei.com" <tanxiaofei@huawei.com>, "prime.zeng@hisilicon.com"
	<prime.zeng@hisilicon.com>, "kangkang.shen@futurewei.com"
	<kangkang.shen@futurewei.com>, "wanghuiqiang@huawei.com"
	<wanghuiqiang@huawei.com>, "linuxarm@huawei.com" <linuxarm@huawei.com>
Subject: RE: [RFC PATCH v7 00/12] memory: scrub: introduce subsystem +
 CXL/ACPI-RAS2 drivers
Thread-Topic: [RFC PATCH v7 00/12] memory: scrub: introduce subsystem +
 CXL/ACPI-RAS2 drivers
Thread-Index: AQHaZm8buLMwjFZAQ0uEYAlft3jKNLEYHRCAgAAZKjA=
Date: Fri, 23 Feb 2024 17:57:26 +0000
Message-ID: 
 <BN7PR12MB2644C263D85DBE3DD6431B42F9552@BN7PR12MB2644.namprd12.prod.outlook.com>
References: <20240223143723.1574-1-shiju.jose@huawei.com>
	<20240223154251.GAZdi8--NPaMAK_ZBp@fat_crate.local>
 <20240223162551.000013ec@Huawei.com>
In-Reply-To: <20240223162551.000013ec@Huawei.com>
Accept-Language: en-US
Content-Language: en-US
X-MS-Has-Attach: 
X-MS-TNEF-Correlator: 
msip_labels: 
 MSIP_Label_4342314e-0df4-4b58-84bf-38bed6170a0f_ActionId=799fb89d-1cba-4cae-aed7-d5dd753ca8ab;MSIP_Label_4342314e-0df4-4b58-84bf-38bed6170a0f_ContentBits=0;MSIP_Label_4342314e-0df4-4b58-84bf-38bed6170a0f_Enabled=true;MSIP_Label_4342314e-0df4-4b58-84bf-38bed6170a0f_Method=Standard;MSIP_Label_4342314e-0df4-4b58-84bf-38bed6170a0f_Name=General;MSIP_Label_4342314e-0df4-4b58-84bf-38bed6170a0f_SetDate=2024-02-23T17:55:55Z;MSIP_Label_4342314e-0df4-4b58-84bf-38bed6170a0f_SiteId=3dd8961f-e488-4e60-8e11-a82d994e183d;
authentication-results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=amd.com;
x-ms-publictraffictype: Email
x-ms-traffictypediagnostic: BN7PR12MB2644:EE_|PH8PR12MB7207:EE_
x-ms-office365-filtering-correlation-id: 2d695d24-1d30-4006-f81c-08dc3498e50d
x-ms-exchange-senderadcheck: 1
x-ms-exchange-antispam-relay: 0
x-microsoft-antispam: BCL:0;
x-microsoft-antispam-message-info: 
 H7m++3iZ6+EAJrWNGNPx4XfMJiPXjQCylGfSlDSe9YkZhYdiQulRcQTK/iakWScqpvHP53LrHHoQNdLGviS9iD+0j3MRCVAHJqYEuMsp3HUpeztHWolFvV2/NuMwXydDq3goEaF6FmkWg+uKwJF2jJApjqf4l0uU3WOpyHX9UQW8OnPG24oVlolLl2iiGwnoATfJC0QRw2l+O5MGv4yn9T8Rtz8F/70CXZrZ1L8iV0aI5orGOaEhAf5yp1EC3hPiC9TQPrpMeFO0e7BXGSjndCek5E2L4dRhOqf7VMdDdOQv8OBfE2lgM8EC/gyrQ6RXAjVlFLzp4nRq/64tBiARf23zzHYwHeTOd/ft09lib1BRrJ93lHw8JWh2r+ilzqjEeYvhsseXT+BWN4Hrgh9suEFzn5M9Nh5jbNFND1LugtkndGJzstLzYu13r63kRNbnhfSsC0K228qxDeMAbFHN9J77VPktXV39bKBOGdq/NKU2Ym+D/22zwfscN6WDiEHuraHsh4adM5em3q4NfhilL+TqF0kkSTJoyQu0GSc+Nc0/Eef6P1i094CyzOYtTN5O2SO0i6u3cZ5Eiwd56QdJFyMrnsxHhcvPhV3vYNz2A3g=
x-forefront-antispam-report: 
 CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:BN7PR12MB2644.namprd12.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230031)(38070700009);DIR:OUT;SFP:1101;
x-ms-exchange-antispam-messagedata-chunkcount: 1
x-ms-exchange-antispam-messagedata-0: 
 =?us-ascii?Q?NuspfxVT3Jd6if5P8DXH81Mj2x1zTl1x2SEjEQkWjT84eascL5XiSP+PnsWh?=
 =?us-ascii?Q?4/c8pQlWKFNNJjX5nTo8blyVdkhcuMIM4Vpvzydo9y5QVsjymUwhu2ttoHli?=
 =?us-ascii?Q?jXqqUxcTRrWsBuM/ZE6fmptWdZfWKvsgvVgru33t2rkWQCsM1d26urYKLpvr?=
 =?us-ascii?Q?n2SvOcjQsdWifUuR2suC4jESx5JD3V5u3e5cgDDeIKbmXIOWzGtKFB20MOIU?=
 =?us-ascii?Q?dMjaWJEsAlOQz6f/d5pGKD3Far2QdLTwINv2s9Twy9SiDvY86lOg9gE2Ev7W?=
 =?us-ascii?Q?pt6lM45LGoUQb6MrhMPoBDAHfCiV+IyfpyhVrvb5CAicb1inajruzpxELmfH?=
 =?us-ascii?Q?ZvVZ70pra8VoR054sOXlcTKTipUJA+1TFxb5vlT6qWxfSllXx8O2XYlGsQ29?=
 =?us-ascii?Q?yiBmvepIdyDwZ8Ve2LHYFshIHUcTR06Z4mtvJm3TWeec1mBrieRoyc3L8wdW?=
 =?us-ascii?Q?sPm4Rpaf7vLHNhVxJAthmbMW9foz2OIwfB2UqpNtMYSYK6W9oLul5+yGnB0e?=
 =?us-ascii?Q?l8OWMeLuKdmgrNAOBH/pr/8pRYSmvZiTky/7Fr5hkjyJ2gnrxB+l2NYSvAK6?=
 =?us-ascii?Q?hgDneohJTSu0hd8QQrDRW+OwSN22hesAuDmCvBP8L8G7ydwaXbL8jzE/hPrA?=
 =?us-ascii?Q?8rHKwBh2CtM4mrKixDuoh3p/NvnlfWzWcXJBxRCVPUMJU+PvcK+PExAI8Exp?=
 =?us-ascii?Q?K3S/YL+Fnbq3nyzt8xvVmiuwt7UK+EX2OLWZR4yEaOk0hkRY0Agdb3tQj8eV?=
 =?us-ascii?Q?5mc5YHG0vkuXUZJVqIRr7W0njuRxQAQbwc/Eb9uLjknTKc99LwDraMZOxhbG?=
 =?us-ascii?Q?haBEdUC6d/9ANr2kIKc98tJzQUVgg2e/OaF/BYKi2tWAW5zYGWyf0Wae6z9i?=
 =?us-ascii?Q?eEVYM0YVHcoDjqdCwITsIKmViG7yN+tli5BjazBc2OavFKHYsbw/YUk90ttT?=
 =?us-ascii?Q?0q8q5BkMhvw+N0ZYXhM8WD3+FIl7yXR+o5SaRxZReGNk7XgnPN7Fp+Ec9flp?=
 =?us-ascii?Q?TsC1BY4SBKAe7Yl4iY6sjsMK1hTnoAuTyIHEQ+0XK0TutxNaWjUtmz1JiCwG?=
 =?us-ascii?Q?0cj1PG1vcfq2glLY3DRrfopNi7gq9Sfpk7kbrjdZDMSSM56RXcu9vsidDNzE?=
 =?us-ascii?Q?mt58jujLZ+h2VPXEMSBnUgn3UZz0zlpBrDPx4dDdLaSOCrdYh8gjSNgWbIrW?=
 =?us-ascii?Q?YB9Zbj1fOq0kZ0cadZ1mzEa7PV9bfmAKnGV55Y7wyeP69cLv3Xkn/3TscEVG?=
 =?us-ascii?Q?9HQ4Aj61GSfpxHQWg5hpaL2AspfhjsiSYRXJeQTP8ZBb8RZUpgrkLgXveCLe?=
 =?us-ascii?Q?egwWd+2Lr9xFSn97EllJ1rTR/agUUcVISFvF885SogFjLZKARoJSKl1j95JJ?=
 =?us-ascii?Q?9hdgrVHdd/q+MtYpOmsw6ISB+FAEYl6BN3n2jZ18eFIV5BC3XZTLmBKtW0jv?=
 =?us-ascii?Q?5SSj5r4dm4PcPgqHmhm2riGl9B5nxIa/AXn5CycvT5pVqkBs9WuF5GDNCfVb?=
 =?us-ascii?Q?LuOU6/NoFB3EqB4TmkzENZt/BDYSZNPgrg52VVJ9Yky0MTtntYd/XB20FKEU?=
 =?us-ascii?Q?mWN+bShdDjfzcRcuy+I=3D?=
Content-Type: text/plain; charset="us-ascii"
Content-Transfer-Encoding: quoted-printable
Precedence: bulk
X-Mailing-List: linux-kernel@vger.kernel.org
List-Id: <linux-kernel.vger.kernel.org>
List-Subscribe: <mailto:linux-kernel+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:linux-kernel+unsubscribe@vger.kernel.org>
MIME-Version: 1.0
X-OriginatorOrg: amd.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-AuthSource: BN7PR12MB2644.namprd12.prod.outlook.com
X-MS-Exchange-CrossTenant-Network-Message-Id: 2d695d24-1d30-4006-f81c-08dc3498e50d
X-MS-Exchange-CrossTenant-originalarrivaltime: 23 Feb 2024 17:57:26.1737
 (UTC)
X-MS-Exchange-CrossTenant-fromentityheader: Hosted
X-MS-Exchange-CrossTenant-id: 3dd8961f-e488-4e60-8e11-a82d994e183d
X-MS-Exchange-CrossTenant-mailboxtype: HOSTED
X-MS-Exchange-CrossTenant-userprincipalname: e/ACqB4sWgSukp8rtg7f+71xLwjkhsCZ/AgY25k2Ie8vV9NWHguOz8t8y8kCIGMf
X-MS-Exchange-Transport-CrossTenantHeadersStamped: PH8PR12MB7207

[AMD Official Use Only - General]

BTW, what is the encoding (units) of the 8-bit "scrub rate"?
(the ACPI spec does not seem to define that detail)

Thanks,
Leo.

-----Original Message-----
From: Jonathan Cameron <Jonathan.Cameron@Huawei.com>
Sent: Friday, February 23, 2024 11:26 AM
To: Borislav Petkov <bp@alien8.de>
Cc: shiju.jose@huawei.com; linux-cxl@vger.kernel.org; linux-acpi@vger.kerne=
l.org; linux-mm@kvack.org; dan.j.williams@intel.com; dave@stgolabs.net; dav=
e.jiang@intel.com; alison.schofield@intel.com; vishal.l.verma@intel.com; ir=
a.weiny@intel.com; linux-edac@vger.kernel.org; linux-kernel@vger.kernel.org=
; david@redhat.com; Sridharan, Vilas <Vilas.Sridharan@amd.com>; Duran, Leo =
<leo.duran@amd.com>; Ghannam, Yazen <Yazen.Ghannam@amd.com>; rientjes@googl=
e.com; jiaqiyan@google.com; tony.luck@intel.com; Grimm, Jon <Jon.Grimm@amd.=
com>; dave.hansen@linux.intel.com; rafael@kernel.org; lenb@kernel.org; naoy=
a.horiguchi@nec.com; james.morse@arm.com; jthoughton@google.com; somasundar=
am.a@hpe.com; erdemaktas@google.com; pgonda@google.com; duenwen@google.com;=
 mike.malvestuto@intel.com; gthelen@google.com; wschwartz@amperecomputing.c=
om; dferguson@amperecomputing.com; tanxiaofei@huawei.com; prime.zeng@hisili=
con.com; kangkang.shen@futurewei.com; wanghuiqiang@huawei.com; linuxarm@hua=
wei.com
Subject: Re: [RFC PATCH v7 00/12] memory: scrub: introduce subsystem + CXL/=
ACPI-RAS2 drivers

On Fri, 23 Feb 2024 16:42:51 +0100
Borislav Petkov <bp@alien8.de> wrote:

> On Fri, Feb 23, 2024 at 10:37:11PM +0800, shiju.jose@huawei.com wrote:
> > CXL patrol scrub and DDR5 ECS and ACPI RAS2 HW based memory patrol
> > scrub features are added as use cases for the scrub subsystem to
> > expose the scrub controls to the user.
>
> WTH is a RAS2 driver and where is the RAS1 driver?
>
Odd ACPI naming.  RASF (which is very limited) was replaced by RAS2.

Both are ACPI tables that describe the Platform Communication Channels
(mailbox) + provide a definition of the protocol that is sent over it in or=
der to control memory scrub.  RAS2 has some other uses this driver isn't to=
uching on.

So in short, it's an ACPI spec defined interface for controlling Memory Scr=
ub engines.

https://uefi.org/specs/ACPI/6.5/05_ACPI_Software_Programming_Model.html#acp=
i-ras2-feature-table-ras2

Jonathan

From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from mail-io1-f42.google.com (mail-io1-f42.google.com [209.85.166.42])
	(using TLSv1.2 with cipher ECDHE-RSA-AES128-GCM-SHA256 (128/128 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id ABF5356772;
	Mon, 11 Mar 2024 21:20:43 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=none smtp.client-ip=209.85.166.42
ARC-Seal: i=1; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1710192045; cv=none; b=bbvb8CwJHRDe4mx9JeBUqdMNwf/0cjhCVGjbtcPp5y32hOWxYrQH+dSyl1dfAnJsehPKHfw335IqPk8+/iEMqv7fT6AWRYnbsxT8q8hoOkt+07uUxCHnRknKCLTXd7XcRi5Mqs+hmvY7Hp9sfs5Ea/cKNtycoqQ5h25QJ+ZH/UQ=
ARC-Message-Signature: i=1; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1710192045; c=relaxed/simple;
	bh=HxYdp/+1ZrmqCfP7H1h9KnkYHbDmS8tczK9UeaKATig=;
	h=From:Date:To:Cc:Subject:Message-ID:References:MIME-Version:
	 Content-Type:Content-Disposition:In-Reply-To; b=NeNFU8jQrufw0UNrXtIaWPdjwrLbeUlUJLpHj3802m+e3ktSVc1D8HtX/kkwuEcJbFCTvcP/Q9u4q5Zg85/z+jImgDjQ+UcQw1cli+hY99wOUbZncx/nVeZy9cLDmpJ3Is8fOg0GTqTlycidzMrisIsRjZCZusQVO6WFFH1J72w=
ARC-Authentication-Results: i=1; smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=gmail.com; spf=pass smtp.mailfrom=gmail.com; dkim=pass (2048-bit key) header.d=gmail.com header.i=@gmail.com header.b=D9gGpIua; arc=none smtp.client-ip=209.85.166.42
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=gmail.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=gmail.com
Authentication-Results: smtp.subspace.kernel.org;
	dkim=pass (2048-bit key) header.d=gmail.com header.i=@gmail.com header.b="D9gGpIua"
Received: by mail-io1-f42.google.com with SMTP id ca18e2360f4ac-7bed9fb159fso172492439f.1;
        Mon, 11 Mar 2024 14:20:43 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=gmail.com; s=20230601; t=1710192043; x=1710796843; darn=vger.kernel.org;
        h=in-reply-to:content-disposition:mime-version:references:message-id
         :subject:cc:to:date:from:from:to:cc:subject:date:message-id:reply-to;
        bh=BBhNEQBVy1fL/SUIc8TvpP+Pi6/a540l6mhfsmCEnoA=;
        b=D9gGpIuaKliULNOid2NDaeh/rxs8s9kHu1YDiG5TYBrkC3bAoW2CUIioGe5LzmITXn
         UEtWWw+drSglfkEAq1Z4FN3MIIlyScW5yxvYXhLZB2PMTR17Jz4Buvuce002k3I+YkIA
         GOyoJISL2jJ4rQw7yTK/ZCbtQWKGEJLkecLqZekN/prt3Zsj74GYmS7Q9KGIvtP8ewKr
         xFzdAlj9Gc3w3Qe8adxiUTfkkjfXBxoegs/L3NtluYoVlNfGndQwWJidy9nBNhzr3+HA
         IUJLEgN/cWFLy33yDRaqzr2xY3N8ju3tJYwqwSmHJpw0Dg4mHmrmwaJF0sTksb8w/W18
         k1qw==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20230601; t=1710192043; x=1710796843;
        h=in-reply-to:content-disposition:mime-version:references:message-id
         :subject:cc:to:date:from:x-gm-message-state:from:to:cc:subject:date
         :message-id:reply-to;
        bh=BBhNEQBVy1fL/SUIc8TvpP+Pi6/a540l6mhfsmCEnoA=;
        b=uyRtQ5rLtO3BwPYbQzfQ6hOoQQG1xi3km79ntZS5l/0sJUYw9M2lV0xAG0ROgsJFid
         hXkEfUPOV3/DHgtZlbhB1W//EX5DMa97aK289zZYg5anBEu/7fZHGh2OUhjDkNRHxSU8
         HTT1nIlLLRcofYWTcyryx7s4Fg7cl1675IFDgPCyeO8k8TGbGYgUFspzXVf8G2fqCz6v
         l47td1y4prNvzt+//usvQ6O70ceqb6T8ddMOHYF1WirkFD/1Ic9uDkDr2UXzfE+hIhRP
         IBiIImevwCollKJdut1apy0OlyGF/UTfWg2GaJJbHmtNF6LnE0ZZKqat6tI5inATvom1
         7C/w==
X-Forwarded-Encrypted: i=1; AJvYcCXNZQPRKceiaLGRVDNzxqvo+VUj9wDwQC4KfRitebiCToT+MWPZG/CIxopkzQs5tJdTny0vRkrYwnFtm11icOKVzSZWf652+7Ba5Q/fMUst7KYZfPsiI55lX7Xh9WybJivDHdQbofpmKtnDc9aXYAYYHVZasb9Jl4cMs31SFw0JJlz5+Lc=
X-Gm-Message-State: AOJu0YzR5ibGQWoONgv92ceKVG0MSXQqJYfUhQrfprmTaWN9zu4+yPoy
	A9CRRv4cSHe8QlFd9Zs2RzlEspYjj4I7JSN5/cH7aSnJUP86pNAK
X-Google-Smtp-Source: AGHT+IF0bJjkZx211Ow0o9UR7ZYHFVRcRVsv6ZP9/5/UfJ2pK3pt/4piWTc05I528CJAag+9Qocpiw==
X-Received: by 2002:a05:6602:3307:b0:7c7:b761:9cea with SMTP id b7-20020a056602330700b007c7b7619ceamr8625565ioz.14.1710192042729;
        Mon, 11 Mar 2024 14:20:42 -0700 (PDT)
Received: from debian ([50.205.20.42])
        by smtp.gmail.com with ESMTPSA id a26-20020a056638005a00b004746fab2afdsm1904555jap.40.2024.03.11.14.20.40
        (version=TLS1_3 cipher=TLS_AES_256_GCM_SHA384 bits=256/256);
        Mon, 11 Mar 2024 14:20:42 -0700 (PDT)
From: fan <nifan.cxl@gmail.com>
X-Google-Original-From: fan <fan@debian>
Date: Mon, 11 Mar 2024 14:20:23 -0700
To: shiju.jose@huawei.com
Cc: linux-cxl@vger.kernel.org, linux-acpi@vger.kernel.org,
	linux-mm@kvack.org, dan.j.williams@intel.com, dave@stgolabs.net,
	jonathan.cameron@huawei.com, dave.jiang@intel.com,
	alison.schofield@intel.com, vishal.l.verma@intel.com,
	ira.weiny@intel.com, linux-edac@vger.kernel.org,
	linux-kernel@vger.kernel.org, david@redhat.com,
	Vilas.Sridharan@amd.com, leo.duran@amd.com, Yazen.Ghannam@amd.com,
	rientjes@google.com, jiaqiyan@google.com, tony.luck@intel.com,
	Jon.Grimm@amd.com, dave.hansen@linux.intel.com, rafael@kernel.org,
	lenb@kernel.org, naoya.horiguchi@nec.com, james.morse@arm.com,
	jthoughton@google.com, somasundaram.a@hpe.com,
	erdemaktas@google.com, pgonda@google.com, duenwen@google.com,
	mike.malvestuto@intel.com, gthelen@google.com,
	wschwartz@amperecomputing.com, dferguson@amperecomputing.com,
	tanxiaofei@huawei.com, prime.zeng@hisilicon.com,
	kangkang.shen@futurewei.com, wanghuiqiang@huawei.com,
	linuxarm@huawei.com
Subject: Re: [RFC PATCH v7 03/12] cxl/mbox: Add SET_FEATURE mailbox command
Message-ID: <Ze91l0jz_DZR9jjx@debian>
References: <20240223143723.1574-1-shiju.jose@huawei.com>
 <20240223143723.1574-4-shiju.jose@huawei.com>
Precedence: bulk
X-Mailing-List: linux-kernel@vger.kernel.org
List-Id: <linux-kernel.vger.kernel.org>
List-Subscribe: <mailto:linux-kernel+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:linux-kernel+unsubscribe@vger.kernel.org>
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: <20240223143723.1574-4-shiju.jose@huawei.com>

On Fri, Feb 23, 2024 at 10:37:14PM +0800, shiju.jose@huawei.com wrote:
> From: Shiju Jose <shiju.jose@huawei.com>
> 
> Add support for SET_FEATURE mailbox command.
> 
> CXL spec 3.1 section 8.2.9.6 describes optional device specific features.
> CXL devices supports features with changeable attributes.
> The settings of a feature can be optionally modified using Set Feature
> command.
> 
> Signed-off-by: Shiju Jose <shiju.jose@huawei.com>
> ---
>  drivers/cxl/core/mbox.c | 67 +++++++++++++++++++++++++++++++++++++++++
>  drivers/cxl/cxlmem.h    | 30 ++++++++++++++++++
>  2 files changed, 97 insertions(+)
> 
> diff --git a/drivers/cxl/core/mbox.c b/drivers/cxl/core/mbox.c
> index c078e62ea194..d1660bd20bdb 100644
> --- a/drivers/cxl/core/mbox.c
> +++ b/drivers/cxl/core/mbox.c
> @@ -1366,6 +1366,73 @@ size_t cxl_get_feature(struct cxl_memdev_state *mds,
>  }
>  EXPORT_SYMBOL_NS_GPL(cxl_get_feature, CXL);
>  
> +int cxl_set_feature(struct cxl_memdev_state *mds,
> +		    const uuid_t feat_uuid, u8 feat_version,
> +		    void *feat_data, size_t feat_data_size,
> +		    u8 feat_flag)
> +{
> +	struct cxl_memdev_set_feat_pi {
> +		struct cxl_mbox_set_feat_hdr hdr;
> +		u8 feat_data[];
> +	}  __packed;
> +	size_t data_in_size, data_sent_size = 0;
> +	struct cxl_mbox_cmd mbox_cmd;
> +	size_t hdr_size;
> +	int rc = 0;
> +
> +	struct cxl_memdev_set_feat_pi *pi __free(kfree) =
> +					kmalloc(mds->payload_size, GFP_KERNEL);
> +	pi->hdr.uuid = feat_uuid;
> +	pi->hdr.version = feat_version;
> +	feat_flag &= ~CXL_SET_FEAT_FLAG_DATA_TRANSFER_MASK;
> +	hdr_size = sizeof(pi->hdr);
> +	/*
> +	 * Check minimum mbox payload size is available for
> +	 * the feature data transfer.
> +	 */
> +	if (hdr_size + 10 > mds->payload_size)

Where does this magic number come from? 

Fan

> +		return -ENOMEM;
> +
> +	if ((hdr_size + feat_data_size) <= mds->payload_size) {
> +		pi->hdr.flags = cpu_to_le32(feat_flag |
> +				       CXL_SET_FEAT_FLAG_FULL_DATA_TRANSFER);
> +		data_in_size = feat_data_size;
> +	} else {
> +		pi->hdr.flags = cpu_to_le32(feat_flag |
> +				       CXL_SET_FEAT_FLAG_INITIATE_DATA_TRANSFER);
> +		data_in_size = mds->payload_size - hdr_size;
> +	}
> +
> +	do {
> +		pi->hdr.offset = cpu_to_le16(data_sent_size);
> +		memcpy(pi->feat_data, feat_data + data_sent_size, data_in_size);
> +		mbox_cmd = (struct cxl_mbox_cmd) {
> +			.opcode = CXL_MBOX_OP_SET_FEATURE,
> +			.size_in = hdr_size + data_in_size,
> +			.payload_in = pi,
> +		};
> +		rc = cxl_internal_send_cmd(mds, &mbox_cmd);
> +		if (rc < 0)
> +			return rc;
> +
> +		data_sent_size += data_in_size;
> +		if (data_sent_size >= feat_data_size)
> +			return 0;
> +
> +		if ((feat_data_size - data_sent_size) <= (mds->payload_size - hdr_size)) {
> +			data_in_size = feat_data_size - data_sent_size;
> +			pi->hdr.flags = cpu_to_le32(feat_flag |
> +					       CXL_SET_FEAT_FLAG_FINISH_DATA_TRANSFER);
> +		} else {
> +			pi->hdr.flags = cpu_to_le32(feat_flag |
> +					       CXL_SET_FEAT_FLAG_CONTINUE_DATA_TRANSFER);
> +		}
> +	} while (true);
> +
> +	return rc;
> +}
> +EXPORT_SYMBOL_NS_GPL(cxl_set_feature, CXL);
> +
>  int cxl_mem_get_poison(struct cxl_memdev *cxlmd, u64 offset, u64 len,
>  		       struct cxl_region *cxlr)
>  {
> diff --git a/drivers/cxl/cxlmem.h b/drivers/cxl/cxlmem.h
> index bcfefff062a6..a8d4104afa53 100644
> --- a/drivers/cxl/cxlmem.h
> +++ b/drivers/cxl/cxlmem.h
> @@ -531,6 +531,7 @@ enum cxl_opcode {
>  	CXL_MBOX_OP_GET_LOG		= 0x0401,
>  	CXL_MBOX_OP_GET_SUPPORTED_FEATURES	= 0x0500,
>  	CXL_MBOX_OP_GET_FEATURE		= 0x0501,
> +	CXL_MBOX_OP_SET_FEATURE		= 0x0502,
>  	CXL_MBOX_OP_IDENTIFY		= 0x4000,
>  	CXL_MBOX_OP_GET_PARTITION_INFO	= 0x4100,
>  	CXL_MBOX_OP_SET_PARTITION_INFO	= 0x4101,
> @@ -773,6 +774,31 @@ struct cxl_mbox_get_feat_in {
>  	u8 selection;
>  }  __packed;
>  
> +/* Set Feature CXL 3.1 Spec 8.2.9.6.3 */
> +/*
> + * Set Feature input payload
> + * CXL rev 3.1 section 8.2.9.6.3 Table 8-101
> + */
> +/* Set Feature : Payload in flags */
> +#define CXL_SET_FEAT_FLAG_DATA_TRANSFER_MASK	GENMASK(2, 0)
> +enum cxl_set_feat_flag_data_transfer {
> +	CXL_SET_FEAT_FLAG_FULL_DATA_TRANSFER,
> +	CXL_SET_FEAT_FLAG_INITIATE_DATA_TRANSFER,
> +	CXL_SET_FEAT_FLAG_CONTINUE_DATA_TRANSFER,
> +	CXL_SET_FEAT_FLAG_FINISH_DATA_TRANSFER,
> +	CXL_SET_FEAT_FLAG_ABORT_DATA_TRANSFER,
> +	CXL_SET_FEAT_FLAG_DATA_TRANSFER_MAX
> +};
> +#define CXL_SET_FEAT_FLAG_DATA_SAVED_ACROSS_RESET	BIT(3)
> +
> +struct cxl_mbox_set_feat_hdr {
> +	uuid_t uuid;
> +	__le32 flags;
> +	__le16 offset;
> +	u8 version;
> +	u8 rsvd[9];
> +}  __packed;
> +
>  /* Get Poison List  CXL 3.0 Spec 8.2.9.8.4.1 */
>  struct cxl_mbox_poison_in {
>  	__le64 offset;
> @@ -912,6 +938,10 @@ size_t cxl_get_feature(struct cxl_memdev_state *mds,
>  		       size_t feat_out_size,
>  		       size_t feat_out_min_size,
>  		       enum cxl_get_feat_selection selection);
> +int cxl_set_feature(struct cxl_memdev_state *mds,
> +		    const uuid_t feat_uuid, u8 feat_version,
> +		    void *feat_data, size_t feat_data_size,
> +		    u8 feat_flag);
>  int cxl_poison_state_init(struct cxl_memdev_state *mds);
>  int cxl_mem_get_poison(struct cxl_memdev *cxlmd, u64 offset, u64 len,
>  		       struct cxl_region *cxlr);
> -- 
> 2.34.1
> 

From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id 13AF278273;
	Tue, 12 Mar 2024 09:41:30 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=none smtp.client-ip=185.176.79.56
ARC-Seal: i=1; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1710236495; cv=none; b=ZbTOulhdLw+++OtY683nKbzLHkEDoCNXrIW3FESjfrBDC8IJM8yQLJ3CyoctQavDA5YH8WuaL4+DT+FyU4Q9rvz+e1rqsOtepY9T3DdeRD+tJ1c/a//WkpObsnbfTKbFvpWfP/rNkH4KJd0S7y4H75RMORduz5ECfAW0nJLZax8=
ARC-Message-Signature: i=1; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1710236495; c=relaxed/simple;
	bh=9BVd3T4GZqlg+poIfhaoPYk3KkThuqvVtjsxrrpVzUg=;
	h=From:To:CC:Subject:Date:Message-ID:References:In-Reply-To:
	 Content-Type:MIME-Version; b=nXsjDloJSJjTY1IYr81d91FJtZJfe9iTyfdcFrYgOo2ukmQqw19ry4ICQz/avYpvbtpPGC9V+phYCf4Wq8KpEjge7+eO3334C8ShFZ3aN/NWFnDOeg2DDTLr0X4o3bWuXI1m6DXx8GYb1Dl1S8XeIavYxCYu9AarsH7yPI10UVA=
ARC-Authentication-Results: i=1; smtp.subspace.kernel.org; dmarc=pass (p=quarantine dis=none) header.from=huawei.com; spf=pass smtp.mailfrom=huawei.com; arc=none smtp.client-ip=185.176.79.56
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=quarantine dis=none) header.from=huawei.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=huawei.com
Received: from mail.maildlp.com (unknown [172.18.186.231])
	by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4Tv7pW0sy4z688hZ;
	Tue, 12 Mar 2024 17:37:23 +0800 (CST)
Received: from lhrpeml500003.china.huawei.com (unknown [7.191.162.67])
	by mail.maildlp.com (Postfix) with ESMTPS id 5738E140D1D;
	Tue, 12 Mar 2024 17:41:28 +0800 (CST)
Received: from lhrpeml500006.china.huawei.com (7.191.161.198) by
 lhrpeml500003.china.huawei.com (7.191.162.67) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.35; Tue, 12 Mar 2024 09:41:27 +0000
Received: from lhrpeml500006.china.huawei.com ([7.191.161.198]) by
 lhrpeml500006.china.huawei.com ([7.191.161.198]) with mapi id 15.01.2507.035;
 Tue, 12 Mar 2024 09:41:27 +0000
From: Shiju Jose <shiju.jose@huawei.com>
To: fan <nifan.cxl@gmail.com>
CC: "linux-cxl@vger.kernel.org" <linux-cxl@vger.kernel.org>,
	"linux-acpi@vger.kernel.org" <linux-acpi@vger.kernel.org>,
	"linux-mm@kvack.org" <linux-mm@kvack.org>, "dan.j.williams@intel.com"
	<dan.j.williams@intel.com>, "dave@stgolabs.net" <dave@stgolabs.net>,
	"Jonathan Cameron" <jonathan.cameron@huawei.com>, "dave.jiang@intel.com"
	<dave.jiang@intel.com>, "alison.schofield@intel.com"
	<alison.schofield@intel.com>, "vishal.l.verma@intel.com"
	<vishal.l.verma@intel.com>, "ira.weiny@intel.com" <ira.weiny@intel.com>,
	"linux-edac@vger.kernel.org" <linux-edac@vger.kernel.org>,
	"linux-kernel@vger.kernel.org" <linux-kernel@vger.kernel.org>,
	"david@redhat.com" <david@redhat.com>, "Vilas.Sridharan@amd.com"
	<Vilas.Sridharan@amd.com>, "leo.duran@amd.com" <leo.duran@amd.com>,
	"Yazen.Ghannam@amd.com" <Yazen.Ghannam@amd.com>, "rientjes@google.com"
	<rientjes@google.com>, "jiaqiyan@google.com" <jiaqiyan@google.com>,
	"tony.luck@intel.com" <tony.luck@intel.com>, "Jon.Grimm@amd.com"
	<Jon.Grimm@amd.com>, "dave.hansen@linux.intel.com"
	<dave.hansen@linux.intel.com>, "rafael@kernel.org" <rafael@kernel.org>,
	"lenb@kernel.org" <lenb@kernel.org>, "naoya.horiguchi@nec.com"
	<naoya.horiguchi@nec.com>, "james.morse@arm.com" <james.morse@arm.com>,
	"jthoughton@google.com" <jthoughton@google.com>, "somasundaram.a@hpe.com"
	<somasundaram.a@hpe.com>, "erdemaktas@google.com" <erdemaktas@google.com>,
	"pgonda@google.com" <pgonda@google.com>, "duenwen@google.com"
	<duenwen@google.com>, "mike.malvestuto@intel.com"
	<mike.malvestuto@intel.com>, "gthelen@google.com" <gthelen@google.com>,
	"wschwartz@amperecomputing.com" <wschwartz@amperecomputing.com>,
	"dferguson@amperecomputing.com" <dferguson@amperecomputing.com>, tanxiaofei
	<tanxiaofei@huawei.com>, "Zengtao (B)" <prime.zeng@hisilicon.com>,
	"kangkang.shen@futurewei.com" <kangkang.shen@futurewei.com>, wanghuiqiang
	<wanghuiqiang@huawei.com>, Linuxarm <linuxarm@huawei.com>
Subject: RE: [RFC PATCH v7 03/12] cxl/mbox: Add SET_FEATURE mailbox command
Thread-Topic: [RFC PATCH v7 03/12] cxl/mbox: Add SET_FEATURE mailbox command
Thread-Index: AQHaZmXa2rf54FiQvUO4a7U5LboEzbEzJw+AgADJeeA=
Date: Tue, 12 Mar 2024 09:41:27 +0000
Message-ID: <b6aa1dd19ab44b7db7b9aa1318c5d8b0@huawei.com>
References: <20240223143723.1574-1-shiju.jose@huawei.com>
 <20240223143723.1574-4-shiju.jose@huawei.com> <Ze91l0jz_DZR9jjx@debian>
In-Reply-To: <Ze91l0jz_DZR9jjx@debian>
Accept-Language: en-GB, en-US
Content-Language: en-US
X-MS-Has-Attach: 
X-MS-TNEF-Correlator: 
Content-Type: text/plain; charset="us-ascii"
Content-Transfer-Encoding: quoted-printable
Precedence: bulk
X-Mailing-List: linux-kernel@vger.kernel.org
List-Id: <linux-kernel.vger.kernel.org>
List-Subscribe: <mailto:linux-kernel+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:linux-kernel+unsubscribe@vger.kernel.org>
MIME-Version: 1.0

Hi Fan,

>-----Original Message-----
>From: fan <nifan.cxl@gmail.com>
>Sent: 11 March 2024 21:20
>To: Shiju Jose <shiju.jose@huawei.com>
>Cc: linux-cxl@vger.kernel.org; linux-acpi@vger.kernel.org; linux-
>mm@kvack.org; dan.j.williams@intel.com; dave@stgolabs.net; Jonathan
>Cameron <jonathan.cameron@huawei.com>; dave.jiang@intel.com;
>alison.schofield@intel.com; vishal.l.verma@intel.com; ira.weiny@intel.com;
>linux-edac@vger.kernel.org; linux-kernel@vger.kernel.org; david@redhat.com=
;
>Vilas.Sridharan@amd.com; leo.duran@amd.com; Yazen.Ghannam@amd.com;
>rientjes@google.com; jiaqiyan@google.com; tony.luck@intel.com;
>Jon.Grimm@amd.com; dave.hansen@linux.intel.com; rafael@kernel.org;
>lenb@kernel.org; naoya.horiguchi@nec.com; james.morse@arm.com;
>jthoughton@google.com; somasundaram.a@hpe.com;
>erdemaktas@google.com; pgonda@google.com; duenwen@google.com;
>mike.malvestuto@intel.com; gthelen@google.com;
>wschwartz@amperecomputing.com; dferguson@amperecomputing.com;
>tanxiaofei <tanxiaofei@huawei.com>; Zengtao (B) <prime.zeng@hisilicon.com>=
;
>kangkang.shen@futurewei.com; wanghuiqiang <wanghuiqiang@huawei.com>;
>Linuxarm <linuxarm@huawei.com>
>Subject: Re: [RFC PATCH v7 03/12] cxl/mbox: Add SET_FEATURE mailbox
>command
>
>On Fri, Feb 23, 2024 at 10:37:14PM +0800, shiju.jose@huawei.com wrote:
>> From: Shiju Jose <shiju.jose@huawei.com>
>>
>> Add support for SET_FEATURE mailbox command.
>>
>> CXL spec 3.1 section 8.2.9.6 describes optional device specific features=
.
>> CXL devices supports features with changeable attributes.
>> The settings of a feature can be optionally modified using Set Feature
>> command.
>>
>> Signed-off-by: Shiju Jose <shiju.jose@huawei.com>
>> ---
>>  drivers/cxl/core/mbox.c | 67
>+++++++++++++++++++++++++++++++++++++++++
>>  drivers/cxl/cxlmem.h    | 30 ++++++++++++++++++
>>  2 files changed, 97 insertions(+)
>>
>> diff --git a/drivers/cxl/core/mbox.c b/drivers/cxl/core/mbox.c index
>> c078e62ea194..d1660bd20bdb 100644
>> --- a/drivers/cxl/core/mbox.c
>> +++ b/drivers/cxl/core/mbox.c
>> @@ -1366,6 +1366,73 @@ size_t cxl_get_feature(struct cxl_memdev_state
>> *mds,  }  EXPORT_SYMBOL_NS_GPL(cxl_get_feature, CXL);
>>
>> +int cxl_set_feature(struct cxl_memdev_state *mds,
>> +		    const uuid_t feat_uuid, u8 feat_version,
>> +		    void *feat_data, size_t feat_data_size,
>> +		    u8 feat_flag)
>> +{
>> +	struct cxl_memdev_set_feat_pi {
>> +		struct cxl_mbox_set_feat_hdr hdr;
>> +		u8 feat_data[];
>> +	}  __packed;
>> +	size_t data_in_size, data_sent_size =3D 0;
>> +	struct cxl_mbox_cmd mbox_cmd;
>> +	size_t hdr_size;
>> +	int rc =3D 0;
>> +
>> +	struct cxl_memdev_set_feat_pi *pi __free(kfree) =3D
>> +					kmalloc(mds->payload_size,
>GFP_KERNEL);
>> +	pi->hdr.uuid =3D feat_uuid;
>> +	pi->hdr.version =3D feat_version;
>> +	feat_flag &=3D ~CXL_SET_FEAT_FLAG_DATA_TRANSFER_MASK;
>> +	hdr_size =3D sizeof(pi->hdr);
>> +	/*
>> +	 * Check minimum mbox payload size is available for
>> +	 * the feature data transfer.
>> +	 */
>> +	if (hdr_size + 10 > mds->payload_size)
>
>Where does this magic number come from?

This represents minimum extra number of bytes to be available in the mail b=
ox
for storing the actual feature data to work with multipart feature data tra=
nsfers.
This will be set as a definition in the next version and however not sure t=
he
best value to be set.
>
>Fan
>
>> +		return -ENOMEM;
>> +
>> +	if ((hdr_size + feat_data_size) <=3D mds->payload_size) {
>> +		pi->hdr.flags =3D cpu_to_le32(feat_flag |
>> +
>CXL_SET_FEAT_FLAG_FULL_DATA_TRANSFER);
>> +		data_in_size =3D feat_data_size;
>> +	} else {
>> +		pi->hdr.flags =3D cpu_to_le32(feat_flag |
>> +
>CXL_SET_FEAT_FLAG_INITIATE_DATA_TRANSFER);
>> +		data_in_size =3D mds->payload_size - hdr_size;
>> +	}
>> +
>> +	do {
>> +		pi->hdr.offset =3D cpu_to_le16(data_sent_size);
>> +		memcpy(pi->feat_data, feat_data + data_sent_size,
>data_in_size);
>> +		mbox_cmd =3D (struct cxl_mbox_cmd) {
>> +			.opcode =3D CXL_MBOX_OP_SET_FEATURE,
>> +			.size_in =3D hdr_size + data_in_size,
>> +			.payload_in =3D pi,
>> +		};
>> +		rc =3D cxl_internal_send_cmd(mds, &mbox_cmd);
>> +		if (rc < 0)
>> +			return rc;
>> +
>> +		data_sent_size +=3D data_in_size;
>> +		if (data_sent_size >=3D feat_data_size)
>> +			return 0;
>> +
>> +		if ((feat_data_size - data_sent_size) <=3D (mds->payload_size -
>hdr_size)) {
>> +			data_in_size =3D feat_data_size - data_sent_size;
>> +			pi->hdr.flags =3D cpu_to_le32(feat_flag |
>> +
>CXL_SET_FEAT_FLAG_FINISH_DATA_TRANSFER);
>> +		} else {
>> +			pi->hdr.flags =3D cpu_to_le32(feat_flag |
>> +
>CXL_SET_FEAT_FLAG_CONTINUE_DATA_TRANSFER);
>> +		}
>> +	} while (true);
>> +
>> +	return rc;
>> +}
>> +EXPORT_SYMBOL_NS_GPL(cxl_set_feature, CXL);
>> +
>>  int cxl_mem_get_poison(struct cxl_memdev *cxlmd, u64 offset, u64 len,
>>  		       struct cxl_region *cxlr)
>>  {
>> diff --git a/drivers/cxl/cxlmem.h b/drivers/cxl/cxlmem.h index
>> bcfefff062a6..a8d4104afa53 100644
>> --- a/drivers/cxl/cxlmem.h
>> +++ b/drivers/cxl/cxlmem.h
>> @@ -531,6 +531,7 @@ enum cxl_opcode {
>>  	CXL_MBOX_OP_GET_LOG		=3D 0x0401,
>>  	CXL_MBOX_OP_GET_SUPPORTED_FEATURES	=3D 0x0500,
>>  	CXL_MBOX_OP_GET_FEATURE		=3D 0x0501,
>> +	CXL_MBOX_OP_SET_FEATURE		=3D 0x0502,
>>  	CXL_MBOX_OP_IDENTIFY		=3D 0x4000,
>>  	CXL_MBOX_OP_GET_PARTITION_INFO	=3D 0x4100,
>>  	CXL_MBOX_OP_SET_PARTITION_INFO	=3D 0x4101,
>> @@ -773,6 +774,31 @@ struct cxl_mbox_get_feat_in {
>>  	u8 selection;
>>  }  __packed;
>>
>> +/* Set Feature CXL 3.1 Spec 8.2.9.6.3 */
>> +/*
>> + * Set Feature input payload
>> + * CXL rev 3.1 section 8.2.9.6.3 Table 8-101  */
>> +/* Set Feature : Payload in flags */
>> +#define CXL_SET_FEAT_FLAG_DATA_TRANSFER_MASK	GENMASK(2, 0)
>> +enum cxl_set_feat_flag_data_transfer {
>> +	CXL_SET_FEAT_FLAG_FULL_DATA_TRANSFER,
>> +	CXL_SET_FEAT_FLAG_INITIATE_DATA_TRANSFER,
>> +	CXL_SET_FEAT_FLAG_CONTINUE_DATA_TRANSFER,
>> +	CXL_SET_FEAT_FLAG_FINISH_DATA_TRANSFER,
>> +	CXL_SET_FEAT_FLAG_ABORT_DATA_TRANSFER,
>> +	CXL_SET_FEAT_FLAG_DATA_TRANSFER_MAX
>> +};
>> +#define CXL_SET_FEAT_FLAG_DATA_SAVED_ACROSS_RESET	BIT(3)
>> +
>> +struct cxl_mbox_set_feat_hdr {
>> +	uuid_t uuid;
>> +	__le32 flags;
>> +	__le16 offset;
>> +	u8 version;
>> +	u8 rsvd[9];
>> +}  __packed;
>> +
>>  /* Get Poison List  CXL 3.0 Spec 8.2.9.8.4.1 */  struct
>> cxl_mbox_poison_in {
>>  	__le64 offset;
>> @@ -912,6 +938,10 @@ size_t cxl_get_feature(struct cxl_memdev_state
>*mds,
>>  		       size_t feat_out_size,
>>  		       size_t feat_out_min_size,
>>  		       enum cxl_get_feat_selection selection);
>> +int cxl_set_feature(struct cxl_memdev_state *mds,
>> +		    const uuid_t feat_uuid, u8 feat_version,
>> +		    void *feat_data, size_t feat_data_size,
>> +		    u8 feat_flag);
>>  int cxl_poison_state_init(struct cxl_memdev_state *mds);  int
>> cxl_mem_get_poison(struct cxl_memdev *cxlmd, u64 offset, u64 len,
>>  		       struct cxl_region *cxlr);
>> --
>> 2.34.1
>>

Thanks,
Shiju

From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from mail-io1-f41.google.com (mail-io1-f41.google.com [209.85.166.41])
	(using TLSv1.2 with cipher ECDHE-RSA-AES128-GCM-SHA256 (128/128 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id AACB813B791;
	Tue, 12 Mar 2024 18:32:34 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=none smtp.client-ip=209.85.166.41
ARC-Seal: i=1; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1710268356; cv=none; b=FLZmdbtd0D46Ohzx7BF/OjZ66l25HQ390GPg6U37yrQOrL5SC6he9FQb76Hgygk/5zdhkinH3vvHCuB38Pi4t5IlMPhYW88ZPAoxAxY50xsjxLmNcS6FrmQrbzjcmv1M+dDi/G83NnouTR7NwZxVbLLkiu4jkGh6NOLL1rn0et0=
ARC-Message-Signature: i=1; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1710268356; c=relaxed/simple;
	bh=yEXm95J5wvGnUMUtqcXy7Ftllk3x5/GMp5heKqnYsHA=;
	h=From:Date:To:Cc:Subject:Message-ID:References:MIME-Version:
	 Content-Type:Content-Disposition:In-Reply-To; b=cY0qjS4S5Gp+RxDExNvmXLYhYec90u6wzSbxWEwfsikXyoFqc2Np3vQObDBg55mpy5Mmy3plWv7tvSXv7Qn+7rC16+FiCoqgTwVxuOKMUt4X9i2X42lm6Jtyh9GChHX72eH6o20WPZ+gcIfmHtwUWKOsLEuENtxJbVRiBEBTJTY=
ARC-Authentication-Results: i=1; smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=gmail.com; spf=pass smtp.mailfrom=gmail.com; dkim=pass (2048-bit key) header.d=gmail.com header.i=@gmail.com header.b=Tx6xWRPX; arc=none smtp.client-ip=209.85.166.41
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=gmail.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=gmail.com
Authentication-Results: smtp.subspace.kernel.org;
	dkim=pass (2048-bit key) header.d=gmail.com header.i=@gmail.com header.b="Tx6xWRPX"
Received: by mail-io1-f41.google.com with SMTP id ca18e2360f4ac-7c88a2173daso8363239f.0;
        Tue, 12 Mar 2024 11:32:34 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=gmail.com; s=20230601; t=1710268354; x=1710873154; darn=vger.kernel.org;
        h=in-reply-to:content-disposition:mime-version:references:message-id
         :subject:cc:to:date:from:from:to:cc:subject:date:message-id:reply-to;
        bh=pqU8vwf+tbdTSkXAgzjKJdEijPq7ApphWIX0SIRCQzk=;
        b=Tx6xWRPXaLRsXGvcZcjAEL0ivLXuLZuf/uKXYZQk33G1cMijavtnpASkRvhIFXjBGP
         blNvUGbEbCH6qvIEHpApW9Bt22PjBPAMUcQLssxCll+BjucY2CosOVa1Flx/TDr5Qp+P
         AOqtl5d3NqNw8MxIDyRIv0KZ63GG5cI4c97RnvHkYfi5cdRLCKRWAE9aIyG9vLJdvgeb
         GpCMJw+8gqHM9MYLb3OZNZI96s//0E78hlsS6gE20OgeKzV/xibkQuUhOFW/nVjyxP8O
         +jHeTQJp2mhZYvFufbi7EqoxOQuA6y8U80EeG79Tk8KbpkCmxFbYS0IjPWWo19EFCTql
         0joA==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20230601; t=1710268354; x=1710873154;
        h=in-reply-to:content-disposition:mime-version:references:message-id
         :subject:cc:to:date:from:x-gm-message-state:from:to:cc:subject:date
         :message-id:reply-to;
        bh=pqU8vwf+tbdTSkXAgzjKJdEijPq7ApphWIX0SIRCQzk=;
        b=vxD/IivbmGMdULnVYH4jeEbWdexEeaYTXd/XgoCjMZSiB2+hkKYcukcf8TI3Ty+z/7
         YuQ3iwVTPgWUXVxKxd8U7n50Tpp/awYMHeVzFOEuIRVNZtOigUe3sWSXpI3BaHD+QEus
         Kd5QDGQPkhzA2juXVLfChg7ysQKgUb71eqXYghWv4RQa+r3Bp7OJMm73PAEYM1gXtx9f
         2VE/ZyhKqMNJOP4onFZZY80AH8mNJabhlYVbhlaNeWbNhgXTaS8+6q8UaEgM+cK3IWjt
         TTRtZL/uar3tmbCB+42d/PXMxgsCdJtIGMSw45fPOa5ORrYfShlR9Ecz51jfHmsUWwud
         w6wQ==
X-Forwarded-Encrypted: i=1; AJvYcCVYDRHSEUPWixRKkyqmpUEHfLYkKM6satrH0esz4relotG0PKZ3OgV1v+tbAO5ybpTGhPTz4RoB6Bmwz4pjIpE6XpArUSDjun1RmCbKjWJmo0iwLH9fIO2kLeF/FMFmaWwtEdVz+1RFUfWiPej/QKA+OF3nme1UjbRwV99PvHJATHF3kwA=
X-Gm-Message-State: AOJu0YyD83P9c9yM2GScCTbHbfZxJ0GLDP/DiQqKLPG85aC8KDjEh0w9
	KOPdFLT/q9GAeAvUXK/hKguGb0XdX9NljDp5M/kIFW6t+rF215JJnnBbKz1V
X-Google-Smtp-Source: AGHT+IHQ91EGeIfz2oaj8S9TucVWBSI/m7YsmBPoTA68buP0uVHpq6iN4yvUa+DL1kIPCUmvF0cgcw==
X-Received: by 2002:a6b:5c12:0:b0:7c8:c9b8:f976 with SMTP id z18-20020a6b5c12000000b007c8c9b8f976mr1280322ioh.21.1710268353693;
        Tue, 12 Mar 2024 11:32:33 -0700 (PDT)
Received: from debian ([50.205.20.42])
        by smtp.gmail.com with ESMTPSA id c18-20020a02c9d2000000b00474fab2523dsm2436749jap.62.2024.03.12.11.32.31
        (version=TLS1_3 cipher=TLS_AES_256_GCM_SHA384 bits=256/256);
        Tue, 12 Mar 2024 11:32:33 -0700 (PDT)
From: fan <nifan.cxl@gmail.com>
X-Google-Original-From: fan <fan@debian>
Date: Tue, 12 Mar 2024 11:32:17 -0700
To: shiju.jose@huawei.com
Cc: linux-cxl@vger.kernel.org, linux-acpi@vger.kernel.org,
	linux-mm@kvack.org, dan.j.williams@intel.com, dave@stgolabs.net,
	jonathan.cameron@huawei.com, dave.jiang@intel.com,
	alison.schofield@intel.com, vishal.l.verma@intel.com,
	ira.weiny@intel.com, linux-edac@vger.kernel.org,
	linux-kernel@vger.kernel.org, david@redhat.com,
	Vilas.Sridharan@amd.com, leo.duran@amd.com, Yazen.Ghannam@amd.com,
	rientjes@google.com, jiaqiyan@google.com, tony.luck@intel.com,
	Jon.Grimm@amd.com, dave.hansen@linux.intel.com, rafael@kernel.org,
	lenb@kernel.org, naoya.horiguchi@nec.com, james.morse@arm.com,
	jthoughton@google.com, somasundaram.a@hpe.com,
	erdemaktas@google.com, pgonda@google.com, duenwen@google.com,
	mike.malvestuto@intel.com, gthelen@google.com,
	wschwartz@amperecomputing.com, dferguson@amperecomputing.com,
	tanxiaofei@huawei.com, prime.zeng@hisilicon.com,
	kangkang.shen@futurewei.com, wanghuiqiang@huawei.com,
	linuxarm@huawei.com
Subject: Re: [RFC PATCH v7 10/12] ACPI:RAS2: Add common library for RAS2 PCC
 interfaces
Message-ID: <ZfCfsZARb_QY7bA5@debian>
References: <20240223143723.1574-1-shiju.jose@huawei.com>
 <20240223143723.1574-11-shiju.jose@huawei.com>
Precedence: bulk
X-Mailing-List: linux-kernel@vger.kernel.org
List-Id: <linux-kernel.vger.kernel.org>
List-Subscribe: <mailto:linux-kernel+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:linux-kernel+unsubscribe@vger.kernel.org>
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: <20240223143723.1574-11-shiju.jose@huawei.com>

On Fri, Feb 23, 2024 at 10:37:21PM +0800, shiju.jose@huawei.com wrote:
> From: A Somasundaram <somasundaram.a@hpe.com>
> 
> The code contains PCC interfaces for RAS2 table, functions to send
> RAS2 commands as per ACPI 6.5 & upwards revision.
> 
> References for this implementation,
> ACPI specification 6.5 section 5.2.21 for RAS2 table and chapter 14
> for PCC (Platform Communication Channel).
> 
> Driver uses PCC interfaces to communicate to the ACPI HW. This code
> implements PCC interfaces and the functions to send the RAS2 commands
> to be used by OSPM.
> 
> Signed-off-by: A Somasundaram <somasundaram.a@hpe.com>
> Co-developed-by: Shiju Jose <shiju.jose@huawei.com>
> Signed-off-by: Shiju Jose <shiju.jose@huawei.com>
> ---
>  drivers/acpi/Kconfig            |  14 ++
>  drivers/acpi/Makefile           |   1 +
>  drivers/acpi/ras2_acpi_common.c | 272 ++++++++++++++++++++++++++++++++
>  include/acpi/ras2_acpi.h        |  59 +++++++
>  4 files changed, 346 insertions(+)
>  create mode 100755 drivers/acpi/ras2_acpi_common.c
>  create mode 100644 include/acpi/ras2_acpi.h
> 
> diff --git a/drivers/acpi/Kconfig b/drivers/acpi/Kconfig
> index 3c3f8037ebed..6f69c9976c4f 100644
> --- a/drivers/acpi/Kconfig
> +++ b/drivers/acpi/Kconfig
> @@ -284,6 +284,20 @@ config ACPI_CPPC_LIB
>  	  If your platform does not support CPPC in firmware,
>  	  leave this option disabled.
>  
> +config ACPI_RAS2
> +	bool "ACPI RAS2 driver"
> +	depends on ACPI_PROCESSOR
> +	select MAILBOX
> +	select PCC
> +	help
> +	  The driver adds support for PCC (platform communication
> +	  channel) interfaces to communicate with the ACPI complaint
> +	  hardware platform supports RAS2(RAS2 Feature table).
> +	  The driver adds support for RAS2(extraction of RAS2
> +	  tables from OS system table), PCC interfaces and OSPM interfaces
> +	  to send RAS2 commands. Driver adds platform device which
> +	  binds to the RAS2 memory driver.
> +
>  config ACPI_PROCESSOR
>  	tristate "Processor"
>  	depends on X86 || ARM64 || LOONGARCH
> diff --git a/drivers/acpi/Makefile b/drivers/acpi/Makefile
> index 12ef8180d272..b12fba9cff06 100644
> --- a/drivers/acpi/Makefile
> +++ b/drivers/acpi/Makefile
> @@ -105,6 +105,7 @@ obj-$(CONFIG_ACPI_CUSTOM_METHOD)+= custom_method.o
>  obj-$(CONFIG_ACPI_BGRT)		+= bgrt.o
>  obj-$(CONFIG_ACPI_CPPC_LIB)	+= cppc_acpi.o
>  obj-$(CONFIG_ACPI_SPCR_TABLE)	+= spcr.o
> +obj-$(CONFIG_ACPI_RAS2)		+= ras2_acpi_common.o
>  obj-$(CONFIG_ACPI_DEBUGGER_USER) += acpi_dbg.o
>  obj-$(CONFIG_ACPI_PPTT) 	+= pptt.o
>  obj-$(CONFIG_ACPI_PFRUT)	+= pfr_update.o pfr_telemetry.o
> diff --git a/drivers/acpi/ras2_acpi_common.c b/drivers/acpi/ras2_acpi_common.c
> new file mode 100755
> index 000000000000..c6e4ed96cd81
> --- /dev/null
> +++ b/drivers/acpi/ras2_acpi_common.c
> @@ -0,0 +1,272 @@
> +// SPDX-License-Identifier: GPL-2.0-only
> +/*
> + * ACPI RAS2 table processing common functions
> + *
> + * (C) Copyright 2014, 2015 Hewlett-Packard Enterprises.
> + *
> + * Copyright (c) 2024 HiSilicon Limited.
> + *
> + * Support for
> + * RAS2 - ACPI 6.5 Specification, section 5.2.21
> + * PCC(Platform Communications Channel) - ACPI 6.5 Specification,
> + * chapter 14.
> + *
> + * Code contains common functions for RAS2.
> + * PCC(Platform communication channel) interfaces for the RAS2
> + * and the functions for sending RAS2 commands to the ACPI HW.
> + */
> +
> +#include <linux/export.h>
> +#include <linux/delay.h>
> +#include <linux/ktime.h>
> +#include <linux/platform_device.h>
> +#include <acpi/ras2_acpi.h>
> +#include <acpi/acpixf.h>
> +
> +static int ras2_check_pcc_chan(struct ras2_context *ras2_ctx)
> +{
> +	struct acpi_ras2_shared_memory  __iomem *generic_comm_base = ras2_ctx->pcc_comm_addr;
> +	ktime_t next_deadline = ktime_add(ktime_get(), ras2_ctx->deadline);
> +
> +	while (!ktime_after(ktime_get(), next_deadline)) {
> +		/*
> +		 * As per ACPI spec, the PCC space wil be initialized by

s/wil/will/

Fan
> +		 * platform and should have set the command completion bit when
> +		 * PCC can be used by OSPM
> +		 */
> +		if (readw_relaxed(&generic_comm_base->status) & RAS2_PCC_CMD_COMPLETE)
> +			return 0;
> +		/*
> +		 * Reducing the bus traffic in case this loop takes longer than
> +		 * a few retries.
> +		 */
> +		udelay(10);
> +	}
> +
> +	return -EIO;
> +}
> +
> +/**
> + * ras2_send_pcc_cmd() - Send RAS2 command via PCC channel
> + * @ras2_ctx:	pointer to the ras2 context structure
> + * @cmd:	command to send
> + *
> + * Returns: 0 on success, an error otherwise
> + */
> +int ras2_send_pcc_cmd(struct ras2_context *ras2_ctx, u16 cmd)
> +{
> +	int ret;
> +	struct acpi_ras2_shared_memory  *generic_comm_base =
> +		(struct acpi_ras2_shared_memory *)ras2_ctx->pcc_comm_addr;
> +	static ktime_t last_cmd_cmpl_time, last_mpar_reset;
> +	struct mbox_chan *pcc_channel;
> +	static int mpar_count;
> +	unsigned int time_delta;
> +
> +	if (cmd == RAS2_PCC_CMD_EXEC) {
> +		ret = ras2_check_pcc_chan(ras2_ctx);
> +		if (ret)
> +			return ret;
> +	}
> +	pcc_channel = ras2_ctx->pcc_chan->mchan;
> +
> +	/*
> +	 * Handle the Minimum Request Turnaround Time(MRTT)
> +	 * "The minimum amount of time that OSPM must wait after the completion
> +	 * of a command before issuing the next command, in microseconds"
> +	 */
> +	if (ras2_ctx->pcc_mrtt) {
> +		time_delta = ktime_us_delta(ktime_get(), last_cmd_cmpl_time);
> +		if (ras2_ctx->pcc_mrtt > time_delta)
> +			udelay(ras2_ctx->pcc_mrtt - time_delta);
> +	}
> +
> +	/*
> +	 * Handle the non-zero Maximum Periodic Access Rate(MPAR)
> +	 * "The maximum number of periodic requests that the subspace channel can
> +	 * support, reported in commands per minute. 0 indicates no limitation."
> +	 *
> +	 * This parameter should be ideally zero or large enough so that it can
> +	 * handle maximum number of requests that all the cores in the system can
> +	 * collectively generate. If it is not, we will follow the spec and just
> +	 * not send the request to the platform after hitting the MPAR limit in
> +	 * any 60s window
> +	 */
> +	if (ras2_ctx->pcc_mpar) {
> +		if (mpar_count == 0) {
> +			time_delta = ktime_ms_delta(ktime_get(), last_mpar_reset);
> +			if (time_delta < 60 * MSEC_PER_SEC) {
> +				dev_dbg(ras2_ctx->dev,
> +					"PCC cmd not sent due to MPAR limit");
> +				return -EIO;
> +			}
> +			last_mpar_reset = ktime_get();
> +			mpar_count = ras2_ctx->pcc_mpar;
> +		}
> +		mpar_count--;
> +	}
> +
> +	/* Write to the shared comm region. */
> +	writew_relaxed(cmd, &generic_comm_base->command);
> +
> +	/* Flip CMD COMPLETE bit */
> +	writew_relaxed(0, &generic_comm_base->status);
> +
> +	/* Ring doorbell */
> +	ret = mbox_send_message(pcc_channel, &cmd);
> +	if (ret < 0) {
> +		dev_err(ras2_ctx->dev,
> +			"Err sending PCC mbox message. cmd:%d, ret:%d\n",
> +			cmd, ret);
> +		return ret;
> +	}
> +
> +	/*
> +	 * For READs we need to ensure the cmd completed to ensure
> +	 * the ensuing read()s can proceed. For WRITEs we dont care
> +	 * because the actual write()s are done before coming here
> +	 * and the next READ or WRITE will check if the channel
> +	 * is busy/free at the entry of this call.
> +	 *
> +	 * If Minimum Request Turnaround Time is non-zero, we need
> +	 * to record the completion time of both READ and WRITE
> +	 * command for proper handling of MRTT, so we need to check
> +	 * for pcc_mrtt in addition to CMD_READ
> +	 */
> +	if (cmd == RAS2_PCC_CMD_EXEC || ras2_ctx->pcc_mrtt) {
> +		ret = ras2_check_pcc_chan(ras2_ctx);
> +		if (ras2_ctx->pcc_mrtt)
> +			last_cmd_cmpl_time = ktime_get();
> +	}
> +
> +	if (pcc_channel->mbox->txdone_irq)
> +		mbox_chan_txdone(pcc_channel, ret);
> +	else
> +		mbox_client_txdone(pcc_channel, ret);
> +
> +	return ret;
> +}
> +EXPORT_SYMBOL_GPL(ras2_send_pcc_cmd);
> +
> +/**
> + * ras2_register_pcc_channel() - Register PCC channel
> + * @ras2_ctx:	pointer to the ras2 context structure
> + *
> + * Returns: 0 on success, an error otherwise
> + */
> +int ras2_register_pcc_channel(struct ras2_context *ras2_ctx)
> +{
> +	u64 usecs_lat;
> +	unsigned int len;
> +	struct pcc_mbox_chan *pcc_chan;
> +	struct mbox_client *ras2_mbox_cl;
> +	struct acpi_pcct_hw_reduced *ras2_ss;
> +
> +	ras2_mbox_cl = &ras2_ctx->mbox_client;
> +	if (!ras2_mbox_cl || ras2_ctx->pcc_subspace_idx < 0)
> +		return -EINVAL;
> +
> +	pcc_chan = pcc_mbox_request_channel(ras2_mbox_cl,
> +					    ras2_ctx->pcc_subspace_idx);
> +
> +	if (IS_ERR(pcc_chan)) {
> +		dev_err(ras2_ctx->dev,
> +			"Failed to find PCC channel for subspace %d\n",
> +			ras2_ctx->pcc_subspace_idx);
> +		return -ENODEV;
> +	}
> +	ras2_ctx->pcc_chan = pcc_chan;
> +	/*
> +	 * The PCC mailbox controller driver should
> +	 * have parsed the PCCT (global table of all
> +	 * PCC channels) and stored pointers to the
> +	 * subspace communication region in con_priv.
> +	 */
> +	ras2_ss = pcc_chan->mchan->con_priv;
> +
> +	if (!ras2_ss) {
> +		dev_err(ras2_ctx->dev, "No PCC subspace found for RAS2\n");
> +		pcc_mbox_free_channel(ras2_ctx->pcc_chan);
> +		return -ENODEV;
> +	}
> +
> +	/*
> +	 * This is the shared communication region
> +	 * for the OS and Platform to communicate over.
> +	 */
> +	ras2_ctx->comm_base_addr = ras2_ss->base_address;
> +	len = ras2_ss->length;
> +	dev_dbg(ras2_ctx->dev, "PCC subspace for RAS2=0x%llx len=%d\n",
> +		ras2_ctx->comm_base_addr, len);
> +
> +	/*
> +	 * ras2_ss->latency is just a Nominal value. In reality
> +	 * the remote processor could be much slower to reply.
> +	 * So add an arbitrary amount of wait on top of Nominal.
> +	 */
> +	usecs_lat = RAS2_NUM_RETRIES * ras2_ss->latency;
> +	ras2_ctx->deadline = ns_to_ktime(usecs_lat * NSEC_PER_USEC);
> +	ras2_ctx->pcc_mrtt = ras2_ss->min_turnaround_time;
> +	ras2_ctx->pcc_mpar = ras2_ss->max_access_rate;
> +	ras2_ctx->pcc_comm_addr = acpi_os_ioremap(ras2_ctx->comm_base_addr,
> +						  len);
> +	dev_dbg(ras2_ctx->dev, "pcc_comm_addr=%p\n",
> +		ras2_ctx->pcc_comm_addr);
> +
> +	/* Set flag so that we dont come here for each CPU. */
> +	ras2_ctx->pcc_channel_acquired = true;
> +
> +	return 0;
> +}
> +EXPORT_SYMBOL_GPL(ras2_register_pcc_channel);
> +
> +/**
> + * ras2_unregister_pcc_channel() - Unregister PCC channel
> + * @ras2_ctx:	pointer to the ras2 context structure
> + *
> + * Returns: 0 on success, an error otherwise
> + */
> +int ras2_unregister_pcc_channel(struct ras2_context *ras2_ctx)
> +{
> +	if (!ras2_ctx->pcc_chan)
> +		return -EINVAL;
> +
> +	pcc_mbox_free_channel(ras2_ctx->pcc_chan);
> +
> +	return 0;
> +}
> +EXPORT_SYMBOL_GPL(ras2_unregister_pcc_channel);
> +
> +/**
> + * ras2_add_platform_device() - Add a platform device for RAS2
> + * @name:	name of the device we're adding
> + * @data:	platform specific data for this platform device
> + * @size:	size of platform specific data
> + *
> + * Returns: pointer to platform device on success, an error otherwise
> + */
> +struct platform_device *ras2_add_platform_device(char *name, const void *data,
> +						 size_t size)
> +{
> +	int ret;
> +	struct platform_device *pdev;
> +
> +	pdev = platform_device_alloc(name, PLATFORM_DEVID_AUTO);
> +	if (!pdev)
> +		return NULL;
> +
> +	ret = platform_device_add_data(pdev, data, size);
> +	if (ret)
> +		goto dev_put;
> +
> +	ret = platform_device_add(pdev);
> +	if (ret)
> +		goto dev_put;
> +
> +	return pdev;
> +
> +dev_put:
> +	platform_device_put(pdev);
> +
> +	return ERR_PTR(ret);
> +}
> diff --git a/include/acpi/ras2_acpi.h b/include/acpi/ras2_acpi.h
> new file mode 100644
> index 000000000000..5e9ac788670a
> --- /dev/null
> +++ b/include/acpi/ras2_acpi.h
> @@ -0,0 +1,59 @@
> +/* SPDX-License-Identifier: GPL-2.0-only */
> +/*
> + * RAS2 ACPI driver header file
> + *
> + * (C) Copyright 2014, 2015 Hewlett-Packard Enterprises
> + *
> + * Copyright (c) 2024 HiSilicon Limited
> + */
> +
> +#ifndef _RAS2_ACPI_H
> +#define _RAS2_ACPI_H
> +
> +#include <linux/acpi.h>
> +#include <linux/mailbox_client.h>
> +#include <linux/mailbox_controller.h>
> +#include <linux/types.h>
> +#include <acpi/pcc.h>
> +
> +#define RAS2_PCC_CMD_COMPLETE 1
> +
> +/* RAS2 specific PCC commands */
> +#define RAS2_PCC_CMD_EXEC 0x01
> +
> +#define RAS2_FAILURE 0
> +#define RAS2_SUCCESS 1
> +
> +/*
> + * Arbitrary Retries for PCC commands because the
> + * remote processor could be much slower to reply.
> + */
> +#define RAS2_NUM_RETRIES 600
> +
> +/*
> + * Data structures for PCC communication and RAS2 table
> + */
> +struct ras2_context {
> +	struct device *dev;
> +	int id;
> +	struct mbox_client mbox_client;
> +	struct pcc_mbox_chan *pcc_chan;
> +	void __iomem *pcc_comm_addr;
> +	u64 comm_base_addr;
> +	int pcc_subspace_idx;
> +	bool pcc_channel_acquired;
> +	ktime_t deadline;
> +	unsigned int pcc_mpar;
> +	unsigned int pcc_mrtt;
> +	/* Lock to provide mutually exclusive access to PCC channel */
> +	spinlock_t spinlock;
> +	struct device *scrub_dev;
> +	const struct ras2_hw_scrub_ops *ops;
> +};
> +
> +struct platform_device *ras2_add_platform_device(char *name, const void *data,
> +						 size_t size);
> +int ras2_send_pcc_cmd(struct ras2_context *ras2_ctx, u16 cmd);
> +int ras2_register_pcc_channel(struct ras2_context *ras2_ctx);
> +int ras2_unregister_pcc_channel(struct ras2_context *ras2_ctx);
> +#endif /* _RAS2_ACPI_H */
> -- 
> 2.34.1
> 

From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from NAM04-MW2-obe.outbound.protection.outlook.com (mail-mw2nam04on2073.outbound.protection.outlook.com [40.107.101.73])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id 7ACB883A1C;
	Thu, 28 Mar 2024 15:23:48 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=fail smtp.client-ip=40.107.101.73
ARC-Seal: i=2; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1711639430; cv=fail; b=DTCThtIBv4/+dTFEWWnP38WNVYuY1U/W8Jex3SJSQNhzJLVWWgLdQtpvu8TQvKgMazNgCCyWIHXkHdSSAWeWjejbizu+tDtWHpjRXOe3d4vKoE6nAzbprHN2+dsgKIT2EJBWO/Z1gs4BHdQrmzVDukWPclyh6Ls63Lk8QA3nqdo=
ARC-Message-Signature: i=2; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1711639430; c=relaxed/simple;
	bh=eg9z9FlPwWIyPLSfNVOgcFRlrrr5PQsu7PXQ7zpQdqA=;
	h=Message-ID:Date:Cc:Subject:To:References:From:In-Reply-To:
	 Content-Type:MIME-Version; b=m+U76ww3SXsn/1i4aCk3yBHoMvEqEa2zion0TUNdDifbfqUQYgIpeP9H4QMBUnHASJxI61NXS2OqT1ugj06N4Y/0clSWowZJeRwgxNsU6KSbI/CVjMhjuV2Y1+V173n+r7N56w+yGzMv9lg+4e/Q/QxjWVgmpZJMR37xbNS22og=
ARC-Authentication-Results: i=2; smtp.subspace.kernel.org; dmarc=pass (p=quarantine dis=none) header.from=amd.com; spf=fail smtp.mailfrom=amd.com; dkim=pass (1024-bit key) header.d=amd.com header.i=@amd.com header.b=0UY7/iBw; arc=fail smtp.client-ip=40.107.101.73
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=quarantine dis=none) header.from=amd.com
Authentication-Results: smtp.subspace.kernel.org; spf=fail smtp.mailfrom=amd.com
Authentication-Results: smtp.subspace.kernel.org;
	dkim=pass (1024-bit key) header.d=amd.com header.i=@amd.com header.b="0UY7/iBw"
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=jcayof/77NFYdvGlMLNV0Q73wIDd0T9fEBYJesuxQ+dZv+tQCAPwH1NLKmjShJnd8rq5Wz4bvarVeeAUfUwgNb3LdosMkbX5nbiJiqy4vvIZKFahHBunJRLdLIpreiG7SeYCWf4F2c0PhKDqBVVC4xh8MNFJyneBG35+RJyfJPvbiaPs6+i9jhtoZuyQqUMRTELeOSu22vNGlJJS9dWHZsCQ7rCfycMLnMD59uDPnlPVW999FP0Kk4Jydu5jvt+3t4XPwV7xWbF0dMWTTcGSB5fTrM5ePkMUB+ZqRU8LoKRbR2ol2d6QGMEw413qfqt8yqxxqQb48aHx6nMKiIO4SQ==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=pEfXySuwTdOLIgv3Kn/rdQcMtjZuP4sP3SGzGbfpAro=;
 b=mgfjj2q5JPZSv8NJs7DqGY7yw394S7lYAopC1pw1iDk47dDLH4zoy8NL1fxXhZaLMzZjUiTZRQDzgwy+2yGCDqSlEk3CjfcKP4aFtvqbJvPVuaJoEozhP9c4opk9nIHfEKCqdwoCvdsloQ9g+tgTfTYjYKPqlcSyjGT4XsOi10TgPPpZnxFCgQCkqftU/cKw4ywixrAJOVtWLpcQC3SCAWLNiOY8eZ+J/FmfnxQX4Be2RyuKxTBPm3eSEM9gdxWTl7DWvnlwd1pfFDnhbaabkS5YRE+HNZ2V0dYVYLaEIWwY+y41mPcjaBPM07n78wSHBfK4TufxdtPBkNInWyiX4g==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=amd.com; dmarc=pass action=none header.from=amd.com; dkim=pass
 header.d=amd.com; arc=none
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=amd.com; s=selector1;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-SenderADCheck;
 bh=pEfXySuwTdOLIgv3Kn/rdQcMtjZuP4sP3SGzGbfpAro=;
 b=0UY7/iBw/9DdRKmK7a99vTvhIXYGuW8trZlE/GLwgsR82uoyyZXB6DHcg4tUxxt1ovNNQVl+rUOhSLp1cOlk54eCOc8355Ba1t1t3tjYn+4lwD0fChQ0cbz2NG3tJnNMcqftNQqkAYqQF6ddtKfEBua7l6HG2HLzJ4NyKjs5w/8=
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=amd.com;
Received: from BYAPR12MB3109.namprd12.prod.outlook.com (2603:10b6:a03:db::17)
 by DM6PR12MB4076.namprd12.prod.outlook.com (2603:10b6:5:213::15) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.7409.32; Thu, 28 Mar
 2024 15:23:46 +0000
Received: from BYAPR12MB3109.namprd12.prod.outlook.com
 ([fe80::b2b4:a3f1:a86:d6bd]) by BYAPR12MB3109.namprd12.prod.outlook.com
 ([fe80::b2b4:a3f1:a86:d6bd%5]) with mapi id 15.20.7409.028; Thu, 28 Mar 2024
 15:23:46 +0000
Message-ID: <71d41ec9-17ed-442f-8d68-a6cb9bcbb4b0@amd.com>
Date: Thu, 28 Mar 2024 11:23:38 -0400
User-Agent: Mozilla Thunderbird
Cc: yazen.ghannam@amd.com, linux-edac@vger.kernel.org,
 linux-kernel@vger.kernel.org, david@redhat.com, Vilas.Sridharan@amd.com,
 leo.duran@amd.com, rientjes@google.com, jiaqiyan@google.com,
 tony.luck@intel.com, Jon.Grimm@amd.com, dave.hansen@linux.intel.com,
 rafael@kernel.org, lenb@kernel.org, naoya.horiguchi@nec.com,
 james.morse@arm.com, jthoughton@google.com, somasundaram.a@hpe.com,
 erdemaktas@google.com, pgonda@google.com, duenwen@google.com,
 mike.malvestuto@intel.com, gthelen@google.com,
 wschwartz@amperecomputing.com, dferguson@amperecomputing.com,
 tanxiaofei@huawei.com, prime.zeng@hisilicon.com,
 kangkang.shen@futurewei.com, wanghuiqiang@huawei.com, linuxarm@huawei.com
Subject: Re: [RFC PATCH v7 12/12] memory: RAS2: Add memory RAS2 driver
To: shiju.jose@huawei.com, linux-cxl@vger.kernel.org,
 linux-acpi@vger.kernel.org, linux-mm@kvack.org, dan.j.williams@intel.com,
 dave@stgolabs.net, jonathan.cameron@huawei.com, dave.jiang@intel.com,
 alison.schofield@intel.com, vishal.l.verma@intel.com, ira.weiny@intel.com
References: <20240223143723.1574-1-shiju.jose@huawei.com>
 <20240223143723.1574-13-shiju.jose@huawei.com>
Content-Language: en-US
From: Yazen Ghannam <yazen.ghannam@amd.com>
In-Reply-To: <20240223143723.1574-13-shiju.jose@huawei.com>
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
X-ClientProxiedBy: BN0PR03CA0016.namprd03.prod.outlook.com
 (2603:10b6:408:e6::21) To BYAPR12MB3109.namprd12.prod.outlook.com
 (2603:10b6:a03:db::17)
Precedence: bulk
X-Mailing-List: linux-kernel@vger.kernel.org
List-Id: <linux-kernel.vger.kernel.org>
List-Subscribe: <mailto:linux-kernel+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:linux-kernel+unsubscribe@vger.kernel.org>
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: BYAPR12MB3109:EE_|DM6PR12MB4076:EE_
X-MS-Office365-Filtering-Correlation-Id: 5d0a7ba7-9954-4727-c834-08dc4f3b0ec8
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;
X-Microsoft-Antispam-Message-Info: 
	+UoNphMplPg2CG01laOq2FKVqNqjMD5g9dOL4zPgDTVz9jDNvb+5w1dmRcP03XYAf3TfNNh/w2HpYyGxI4aKPr3IJEqyD8l7HJRbP0DwZauUOoODHYpWbJQZTt/TXxI7Lr8Pw1AWGcpqIInhd155FAseN0+VI2OGXJXCiZlSdwE7EeNMlWZOPXUz2W9NxxCMQ2PiCo1/qqqUzJkfXZ6KOyS7bNivmVhoUkPO0RIFFzrmUxDOEv2k/6X3XERJa7ivj+TKU2n+schQae0EZcDiQfxsprAlXLx13uexx4VH+AMQnWdVIFHidt9AefXfOQVtwnd64UWnA2Beh7wSnQ/Hwdy3TkYQW39oPOz8+rSLl3/4HkYPjpm7Hd2leFldVwO+Xm7oSpWkYUKhdRnrhUe6DXyNxo/2i5S0aqyLLoUP9SEsJefGnAfRU+XD+v35TWaA7jCw8WCcg29Bqu56ioEEmjQSl1MTNxN1M3YSiX8woxOQd8VIO9tzQs/ZZEg7Xyij1D1zjSWQbdvexOHxhqrXxkrNS/2LT0F6Ounf1iEoxb+KWWZZi2aYK1//F21ny2030CM08QDdScy20Fghk2EYB7g+Nop/WgUWqXNqUq8uDC1uAyB/4rGI8UVVPEtvcZhGtOVhVdjKQ1QYpoj1Ypn5klEW0l9cjyN2doBkKX5gRAiiK64XPZoEHPMc95nrCvdkbRD3Cko9kYS+MAIdQOZ4jw==
X-Forefront-Antispam-Report: 
	CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:BYAPR12MB3109.namprd12.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230031)(1800799015)(7416005)(376005)(366007)(921011);DIR:OUT;SFP:1101;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: 
	=?utf-8?B?UUt2S2l1ak9FZUpPVlUxOHVBOEwxMktlK211SC9yUmZjREY5RkplTXhNS0Nx?=
 =?utf-8?B?M1VUVW5BZEJnS0hEbXpRdzFyK3lsNkgvemptWTRpVyt4RDFIb09Gdk5CbmRl?=
 =?utf-8?B?eCtSbnduSFVHVzJ4ZXc5aW1sV0ozbmZaK3pSV1Y1RDFPbEE3N1lXY2R0QllZ?=
 =?utf-8?B?ODZOaHdYQ1lJUFl4QnByR0tqK1JWa2ZyUVNSWXRwS1Ayb3F2dGZGRTVFREhI?=
 =?utf-8?B?RnRqWS8xcmZBcVBNdFF5ZXVQd2xib01PdXhiSjlEL0tPWWNINHdFeHFCNEpK?=
 =?utf-8?B?SmduKy9DNFhHYXRpSzVhWGhtK3FicG1Qa1I0ODA5ZGRlT2E5UEFsaUQ2L093?=
 =?utf-8?B?MGJRMHlpOEJKUndEWGNkOXBQOFJOb0x1L3JEOTNtMlB6b1NyczBBd1J4TEZy?=
 =?utf-8?B?VXhzTTNGdVNpRDRodGVRZ0RSS25ZejdQTDltSHpISERYV3RYa2VsMis1RjV4?=
 =?utf-8?B?Y3RzQklIS09LeS9NdTlSdkRYQWtwckRZUzNDUnJOWFJnMENxMWxvZS82YkR3?=
 =?utf-8?B?OFRVZE01ZXB4Ni9JcXdxVENYZXJ4NUI0cjlzSUVjMG1DYVlFMnpIbWNJWDcx?=
 =?utf-8?B?Y3h6aDBxMWZpNE1hTzNtQ1huVzVEUEZsOEd6U1lJbVZuMEs2NFBUU3o4NmZW?=
 =?utf-8?B?Qk13ekJwb1BUL1VlNkxnb25rV2lvRWprRHdjdTJ4VE16eWVXUk1Va3p2SkZv?=
 =?utf-8?B?MFBpc1dybk9GaE41N2p2TlA0NEZzcVovTzB1S29OTlRJQXF0RXpSU282WFZ4?=
 =?utf-8?B?dTFWdXBqN1FRWStmOU43V2JuNXp2bkJnMk42dlFzUE41bUFLWmRXNUdUWmM4?=
 =?utf-8?B?SUZSWXZMbGM2a1pVd214bnNIdklOUFUxNDhQcDhHak1wUVhyelFvbkI0eENK?=
 =?utf-8?B?eVJCMXhXRlNrZk1NUDNFb1BVWXQ2NUVvdElNaFpQa1ZoT3llOTFYSzIraGlW?=
 =?utf-8?B?UjNyV2pjdzZlWlZPMzJZQjMzM1NBT3ZLcVp3Nzl0ajZFUDM2eS80NnBmdCtQ?=
 =?utf-8?B?RTNyYk96MHh6RDJFU0htVkJsTkRCV3ArZnpkTm9xWm93d1p1SWh5MmlYN1Bu?=
 =?utf-8?B?Si9HN1k3WlNwT3hibDk1cFMzdTBJbG9xamtQQVNDRUlDaW5TYmxxcjgybjR5?=
 =?utf-8?B?byt4Y1dCRjE4cy9qSXRpRjJHZFFsazBLc2xURnl6L1pKUVIwL2Izd3ZRNENn?=
 =?utf-8?B?L245eWNiaUdlQVMyNmVYRHBETlZWM3NWQ1RFWWM5bHJuNUV2UW9FV3U5eWxN?=
 =?utf-8?B?U29HaVYxdU5JRkNqU3NYaTBoSTJqeU5kQUNWSkN2Q1lMVlcxK0E3cVRnN3ZV?=
 =?utf-8?B?NTZZYld0ek1XalZVaXY3NmRSKzJ2MU5MeEFNUWdSQXAzeVNESGkyV0E1RUtI?=
 =?utf-8?B?M0dIRElycFhpdkxJWDRocUswTEpqTmd4TUZSeEU0NWgrWFlMMGU0c3RpRENF?=
 =?utf-8?B?b3BROVdyQmIreXZHcnUvVENVckowWTZmZGJXZmpPeklma2ZEUVJlMkViNjFs?=
 =?utf-8?B?WFAvM2NaZFlHYWEzQkNLNjNyUDRKdzJDUFJ4Y3BXR25CcEVEdzQzUVBMWTFv?=
 =?utf-8?B?Si9tb0RuNE9oMGxocERzY3JCaVVYQmlNN1VpT1BYaW5xK1AvODhKMVNYYWtn?=
 =?utf-8?B?K3NzMVloWjIxZFFEbXN4MzdkRXVYZDVCbWRzS015RzdDcUppR3NmckhZdkxN?=
 =?utf-8?B?OThEK0ZzZnRvL25aWWJFaDFzSTh0SGwvSDZhbEYxUEo0UEFlWThOTXovQkcv?=
 =?utf-8?B?ZWdKQ1ZrUSsrNEU0MHVlVjU0UDdqMHAxZjQxZmRzeStwUCtwWk9PNWY5eHVN?=
 =?utf-8?B?Um1McEc5aFlMTSt0LzFyU1JCQ1UrUVRING82dGV2em5pRXc2ZU5KS2pXWCtv?=
 =?utf-8?B?cmg4clJnOGZmZGxLVklzMmF3dmxPOHU4ZytWNGErRS84K21IQjRWTEd2Zklx?=
 =?utf-8?B?SUFFTW1lSDZuQSs1bU5QN0c5MEM2RkhIdzJEbkh2TkRMMXVWK3I1ckZYdTBu?=
 =?utf-8?B?N3BxcHYwYVdjbVU5ejBjdXZTVENiaURjYnB2TDkwVjF3UUJMOVdZNWxZWlJD?=
 =?utf-8?B?YVpyRE5hUUVyT3ZJVHpTTFljS3l3N3FZV1p2QkNFWDZIelExQkhocGxKekIr?=
 =?utf-8?Q?EplYsj+hSJ9LsOWkTEAOS6sh8?=
X-OriginatorOrg: amd.com
X-MS-Exchange-CrossTenant-Network-Message-Id: 5d0a7ba7-9954-4727-c834-08dc4f3b0ec8
X-MS-Exchange-CrossTenant-AuthSource: BYAPR12MB3109.namprd12.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 28 Mar 2024 15:23:45.9083
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 3dd8961f-e488-4e60-8e11-a82d994e183d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: eTRTkkTcfKInFLKtq0xfZtBR5mMN8bLub66IgWwurrYzdgPelaFY78Hd8cQXmQ7yA7V0S3GYxmTL6AhG3U+rSQ==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: DM6PR12MB4076

On 2/23/2024 9:37 AM, shiju.jose@huawei.com wrote:
> From: Shiju Jose <shiju.jose@huawei.com>
> 
> Memory RAS2 driver binds to the platform device add by the ACPI RAS2
> driver.
> Driver registers the PCC channel for communicating with the ACPI compliant
> platform that contains RAS2 command support in the hardware.
> 
> Add interface functions to support configuring the parameters of HW patrol
> scrubs in the system, which exposed to the kernel via the RAS2 and PCC,
> using the RAS2 commands.
> 
> Add support for RAS2 platform devices to register with scrub subsystem
> driver. This enables user to configure the parameters of HW patrol scrubs,
> which exposed to the kernel via the RAS2 table, through the scrub sysfs
> attributes.
> 
> Open Question:
> Sysfs scrub control attribute "enable_background_scrub" is added for RAS2,
> based on the feedback from Bill Schwartz <wschwartz@amperecomputing.com
> on v4 to enable/disable the background_scrubbing in the platform as defined in the
> Configure Scrub Parameters [INPUT] field  in RAS2 Table 5.87: Parameter Block
> Structure for PATROL_SCRUB.
> Is it a right approach to support "enable_background_scrub" in the sysfs
> scrub control?
> 
> Signed-off-by: Shiju Jose <shiju.jose@huawei.com>
> ---
>  drivers/memory/Kconfig       |  14 ++
>  drivers/memory/Makefile      |   2 +
>  drivers/memory/ras2.c        | 364 +++++++++++++++++++++++++++++++++++
>  drivers/memory/ras2_common.c | 282 +++++++++++++++++++++++++++
>  include/memory/ras2.h        |  88 +++++++++
>  5 files changed, 750 insertions(+)
>  create mode 100644 drivers/memory/ras2.c
>  create mode 100644 drivers/memory/ras2_common.c
>  create mode 100755 include/memory/ras2.h
> 

Sorry if this was already covered, but why not put the common scrub and ras2
changes under /drivers/ras/?

Thanks,
Yazen

From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from NAM10-BN7-obe.outbound.protection.outlook.com (mail-bn7nam10on2093.outbound.protection.outlook.com [40.107.92.93])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id 0DA5231A89;
	Thu, 28 Mar 2024 23:39:51 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=fail smtp.client-ip=40.107.92.93
ARC-Seal: i=2; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1711669193; cv=fail; b=K5wG8LY6Cbvfv3LV3y/TnjM7x6e/o0lSxHNQwkzwTrG4nYTMPzVEOSRmzPFsA2WjDVKgJzOy8iY4AMkunAFbScNtFIoWchRtrZ5hkne/pgxtGQNN6t+1lLf1pSSND8g7cA86+zYaFKgBxYKfy817cH58GqiDDlem1Dr1fSAX9bU=
ARC-Message-Signature: i=2; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1711669193; c=relaxed/simple;
	bh=nHf7h5Z5teGy2pUM3vNLJDX6rtRYpBzolpwMWuNakCs=;
	h=Message-ID:Date:From:Subject:To:Cc:References:In-Reply-To:
	 Content-Type:MIME-Version; b=cDrbWfDmEx/R6n1nswfKeMJo07i1tjnmLva8SeQmF4lzBXXzptd34aSQwuHreyx/SyNoSZFg/OAdDJOAYIafItOyZgOE2om3skYAjSf0aWPlVD+pO32ZjowsgVQu3pNzP9dtjq+4M5JFPcYchV9f4smR2iX37TPzTJE/QZWIBME=
ARC-Authentication-Results: i=2; smtp.subspace.kernel.org; dmarc=pass (p=quarantine dis=none) header.from=os.amperecomputing.com; spf=pass smtp.mailfrom=os.amperecomputing.com; dkim=pass (1024-bit key) header.d=os.amperecomputing.com header.i=@os.amperecomputing.com header.b=FJUk3OOU; arc=fail smtp.client-ip=40.107.92.93
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=quarantine dis=none) header.from=os.amperecomputing.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=os.amperecomputing.com
Authentication-Results: smtp.subspace.kernel.org;
	dkim=pass (1024-bit key) header.d=os.amperecomputing.com header.i=@os.amperecomputing.com header.b="FJUk3OOU"
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=gc6obCeHyFD/iWGwYnW6cM2pV+BnUXjoXPQ4tQNipK0WhnusbOwh66b0YdWFlG4gNvKW12Z1da7fXr0JqoIrQqMJ6zpUrYFUnvV/Vwia4W/k2QuRQ8iAe7RMzlHLVCoyclPZhbjoYI8UZTIVbIlwWLZLFShm3A7NUli2QrKmoqx9+4usy0s6m6q9ZKuMAFeq22A0TE1z99peJmI2Ft2BqBK2X5ZqIGxhqK+42Jm2v0IT9jIGaCtjwVNy+966qmLqsBPtfFlSS85wxJ03pgM9dTcSn3AEAVj9ZMzJi+8bTM0gowrT8UDQeIbSyQ8rctJbSgqt/PAUprqus3la/kaUZg==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=jKo5hnhswaXSkcMDlFaJkiG7TFqG7scMK9fwUsx5K34=;
 b=VrVZBnyEAHKTlgYUPft2RSz1Wlg+DLCnxs95gRmrVJPEx44byreQ3eJsDzRMSPxZJLyoyoA+qbYasjeeB1+V6kC0t9Ey2B6Uv3J5nj6nF4yLdQk1HLhRJBbuK0xKYMrmGOJ745xtS3qbSWBcQX6C566pZEM0W/CM1iM9pnN3O5HHdTehAM8ZZH5QOI+kPqAxnlKgforLARO8keC40foPJVvzDmJ6MMfo0dXnYONkJp7enmV7LPN5N9SAad26PIdESbFUiKOWCjd3A0iONrAqLPMVtGwB4E9B4FI+7aAbg6gyYsvMM+to5mUDt4kSVXx1IouonW+K1BDUrN+OFOY68w==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=os.amperecomputing.com; dmarc=pass action=none
 header.from=os.amperecomputing.com; dkim=pass
 header.d=os.amperecomputing.com; arc=none
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
 d=os.amperecomputing.com; s=selector2;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-SenderADCheck;
 bh=jKo5hnhswaXSkcMDlFaJkiG7TFqG7scMK9fwUsx5K34=;
 b=FJUk3OOUuM6jLop/Est6TDKIBMuNQXry46Q7QTCnU9s/TQgnsSXtHvO8IVJDx3Ujocsb0up9ThoRWUugs3DfCb2WqOF+C1qFoQGMUHevpofbBDmJ+4hD2MLvpOHBqGtDWzo/uR+iLY0sfd1W0OOpk+vKNTDqF47QPO9ViAG4czE=
Received: from CO1PR01MB7370.prod.exchangelabs.com (2603:10b6:303:159::16) by
 SJ0PR01MB6400.prod.exchangelabs.com (2603:10b6:a03:2a2::11) with Microsoft
 SMTP Server (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.20.7409.40; Thu, 28 Mar 2024 23:39:49 +0000
Received: from CO1PR01MB7370.prod.exchangelabs.com
 ([fe80::994c:4200:8a4b:6882]) by CO1PR01MB7370.prod.exchangelabs.com
 ([fe80::994c:4200:8a4b:6882%6]) with mapi id 15.20.7409.031; Thu, 28 Mar 2024
 23:39:49 +0000
Message-ID: <0309f5f9-9a95-485c-a442-e9fba603d676@os.amperecomputing.com>
Date: Thu, 28 Mar 2024 16:39:44 -0700
User-Agent: Mozilla Thunderbird
From: Daniel Ferguson <danielf@os.amperecomputing.com>
Subject: Re: [RFC PATCH v7 00/12] memory: scrub: introduce subsystem +
 CXL/ACPI-RAS2 drivers
To: shiju.jose@huawei.com, linux-cxl@vger.kernel.org,
 linux-acpi@vger.kernel.org, linux-mm@kvack.org, dan.j.williams@intel.com,
 dave@stgolabs.net, jonathan.cameron@huawei.com, dave.jiang@intel.com,
 alison.schofield@intel.com, vishal.l.verma@intel.com, ira.weiny@intel.com
Cc: linux-edac@vger.kernel.org, linux-kernel@vger.kernel.org,
 david@redhat.com, Vilas.Sridharan@amd.com, leo.duran@amd.com,
 Yazen.Ghannam@amd.com, rientjes@google.com, jiaqiyan@google.com,
 tony.luck@intel.com, Jon.Grimm@amd.com, dave.hansen@linux.intel.com,
 rafael@kernel.org, lenb@kernel.org, naoya.horiguchi@nec.com,
 james.morse@arm.com, jthoughton@google.com, somasundaram.a@hpe.com,
 erdemaktas@google.com, pgonda@google.com, duenwen@google.com,
 mike.malvestuto@intel.com, gthelen@google.com,
 wschwartz@amperecomputing.com, dferguson@amperecomputing.com,
 tanxiaofei@huawei.com, prime.zeng@hisilicon.com,
 kangkang.shen@futurewei.com, wanghuiqiang@huawei.com, linuxarm@huawei.com,
 wbs@os.amperecomputing.com
References: <20240223143723.1574-1-shiju.jose@huawei.com>
Content-Language: en-US
In-Reply-To: <20240223143723.1574-1-shiju.jose@huawei.com>
Content-Type: text/plain; charset=UTF-8; format=flowed
Content-Transfer-Encoding: 7bit
X-ClientProxiedBy: CH0PR03CA0068.namprd03.prod.outlook.com
 (2603:10b6:610:cc::13) To CO1PR01MB7370.prod.exchangelabs.com
 (2603:10b6:303:159::16)
Precedence: bulk
X-Mailing-List: linux-kernel@vger.kernel.org
List-Id: <linux-kernel.vger.kernel.org>
List-Subscribe: <mailto:linux-kernel+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:linux-kernel+unsubscribe@vger.kernel.org>
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: CO1PR01MB7370:EE_|SJ0PR01MB6400:EE_
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;
X-Microsoft-Antispam-Message-Info: 
	oY/cTr1Y2ZBzYKzf89VaHlzZuaTuAGGhn6XFXT2P91vhzriciD7xeSqUhUj+AaFw/Bx9ALrbriw9TCccyJSaG9u15q7tst1JZimcl4QG4zfm9qlmAgYgL/gr7gMbLIAT3ZZnagoFg3Hal2Vnkm1LIFu5Fw0l6lrCGau3Q/oREqA/sZYh507qWuHCy+EJeB/IMyZ8sf+XTDD1d7N9YPq/O3ISnZUO/O4t4vvqAhZcPa26gZqEjwLJUaLm2mt2Xvt7j9K/e7YberaOJ/fchDe3n0zcsJT8iOWq258p8fiFTdC7wDspfoUxs21spJkiAeM3HgKQhEtWjl8zZsDO6Ou0riF2hfMFyWX0rmJTIVL4Bivkexhzj3dmLFubCS7xKx9qG6nVI4Si3Gq7PfPok0TjmHPXKvV7pv5lbcTokF5cceQug4yijgSMhVQhudMKi3PPwruI6eo3QImqczD1UBUV+eGCe9Wz3SmIHbxNkoCuRD9Mhy4QkqoaBikqZ+1f35iW5cUyXiGQ13oLMq+FvtByq0tD1EqG0zE7CiUXQVR1nuwfKxQiRx6mRSGydHAI3J6gMVqBzwCN5qicR3Jx5sgVG+acRyJ+Vt80kfSamoiO0kx5xm/YGITmyXYRd4tsnn4MsKX8uytQw+3BQN5hlRH2PoOnyjrcex4WlWXD5IQPxARRYv1nUhHJgB45bAohL2oaBH8UXluRslQO60Bd3rKbaQxDiDgbIRiNQQNvyQ12Aa0=
X-Forefront-Antispam-Report: 
	CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:CO1PR01MB7370.prod.exchangelabs.com;PTR:;CAT:NONE;SFS:(13230031)(7416005)(52116005)(1800799015)(376005)(366007)(921011)(38350700005);DIR:OUT;SFP:1102;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: 
	=?utf-8?B?RDFKK2lqbCtXYTI0N1l2Z2ZlUnhNemJOZjNxOE91LzBUcFU2VkVwNkRPN2gv?=
 =?utf-8?B?aTQxUlZOYm00RE85OGRpV2J1blg5Uk02VnJUYm5hSkllUzBnYWZVSnBaUlV3?=
 =?utf-8?B?aEVHTGRYd3oydER4bFpKYWtDNjdJM1pLNnFVNGpMNzdOSzBzSytHcmw4K0p6?=
 =?utf-8?B?cTFGSmNDaVdncm1PNzFUNW9xRFg5SldUOFpEMDlVS3dCVkNKWlBoRWdVRlZ0?=
 =?utf-8?B?azEvSnlWMHJPNkpUVGxzOCtsQ0gwZDBvWGlHdXRYemxYZ29DUWFpUHhuK1V2?=
 =?utf-8?B?eE5pbEtzRERpc0dkOTVKeUFoU3RJK2o3Y2FidTJXOFhYbHUxUmtaQ1Rmc3Vl?=
 =?utf-8?B?NGZoVTFkbmdqTnFwcXExVHZ1ckplOTh3bFFYYmVRakdHa09DM2k4MXdtWG8z?=
 =?utf-8?B?aGRlaEhtRy9oTkszTWhSMzJmUkRJN0FDTWkrVnZhN3BEU013UitrWW9HUlRT?=
 =?utf-8?B?TTczZFROUGtvNEoyY3QyVDNBMVk4OEUxWVE2Y1owZng2Q1NZcjEvQ3JLbFBt?=
 =?utf-8?B?VVZHeTVKVGFZc1cwbmFFYk5tR1E2aGVhVW1NQTNLdWltYVV2WDRwNWlHczRH?=
 =?utf-8?B?QmVZUVhaMXMzNm5zOCtnVkR3Q2hxV2R4NFM2enJYb09MZ2t5MStiZ0M4ZUY3?=
 =?utf-8?B?K0JERHlSYUdrSDZyL0ZwUjVCb1g4bjIveTBLWFhRdlhwT3RoVm9iOU9rQ1NF?=
 =?utf-8?B?NDVoUG9nWGhIYUdEUEtzd2tmNjExbXhVc05QLzN4cFl6S2QvaVdVekVUajNX?=
 =?utf-8?B?Z2RQNHVLenlWbmJ1bGprTDliUTdaMGtUOGJFU0l3UDVQR05FSlZKY3E1bjJv?=
 =?utf-8?B?ZzUyZFVyOWRRSXAwUTZIWjM3K2cyNlZnanlFQnFNaWtVbEdIb1BBa29NSkVJ?=
 =?utf-8?B?cXB0NzJlZWUrVDQ0NzYwczI2TWw5RFltbmszMnE5WkVFTjZZNnRNN3ZsNWc5?=
 =?utf-8?B?aGU0Vmg4UTBYaStYVWNXSlJFZnZaMUU3S29BTENRS3dxUnVCK1FhdVZRMWUw?=
 =?utf-8?B?NEswOTl4K05UaDlVK0pkUDJnaEpaV1pGdlgxVHNXVHRQbko1RkpFL0NENWhR?=
 =?utf-8?B?QnFjQWtsaDhwN243dThRKzkrYlJoMTc2QVd1dUJFZmxHd2o0cnlUV25kL2dl?=
 =?utf-8?B?ZFBrNHhEUHNTNG02Ty9HWll6c2t0MWozejU5bFo0bGNPbEFKMWE0dFJWRlZJ?=
 =?utf-8?B?ZVNCby82QmVBdVZVUzRxdXhsbmxSVVZreC95ZWl6SWxocWZSYjgxQjVPQnVv?=
 =?utf-8?B?ZXhmWThrMnJic3FYaHQzY0RhVFNod3g0UUxrWmtRNVd0dlAyeTEzUnd1UEgx?=
 =?utf-8?B?d0N6Ny9tU25TNXNnTlJqSDdZaDhGRU9sU0pXZ3NabVo1RkIwN0p5ZXRFNDZ6?=
 =?utf-8?B?NURPU3FLWXphVmVwd0ZkeTdCK2FNajVHeERUdHNlNnp4bTdvdHpRdmZhcjVD?=
 =?utf-8?B?d1pUQVArMjNWMjNmWW5oM28rTklrOWs1NG5POEQ1aUVhT2xwZUtnU0JNdGxQ?=
 =?utf-8?B?dDJ2dU9HZURSSS9aUit4Uzh1UHl6b1pQa2gwUzJrRSswNHVCTVBxcnZGbjRi?=
 =?utf-8?B?RG4ybUVZTGNCWU5mdVdCUUFCVWNoUGJKKzhFb1ZtanhwOTdJcGpxRVRUVVV2?=
 =?utf-8?B?S0lpSTNvdFloV1ZnSW5EQ2RKczN1RzJ3ZHVxdExUdU15SkF0R1pkZ21neUIv?=
 =?utf-8?B?YnM1alhPcXRsbmRmUFlqMXRCRUJIa1dReExHSEhySWVpR2VCRDlaYUZrcDVT?=
 =?utf-8?B?OHFNWEZuTmlqUlI0N1BJZXFLcXZIOXRrQUl0ZXpwdzdwY3d1dVdIdGxvY0ZJ?=
 =?utf-8?B?cmlnNkRnQVpRNmVFRjZXUGUwQ1YxQkw5bDhVR3d2SFFoUC9uY3ZzWm1oT2FY?=
 =?utf-8?B?TFJhZzkwUStoQ2JoczVWNnpzd0JMUWMydzJ0enFES1VrVjZnUEZqK3FTK2x1?=
 =?utf-8?B?Y3NLa2M5N3dJa0lGOEhaZDMwVXdtUnFGUjllRTZKRS9PNTZOa0kycGsrOXpO?=
 =?utf-8?B?V2xMTm1jalYxb2N6TXJkSExmWVJuNkh0Tks5Q0liWFlSWnAxdlZ6ekJya3RP?=
 =?utf-8?B?OGZPbFRXZU5DTDFqVXFzVHRRUGlGL2xZdmh6UGdJYkZ5blJyNkJ4S3RjR0Vm?=
 =?utf-8?B?UjFROVM4QmpzSzJsQkdSN25tdWx2emdyU1JKY3o0Ky9TZW13Q2hRYzMxeHV5?=
 =?utf-8?Q?jkK9cBixD2L39SRuKsnVQHg=3D?=
X-OriginatorOrg: os.amperecomputing.com
X-MS-Exchange-CrossTenant-Network-Message-Id: b5788c87-846e-4c83-521c-08dc4f805b6c
X-MS-Exchange-CrossTenant-AuthSource: CO1PR01MB7370.prod.exchangelabs.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 28 Mar 2024 23:39:49.1017
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 3bc2b170-fd94-476d-b0ce-4229bdc904a7
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: 3fJ2w6/Rxzljqz1bm3XokxkbhadSOdxlRVzQrfCVzxHd6R7fy9xrjiwTe+VVKC0mEO5ZCzVBdvbiTt2wnRAGXOR+fdH2GRnsYUtDlSoW29T7tUBnviWW3LaP/nQZ5A8N
X-MS-Exchange-Transport-CrossTenantHeadersStamped: SJ0PR01MB6400

> RAS2 HW based memory patrol scrub needs RAS2 PCC interfaces
> and ACPI RAS2 driver for communication b/w kernel and firmware.
> ACPI RAS2 Driver adds platform device, for each memory feature,
> which binds to the RAS2 memory driver.
> Memory RAS2 driver registers with the memory scrub subsystem to
> expose the RAS2 scrub controls to the user.

Hi Shiju,
Thanks for this work. This has been very useful for us, as we've
been using it to test a RAS2 implementation here at Ampere
Computing.

In general, the pieces implementing RAS2 are useful and functional. We did,
however, encounter a few places where we had to make some bug fixes.
I'll reply to specific patches with changes I can recommend. Also, there are
a few implementation choices that I will have questions about.

Here is an outline containing the generalized comments I plan on making
within/near relevant patches:
1) Found a bug in ras2.c in how the pcc_desc_list pointer is incremented.
2) Executing a RAS2 command seems unnecessary for feature detection.
specifically, in the functions ras2_is_patrol_scrub_support() and 
ras2_get_patrol_scrub_params()
3) Consider adding more error detection/reporting in ras2_check_pcc_chan()
4) Concerns with multiple scrub devices attempting to map the same PCC 
channel.

-Daniel














From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from NAM12-MW2-obe.outbound.protection.outlook.com (mail-mw2nam12on2132.outbound.protection.outlook.com [40.107.244.132])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id C3F5A31A89;
	Thu, 28 Mar 2024 23:41:06 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=fail smtp.client-ip=40.107.244.132
ARC-Seal: i=2; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1711669268; cv=fail; b=RGnFmKvZN7P9y+YhCnq2IcBkx3DCvXKBMJFUq9c+DS7T2TnB0CLJq9CJL7we8xj25u5fYaoUIzaIvgU9c5rGGvyDXvfgJZjmA0QhwC8jKDcVKfiwC5/t829D1nMWJS7K9O1KjOjaJbz+3yDtHXKjBs9jTh92YbA3QUZgLpnRzKg=
ARC-Message-Signature: i=2; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1711669268; c=relaxed/simple;
	bh=M42AXlrYoWZPlZrmnTbyWvcvUcF3z2XTxddrFK8UFMc=;
	h=Message-ID:Date:From:Subject:To:Cc:References:In-Reply-To:
	 Content-Type:MIME-Version; b=LttwwYSbhVfTmSrx3ut5y6ow4W78/A9t9KOpYqhHRPTcyWhwhqcYk6d1UYRAIdUco89KFaOULfyjj6IKb9HksB83PNqAJno3rrYOLR4pby1esm0sqWiAHfNNbVJLnzo3wS8QK2S2yft+aJKz9Bp6yB1L0tKXw8R7lTigpcDolwU=
ARC-Authentication-Results: i=2; smtp.subspace.kernel.org; dmarc=pass (p=quarantine dis=none) header.from=os.amperecomputing.com; spf=pass smtp.mailfrom=os.amperecomputing.com; dkim=pass (1024-bit key) header.d=os.amperecomputing.com header.i=@os.amperecomputing.com header.b=M7SzFza5; arc=fail smtp.client-ip=40.107.244.132
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=quarantine dis=none) header.from=os.amperecomputing.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=os.amperecomputing.com
Authentication-Results: smtp.subspace.kernel.org;
	dkim=pass (1024-bit key) header.d=os.amperecomputing.com header.i=@os.amperecomputing.com header.b="M7SzFza5"
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=PKcXWm9PFUczcLxegPJlv/4ny4H64FxAAvLdSs6hMo7f+Bcc1zKUIk/9Zdqgut6sQtSobqq8quqpYx6NDDpOmsqMcARWAPZEU2GIdHQ213NTjwpdg+6aTTZ+V6IaulSqoWsoKAYYPJV92MvbkeKYHX3+L749Hoa7s2g5N4Rq0u9drJyDruy6SKdhhUfLjAVGDsXR69tEnPecqAyfNWAWGq3jOfyENeMe2Yq/yOY0oHMCoTzMq8OWxJhKykJtsD3Yzvq+I8lcGleHMWJ2Dcvrqd02w3tiY7e+1ZVSLWzA9uT7IhCED0/naJq38A5sEW6rkGQMMaftNDzZ2TPvTcvKxw==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=ifdDr9Pm/vCS2faiLvXwMKlUrOVmpwk2L+9S97LuZOM=;
 b=NWdJpqnJeH82XsnIXR4gGIpo9uESKFF8+o4SDzXL4plppw/Ofe8grYND+I+s3ptKd0QglGAwDrvKLU5R9/WIyMKOKzOKcI9UxEwIFV7g9MZbjlf390UrdrGZ4byEnWsRIdIs6qZYnJQC2mTCYX3uts7+5OHee/HO/b2zMIeeldGNdVb6f4OuOXwp3SI8qRo9BfLxxS/veJgM3nKiTEzfEgliCNYGvGzIR4Oy60bujnyDfQntkws/txNrBo0XEX4AdJ0tNS5mbI1vdt8CF8SkSB8mvvTDgM+0WdJGnxAOl+fCu7KZm3yX7VRwLNRIfyoEa64ne0KqEpD21ROUxGu2bQ==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=os.amperecomputing.com; dmarc=pass action=none
 header.from=os.amperecomputing.com; dkim=pass
 header.d=os.amperecomputing.com; arc=none
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
 d=os.amperecomputing.com; s=selector2;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-SenderADCheck;
 bh=ifdDr9Pm/vCS2faiLvXwMKlUrOVmpwk2L+9S97LuZOM=;
 b=M7SzFza50WnPNBBysi9LJAgYUVwUNygpELCwoWjMnEB04JzoF85Q1bsVJFPw4GTrPn7TU21DcXF2OzpKYFYfgIeT377W+sSBLXEQ87q0ldJQ8QUUMUvif0eIe4ivUrrFKiKUpaxkqSYtKrkU/ifaclaAAQvC+sygfU9JH5T2jHU=
Received: from CO1PR01MB7370.prod.exchangelabs.com (2603:10b6:303:159::16) by
 SA1PR01MB8180.prod.exchangelabs.com (2603:10b6:806:339::19) with Microsoft
 SMTP Server (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.20.7409.33; Thu, 28 Mar 2024 23:41:03 +0000
Received: from CO1PR01MB7370.prod.exchangelabs.com
 ([fe80::994c:4200:8a4b:6882]) by CO1PR01MB7370.prod.exchangelabs.com
 ([fe80::994c:4200:8a4b:6882%6]) with mapi id 15.20.7409.031; Thu, 28 Mar 2024
 23:41:03 +0000
Message-ID: <3fa20038-347f-48c3-814c-0dc1ed109244@os.amperecomputing.com>
Date: Thu, 28 Mar 2024 16:40:58 -0700
User-Agent: Mozilla Thunderbird
From: Daniel Ferguson <danielf@os.amperecomputing.com>
Subject: Re: [RFC PATCH v7 10/12] ACPI:RAS2: Add common library for RAS2 PCC
 interfaces
To: shiju.jose@huawei.com, linux-cxl@vger.kernel.org,
 linux-acpi@vger.kernel.org, linux-mm@kvack.org, dan.j.williams@intel.com,
 dave@stgolabs.net, jonathan.cameron@huawei.com, dave.jiang@intel.com,
 alison.schofield@intel.com, vishal.l.verma@intel.com, ira.weiny@intel.com
Cc: linux-edac@vger.kernel.org, linux-kernel@vger.kernel.org,
 david@redhat.com, Vilas.Sridharan@amd.com, leo.duran@amd.com,
 Yazen.Ghannam@amd.com, rientjes@google.com, jiaqiyan@google.com,
 tony.luck@intel.com, Jon.Grimm@amd.com, dave.hansen@linux.intel.com,
 rafael@kernel.org, lenb@kernel.org, naoya.horiguchi@nec.com,
 james.morse@arm.com, jthoughton@google.com, somasundaram.a@hpe.com,
 erdemaktas@google.com, pgonda@google.com, duenwen@google.com,
 mike.malvestuto@intel.com, gthelen@google.com,
 wschwartz@amperecomputing.com, dferguson@amperecomputing.com,
 tanxiaofei@huawei.com, prime.zeng@hisilicon.com,
 kangkang.shen@futurewei.com, wanghuiqiang@huawei.com, linuxarm@huawei.com,
 wbs@os.amperecomputing.com
References: <20240223143723.1574-1-shiju.jose@huawei.com>
 <20240223143723.1574-11-shiju.jose@huawei.com>
Content-Language: en-US
In-Reply-To: <20240223143723.1574-11-shiju.jose@huawei.com>
Content-Type: text/plain; charset=UTF-8; format=flowed
Content-Transfer-Encoding: 7bit
X-ClientProxiedBy: CH0PR03CA0181.namprd03.prod.outlook.com
 (2603:10b6:610:e4::6) To CO1PR01MB7370.prod.exchangelabs.com
 (2603:10b6:303:159::16)
Precedence: bulk
X-Mailing-List: linux-kernel@vger.kernel.org
List-Id: <linux-kernel.vger.kernel.org>
List-Subscribe: <mailto:linux-kernel+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:linux-kernel+unsubscribe@vger.kernel.org>
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: CO1PR01MB7370:EE_|SA1PR01MB8180:EE_
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;
X-Microsoft-Antispam-Message-Info: 
	x9U8wRyPi+zxslJVSyV/8r7cszUcc9hmYG8s2UXPgYz9wK+G8KIosxFpHeZATJCPEWDQderhmH4/RBvi+Np2BKebfpDFe8xrnfJDoOzVj/cWJQcnoraIOBnGvQ2TE3eWnbfp0kN04ArsliTD0/S7YEbSSeZiqfa0f1CI+YUPqlUE1E+Oa+lBCu5xPwWTDq/1H6SpCiFouGe/ATzK7rLSQw3uT6N/Mv7loi0bm6BqzKnhfhH6pKJ9wuwSDSPvdndlvp37+qPjErkcOXnxlC+SqVkXB5o5Ate1VsYdKA/xpyDijrsa2bj591KyrufIXsF7VhzEAbEmaFQ6i6l6H+FqU/XNEAF7iNMkI4A0NisOqTFQawzZjaZ8KsHm50uA5qwqUh8mWtTCjbRrFzm1S+LFps4Tgg06x4xmQGKAFopr4rFFUqfcMYNIDe0lf1i+gipJQ4/xmEUQNnotx/pZMaF0OUJf+eFW6fdUrD0gRzPLT+VyB0USj59IaEmX+t1iB6SMmvBwphfpBzALFL2FXNn3d2t3xVzHJbB6d+9K2xv6ozroryHz7IXEPbdnhcI+lmGDLhCMfPD6sG3LIfzSJxxaJQ+3deXipPEj+AkSw7+NbeEWxGWUrKdxmnPmgel/OH4xW9Q8tzjyYySQTYr4JKEeFrGJd3LYl8O/ra4+5g+CMYopVeyc7FfcjdNnQ2fqQ2DB1LnI2emzzDIYJGeTkAN84YoMLA1aONLGtUm9sLoOD4Y=
X-Forefront-Antispam-Report: 
	CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:CO1PR01MB7370.prod.exchangelabs.com;PTR:;CAT:NONE;SFS:(13230031)(1800799015)(7416005)(366007)(376005)(52116005)(921011)(38350700005);DIR:OUT;SFP:1102;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: 
	=?utf-8?B?N1ZPQmF3ZU9LVkdiZ3U2bmcraFZNeDZoWHhwVjFpZWp1WldyZWlTTktibUVy?=
 =?utf-8?B?VERqVGsvMEJ6V1JwVzNpSG04c0JmL0oxUXE2RDhxOHFSWFdvUjlnbXQ5SCto?=
 =?utf-8?B?bHBjOUtxMzBBTlI0ZlRqZUIzOTdVem5rcTNETU5zaFJQVEtvL2FySHJNeUMr?=
 =?utf-8?B?QTVhUlFlZnA0TVVjTGhiejFuUFNwS2NoYkRKb1V3MHpFUlZ2K1NqZzE5WllS?=
 =?utf-8?B?aXI3ZG94b28rTTF5MHdrZEVDT0lSQ2JJd0RLL2RoNTJBOG1jUXNKV1NLYWla?=
 =?utf-8?B?M01OUUxiRFY5L2VxWHdJbkpSdzZNU3kyaTZRNU1OWHd2dU43MXREZy83bGoz?=
 =?utf-8?B?U0g5OVM5NC9DSnZzT00vNzVZTFBiTVVMNzZreHZIUVB4OXVhZVNHU0dsZW9J?=
 =?utf-8?B?WFNvM3VmWW5ZMmQrYmhLVm0ycTh1c0tmN1YxRHYwL1BtM3hSRW1ESmZTZHdC?=
 =?utf-8?B?d1ZWb3c4L1A5Y3JMUE10ZGJiZm5sa2R2QVZHYm04NUdMVnUrckNIUjVNTk1i?=
 =?utf-8?B?Y0RLSHcxV0xKemhoN3FyN0taeFZ4VFp6eUxpTnhTNTVNT0IwN3lvVE5GTDk4?=
 =?utf-8?B?T2hOUnBkTVdtUVpUVG5Dend4OFRBdTFiK3dhTmNkU3VydWs0SnpUZDFZRzFD?=
 =?utf-8?B?WjhXbE9hUnRLelF3Ry9TWkxlTFJaSHZhdWNQT3VldGJEL21jN2VKOEI5RGs0?=
 =?utf-8?B?Ry85eUc5U01DUjI5SjV2VlVKMWt0SFErLzNNYy9sWC9rRXJZREVPdFRsWjZj?=
 =?utf-8?B?NGhkRHBNeW8ybmxMQ29qcEMwK1RzQTZvT1Z6T1E0QnIrbVlNQTBvWkpxZVJR?=
 =?utf-8?B?aVVseW4wUkdma082VzNtNkh1YzdvUWIxMldjb3ExSGRpUmQ0RDBqeGxmdTZU?=
 =?utf-8?B?OG5zSndJSmpwT1dEV0N0ZitNaUtQaEtEckQ4aTdodnY4S2x0d3J2Zis3V2lr?=
 =?utf-8?B?VWxqUWwwQTZTZWFUamQ4N25iUVNPL3l3TEZDREo4NVhwZ3pnRnlzTmpya1gy?=
 =?utf-8?B?TmIrYjJQSWQrTE1lNHRxamNGZzFKSk85K1NUL0hFVDBtNVl2V2xpUjUwQlB3?=
 =?utf-8?B?cTdwQzBCOUd2aGk1ZENzNmRiWWFEVTVwd1o4RmJLaGRDRDZrdmVXV1BYK3d4?=
 =?utf-8?B?MzVBZGtTSHdUM2h1NkNqVjhJRkJYdTJRK1FxcGpkcDNOSnU5ZDd1UHJWeWRo?=
 =?utf-8?B?dENURkQzV1B5R2tyTVZyNm5RRE5zb2dUek1TR29BZ2tFSm0wdEQxMkEvd21l?=
 =?utf-8?B?Qm5RZjBTOS93aTlIbHRwb2MrY2VPb1liWWdxMVdQcFlvOStEQkVOYzE5UTJ4?=
 =?utf-8?B?dFZoVEc0NjZkNmRWTGROWUNPMU05WHg1QXFOcm5WL0VGMElNQUdZbnlHZ0ll?=
 =?utf-8?B?SjlyNzRZN3VVYXcyMGxTVm9LRk52bktSUmcrZWs1dGdDVGRXZzFUNkZTdHFG?=
 =?utf-8?B?RHAyT0FKcmpXaEtQL3dma3ZsNXc1UEF6RjZqR0FxdkZqbWVTd0FTYUZSRWJB?=
 =?utf-8?B?REFrLzFUWWJMOERnOThhR0lsTmNGWWd1NE9WL0ZpNkJRVDlhYllLM1VXbEJj?=
 =?utf-8?B?cXdMWlFPZHpkRWhNUVBadmNabVU0eDJxckx5cHJwWWZKRUtBZEl1TUhpVmlL?=
 =?utf-8?B?aWpicStBcmo4TE5UQTQrRFh5dEtDNWo5bURQa2ZOR21zZFhwYkNuQllneDVQ?=
 =?utf-8?B?N1RmVU9pS3ZCQTBjaUMwZU9pemJ4aUtic1JTazFWN1JoY2JlRzBhK2NDQjNN?=
 =?utf-8?B?b2N1d2kzU2l2dlZacHZ2eVpRVFpSdnlMS0Uza1Z2WkNpbEdXOU1aL3JsL2Jy?=
 =?utf-8?B?SnZUYWF1UDgvczlEVUMvSGZ0bTR2OXpEdEN2a1BCMmVTNlNNZmZRd3RQY2xU?=
 =?utf-8?B?S0hUYm5CM1lpbGRFY3UyTmtQbGU0MUVnSWEyRWJQUFFIeFdic01zZzdvNHln?=
 =?utf-8?B?eFBwZGJBSUljci9wSkRPUTZQRDVvaGorVGh0MmlGdjV4U21XKy9PaVZUQXVS?=
 =?utf-8?B?ZnJDWVhMaWhtcWNMYmVFYktFaVBaOWsyQnQwVTZyWWFhZjM1aW16azFSaHEz?=
 =?utf-8?B?R0U5YnBMazRueUxiL0pyWXoyS3I5L2ZKc09TZUJnZUp5czFJRHJYZjlVNXVY?=
 =?utf-8?B?RmVrT2JiK0wwQWMramZYbDh2VVd4Szh0VGhtaldKdEVpcmNKRmJ2WGFyZFVr?=
 =?utf-8?Q?ScWHCD6mRsCMYLf8MKO9LAw=3D?=
X-OriginatorOrg: os.amperecomputing.com
X-MS-Exchange-CrossTenant-Network-Message-Id: 31f6dbdc-47d1-423a-3a02-08dc4f8087cd
X-MS-Exchange-CrossTenant-AuthSource: CO1PR01MB7370.prod.exchangelabs.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 28 Mar 2024 23:41:03.4497
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 3bc2b170-fd94-476d-b0ce-4229bdc904a7
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: UD5iQSivVZDHIqDm83n1MzCQAm1PXSlT/4mSH989GCOSZ9P43Udlt7KUfR+6Ed+Da9mduu6dVnGL9JOb6uK1DEIgTv0Z9UByPXxHEjBa7vtuxcAfhfizAsvHBOxqKI8s
X-MS-Exchange-Transport-CrossTenantHeadersStamped: SA1PR01MB8180

> +static int ras2_check_pcc_chan(struct ras2_context *ras2_ctx)
> +{
> +	struct acpi_ras2_shared_memory  __iomem *generic_comm_base = ras2_ctx->pcc_comm_addr;
> +	ktime_t next_deadline = ktime_add(ktime_get(), ras2_ctx->deadline);
> +
> +	while (!ktime_after(ktime_get(), next_deadline)) {
> +		/*
> +		 * As per ACPI spec, the PCC space wil be initialized by
> +		 * platform and should have set the command completion bit when
> +		 * PCC can be used by OSPM
> +		 */
> +		if (readw_relaxed(&generic_comm_base->status) & RAS2_PCC_CMD_COMPLETE)
> +			return 0;

We should consider adding error checking here. In a modification of this
driver in our enabling efforts, we are checking bit 2 in the status register
for errors. For example, in our FW, we will set bit 2 if you try to 
disable an
already disabled scrub.
> +		/*
> +		 * Reducing the bus traffic in case this loop takes longer than
> +		 * a few retries.
> +		 */
> +		udelay(10);
> +	}
> +
> +	return -EIO;
> +}














From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from NAM12-MW2-obe.outbound.protection.outlook.com (mail-mw2nam12on2092.outbound.protection.outlook.com [40.107.244.92])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id 7054E38FA1;
	Thu, 28 Mar 2024 23:41:23 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=fail smtp.client-ip=40.107.244.92
ARC-Seal: i=2; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1711669285; cv=fail; b=ivT93aXg9SO1UXMA4A52xLlnCqs1yOYEdbdr5N5QrShGJrfUIyMlW7X1bT8X1SdVItHgPusz4faYyXv3BZIYS9Cl4RFGWZ2U/+zJ1CKsaqxXCMYcp5whyiDz515eNdUws4icv3a1UvB8uwWycVeY9cAVXcXpSjf1fXTlAyNP1j8=
ARC-Message-Signature: i=2; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1711669285; c=relaxed/simple;
	bh=K1EbGR//cNxoepaVsUt2asFYmA562aoc7bpv4D1h5fI=;
	h=Message-ID:Date:From:Subject:To:Cc:References:In-Reply-To:
	 Content-Type:MIME-Version; b=Pr8kSbG8cpAZxEV99PyEOwXjZODUXWRA4gI2GWFClLxs33HIA1bKMWgft9Od5RAChrhjPasbRDSbQrCbjPVVep7ly+FFNgEYsVpVdfAhe5Mho8+LiMWra9H4kCVPXdzZ5c33DvWwvSbfl03uxlN3/gYnq91hlOou7+YAn3ZmkR8=
ARC-Authentication-Results: i=2; smtp.subspace.kernel.org; dmarc=pass (p=quarantine dis=none) header.from=os.amperecomputing.com; spf=pass smtp.mailfrom=os.amperecomputing.com; dkim=pass (1024-bit key) header.d=os.amperecomputing.com header.i=@os.amperecomputing.com header.b=eh7wC19G; arc=fail smtp.client-ip=40.107.244.92
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=quarantine dis=none) header.from=os.amperecomputing.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=os.amperecomputing.com
Authentication-Results: smtp.subspace.kernel.org;
	dkim=pass (1024-bit key) header.d=os.amperecomputing.com header.i=@os.amperecomputing.com header.b="eh7wC19G"
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=OLlYYa4IgswAHo/W6RKf4nvc9OC4Zndg2oWfTKOhQQM5Uw+HrDrNe/oEoqEMTSTrxG9ONyCVKbfQ1AwQ+R/qxylF2ERuue2OrWjO6wlUdtmclfyVuIz2etGf0C6AsUf2O/+8pG2ErQjGxtrceGX0d9KFKjiCP7zeHqQatfBG1JPKJHv/plEZsbTw3+XIVM/g1aQmLwE7fDCPu2LSQFGTrSv69WkiyO2uuf7ksNtAsFjOZJ3k7Q4azhoZbBl8ZeKGXkoC+Ds5AWFPDRuxqtEVA1P5VOsl+11Vls5wS0jo+7w1hZPTJokQMcxWWHvBna3zMg4a9JmaBusmJv+sivp7lA==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=XJx/YV0TFwouXt8PvLCFfp7+wDAcQhhbNpHx+MrnQzU=;
 b=dACxjbmp7mWBgEQYfSo8kNZqk+RNjprHqM8PL75aNhpjezYcwp+dbBW6b0kQQvqIW78oavNApHUNjWJbY9fR3sRLHMHiCdJz8YpZIwA48I++nPo6p0PdUjrVQZcyy0qzqiCJ08V9slU01aY8r0VESGA7P/BO5+CFAtaneG26WTQxtMjgdUZ1tXF8Amr4gxLVyeBOp/taEJxNwnm3KB3Yr9LjY1xbjBibkCsdUXCk0owzSF1ypnxhzb7nn6AMGXuRUk97kD+S04AvotUZOZz8SwsF5j+E11tzusIpM2I433kaQdGfCH030+WUPCGxeYL5BXOboqVp1S6x4cn/yiVyyg==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=os.amperecomputing.com; dmarc=pass action=none
 header.from=os.amperecomputing.com; dkim=pass
 header.d=os.amperecomputing.com; arc=none
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
 d=os.amperecomputing.com; s=selector2;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-SenderADCheck;
 bh=XJx/YV0TFwouXt8PvLCFfp7+wDAcQhhbNpHx+MrnQzU=;
 b=eh7wC19GpSgHDW+SCNb6hoM5KZn84YLMeO+L1mzjcs7NxAbLApgs4SzugqWxlz/7MFr1XURM/R7vY5KFpK+OOySicZmUjfWH1R8m4usy09EGw1cW3WqNMxd6ug47VhYY7t7bkQ/8UsOW0g/QGUvtB8StX4CSrzCFaLBxlT6HEu4=
Received: from CO1PR01MB7370.prod.exchangelabs.com (2603:10b6:303:159::16) by
 SA1PR01MB8180.prod.exchangelabs.com (2603:10b6:806:339::19) with Microsoft
 SMTP Server (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.20.7409.33; Thu, 28 Mar 2024 23:41:21 +0000
Received: from CO1PR01MB7370.prod.exchangelabs.com
 ([fe80::994c:4200:8a4b:6882]) by CO1PR01MB7370.prod.exchangelabs.com
 ([fe80::994c:4200:8a4b:6882%6]) with mapi id 15.20.7409.031; Thu, 28 Mar 2024
 23:41:21 +0000
Message-ID: <0d398f19-b8df-4936-97e0-fba8eb041d88@os.amperecomputing.com>
Date: Thu, 28 Mar 2024 16:41:17 -0700
User-Agent: Mozilla Thunderbird
From: Daniel Ferguson <danielf@os.amperecomputing.com>
Subject: Re: [RFC PATCH v7 11/12] ACPI:RAS2: Add driver for ACPI RAS2 feature
 table (RAS2)
To: shiju.jose@huawei.com, linux-cxl@vger.kernel.org,
 linux-acpi@vger.kernel.org, linux-mm@kvack.org, dan.j.williams@intel.com,
 dave@stgolabs.net, jonathan.cameron@huawei.com, dave.jiang@intel.com,
 alison.schofield@intel.com, vishal.l.verma@intel.com, ira.weiny@intel.com
Cc: linux-edac@vger.kernel.org, linux-kernel@vger.kernel.org,
 david@redhat.com, Vilas.Sridharan@amd.com, leo.duran@amd.com,
 Yazen.Ghannam@amd.com, rientjes@google.com, jiaqiyan@google.com,
 tony.luck@intel.com, Jon.Grimm@amd.com, dave.hansen@linux.intel.com,
 rafael@kernel.org, lenb@kernel.org, naoya.horiguchi@nec.com,
 james.morse@arm.com, jthoughton@google.com, somasundaram.a@hpe.com,
 erdemaktas@google.com, pgonda@google.com, duenwen@google.com,
 mike.malvestuto@intel.com, gthelen@google.com,
 wschwartz@amperecomputing.com, dferguson@amperecomputing.com,
 tanxiaofei@huawei.com, prime.zeng@hisilicon.com,
 kangkang.shen@futurewei.com, wanghuiqiang@huawei.com, linuxarm@huawei.com,
 wbs@os.amperecomputing.com
References: <20240223143723.1574-1-shiju.jose@huawei.com>
 <20240223143723.1574-12-shiju.jose@huawei.com>
Content-Language: en-US
In-Reply-To: <20240223143723.1574-12-shiju.jose@huawei.com>
Content-Type: text/plain; charset=UTF-8; format=flowed
Content-Transfer-Encoding: 7bit
X-ClientProxiedBy: CH0PR03CA0195.namprd03.prod.outlook.com
 (2603:10b6:610:e4::20) To CO1PR01MB7370.prod.exchangelabs.com
 (2603:10b6:303:159::16)
Precedence: bulk
X-Mailing-List: linux-kernel@vger.kernel.org
List-Id: <linux-kernel.vger.kernel.org>
List-Subscribe: <mailto:linux-kernel+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:linux-kernel+unsubscribe@vger.kernel.org>
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: CO1PR01MB7370:EE_|SA1PR01MB8180:EE_
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;
X-Microsoft-Antispam-Message-Info: 
	EaLGzZY7xB8EHyRyUgAuQJSuow52527ozdgFC9g0OnTW8SKdYcdcATqE8Pv35GVZQ73xTkhyP8LpDmAui4DqsRaDd12eWMEWvSrDL18zATUjouSgY5IqxkrJQ7E0bet8V9mYsaFujlX9H+J3R7JJlTrHJ5I1iUieGP5uXzZv/9SMpF2h5C51XN0xZDHtP/GKIZXWx+3CqBraOp+RyAGbB24X+OEDFHBZnAKz2FUWuR+Yg4bnVz2Qb9HjA/IpZ1ja8nfJrc8GW7EQwHc74ir4SbFDyPs7sSIeSQZCTe7R5Ehk5twhtv2IaPuhaKyc/WhOrXHwW6ycPlKRAwS22l9CUWKzFK8eMsJFf1qIoeh/lX9xGqbym85o3FpZEVAIfxCLnKeAM5vU1mDGIpaVAx6VATg73b4lhb5zheMRgdVtiKl+CZ5HGvdp0VGtKr49801kJTb+L/o/xQYjaOo/99ZoQ80SXwe1jfIwOwXOTcHf7J/v4ki3YnNMNXsMOVd4/Yi/yKkWMLl0koRjnhI0+NAJ3wlIt0yzhOjaW8LTYU7EtlcgFw0I9VGMR6ycsy52VM9V1Xkg64iPgQwmdcfZRmaHKNhdQG7jesFwWrXP+13BZkFfYYVSq9fP28lWjGKNaPIDXbCgKS+3JoyldjBOZK27gWpkrFdiEKIHJn4AHJKlZJXF6kcFHkMX/Ilw3kPwY7NKNoQWs8gRDB+t/bYe7J/EtVAh58jqidye/RZ8mT5omYM=
X-Forefront-Antispam-Report: 
	CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:CO1PR01MB7370.prod.exchangelabs.com;PTR:;CAT:NONE;SFS:(13230031)(1800799015)(7416005)(366007)(376005)(52116005)(921011)(38350700005);DIR:OUT;SFP:1102;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: 
	=?utf-8?B?RmZXbWp6SEZaTUloczVUbFk2QTVYZmc5Si9yMWcya1J1Y0ljQ0krY09iUDJH?=
 =?utf-8?B?ciswc0hZK1V0eHpyTjBKVnExWjI5WnlkT3h4T2t3M0Y4eXJoV3llTmljaU5C?=
 =?utf-8?B?T2lYNWdIS3puSm5QbnRHTFgwRnVEQ0E4Y0sraHMxOEovNStGcnVhQjBYbmlr?=
 =?utf-8?B?TjNhNmhSaTdUQUk4cGVWd2QwZnZmNnkrZHF0V1luNTJJeDZ3SkliNjJRbEVE?=
 =?utf-8?B?WFRvSWRwNzJZbFVFRkRxemlsenU5RlU4RFlGZ0JKRTVlcUhDWnp2b3dydWxO?=
 =?utf-8?B?WjBZTTNkc1V5U1hVYXBIVWw0RmNyck1GVkRSL2N4b2tHUWQ1dDNaOGdoTHNj?=
 =?utf-8?B?NTVxU1N0MUMvTFIxMlVHYjQ4QTFXZXRhTDdGREV5TCttZjBGZUh5K3RKZkdY?=
 =?utf-8?B?emhPY2FCaWlPV3FlMTRzQnJDQkFvdlNna2VPOGZGaFpPMXUvSHVMYnptV3Ay?=
 =?utf-8?B?cDFHVVJMdjMwdDhTc0hIVFFxcHY5U3dPdmdLNENnM29vMUlsaVdsaUkzSlM5?=
 =?utf-8?B?MTRPSC8rcmlDVWN3dEFQL3VnR25sdkkwdE80c0tyWDdXMkgzUDkyRzdsZEhv?=
 =?utf-8?B?VkoyNXVvMm11WnRBRVJCUklYcThmUWdWMjIyemxWVXgrVU5mcTNLTlJVWGM2?=
 =?utf-8?B?NTBxayswSjBNSlZrdHBEZWg0VVZ4U0RQdk96c1hQTFlPWUlSdTFKSHVzbkVh?=
 =?utf-8?B?bTNaWkQrY1ZIeTAvOE1seUJWcS9IeU9WRlpKZyt3VHJXTGhMVWRmUm9YUkor?=
 =?utf-8?B?ZDVTLzRwTUVkZDgvWlc4dUlYK3Y2Qzhrc3NoZG01QnN6ZTdZbG9jOERlUzRP?=
 =?utf-8?B?YkU1ZzN1N2hGN0duOFVNUGdZU2VWQWZvc0NvSytGdFM2WXJwcWZEdS94YzdH?=
 =?utf-8?B?MC8xdnZSd2Vva0FWOW5JOEoyWGl4WFQxMnd1SlNESzZwY2dIWE9Va1NCZUFH?=
 =?utf-8?B?MHpKaUhMU1VNazQrZEFSbUhqNSszVHUzQ0sxY0NOU3JVVHZOSEZKaWlzeXFJ?=
 =?utf-8?B?QVhadjFGSlBQcVNLazdMZy9vVUs5Rm8rOUVrVmJqRTd3eENBa3ZCWG5WUWhq?=
 =?utf-8?B?TmJtTXQrbFI5S0pCSk0wQld0V2JzLzFlTUh0RG1GRzVlcVdlUm15cTVXTXlQ?=
 =?utf-8?B?Z21ueWRoK005M2dlcmJTWGNTd2NqaGV2b0ZLMHVvUENhanZiVUJFeGVRRGR3?=
 =?utf-8?B?R2tSdlJuSGIvL1l3QUQ0aGxSUFlYQ05GQUZ5OHJRUzhDK3lzc0g5OGh3NUhm?=
 =?utf-8?B?bUFOOFArOVVVdDRwSjNvNWhZNXdZYTJYYno5K2VQd0E5RWNPUHZEN3FXT3Jx?=
 =?utf-8?B?MTZZSWJvRm51Q1RIZkhjaVZ6a0daZ0NEU1VBb0NVUmZqc2ozV01kOHNrdjh3?=
 =?utf-8?B?WnQ3VjZBZHhRUFhRcmxma1ZSTFdaNkIzMFduK29yUXhOaDg1dmVCVGRuMEQv?=
 =?utf-8?B?T3FJYlMxQis4VFFDbEFzUjVFRDFmL2VVWXZwRjFQMWZzTUdMWExiS0lOTzRF?=
 =?utf-8?B?NjlEWCtlNGVESnllLys4aWs4VjJTaDlVVCtjRWZaalAzMjNVRHpUQkFXYTNQ?=
 =?utf-8?B?Qml5MmtXZmFOSkZ3V1V0SkV5L3ZZcUpScTNrUUJ6TUZLSTVDZmRXYStIa0lH?=
 =?utf-8?B?WGZudm1GL29OOHhoL0NmK05aVHpOM3pCNy9FVXlTYWlmVENmdDJNYnNXbUpv?=
 =?utf-8?B?WnByak9KVXFEQy9oUmJCV3hrRWRlUXBMMzhnTXdnbnpmZFF1Z0p3UEh6Vngw?=
 =?utf-8?B?MUViRHBqTWVhbVE5dFhSR1dwNHhndml2UkRkam5UR1AxV0lxZmdCU0xSb25T?=
 =?utf-8?B?RERlczUvM2dxanYwYTVPejY4Q0RzR0xyNUY1TDV6a0ZTQzdYTDQ1NitJNGVC?=
 =?utf-8?B?aUhPTU52QUNFRy9YZEszajlvY29pTXNhNjREQWNGYTVDc0dDSHhvTEkwdUxS?=
 =?utf-8?B?WjdVcVI5WHVxUWdhN2xESlIzZTBpQ29sRklMVlBHUHlENGpNQW5qaHoxWjh3?=
 =?utf-8?B?WjlRdENKS3RaNjd3VHNscHFDbGVmUGhDaXBlWFRKWGZmMDd0T3JvVHBwQUtR?=
 =?utf-8?B?bzRJdWJxZC9VYVF6N3FwN3NPMXdNRllJS0dybm9xUE9NUmw0TzV4ZmNXeHJT?=
 =?utf-8?B?M1lUdlB5b2hCdU4rSzFGbk1lOTczS0JRVTkrS3lWaG9kdldudWZDRTVmOU1E?=
 =?utf-8?Q?SKHFAVRB9PwXQgBx7KaAV7Y=3D?=
X-OriginatorOrg: os.amperecomputing.com
X-MS-Exchange-CrossTenant-Network-Message-Id: fc8870d1-fdb7-48b4-05c9-08dc4f809286
X-MS-Exchange-CrossTenant-AuthSource: CO1PR01MB7370.prod.exchangelabs.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 28 Mar 2024 23:41:21.3307
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 3bc2b170-fd94-476d-b0ce-4229bdc904a7
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: Bs6aT1qO1aA2smAkxHbD/Brb+wOXHYzhcfwd3/nSWNmwBJqwp25a+usPaXY52R8dOJZ1hOr74SeQh4sCaLQmGT9t3G71p9J80GsAOZqQFtr3cb7AslMRIu8pNxkVp2VQ
X-MS-Exchange-Transport-CrossTenantHeadersStamped: SA1PR01MB8180

> +static int __init ras2_acpi_init(void)
> +{
> +	u8 count;
> +	acpi_status status;
> +	acpi_size ras2_size;
> +	int pcc_subspace_idx;
> +	struct platform_device *pdev;
> +	struct acpi_table_ras2 *pRas2Table;
> +	struct acpi_ras2_pcc_desc *pcc_desc_list;
> +	struct platform_device **pdev_list = NULL;
> +	struct acpi_table_header *pAcpiTable = NULL;
> +
> +	status = acpi_get_table("RAS2", 0, &pAcpiTable);
> +	if (ACPI_FAILURE(status) || !pAcpiTable) {
> +		pr_err("ACPI RAS2 driver failed to initialize, get table failed\n");
> +		return RAS2_FAILURE;
> +	}
> +
> +	ras2_size = pAcpiTable->length;
> +	if (ras2_size < sizeof(struct acpi_table_ras2)) {
> +		pr_err("ACPI RAS2 table present but broken (too short #1)\n");
> +		goto free_ras2_table;
> +	}
> +
> +	pRas2Table = (struct acpi_table_ras2 *)pAcpiTable;
> +
> +	if (pRas2Table->num_pcc_descs <= 0) {
> +		pr_err("ACPI RAS2 table does not contain PCC descriptors\n");
> +		goto free_ras2_table;
> +	}
> +
> +	pdev_list = kzalloc((pRas2Table->num_pcc_descs * sizeof(struct platform_device *)),
> +			     GFP_KERNEL);
> +	if (!pdev_list)
> +		goto free_ras2_table;
> +
> +	pcc_desc_list = (struct acpi_ras2_pcc_desc *)
> +				((void *)pRas2Table + sizeof(struct acpi_table_ras2));
> +	count = 0;
> +	while (count < pRas2Table->num_pcc_descs) {
> +		if (pcc_desc_list->feature_type == RAS2_FEATURE_TYPE_MEMORY) {
> +			pcc_subspace_idx = pcc_desc_list->channel_id;
> +			/* Add the platform device and bind ras2 memory driver */
> +			pdev = ras2_add_platform_device("ras2", &pcc_subspace_idx,
> +							sizeof(pcc_subspace_idx));
> +			if (!pdev)
> +				goto free_ras2_pdev;
> +			pdev_list[count] = pdev;
> +		}
> +		count++;
> +		pcc_desc_list = pcc_desc_list + sizeof(struct acpi_ras2_pcc_desc);

This line needs to be:
pcc_desc_list = pcc_desc_list + 1
because pcc_desc_list is a type larger than a byte.
This bug will crash the module when num_pcc_descs
is greater than 1

> +	}
> +
> +	acpi_put_table(pAcpiTable);
> +	return RAS2_SUCCESS;
> +
> +free_ras2_pdev:
> +	count = 0;
> +	while (count < pRas2Table->num_pcc_descs) {
> +		if (pcc_desc_list->feature_type ==
> +				RAS2_FEATURE_TYPE_MEMORY)
> +			platform_device_put(pdev_list[count++]);
> +	}
> +	kfree(pdev_list);
> +
> +free_ras2_table:
> +	acpi_put_table(pAcpiTable);
> +	return RAS2_FAILURE;
> +}







From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from BN8PR05CU002.outbound.protection.outlook.com (mail-eastus2azon11023019.outbound.protection.outlook.com [52.101.56.19])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id 5CB6C1DFF5;
	Thu, 28 Mar 2024 23:41:47 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=fail smtp.client-ip=52.101.56.19
ARC-Seal: i=2; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1711669309; cv=fail; b=puXmp9kzXhRDt5/zLo/TX2c46PwtZ7kh94kecKeA5QEFJFVeiwDr7OM8hAAMubZdBrmpMKVenMkobkYfOsINnBGnqcEWdRZKGivdIlJBLd8HMD+mJYeD+Pn5f3Qtl23ATydUdplvMNAMa37WqtjBhIISRWYMgxFxChY/Bhs4Li4=
ARC-Message-Signature: i=2; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1711669309; c=relaxed/simple;
	bh=9yKHJ9B63AEBPkTpFw3vGvcL1gJrvmyjlao/9H1pOVA=;
	h=Message-ID:Date:From:Subject:To:Cc:References:In-Reply-To:
	 Content-Type:MIME-Version; b=FvxxD0luPZayEVfAmqXdkeLw5a2vEYxmFqYEFBmy/kNs2fA7LObfRoSgYpuVWf3SrS6zo0VqnHYCrkzuT4zu5XeA2rPfk85C1VuQIN1Vd1MohuLRlRpRDHFUEXfRfMMLOsdH93se+f3P4/3SPwEdPoRVg9zhjr6BRdikWnxxAR4=
ARC-Authentication-Results: i=2; smtp.subspace.kernel.org; dmarc=pass (p=quarantine dis=none) header.from=os.amperecomputing.com; spf=pass smtp.mailfrom=os.amperecomputing.com; dkim=pass (1024-bit key) header.d=os.amperecomputing.com header.i=@os.amperecomputing.com header.b=F4LLCIkZ; arc=fail smtp.client-ip=52.101.56.19
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=quarantine dis=none) header.from=os.amperecomputing.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=os.amperecomputing.com
Authentication-Results: smtp.subspace.kernel.org;
	dkim=pass (1024-bit key) header.d=os.amperecomputing.com header.i=@os.amperecomputing.com header.b="F4LLCIkZ"
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=Qj8OiJj4zt4M6PXeI0M2n3DmNUizHabwpa8iZOPJh7YEHLeq9HPBruqczfV1DD4aFIsa9EXuvrCQAucud3irznJM0pgmo0WurSfxhTdMWY6rQ8c8puNLjPDn7GEJ5Yo9no0FszwZAlguIy01roYm1r8ITSCcDWVVd/V+J3sIXYKZthe9aIOZMg888L00tEVZRkt360YEx/KIhZdF7jGMCeGLOo/3aoquOMGSCnZX/Zhnj3h9/S+Jz1neBbPubI6wj47QUaNiPO8zDaldad6l2vOiMGklXgAw1o0dC/Q+HBdEljieG0VWsZf/Ccd+i9wtIpX/GR1M+Lwmyu33LTxfzg==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=G8QPhe+BU0s3uMP7YryxtgGR2g/P0au8w6M/3Jc1bLM=;
 b=OaRARyyrO5aHpbWkQUqj7t1EVBkOXBjTljLdcgu+FO21KtB2nW8Ix0bQ10CE8NmIlP+FK/LY6H3iSQ0JLgbvHijGZ3EiIrSSyKotqDmK5AHcz0Pp1BW3H6crx9cFtcN3qSyLDqgKtGGBUq9D0yeAYDdztyClSIs/kotSjWI/4yZbfOkdZzWpPbOL5tN3fvFDqPui/ciyJaZ+ipiWDD41lj32gydDYxKFD5FDR4pept6TtT15I/Kdw22yv3oDpOunB0WQbVzuficjrwnIcLu9ygs5oKYntj9HMFqjsjXP3JkscoRX8BRq72ggA9IfSe2RQIRDPRDUjsv3HAxMcAVveQ==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=os.amperecomputing.com; dmarc=pass action=none
 header.from=os.amperecomputing.com; dkim=pass
 header.d=os.amperecomputing.com; arc=none
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
 d=os.amperecomputing.com; s=selector2;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-SenderADCheck;
 bh=G8QPhe+BU0s3uMP7YryxtgGR2g/P0au8w6M/3Jc1bLM=;
 b=F4LLCIkZ4aLsKVmrURnthJYpuUsVrKa54eM0JBe4XSfv+TQzY05Pb6iQNnJQuanemQuCYnQ9MViZpw9Zuaxs3n2EJprV96tVGbDCPRX6topFPjvT+QaAEO8uR8888c11siu22vh/ExmLgF3Kuk8z0ZTqkH5ZvFN4OyyJRlM4X7A=
Received: from CO1PR01MB7370.prod.exchangelabs.com (2603:10b6:303:159::16) by
 PH0PR01MB7399.prod.exchangelabs.com (2603:10b6:510:10a::5) with Microsoft
 SMTP Server (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.20.7409.38; Thu, 28 Mar 2024 23:41:41 +0000
Received: from CO1PR01MB7370.prod.exchangelabs.com
 ([fe80::994c:4200:8a4b:6882]) by CO1PR01MB7370.prod.exchangelabs.com
 ([fe80::994c:4200:8a4b:6882%6]) with mapi id 15.20.7409.031; Thu, 28 Mar 2024
 23:41:41 +0000
Message-ID: <78d11760-bb43-42a1-a302-3e2d3bf40c48@os.amperecomputing.com>
Date: Thu, 28 Mar 2024 16:41:36 -0700
User-Agent: Mozilla Thunderbird
From: Daniel Ferguson <danielf@os.amperecomputing.com>
Subject: Re: [RFC PATCH v7 12/12] memory: RAS2: Add memory RAS2 driver
To: shiju.jose@huawei.com, linux-cxl@vger.kernel.org,
 linux-acpi@vger.kernel.org, linux-mm@kvack.org, dan.j.williams@intel.com,
 dave@stgolabs.net, jonathan.cameron@huawei.com, dave.jiang@intel.com,
 alison.schofield@intel.com, vishal.l.verma@intel.com, ira.weiny@intel.com
Cc: linux-edac@vger.kernel.org, linux-kernel@vger.kernel.org,
 david@redhat.com, Vilas.Sridharan@amd.com, leo.duran@amd.com,
 Yazen.Ghannam@amd.com, rientjes@google.com, jiaqiyan@google.com,
 tony.luck@intel.com, Jon.Grimm@amd.com, dave.hansen@linux.intel.com,
 rafael@kernel.org, lenb@kernel.org, naoya.horiguchi@nec.com,
 james.morse@arm.com, jthoughton@google.com, somasundaram.a@hpe.com,
 erdemaktas@google.com, pgonda@google.com, duenwen@google.com,
 mike.malvestuto@intel.com, gthelen@google.com,
 wschwartz@amperecomputing.com, dferguson@amperecomputing.com,
 tanxiaofei@huawei.com, prime.zeng@hisilicon.com,
 kangkang.shen@futurewei.com, wanghuiqiang@huawei.com, linuxarm@huawei.com,
 wbs@os.amperecomputing.com
References: <20240223143723.1574-1-shiju.jose@huawei.com>
 <20240223143723.1574-13-shiju.jose@huawei.com>
Content-Language: en-US
In-Reply-To: <20240223143723.1574-13-shiju.jose@huawei.com>
Content-Type: text/plain; charset=UTF-8; format=flowed
Content-Transfer-Encoding: 7bit
X-ClientProxiedBy: CH5P222CA0022.NAMP222.PROD.OUTLOOK.COM
 (2603:10b6:610:1ee::18) To CO1PR01MB7370.prod.exchangelabs.com
 (2603:10b6:303:159::16)
Precedence: bulk
X-Mailing-List: linux-kernel@vger.kernel.org
List-Id: <linux-kernel.vger.kernel.org>
List-Subscribe: <mailto:linux-kernel+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:linux-kernel+unsubscribe@vger.kernel.org>
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: CO1PR01MB7370:EE_|PH0PR01MB7399:EE_
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;
X-Microsoft-Antispam-Message-Info: 
	0OqT0FpemKT4yv1fW7Art5+4CxYqAk62PV4OyUX0V1EosLb4WtZSau8T1df1Ya3SigLUvH1GbKna1LvssnuMEAbSONMeAsU42WgVW5bn1IQVzOkq9Iae8sGPkGe72/d143NkJF+aYtYseazeRANjsvGS2zRyw4U2WLf1mDszYnEUOrqVxuRjaAEPBd2t5i63phUBUSAcWo627G7ya+IyILKt90Z/zDFAEAOWOslIDkpyXXvkAsJXxrx9K+Si2anUaxm9kyEYdM1pwM1Py32+CgEeSfm4vsmxhreOcIHcPgIIYr1ysT5iSyUpHwGhZ3C8v2LzsSqCEKkKa8Nn3ibdN5YYhbILxCAemqiw8cx8+ibNL7KVLblNS+ugNxIAX7ooBBqKZL9cFN9C4Q6j5VjFUEofnM490P3FxnjwNfqcy/l5Y4/PUMBiWIr5bnDMbMXBIu1h2EGwLFVAy3KIVj9qE7WhVKk1mqHn3uW5wEF++2opOv8uUYFaIqLTJQTCm93XzsgVhAHxDe1UeNyWYyo8y3hKmNHkUIjrmJ/JwCDok4XSG4gKSMwjMxwpBu4x2P/0p/Kc7XZJIhH/tw95lQADf8XLJjK2B5jr2RuXy282BIuWFEh3KvEFMEHWkmsX6KwK77ctEjbBQWkWBPKwE8kTtyNPAuTpXvvNILDLBTEoa34ol2acHxmMggkv+ltSPKDs8IrC5XK6EGyP1oLuQtnjFPjnOWZzKqJJyhcETknU4+s=
X-Forefront-Antispam-Report: 
	CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:CO1PR01MB7370.prod.exchangelabs.com;PTR:;CAT:NONE;SFS:(13230031)(1800799015)(7416005)(376005)(52116005)(366007)(38350700005)(921011);DIR:OUT;SFP:1102;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: 
	=?utf-8?B?c1RFRHYvZkVuWXRJV2N1Vk1HZXdZc3VxRkprV1JSNVd0eDM3NTVMN1cyWmEw?=
 =?utf-8?B?R3IyRjg0WFZjSHFFUVBYR3NPMHdHa1RDL2pUSk0wUVorSmlPU1pNdWZxSEZD?=
 =?utf-8?B?b3FZNEoyYUQvNzEwaktaVlVreVY1UXRQd1dnTGc0RWd0aWE3VkxHMEo5T1lv?=
 =?utf-8?B?SUF2d2x1YThnWGtpZGxQcUd5dXIxM2JCTWowbjMwZm5ZS2tpOEF2ZHBXdDVP?=
 =?utf-8?B?VG4rSDR6MG1yRk56YU9uRUM5ZzFwR2ZZVEhyK1JCMi9UazY3Wm9NVURkMnB2?=
 =?utf-8?B?LzZHVlB5U2NyZ3F6aFpmTkN6aXQ5VWFORDhOL2hrYTRRY2J5ZkNxamtYSG5L?=
 =?utf-8?B?SE5sNUVteDI5WGdjTzhMODRmTWNWZzMrdlE0aXo2RDJlRVVWQnJnMVpFMm9D?=
 =?utf-8?B?dGNPMDcvVzI2WE9LbTRLRS8yS0dwanFPbitvcjEyaGRwK29sRkdYYjFQRjNw?=
 =?utf-8?B?cmdkK2I0VU81cWJaTkYrcFprcndzZ3EvQXJjOHZvZkpJWHltM0xXTkMzb1Bh?=
 =?utf-8?B?MEwzdkhnWU1PZUtlWVZtOGxFOXFZTTR6UUd1bmY0RW1Ia1E5YU14eStjaXBV?=
 =?utf-8?B?Ti9BMFdtY0dPbXlaR1V4RlplL1QwdytFR3NhMHZ4ejlqcWxNSkNOUG9pcy9w?=
 =?utf-8?B?dzlHR29XQWc5UWY1bU5WVkJyOWFzRXRSNndMSHJWOFlNQ3ZTSzR4aUV1blEy?=
 =?utf-8?B?WU9hbTUrSVVMa1hwaXIwTCtKSVNiTzB4NG10WGZHbVR0eGhvMk14V2pHU3Jn?=
 =?utf-8?B?L3VyU1JzS1F3YkkvR21TMWtMS0k1aGRHT1ZHNEFuTVZqQ01UNVBWZi9qcm9s?=
 =?utf-8?B?RWVJY1YvdDVMUm9jTUFWSGJwV24zaE1nZzlYTndLS1NBRTRxYnJmMjIxMWx4?=
 =?utf-8?B?YkdqTFdrWTExYm9XdFdDMElYWmZPV1c1QVBqRTJ0bmdmc05qd3IrQnp4dy81?=
 =?utf-8?B?M1k0bElONGhLdkp5VlhZcURyeWtDZURvK1cyVFZuY3YvM2NYSnpONDdzOU1C?=
 =?utf-8?B?RytOTTNTNzJ5WWtLUzgrdzdGYlZHb2NGYnNlVnJveWo3c3J1ZSs3MkNzUFUr?=
 =?utf-8?B?ZTBrelIyUE5peW1jSVVsRGdUaHFaZ3lQdlc1OEdkenY1TDJZRnFOcFQwRmJM?=
 =?utf-8?B?TGhrVldQd3BKZzFka01acGVZODA2NE0vb1g2c3hsVHV4U3JWTW43bmprNXMx?=
 =?utf-8?B?WTlWOTJTWkFsVEtYRDBuc0JLVXZ6dmcybGxoNE1lYXozNVJLeDZQK2RjQVlR?=
 =?utf-8?B?V0FITmo1K1h5czlnRVJ2dXVRdDZiTVdkRmpONXcrUEtEdXhxRTVybk1pa2t3?=
 =?utf-8?B?ZkgvZ2FueWVST2NnaXhwVTRVZ3ErMDRCb3VSaWdrQnI2azBHWEZmclAreVhs?=
 =?utf-8?B?YzRXelVkSVZjR08va2dHbjc4L2tHaXRjQnltakdLaXV4SUpFMDFnajhOVWg3?=
 =?utf-8?B?c2duK2xLdHlPS3V2WGlERmdtWkk1Um1nRDZEbmlBdEFEMnhFVjkvZUtRd2NU?=
 =?utf-8?B?aHk2clk2cmlMRTJocXFDZTJUOUc0RnhWMW9HRmV2VEpxUnJIY0NBdmF1NTJX?=
 =?utf-8?B?UHU2SS9CVGEzTmJVREpaUGVFdVNCZk5RM3JHOElhWkkvN2d3Vk1DNFFtRHY1?=
 =?utf-8?B?MWQ4Q1N5aUV4Y0pkOFRtdFNYb2NQM2RETmc2S2Y1MXAwRFVPTEpka0ZnaTg3?=
 =?utf-8?B?QTZuSkZEMXVkakkzdVluaHh4enF3RWVEVXUrMW96c2lhNVVuZm5FbElXQ3pk?=
 =?utf-8?B?UStUTk1FZXZWWnZBVDArV1VWQm1yYis0dVJhYW96ZXltblUvVDB3YUxtTmdv?=
 =?utf-8?B?L0E0YVNad2FZckY3ZG0rclV3czZHTTRhYTdhb1ZjRVNnWlY1TXBSdkRzTlQw?=
 =?utf-8?B?UlVKQ2JDOU5WWTkzNUIzWk81Nk5vdlh1K21INEVxemM5bk1kVkFhQk5lSngx?=
 =?utf-8?B?VFhjZnNHVWVGMEF6UXVRU21SSENRUXRpZlJ1a1dibkxYdnBrWFpRWTZEQVNp?=
 =?utf-8?B?TUpZZGVWVHBUNERLaGtOMGFaSFdJMlZydUNIUDg1Z283NmhJMy9MSW9wNy9q?=
 =?utf-8?B?S004UEl2QVMrblVuZXpQQkxJSnp1R2FFQkMxdFdxT2tZai9oa2FOMVhDR01F?=
 =?utf-8?B?T1pjV29LN1F1cWhaTmdpL2x0L3IxM3BzV3I1REV4ZW16UWZyaXROTTUveWtv?=
 =?utf-8?Q?vq7s+tsJWT/45mT6U5aIrgo=3D?=
X-OriginatorOrg: os.amperecomputing.com
X-MS-Exchange-CrossTenant-Network-Message-Id: 8a32e4bb-597d-4985-c408-08dc4f809e81
X-MS-Exchange-CrossTenant-AuthSource: CO1PR01MB7370.prod.exchangelabs.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 28 Mar 2024 23:41:41.4796
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 3bc2b170-fd94-476d-b0ce-4229bdc904a7
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: aeFEioJKwpn9UnLG+6QKPTi/uHWX/1rJ6u4sn5uflDvC8XivuK+7jZXkGy9BSDuV3W+mS7wLeaf/SytML0USq2G1bpfF4rOm4mbtOvZoLQjWJsmN2IWNjjfFmrwAWAG8
X-MS-Exchange-Transport-CrossTenantHeadersStamped: PH0PR01MB7399

> +/*
> + * The below functions are exposed to OSPM, to query, configure and
> + * initiate memory patrol scrub.
> + */
> +static int ras2_is_patrol_scrub_support(struct ras2_context *ras2_ctx)
> +{
> +	int ret;
> +	struct acpi_ras2_shared_memory  __iomem *generic_comm_base;
> +
> +	if (!ras2_ctx || !ras2_ctx->pcc_comm_addr)
> +		return -EFAULT;
> +
> +	generic_comm_base = ras2_ctx->pcc_comm_addr;
> +	guard(spinlock_irqsave)(&ras2_ctx->spinlock);
> +	generic_comm_base->set_capabilities[0] = 0;
> +
> +	/* send command for reading RAS2 capabilities */
> +	ret = ras2_send_pcc_cmd(ras2_ctx, RAS2_PCC_CMD_EXEC);
> +	if (ret) {
> +		dev_err(ras2_ctx->dev,
> +			"%s: ras2_send_pcc_cmd failed\n", __func__);
> +		return ret;
> +	}
> +
> +	return generic_comm_base->features[0] & RAS2_SUPPORT_HW_PARTOL_SCRUB;

Since firmware populates the feature bitmask on initialization, it would 
seem
that we do not need to send a PCC CMD EXEC to read RAS2 capabilities.
> +}
> +
> +static int ras2_get_patrol_scrub_params(struct ras2_context *ras2_ctx,
> +					struct ras2_scrub_params *params)
> +{
> +	int ret = 0;
> +	u8  min_supp_scrub_rate, max_supp_scrub_rate;
> +	struct acpi_ras2_shared_memory  __iomem *generic_comm_base;
> +	struct acpi_ras2_patrol_scrub_parameter __iomem *patrol_scrub_params;
> +
> +	if (!ras2_ctx || !ras2_ctx->pcc_comm_addr)
> +		return -EFAULT;
> +
> +	generic_comm_base = ras2_ctx->pcc_comm_addr;
> +	patrol_scrub_params = ras2_ctx->pcc_comm_addr + sizeof(*generic_comm_base);
> +
> +	guard(spinlock_irqsave)(&ras2_ctx->spinlock);
> +	generic_comm_base->set_capabilities[0] = RAS2_SUPPORT_HW_PARTOL_SCRUB;
> +	/* send command for reading RAS2 capabilities */
> +	ret = ras2_send_pcc_cmd(ras2_ctx, RAS2_PCC_CMD_EXEC);
> +	if (ret) {
> +		dev_err(ras2_ctx->dev,
> +			"%s: ras2_send_pcc_cmd failed\n", __func__);
> +		return ret;
> +	}

Similarly, since firmware populates the feature bitmask on
initialization, it would seem that we do not need to send
a PCC CMD EXEC to read RAS2 capabilities.
> +
> +	if (!(generic_comm_base->features[0] & RAS2_SUPPORT_HW_PARTOL_SCRUB) ||
> +	    !(generic_comm_base->num_parameter_blocks)) {
> +		dev_err(ras2_ctx->dev,
> +			"%s: Platform does not support HW Patrol Scrubber\n", __func__);
> +		return -EOPNOTSUPP;
> +	}
> +
> +	if (!patrol_scrub_params->requested_address_range[1]) {
> +		dev_err(ras2_ctx->dev,
> +			"%s: Invalid requested address range, \
> +			requested_address_range[0]=0x%llx \
> +			requested_address_range[1]=0x%llx\n",
> +			__func__,
> +			patrol_scrub_params->requested_address_range[0],
> +			patrol_scrub_params->requested_address_range[1]);
> +		return -EOPNOTSUPP;
> +	}
> +
> +	generic_comm_base->set_capabilities[0] = RAS2_SUPPORT_HW_PARTOL_SCRUB;
> +	patrol_scrub_params->header.type = RAS2_TYPE_PATROL_SCRUB;

header.type should already be populated by firmware. Is assigning it
here necessary?
> +	patrol_scrub_params->patrol_scrub_command = RAS2_GET_PATROL_PARAMETERS;
> +
> +	/* send command for reading the HW patrol scrub parameters */
> +	ret = ras2_send_pcc_cmd(ras2_ctx, RAS2_PCC_CMD_EXEC);
> +	if (ret) {
> +		dev_err(ras2_ctx->dev,
> +			"%s: failed to read HW patrol scrub parameters\n",
> +			__func__);
> +		return ret;
> +	}
> +
> +	/* copy output scrub parameters */
> +	params->addr_base = patrol_scrub_params->actual_address_range[0];
> +	params->addr_size = patrol_scrub_params->actual_address_range[1];
> +	params->flags = patrol_scrub_params->flags;
> +	params->rate = FIELD_GET(RAS2_PATROL_SCRUB_RATE_OUT_MASK,
> +				 patrol_scrub_params->scrub_params_out);
> +	min_supp_scrub_rate = FIELD_GET(RAS2_PATROL_SCRUB_MIN_RATE_OUT_MASK,
> +					patrol_scrub_params->scrub_params_out);
> +	max_supp_scrub_rate = FIELD_GET(RAS2_PATROL_SCRUB_MAX_RATE_OUT_MASK,
> +					patrol_scrub_params->scrub_params_out);
> +	snprintf(params->rate_avail, RAS2_MAX_RATE_RANGE_LENGTH,
> +		 "%d-%d", min_supp_scrub_rate, max_supp_scrub_rate);
> +
> +	return 0;
> +}
> +
> +static int ras2_enable_patrol_scrub(struct ras2_context *ras2_ctx, bool enable)
> +{
> +	int ret = 0;
> +	struct ras2_scrub_params params;
> +	struct acpi_ras2_shared_memory  __iomem *generic_comm_base;
> +	u8 scrub_rate_to_set, min_supp_scrub_rate, max_supp_scrub_rate;
> +	struct acpi_ras2_patrol_scrub_parameter __iomem *patrol_scrub_params;
> +
> +	if (!ras2_ctx || !ras2_ctx->pcc_comm_addr)
> +		return -EFAULT;
> +
> +	generic_comm_base = ras2_ctx->pcc_comm_addr;
> +	patrol_scrub_params = ras2_ctx->pcc_comm_addr + sizeof(*generic_comm_base);
> +
> +	if (enable) {
> +		ret = ras2_get_patrol_scrub_params(ras2_ctx, &params);
> +		if (ret)
> +			return ret;
> +	}
> +
> +	guard(spinlock_irqsave)(&ras2_ctx->spinlock);
> +	generic_comm_base->set_capabilities[0] = RAS2_SUPPORT_HW_PARTOL_SCRUB;
> +	patrol_scrub_params->header.type = RAS2_TYPE_PATROL_SCRUB;

header.type should already be populated by firmware. Is assigning it
here necessary?
> +
> +	if (enable) {
> +		patrol_scrub_params->patrol_scrub_command = RAS2_START_PATROL_SCRUBBER;
> +		patrol_scrub_params->requested_address_range[0] = params.addr_base;
> +		patrol_scrub_params->requested_address_range[1] = params.addr_size;
> +
> +		scrub_rate_to_set = FIELD_GET(RAS2_PATROL_SCRUB_RATE_IN_MASK,
> +					      patrol_scrub_params->scrub_params_in);
> +		min_supp_scrub_rate = FIELD_GET(RAS2_PATROL_SCRUB_MIN_RATE_OUT_MASK,
> +						patrol_scrub_params->scrub_params_out);
> +		max_supp_scrub_rate = FIELD_GET(RAS2_PATROL_SCRUB_MAX_RATE_OUT_MASK,
> +						patrol_scrub_params->scrub_params_out);
> +		if (scrub_rate_to_set < min_supp_scrub_rate ||
> +		    scrub_rate_to_set > max_supp_scrub_rate) {
> +			dev_warn(ras2_ctx->dev,
> +				 "patrol scrub rate to set is out of the supported range\n");
> +			dev_warn(ras2_ctx->dev,
> +				 "min_supp_scrub_rate=%d max_supp_scrub_rate=%d\n",
> +				 min_supp_scrub_rate, max_supp_scrub_rate);
> +			return -EINVAL;
> +		}
> +	} else {
> +		patrol_scrub_params->patrol_scrub_command = RAS2_STOP_PATROL_SCRUBBER;
> +	}
> +
> +	/* send command for enable/disable HW patrol scrub */
> +	ret = ras2_send_pcc_cmd(ras2_ctx, RAS2_PCC_CMD_EXEC);
> +	if (ret) {
> +		pr_err("%s: failed to enable/disable the HW patrol scrub\n", __func__);
> +		return ret;
> +	}
> +
> +	return 0;
> +}
> +
> +static int ras2_enable_background_scrub(struct ras2_context *ras2_ctx, bool enable)
> +{
> +	int ret;
> +	struct acpi_ras2_shared_memory  __iomem *generic_comm_base;
> +	struct acpi_ras2_patrol_scrub_parameter __iomem *patrol_scrub_params;
> +
> +	if (!ras2_ctx || !ras2_ctx->pcc_comm_addr)
> +		return -EFAULT;
> +
> +	generic_comm_base = ras2_ctx->pcc_comm_addr;
> +	patrol_scrub_params = ras2_ctx->pcc_comm_addr + sizeof(*generic_comm_base);
> +
> +	guard(spinlock_irqsave)(&ras2_ctx->spinlock);
> +	generic_comm_base->set_capabilities[0] = RAS2_SUPPORT_HW_PARTOL_SCRUB;
> +	patrol_scrub_params->header.type = RAS2_TYPE_PATROL_SCRUB;

header.type should already be populated by firmware. Is assigning it
here necessary?
> +	patrol_scrub_params->patrol_scrub_command = RAS2_START_PATROL_SCRUBBER;
> +
> +	patrol_scrub_params->scrub_params_in &= ~RAS2_PATROL_SCRUB_EN_BACKGROUND;
> +	patrol_scrub_params->scrub_params_in |= FIELD_PREP(RAS2_PATROL_SCRUB_EN_BACKGROUND,
> +							   enable);
> +
> +	/* send command for enable/disable HW patrol scrub */
> +	ret = ras2_send_pcc_cmd(ras2_ctx, RAS2_PCC_CMD_EXEC);
> +	if (ret) {
> +		dev_err(ras2_ctx->dev,
> +			"%s: failed to enable/disable background patrol scrubbing\n",
> +			__func__);
> +		return ret;
> +	}
> +
> +	return 0;
> +}
> +static int ras2_set_patrol_scrub_params(struct ras2_context *ras2_ctx,
> +					struct ras2_scrub_params *params, u8 param_type)
> +{
> +	struct acpi_ras2_shared_memory  __iomem *generic_comm_base;
> +	struct acpi_ras2_patrol_scrub_parameter __iomem *patrol_scrub_params;
> +
> +	if (!ras2_ctx || !ras2_ctx->pcc_comm_addr)
> +		return -EFAULT;
> +
> +	generic_comm_base = ras2_ctx->pcc_comm_addr;
> +	patrol_scrub_params = ras2_ctx->pcc_comm_addr + sizeof(*generic_comm_base);
> +
> +	guard(spinlock_irqsave)(&ras2_ctx->spinlock);
> +	patrol_scrub_params->header.type = RAS2_TYPE_PATROL_SCRUB;
> +	if (param_type == RAS2_MEM_SCRUB_PARAM_ADDR_BASE && params->addr_base) {
> +		patrol_scrub_params->requested_address_range[0] = params->addr_base;
> +	} else if (param_type == RAS2_MEM_SCRUB_PARAM_ADDR_SIZE && params->addr_size) {
> +		patrol_scrub_params->requested_address_range[1] = params->addr_size;
> +	} else if (param_type == RAS2_MEM_SCRUB_PARAM_RATE) {
> +		patrol_scrub_params->scrub_params_in &= ~RAS2_PATROL_SCRUB_RATE_IN_MASK;
> +		patrol_scrub_params->scrub_params_in |= FIELD_PREP(RAS2_PATROL_SCRUB_RATE_IN_MASK,
> +								   params->rate);
> +	} else {
> +		dev_err(ras2_ctx->dev, "Invalid patrol scrub parameter to set\n");
> +		return -EINVAL;
> +	}
> +
> +	return 0;
> +}
> +
> +static const struct ras2_hw_scrub_ops ras2_hw_ops = {
> +	.enable_scrub = ras2_enable_patrol_scrub,
> +	.enable_background_scrub = ras2_enable_background_scrub,
> +	.get_scrub_params = ras2_get_patrol_scrub_params,
> +	.set_scrub_params = ras2_set_patrol_scrub_params,
> +};
> +
> +static const struct scrub_ops ras2_scrub_ops = {
> +	.is_visible = ras2_hw_scrub_is_visible,
> +	.read = ras2_hw_scrub_read,
> +	.write = ras2_hw_scrub_write,
> +	.read_string = ras2_hw_scrub_read_strings,
> +};
> +
> +static DEFINE_IDA(ras2_ida);
> +
> +static void devm_ras2_release(void *ctx)
> +{
> +	struct ras2_context *ras2_ctx = ctx;
> +
> +	ida_free(&ras2_ida, ras2_ctx->id);
> +	ras2_unregister_pcc_channel(ras2_ctx);
> +}
> +
> +static int ras2_probe(struct platform_device *pdev)
> +{
> +	int ret, id;
> +	struct mbox_client *cl;
> +	struct device *hw_scrub_dev;
> +	struct ras2_context *ras2_ctx;
> +	char scrub_name[RAS2_MAX_NAME_LENGTH];
> +
> +	ras2_ctx = devm_kzalloc(&pdev->dev, sizeof(*ras2_ctx), GFP_KERNEL);
> +	if (!ras2_ctx)
> +		return -ENOMEM;
> +
> +	ras2_ctx->dev = &pdev->dev;
> +	ras2_ctx->ops = &ras2_hw_ops;
> +	spin_lock_init(&ras2_ctx->spinlock);
> +	platform_set_drvdata(pdev, ras2_ctx);
> +
> +	cl = &ras2_ctx->mbox_client;
> +	/* Request mailbox channel */
> +	cl->dev = &pdev->dev;
> +	cl->tx_done = ras2_tx_done;
> +	cl->knows_txdone = true;
> +	ras2_ctx->pcc_subspace_idx = *((int *)pdev->dev.platform_data);
> +	dev_dbg(&pdev->dev, "pcc-subspace-id=%d\n", ras2_ctx->pcc_subspace_idx);
> +	ret = ras2_register_pcc_channel(ras2_ctx);

In our enabling activities, we have found a challenge here.
Our hardware has a single PCC channel corresponding to a single
platform-wide scrub interface. This driver, following the ACPI spec,
will create a new scrub node for each NUMA node. However, for us,
this means that each scrub device will try to map the same PCC channel,
and this causes an error.
> +	if (ret < 0)
> +		return ret;
> +
> +	ret = devm_add_action_or_reset(&pdev->dev, devm_ras2_release, ras2_ctx);
> +	if (ret < 0)
> +		return ret;
> +
> +	if (ras2_is_patrol_scrub_support(ras2_ctx)) {
> +		id = ida_alloc(&ras2_ida, GFP_KERNEL);
> +		if (id < 0)
> +			return id;
> +		ras2_ctx->id = id;
> +		snprintf(scrub_name, sizeof(scrub_name), "%s%d", RAS2_SCRUB, id);
> +		dev_set_name(&pdev->dev, RAS2_ID_FORMAT, id);
> +		hw_scrub_dev = devm_scrub_device_register(&pdev->dev, scrub_name,
> +							  ras2_ctx, &ras2_scrub_ops,
> +							  0, NULL);
> +		if (PTR_ERR_OR_ZERO(hw_scrub_dev))
> +			return PTR_ERR_OR_ZERO(hw_scrub_dev);
> +	}
> +	ras2_ctx->scrub_dev = hw_scrub_dev;
> +
> +	return 0;
> +}










From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id CD1B75A7AE;
	Tue,  2 Apr 2024 10:17:13 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=none smtp.client-ip=185.176.79.56
ARC-Seal: i=1; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1712053036; cv=none; b=CGo8pjwD2v6GxZuf4JumjHBLKU3LChnZNgZTh8hwQW6UorqXFu9Py7pas1+oa8iaYN/vlbWUMo+vHAT5wMNLnybb5zwt5EOXYk7nbQjf+oLlIgp8Sj83iNNr+t7qNkxrdlU+ZD2LSltQdLBKxcHsgiAJFIKvUgcm+d5+WAS29Ng=
ARC-Message-Signature: i=1; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1712053036; c=relaxed/simple;
	bh=7w+zfYL5/EU3k21GldfEZOmIoR0yGMwEVvQsUYIGfEg=;
	h=Date:From:To:CC:Subject:Message-ID:In-Reply-To:References:
	 MIME-Version:Content-Type; b=WreR7uhbnnMuroSuJfM4KO1/urGSCd211C8rUz3gPSqMk+ttgk3/mzt0mNkOv1Deycpx5FRi4CIEfPcieAXhJsqH5YigbsXkb5+0FmxkJYHRJaYQVqctUNL4hI54DcXc4C4LlZ/v4rZ3Ks34hy/5056zoMfnY7uaQAID7RDFm7c=
ARC-Authentication-Results: i=1; smtp.subspace.kernel.org; dmarc=pass (p=quarantine dis=none) header.from=Huawei.com; spf=pass smtp.mailfrom=huawei.com; arc=none smtp.client-ip=185.176.79.56
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=quarantine dis=none) header.from=Huawei.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=huawei.com
Received: from mail.maildlp.com (unknown [172.18.186.31])
	by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4V83bQ4VC0z6K98F;
	Tue,  2 Apr 2024 18:12:34 +0800 (CST)
Received: from lhrpeml500005.china.huawei.com (unknown [7.191.163.240])
	by mail.maildlp.com (Postfix) with ESMTPS id AFD60140A87;
	Tue,  2 Apr 2024 18:17:10 +0800 (CST)
Received: from localhost (10.202.227.76) by lhrpeml500005.china.huawei.com
 (7.191.163.240) with Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.1.2507.35; Tue, 2 Apr
 2024 11:17:09 +0100
Date: Tue, 2 Apr 2024 11:17:09 +0100
From: Jonathan Cameron <Jonathan.Cameron@Huawei.com>
To: Yazen Ghannam <yazen.ghannam@amd.com>
CC: <shiju.jose@huawei.com>, <linux-cxl@vger.kernel.org>,
	<linux-acpi@vger.kernel.org>, <linux-mm@kvack.org>,
	<dan.j.williams@intel.com>, <dave@stgolabs.net>, <dave.jiang@intel.com>,
	<alison.schofield@intel.com>, <vishal.l.verma@intel.com>,
	<ira.weiny@intel.com>, <linux-edac@vger.kernel.org>,
	<linux-kernel@vger.kernel.org>, <david@redhat.com>,
	<Vilas.Sridharan@amd.com>, <leo.duran@amd.com>, <rientjes@google.com>,
	<jiaqiyan@google.com>, <tony.luck@intel.com>, <Jon.Grimm@amd.com>,
	<dave.hansen@linux.intel.com>, <rafael@kernel.org>, <lenb@kernel.org>,
	<naoya.horiguchi@nec.com>, <james.morse@arm.com>, <jthoughton@google.com>,
	<somasundaram.a@hpe.com>, <erdemaktas@google.com>, <pgonda@google.com>,
	<duenwen@google.com>, <mike.malvestuto@intel.com>, <gthelen@google.com>,
	<wschwartz@amperecomputing.com>, <dferguson@amperecomputing.com>,
	<tanxiaofei@huawei.com>, <prime.zeng@hisilicon.com>,
	<kangkang.shen@futurewei.com>, <wanghuiqiang@huawei.com>,
	<linuxarm@huawei.com>
Subject: Re: [RFC PATCH v7 12/12] memory: RAS2: Add memory RAS2 driver
Message-ID: <20240402111709.0000653a@Huawei.com>
In-Reply-To: <71d41ec9-17ed-442f-8d68-a6cb9bcbb4b0@amd.com>
References: <20240223143723.1574-1-shiju.jose@huawei.com>
	<20240223143723.1574-13-shiju.jose@huawei.com>
	<71d41ec9-17ed-442f-8d68-a6cb9bcbb4b0@amd.com>
Organization: Huawei Technologies Research and Development (UK) Ltd.
X-Mailer: Claws Mail 4.1.0 (GTK 3.24.33; x86_64-w64-mingw32)
Precedence: bulk
X-Mailing-List: linux-kernel@vger.kernel.org
List-Id: <linux-kernel.vger.kernel.org>
List-Subscribe: <mailto:linux-kernel+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:linux-kernel+unsubscribe@vger.kernel.org>
MIME-Version: 1.0
Content-Type: text/plain; charset="UTF-8"
Content-Transfer-Encoding: quoted-printable
X-ClientProxiedBy: lhrpeml500005.china.huawei.com (7.191.163.240) To
 lhrpeml500005.china.huawei.com (7.191.163.240)

On Thu, 28 Mar 2024 11:23:38 -0400
Yazen Ghannam <yazen.ghannam@amd.com> wrote:

> On 2/23/2024 9:37 AM, shiju.jose@huawei.com wrote:
> > From: Shiju Jose <shiju.jose@huawei.com>
> >=20
> > Memory RAS2 driver binds to the platform device add by the ACPI RAS2
> > driver.
> > Driver registers the PCC channel for communicating with the ACPI compli=
ant
> > platform that contains RAS2 command support in the hardware.
> >=20
> > Add interface functions to support configuring the parameters of HW pat=
rol
> > scrubs in the system, which exposed to the kernel via the RAS2 and PCC,
> > using the RAS2 commands.
> >=20
> > Add support for RAS2 platform devices to register with scrub subsystem
> > driver. This enables user to configure the parameters of HW patrol scru=
bs,
> > which exposed to the kernel via the RAS2 table, through the scrub sysfs
> > attributes.
> >=20
> > Open Question:
> > Sysfs scrub control attribute "enable_background_scrub" is added for RA=
S2,
> > based on the feedback from Bill Schwartz <wschwartz@amperecomputing.com
> > on v4 to enable/disable the background_scrubbing in the platform as def=
ined in the
> > =E2=80=9CConfigure Scrub Parameters [INPUT]=E2=80=9C field  in RAS2 Tab=
le 5.87: Parameter Block
> > Structure for PATROL_SCRUB.
> > Is it a right approach to support "enable_background_scrub" in the sysfs
> > scrub control?
> >=20
> > Signed-off-by: Shiju Jose <shiju.jose@huawei.com>
> > ---
> >  drivers/memory/Kconfig       |  14 ++
> >  drivers/memory/Makefile      |   2 +
> >  drivers/memory/ras2.c        | 364 +++++++++++++++++++++++++++++++++++
> >  drivers/memory/ras2_common.c | 282 +++++++++++++++++++++++++++
> >  include/memory/ras2.h        |  88 +++++++++
> >  5 files changed, 750 insertions(+)
> >  create mode 100644 drivers/memory/ras2.c
> >  create mode 100644 drivers/memory/ras2_common.c
> >  create mode 100755 include/memory/ras2.h
> >  =20
>=20
> Sorry if this was already covered, but why not put the common scrub and r=
as2
> changes under /drivers/ras/?

Hi Yazen

Location / naming etc is definitely an open question.
Given the OCP RAS API has repeatedly come up in discussions (and that
has a much wider scope), a RAS focused location may well make sense + some
renaming to avoid being memory scrub specific.

Jonathan

>=20
> Thanks,
> Yazen


From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id 77479148318;
	Wed,  3 Apr 2024 13:52:06 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=none smtp.client-ip=185.176.79.56
ARC-Seal: i=1; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1712152330; cv=none; b=JYrQHtA0ZF7569RwdDW/zC+h7lQ2EgD9pdAEPK1TwnFt8gV3jb3LeKcz+kgD3YXJaAuXs89oR9oSfiff9H7yks/JEALISo4HM7aNDoqA9a2AUpuGX1VXQqpoAdI5nBeJTqX6A+J4aZgcMoJGh/GiORo42yCFrtvgfD43vLF4VWM=
ARC-Message-Signature: i=1; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1712152330; c=relaxed/simple;
	bh=HMEfWzbSwWAN8nTimw2mnfhX0tvSQNkY41MOF5tayJ4=;
	h=From:To:CC:Subject:Date:Message-ID:References:In-Reply-To:
	 Content-Type:MIME-Version; b=CguXoz+RSkLdnsjxXz5RT0JVWjXd+pVCQ88kZW/P6uSLJPZDDFJsgtThmli8JHw9u1vPGQ/1V08bdzoXYiwOen3jrIGNxSte839yH6AdIMRu2nwFH8RyLjy/+mgstJ9gcQ1W/9TTKAR9PtGtq5OmyY4C5V+rm9VJEqfBkgp+5aM=
ARC-Authentication-Results: i=1; smtp.subspace.kernel.org; dmarc=pass (p=quarantine dis=none) header.from=huawei.com; spf=pass smtp.mailfrom=huawei.com; arc=none smtp.client-ip=185.176.79.56
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=quarantine dis=none) header.from=huawei.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=huawei.com
Received: from mail.maildlp.com (unknown [172.18.186.216])
	by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4V8mJs5NVGz6D9Rl;
	Wed,  3 Apr 2024 21:47:25 +0800 (CST)
Received: from lhrpeml500004.china.huawei.com (unknown [7.191.163.9])
	by mail.maildlp.com (Postfix) with ESMTPS id 85C61140CB9;
	Wed,  3 Apr 2024 21:52:03 +0800 (CST)
Received: from lhrpeml500006.china.huawei.com (7.191.161.198) by
 lhrpeml500004.china.huawei.com (7.191.163.9) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.35; Wed, 3 Apr 2024 14:52:03 +0100
Received: from lhrpeml500006.china.huawei.com ([7.191.161.198]) by
 lhrpeml500006.china.huawei.com ([7.191.161.198]) with mapi id 15.01.2507.035;
 Wed, 3 Apr 2024 14:52:03 +0100
From: Shiju Jose <shiju.jose@huawei.com>
To: Daniel Ferguson <danielf@os.amperecomputing.com>,
	"linux-cxl@vger.kernel.org" <linux-cxl@vger.kernel.org>,
	"linux-acpi@vger.kernel.org" <linux-acpi@vger.kernel.org>,
	"linux-mm@kvack.org" <linux-mm@kvack.org>, "dan.j.williams@intel.com"
	<dan.j.williams@intel.com>, "dave@stgolabs.net" <dave@stgolabs.net>,
	"Jonathan Cameron" <jonathan.cameron@huawei.com>, "dave.jiang@intel.com"
	<dave.jiang@intel.com>, "alison.schofield@intel.com"
	<alison.schofield@intel.com>, "vishal.l.verma@intel.com"
	<vishal.l.verma@intel.com>, "ira.weiny@intel.com" <ira.weiny@intel.com>
CC: "linux-edac@vger.kernel.org" <linux-edac@vger.kernel.org>,
	"linux-kernel@vger.kernel.org" <linux-kernel@vger.kernel.org>,
	"david@redhat.com" <david@redhat.com>, "Vilas.Sridharan@amd.com"
	<Vilas.Sridharan@amd.com>, "leo.duran@amd.com" <leo.duran@amd.com>,
	"Yazen.Ghannam@amd.com" <Yazen.Ghannam@amd.com>, "rientjes@google.com"
	<rientjes@google.com>, "jiaqiyan@google.com" <jiaqiyan@google.com>,
	"tony.luck@intel.com" <tony.luck@intel.com>, "Jon.Grimm@amd.com"
	<Jon.Grimm@amd.com>, "dave.hansen@linux.intel.com"
	<dave.hansen@linux.intel.com>, "rafael@kernel.org" <rafael@kernel.org>,
	"lenb@kernel.org" <lenb@kernel.org>, "naoya.horiguchi@nec.com"
	<naoya.horiguchi@nec.com>, "james.morse@arm.com" <james.morse@arm.com>,
	"jthoughton@google.com" <jthoughton@google.com>, "somasundaram.a@hpe.com"
	<somasundaram.a@hpe.com>, "erdemaktas@google.com" <erdemaktas@google.com>,
	"pgonda@google.com" <pgonda@google.com>, "duenwen@google.com"
	<duenwen@google.com>, "mike.malvestuto@intel.com"
	<mike.malvestuto@intel.com>, "gthelen@google.com" <gthelen@google.com>,
	"wschwartz@amperecomputing.com" <wschwartz@amperecomputing.com>,
	"dferguson@amperecomputing.com" <dferguson@amperecomputing.com>, tanxiaofei
	<tanxiaofei@huawei.com>, "Zengtao (B)" <prime.zeng@hisilicon.com>,
	"kangkang.shen@futurewei.com" <kangkang.shen@futurewei.com>, wanghuiqiang
	<wanghuiqiang@huawei.com>, Linuxarm <linuxarm@huawei.com>,
	"wbs@os.amperecomputing.com" <wbs@os.amperecomputing.com>
Subject: RE: [RFC PATCH v7 00/12] memory: scrub: introduce subsystem +
 CXL/ACPI-RAS2 drivers
Thread-Topic: [RFC PATCH v7 00/12] memory: scrub: introduce subsystem +
 CXL/ACPI-RAS2 drivers
Thread-Index: AQHaZmXXQwZWLjPhY0S3rmfIb/nqxrFOBaAAgAie3mA=
Date: Wed, 3 Apr 2024 13:52:02 +0000
Message-ID: <341e8365816746f58bc8f5b270f91eef@huawei.com>
References: <20240223143723.1574-1-shiju.jose@huawei.com>
 <0309f5f9-9a95-485c-a442-e9fba603d676@os.amperecomputing.com>
In-Reply-To: <0309f5f9-9a95-485c-a442-e9fba603d676@os.amperecomputing.com>
Accept-Language: en-GB, en-US
Content-Language: en-US
X-MS-Has-Attach: 
X-MS-TNEF-Correlator: 
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: base64
Precedence: bulk
X-Mailing-List: linux-kernel@vger.kernel.org
List-Id: <linux-kernel.vger.kernel.org>
List-Subscribe: <mailto:linux-kernel+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:linux-kernel+unsubscribe@vger.kernel.org>
MIME-Version: 1.0

SGkgRGFuaWVsLA0KDQpUaGFua3MgZm9yIHRoZSBmZWVkYmFja3MuDQoNCj4tLS0tLU9yaWdpbmFs
IE1lc3NhZ2UtLS0tLQ0KPkZyb206IERhbmllbCBGZXJndXNvbiA8ZGFuaWVsZkBvcy5hbXBlcmVj
b21wdXRpbmcuY29tPg0KPlNlbnQ6IDI4IE1hcmNoIDIwMjQgMjM6NDANCj5UbzogU2hpanUgSm9z
ZSA8c2hpanUuam9zZUBodWF3ZWkuY29tPjsgbGludXgtY3hsQHZnZXIua2VybmVsLm9yZzsgbGlu
dXgtDQo+YWNwaUB2Z2VyLmtlcm5lbC5vcmc7IGxpbnV4LW1tQGt2YWNrLm9yZzsgZGFuLmoud2ls
bGlhbXNAaW50ZWwuY29tOw0KPmRhdmVAc3Rnb2xhYnMubmV0OyBKb25hdGhhbiBDYW1lcm9uIDxq
b25hdGhhbi5jYW1lcm9uQGh1YXdlaS5jb20+Ow0KPmRhdmUuamlhbmdAaW50ZWwuY29tOyBhbGlz
b24uc2Nob2ZpZWxkQGludGVsLmNvbTsgdmlzaGFsLmwudmVybWFAaW50ZWwuY29tOw0KPmlyYS53
ZWlueUBpbnRlbC5jb20NCj5DYzogbGludXgtZWRhY0B2Z2VyLmtlcm5lbC5vcmc7IGxpbnV4LWtl
cm5lbEB2Z2VyLmtlcm5lbC5vcmc7DQo+ZGF2aWRAcmVkaGF0LmNvbTsgVmlsYXMuU3JpZGhhcmFu
QGFtZC5jb207IGxlby5kdXJhbkBhbWQuY29tOw0KPllhemVuLkdoYW5uYW1AYW1kLmNvbTsgcmll
bnRqZXNAZ29vZ2xlLmNvbTsgamlhcWl5YW5AZ29vZ2xlLmNvbTsNCj50b255Lmx1Y2tAaW50ZWwu
Y29tOyBKb24uR3JpbW1AYW1kLmNvbTsgZGF2ZS5oYW5zZW5AbGludXguaW50ZWwuY29tOw0KPnJh
ZmFlbEBrZXJuZWwub3JnOyBsZW5iQGtlcm5lbC5vcmc7IG5hb3lhLmhvcmlndWNoaUBuZWMuY29t
Ow0KPmphbWVzLm1vcnNlQGFybS5jb207IGp0aG91Z2h0b25AZ29vZ2xlLmNvbTsgc29tYXN1bmRh
cmFtLmFAaHBlLmNvbTsNCj5lcmRlbWFrdGFzQGdvb2dsZS5jb207IHBnb25kYUBnb29nbGUuY29t
OyBkdWVud2VuQGdvb2dsZS5jb207DQo+bWlrZS5tYWx2ZXN0dXRvQGludGVsLmNvbTsgZ3RoZWxl
bkBnb29nbGUuY29tOw0KPndzY2h3YXJ0ekBhbXBlcmVjb21wdXRpbmcuY29tOyBkZmVyZ3Vzb25A
YW1wZXJlY29tcHV0aW5nLmNvbTsNCj50YW54aWFvZmVpIDx0YW54aWFvZmVpQGh1YXdlaS5jb20+
OyBaZW5ndGFvIChCKSA8cHJpbWUuemVuZ0BoaXNpbGljb24uY29tPjsNCj5rYW5na2FuZy5zaGVu
QGZ1dHVyZXdlaS5jb207IHdhbmdodWlxaWFuZyA8d2FuZ2h1aXFpYW5nQGh1YXdlaS5jb20+Ow0K
PkxpbnV4YXJtIDxsaW51eGFybUBodWF3ZWkuY29tPjsgd2JzQG9zLmFtcGVyZWNvbXB1dGluZy5j
b20NCj5TdWJqZWN0OiBSZTogW1JGQyBQQVRDSCB2NyAwMC8xMl0gbWVtb3J5OiBzY3J1YjogaW50
cm9kdWNlIHN1YnN5c3RlbSArDQo+Q1hML0FDUEktUkFTMiBkcml2ZXJzDQo+DQo+PiBSQVMyIEhX
IGJhc2VkIG1lbW9yeSBwYXRyb2wgc2NydWIgbmVlZHMgUkFTMiBQQ0MgaW50ZXJmYWNlcyBhbmQg
QUNQSQ0KPj4gUkFTMiBkcml2ZXIgZm9yIGNvbW11bmljYXRpb24gYi93IGtlcm5lbCBhbmQgZmly
bXdhcmUuDQo+PiBBQ1BJIFJBUzIgRHJpdmVyIGFkZHMgcGxhdGZvcm0gZGV2aWNlLCBmb3IgZWFj
aCBtZW1vcnkgZmVhdHVyZSwgd2hpY2gNCj4+IGJpbmRzIHRvIHRoZSBSQVMyIG1lbW9yeSBkcml2
ZXIuDQo+PiBNZW1vcnkgUkFTMiBkcml2ZXIgcmVnaXN0ZXJzIHdpdGggdGhlIG1lbW9yeSBzY3J1
YiBzdWJzeXN0ZW0gdG8gZXhwb3NlDQo+PiB0aGUgUkFTMiBzY3J1YiBjb250cm9scyB0byB0aGUg
dXNlci4NCj4NCj5IaSBTaGlqdSwNCj5UaGFua3MgZm9yIHRoaXMgd29yay4gVGhpcyBoYXMgYmVl
biB2ZXJ5IHVzZWZ1bCBmb3IgdXMsIGFzIHdlJ3ZlIGJlZW4gdXNpbmcgaXQgdG8NCj50ZXN0IGEg
UkFTMiBpbXBsZW1lbnRhdGlvbiBoZXJlIGF0IEFtcGVyZSBDb21wdXRpbmcuDQo+DQo+SW4gZ2Vu
ZXJhbCwgdGhlIHBpZWNlcyBpbXBsZW1lbnRpbmcgUkFTMiBhcmUgdXNlZnVsIGFuZCBmdW5jdGlv
bmFsLiBXZSBkaWQsDQo+aG93ZXZlciwgZW5jb3VudGVyIGEgZmV3IHBsYWNlcyB3aGVyZSB3ZSBo
YWQgdG8gbWFrZSBzb21lIGJ1ZyBmaXhlcy4NCj5JJ2xsIHJlcGx5IHRvIHNwZWNpZmljIHBhdGNo
ZXMgd2l0aCBjaGFuZ2VzIEkgY2FuIHJlY29tbWVuZC4gQWxzbywgdGhlcmUgYXJlIGENCj5mZXcg
aW1wbGVtZW50YXRpb24gY2hvaWNlcyB0aGF0IEkgd2lsbCBoYXZlIHF1ZXN0aW9ucyBhYm91dC4N
Cj4NCj5IZXJlIGlzIGFuIG91dGxpbmUgY29udGFpbmluZyB0aGUgZ2VuZXJhbGl6ZWQgY29tbWVu
dHMgSSBwbGFuIG9uIG1ha2luZw0KPndpdGhpbi9uZWFyIHJlbGV2YW50IHBhdGNoZXM6DQo+MSkg
Rm91bmQgYSBidWcgaW4gcmFzMi5jIGluIGhvdyB0aGUgcGNjX2Rlc2NfbGlzdCBwb2ludGVyIGlz
IGluY3JlbWVudGVkLg0KVGhpcyBidWcgd2FzIGZpeGVkIGluIHRoZSBsb2NhbCB2OCBjb2RlLg0K
DQo+MikgRXhlY3V0aW5nIGEgUkFTMiBjb21tYW5kIHNlZW1zIHVubmVjZXNzYXJ5IGZvciBmZWF0
dXJlIGRldGVjdGlvbi4NCj5zcGVjaWZpY2FsbHksIGluIHRoZSBmdW5jdGlvbnMgcmFzMl9pc19w
YXRyb2xfc2NydWJfc3VwcG9ydCgpIGFuZA0KPnJhczJfZ2V0X3BhdHJvbF9zY3J1Yl9wYXJhbXMo
KQ0KSSB3aWxsIGNoZWNrIGFuZCBtb2RpZnkgaW4gdGhlIG5leHQgdmVyc2lvbi4NCg0KPjMpIENv
bnNpZGVyIGFkZGluZyBtb3JlIGVycm9yIGRldGVjdGlvbi9yZXBvcnRpbmcgaW4gcmFzMl9jaGVj
a19wY2NfY2hhbigpDQpTdXJlLg0KDQo+NCkgQ29uY2VybnMgd2l0aCBtdWx0aXBsZSBzY3J1YiBk
ZXZpY2VzIGF0dGVtcHRpbmcgdG8gbWFwIHRoZSBzYW1lIFBDQw0KPmNoYW5uZWwuDQpJIHdpbGwg
cmVwbHkgaW4gdGhlIHBhdGNoLiANCj4NCj4tRGFuaWVsDQo+DQpUaGFua3MsDQpTaGlqdQ0KDQo=

From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id 47A84148305;
	Wed,  3 Apr 2024 14:04:02 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=none smtp.client-ip=185.176.79.56
ARC-Seal: i=1; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1712153046; cv=none; b=SU/mats1M0BJqS5OaXgGYtN1H8+5J+A6zXH+Q2PrJ9n53TqB5sZcmaWPwvCD1Snrc8+DqefDcvF4gtEiC+NuDyTfZisY+dDHIaxkC9FsUpA4lfxvjMcNAj/IbBsJ30fXq6flBvzHL6jvGUPHQd0y2I1Kl2MFLJEaG7krlr6xbdE=
ARC-Message-Signature: i=1; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1712153046; c=relaxed/simple;
	bh=anWldCiKGwnM3Qr2FBojle4TG/sM3U26csId4sUVpiA=;
	h=From:To:CC:Subject:Date:Message-ID:References:In-Reply-To:
	 Content-Type:MIME-Version; b=qKRhDScXu5TFpUtVbdLrWQETdKentmLtqoMEMfF1UtcmVgq7EWmxhFFxeMC9PoCjC3jOyS1ILBCk7rFxb3EwRX87FGpxffawmUy488mi20sNcwhn6SdniNeOxKOxsjcMQdZayf3fclEV+cqkdxsXjuwrcMqFwp+mnxnizO7wbfM=
ARC-Authentication-Results: i=1; smtp.subspace.kernel.org; dmarc=pass (p=quarantine dis=none) header.from=huawei.com; spf=pass smtp.mailfrom=huawei.com; arc=none smtp.client-ip=185.176.79.56
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=quarantine dis=none) header.from=huawei.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=huawei.com
Received: from mail.maildlp.com (unknown [172.18.186.231])
	by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4V8mfS0nqpz6D8W0;
	Wed,  3 Apr 2024 22:02:40 +0800 (CST)
Received: from lhrpeml500005.china.huawei.com (unknown [7.191.163.240])
	by mail.maildlp.com (Postfix) with ESMTPS id 95D1B140D30;
	Wed,  3 Apr 2024 22:03:59 +0800 (CST)
Received: from lhrpeml500006.china.huawei.com (7.191.161.198) by
 lhrpeml500005.china.huawei.com (7.191.163.240) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.35; Wed, 3 Apr 2024 15:03:59 +0100
Received: from lhrpeml500006.china.huawei.com ([7.191.161.198]) by
 lhrpeml500006.china.huawei.com ([7.191.161.198]) with mapi id 15.01.2507.035;
 Wed, 3 Apr 2024 15:03:59 +0100
From: Shiju Jose <shiju.jose@huawei.com>
To: Daniel Ferguson <danielf@os.amperecomputing.com>,
	"linux-cxl@vger.kernel.org" <linux-cxl@vger.kernel.org>,
	"linux-acpi@vger.kernel.org" <linux-acpi@vger.kernel.org>,
	"linux-mm@kvack.org" <linux-mm@kvack.org>, "dan.j.williams@intel.com"
	<dan.j.williams@intel.com>, "dave@stgolabs.net" <dave@stgolabs.net>,
	"Jonathan Cameron" <jonathan.cameron@huawei.com>, "dave.jiang@intel.com"
	<dave.jiang@intel.com>, "alison.schofield@intel.com"
	<alison.schofield@intel.com>, "vishal.l.verma@intel.com"
	<vishal.l.verma@intel.com>, "ira.weiny@intel.com" <ira.weiny@intel.com>
CC: "linux-edac@vger.kernel.org" <linux-edac@vger.kernel.org>,
	"linux-kernel@vger.kernel.org" <linux-kernel@vger.kernel.org>,
	"david@redhat.com" <david@redhat.com>, "Vilas.Sridharan@amd.com"
	<Vilas.Sridharan@amd.com>, "leo.duran@amd.com" <leo.duran@amd.com>,
	"Yazen.Ghannam@amd.com" <Yazen.Ghannam@amd.com>, "rientjes@google.com"
	<rientjes@google.com>, "jiaqiyan@google.com" <jiaqiyan@google.com>,
	"tony.luck@intel.com" <tony.luck@intel.com>, "Jon.Grimm@amd.com"
	<Jon.Grimm@amd.com>, "dave.hansen@linux.intel.com"
	<dave.hansen@linux.intel.com>, "rafael@kernel.org" <rafael@kernel.org>,
	"lenb@kernel.org" <lenb@kernel.org>, "naoya.horiguchi@nec.com"
	<naoya.horiguchi@nec.com>, "james.morse@arm.com" <james.morse@arm.com>,
	"jthoughton@google.com" <jthoughton@google.com>, "somasundaram.a@hpe.com"
	<somasundaram.a@hpe.com>, "erdemaktas@google.com" <erdemaktas@google.com>,
	"pgonda@google.com" <pgonda@google.com>, "duenwen@google.com"
	<duenwen@google.com>, "mike.malvestuto@intel.com"
	<mike.malvestuto@intel.com>, "gthelen@google.com" <gthelen@google.com>,
	"wschwartz@amperecomputing.com" <wschwartz@amperecomputing.com>,
	"dferguson@amperecomputing.com" <dferguson@amperecomputing.com>, tanxiaofei
	<tanxiaofei@huawei.com>, "Zengtao (B)" <prime.zeng@hisilicon.com>,
	"kangkang.shen@futurewei.com" <kangkang.shen@futurewei.com>, wanghuiqiang
	<wanghuiqiang@huawei.com>, Linuxarm <linuxarm@huawei.com>,
	"wbs@os.amperecomputing.com" <wbs@os.amperecomputing.com>
Subject: RE: [RFC PATCH v7 12/12] memory: RAS2: Add memory RAS2 driver
Thread-Topic: [RFC PATCH v7 12/12] memory: RAS2: Add memory RAS2 driver
Thread-Index: AQHaZmXf7yKhv06+EU6o6xtLiEJk9LFOBiUAgAjJRxA=
Date: Wed, 3 Apr 2024 14:03:58 +0000
Message-ID: <32c348a0a61d4c6585b1b58e923a7f79@huawei.com>
References: <20240223143723.1574-1-shiju.jose@huawei.com>
 <20240223143723.1574-13-shiju.jose@huawei.com>
 <78d11760-bb43-42a1-a302-3e2d3bf40c48@os.amperecomputing.com>
In-Reply-To: <78d11760-bb43-42a1-a302-3e2d3bf40c48@os.amperecomputing.com>
Accept-Language: en-GB, en-US
Content-Language: en-US
X-MS-Has-Attach: 
X-MS-TNEF-Correlator: 
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: base64
Precedence: bulk
X-Mailing-List: linux-kernel@vger.kernel.org
List-Id: <linux-kernel.vger.kernel.org>
List-Subscribe: <mailto:linux-kernel+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:linux-kernel+unsubscribe@vger.kernel.org>
MIME-Version: 1.0

SGkgRGFuaWVsLA0KDQo+LS0tLS1PcmlnaW5hbCBNZXNzYWdlLS0tLS0NCj5Gcm9tOiBEYW5pZWwg
RmVyZ3Vzb24gPGRhbmllbGZAb3MuYW1wZXJlY29tcHV0aW5nLmNvbT4NCj5TZW50OiAyOCBNYXJj
aCAyMDI0IDIzOjQyDQo+VG86IFNoaWp1IEpvc2UgPHNoaWp1Lmpvc2VAaHVhd2VpLmNvbT47IGxp
bnV4LWN4bEB2Z2VyLmtlcm5lbC5vcmc7IGxpbnV4LQ0KPmFjcGlAdmdlci5rZXJuZWwub3JnOyBs
aW51eC1tbUBrdmFjay5vcmc7IGRhbi5qLndpbGxpYW1zQGludGVsLmNvbTsNCj5kYXZlQHN0Z29s
YWJzLm5ldDsgSm9uYXRoYW4gQ2FtZXJvbiA8am9uYXRoYW4uY2FtZXJvbkBodWF3ZWkuY29tPjsN
Cj5kYXZlLmppYW5nQGludGVsLmNvbTsgYWxpc29uLnNjaG9maWVsZEBpbnRlbC5jb207IHZpc2hh
bC5sLnZlcm1hQGludGVsLmNvbTsNCj5pcmEud2VpbnlAaW50ZWwuY29tDQo+Q2M6IGxpbnV4LWVk
YWNAdmdlci5rZXJuZWwub3JnOyBsaW51eC1rZXJuZWxAdmdlci5rZXJuZWwub3JnOw0KPmRhdmlk
QHJlZGhhdC5jb207IFZpbGFzLlNyaWRoYXJhbkBhbWQuY29tOyBsZW8uZHVyYW5AYW1kLmNvbTsN
Cj5ZYXplbi5HaGFubmFtQGFtZC5jb207IHJpZW50amVzQGdvb2dsZS5jb207IGppYXFpeWFuQGdv
b2dsZS5jb207DQo+dG9ueS5sdWNrQGludGVsLmNvbTsgSm9uLkdyaW1tQGFtZC5jb207IGRhdmUu
aGFuc2VuQGxpbnV4LmludGVsLmNvbTsNCj5yYWZhZWxAa2VybmVsLm9yZzsgbGVuYkBrZXJuZWwu
b3JnOyBuYW95YS5ob3JpZ3VjaGlAbmVjLmNvbTsNCj5qYW1lcy5tb3JzZUBhcm0uY29tOyBqdGhv
dWdodG9uQGdvb2dsZS5jb207IHNvbWFzdW5kYXJhbS5hQGhwZS5jb207DQo+ZXJkZW1ha3Rhc0Bn
b29nbGUuY29tOyBwZ29uZGFAZ29vZ2xlLmNvbTsgZHVlbndlbkBnb29nbGUuY29tOw0KPm1pa2Uu
bWFsdmVzdHV0b0BpbnRlbC5jb207IGd0aGVsZW5AZ29vZ2xlLmNvbTsNCj53c2Nod2FydHpAYW1w
ZXJlY29tcHV0aW5nLmNvbTsgZGZlcmd1c29uQGFtcGVyZWNvbXB1dGluZy5jb207DQo+dGFueGlh
b2ZlaSA8dGFueGlhb2ZlaUBodWF3ZWkuY29tPjsgWmVuZ3RhbyAoQikgPHByaW1lLnplbmdAaGlz
aWxpY29uLmNvbT47DQo+a2FuZ2thbmcuc2hlbkBmdXR1cmV3ZWkuY29tOyB3YW5naHVpcWlhbmcg
PHdhbmdodWlxaWFuZ0BodWF3ZWkuY29tPjsNCj5MaW51eGFybSA8bGludXhhcm1AaHVhd2VpLmNv
bT47IHdic0Bvcy5hbXBlcmVjb21wdXRpbmcuY29tDQo+U3ViamVjdDogUmU6IFtSRkMgUEFUQ0gg
djcgMTIvMTJdIG1lbW9yeTogUkFTMjogQWRkIG1lbW9yeSBSQVMyIGRyaXZlcg0KPg0KPj4gKy8q
DQouLi4NCj4+ICsNCj4+ICtzdGF0aWMgaW50IHJhczJfcHJvYmUoc3RydWN0IHBsYXRmb3JtX2Rl
dmljZSAqcGRldikgew0KPj4gKwlpbnQgcmV0LCBpZDsNCj4+ICsJc3RydWN0IG1ib3hfY2xpZW50
ICpjbDsNCj4+ICsJc3RydWN0IGRldmljZSAqaHdfc2NydWJfZGV2Ow0KPj4gKwlzdHJ1Y3QgcmFz
Ml9jb250ZXh0ICpyYXMyX2N0eDsNCj4+ICsJY2hhciBzY3J1Yl9uYW1lW1JBUzJfTUFYX05BTUVf
TEVOR1RIXTsNCj4+ICsNCj4+ICsJcmFzMl9jdHggPSBkZXZtX2t6YWxsb2MoJnBkZXYtPmRldiwg
c2l6ZW9mKCpyYXMyX2N0eCksIEdGUF9LRVJORUwpOw0KPj4gKwlpZiAoIXJhczJfY3R4KQ0KPj4g
KwkJcmV0dXJuIC1FTk9NRU07DQo+PiArDQo+PiArCXJhczJfY3R4LT5kZXYgPSAmcGRldi0+ZGV2
Ow0KPj4gKwlyYXMyX2N0eC0+b3BzID0gJnJhczJfaHdfb3BzOw0KPj4gKwlzcGluX2xvY2tfaW5p
dCgmcmFzMl9jdHgtPnNwaW5sb2NrKTsNCj4+ICsJcGxhdGZvcm1fc2V0X2RydmRhdGEocGRldiwg
cmFzMl9jdHgpOw0KPj4gKw0KPj4gKwljbCA9ICZyYXMyX2N0eC0+bWJveF9jbGllbnQ7DQo+PiAr
CS8qIFJlcXVlc3QgbWFpbGJveCBjaGFubmVsICovDQo+PiArCWNsLT5kZXYgPSAmcGRldi0+ZGV2
Ow0KPj4gKwljbC0+dHhfZG9uZSA9IHJhczJfdHhfZG9uZTsNCj4+ICsJY2wtPmtub3dzX3R4ZG9u
ZSA9IHRydWU7DQo+PiArCXJhczJfY3R4LT5wY2Nfc3Vic3BhY2VfaWR4ID0gKigoaW50ICopcGRl
di0+ZGV2LnBsYXRmb3JtX2RhdGEpOw0KPj4gKwlkZXZfZGJnKCZwZGV2LT5kZXYsICJwY2Mtc3Vi
c3BhY2UtaWQ9JWRcbiIsIHJhczJfY3R4LQ0KPj5wY2Nfc3Vic3BhY2VfaWR4KTsNCj4+ICsJcmV0
ID0gcmFzMl9yZWdpc3Rlcl9wY2NfY2hhbm5lbChyYXMyX2N0eCk7DQo+DQo+SW4gb3VyIGVuYWJs
aW5nIGFjdGl2aXRpZXMsIHdlIGhhdmUgZm91bmQgYSBjaGFsbGVuZ2UgaGVyZS4NCj5PdXIgaGFy
ZHdhcmUgaGFzIGEgc2luZ2xlIFBDQyBjaGFubmVsIGNvcnJlc3BvbmRpbmcgdG8gYSBzaW5nbGUg
cGxhdGZvcm0td2lkZQ0KPnNjcnViIGludGVyZmFjZS4gVGhpcyBkcml2ZXIsIGZvbGxvd2luZyB0
aGUgQUNQSSBzcGVjLCB3aWxsIGNyZWF0ZSBhIG5ldyBzY3J1Yg0KPm5vZGUgZm9yIGVhY2ggTlVN
QSBub2RlLiBIb3dldmVyLCBmb3IgdXMsIHRoaXMgbWVhbnMgdGhhdCBlYWNoIHNjcnViIGRldmlj
ZQ0KPndpbGwgdHJ5IHRvIG1hcCB0aGUgc2FtZSBQQ0MgY2hhbm5lbCwgYW5kIHRoaXMgY2F1c2Vz
IGFuIGVycm9yLg0KDQpJcyBmYWlsaW5nIHRvIHByb2JlIGNsZWFubHkgaXMgZW5vdWdoIGZvciB5
b3VyIHBsYXRmb3JtPyAgaS5lLiBwdXQgYW55IGVycm9yIG1lc3NhZ2VzIGFzIGRldl9kYmcoKQ0K
b3Igd2hpY2hldmVyIG9uZSBjYXVzZXMgdGhpcyBwcm9ibGVtLg0KPj4gKwlpZiAocmV0IDwgMCkN
Cj4+ICsJCXJldHVybiByZXQ7DQo+PiArDQo+PiArCXJldCA9IGRldm1fYWRkX2FjdGlvbl9vcl9y
ZXNldCgmcGRldi0+ZGV2LCBkZXZtX3JhczJfcmVsZWFzZSwNCj5yYXMyX2N0eCk7DQo+PiArCWlm
IChyZXQgPCAwKQ0KPj4gKwkJcmV0dXJuIHJldDsNCj4+ICsNCj4+ICsJaWYgKHJhczJfaXNfcGF0
cm9sX3NjcnViX3N1cHBvcnQocmFzMl9jdHgpKSB7DQo+PiArCQlpZCA9IGlkYV9hbGxvYygmcmFz
Ml9pZGEsIEdGUF9LRVJORUwpOw0KPj4gKwkJaWYgKGlkIDwgMCkNCj4+ICsJCQlyZXR1cm4gaWQ7
DQo+PiArCQlyYXMyX2N0eC0+aWQgPSBpZDsNCj4+ICsJCXNucHJpbnRmKHNjcnViX25hbWUsIHNp
emVvZihzY3J1Yl9uYW1lKSwgIiVzJWQiLA0KPlJBUzJfU0NSVUIsIGlkKTsNCj4+ICsJCWRldl9z
ZXRfbmFtZSgmcGRldi0+ZGV2LCBSQVMyX0lEX0ZPUk1BVCwgaWQpOw0KPj4gKwkJaHdfc2NydWJf
ZGV2ID0gZGV2bV9zY3J1Yl9kZXZpY2VfcmVnaXN0ZXIoJnBkZXYtPmRldiwNCj5zY3J1Yl9uYW1l
LA0KPj4gKwkJCQkJCQkgIHJhczJfY3R4LA0KPiZyYXMyX3NjcnViX29wcywNCj4+ICsJCQkJCQkJ
ICAwLCBOVUxMKTsNCj4+ICsJCWlmIChQVFJfRVJSX09SX1pFUk8oaHdfc2NydWJfZGV2KSkNCj4+
ICsJCQlyZXR1cm4gUFRSX0VSUl9PUl9aRVJPKGh3X3NjcnViX2Rldik7DQo+PiArCX0NCj4+ICsJ
cmFzMl9jdHgtPnNjcnViX2RldiA9IGh3X3NjcnViX2RldjsNCj4+ICsNCj4+ICsJcmV0dXJuIDA7
DQo+PiArfQ0KPg0KVGhhbmtzLA0KU2hpanUNCg==

