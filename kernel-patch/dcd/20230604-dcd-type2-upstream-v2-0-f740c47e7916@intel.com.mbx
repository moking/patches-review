From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id C63E2EC875B
	for <linux-cxl@archiver.kernel.org>; Thu,  7 Sep 2023 21:02:12 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S229888AbjIGVCO (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Thu, 7 Sep 2023 17:02:14 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:44868 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S236325AbjIGVCO (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Thu, 7 Sep 2023 17:02:14 -0400
Received: from mout.gmx.net (mout.gmx.net [212.227.15.18])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 746B11BD0;
        Thu,  7 Sep 2023 14:02:09 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=gmx.us;
 s=s31663417; t=1694120500; x=1694725300; i=fan.ni@gmx.us;
 bh=WrB5oiToAlymIiAhWyGaU1p6lSYTjk9xAiQGH/WXI80=;
 h=X-UI-Sender-Class:Date:From:To:Cc:Subject:References:In-Reply-To;
 b=jvp7ga7QPDGkmkYBFw7d6Hsa1jN1rL21vpoyp7Nr20MfK+JJRSNqs9mdknj6rrKuylcSkX/
 ZK3soy9TmLTt0OhBryhsMplK7yHVpCDx6UwKTyxaXC1ai6rxdiQ7FlCOAzegv1YJWKOV9TAH7
 El0L0oUAqALblW94tAiVU1ySkMJcE0nHKVCVNBjlEmxsk7AWkbFgpjKvO07d+rZkpNZFwE1rr
 /WWrBhAD0yCBs3owmRAKe6ab6Cq3KRClmZsvMTuzuuuztqkLxHFGtqyg7eYrIwMDuOl1XnVsW
 eTAOE/tVrEKiNSUP8sqcsZmht0S1bIJSYDrj5kyxgxF4rW8gTbQA==
X-UI-Sender-Class: 724b4f7f-cbec-4199-ad4e-598c01a50d3a
Received: from debian ([99.13.228.231]) by mail.gmx.net (mrgmx004
 [212.227.17.184]) with ESMTPSA (Nemesis) id 1MZktZ-1qAP4O3uRb-00WjCk; Thu, 07
 Sep 2023 23:01:40 +0200
Date: Thu, 7 Sep 2023 14:01:27 -0700
From: Fan Ni <fan.ni@gmx.us>
To: Ira Weiny <ira.weiny@intel.com>
Cc: Dan Williams <dan.j.williams@intel.com>,
        Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        linux-cxl@vger.kernel.org, linux-kernel@vger.kernel.org,
        a.manzanares@samsung.com, nmtadam.samsung@gmail.com,
        nifan@outlook.com
Subject: Re: [PATCH RFC v2 00/18] DCD: Add support for Dynamic Capacity
 Devices (DCD)
Message-ID: <ZPo6J3OsmD7YbYJs@debian>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
X-Provags-ID: V03:K1:pBQrDzrNcJp9ogGI8qSgQL9I//m97oj7R39Hy/5zl3Obfl5LGUb
 F2H2uNo4zPPYQ/J6AvQ27YDbHw9hgwjVxulNYfzlz4JBVxMarj1Zca4cIlRQIhGx5cJcXPO
 mYzdVxKnBWgpdoxL8qdpmXpitgD0BxhSFKG6y/pI36YRcf+HRskEWmPgsfsy9YwcwnMYEQU
 ssTbmD9vK7VIXHojLplDQ==
UI-OutboundReport: notjunk:1;M01:P0:AH+613zBNz4=;duW8UqZtLXKLDJyR3JAhwGVZNfi
 Z0ozNGXIRRxlt4fnA8M5nz1Mw8I/RRX/NfQHeFM6aYpuz6vztIzIhGa3tpAU/rI6Rz8EE/JZ9
 bYx/7+kqaRNhBKSXz4tNGRxKsgsIJYj0E4uBo6rhNNQ3vpxyJxJHR3zM/vh+/jQe+d+DM3uar
 hRJV3AtWDnxtsIdT1HA8QkN3haNdLELRCeO3LJdn8fReBIYuJcMc4nxmL7RUlBMdMHjqoPvbo
 /tglRR2kAChNx2K0on2FUgJEUPmtR6tlQgOpb79Om1Ovu0ntXmt3SViUSQyDfZzYGXgOOUVYi
 hR24ZZd9nTelak61aXJUWEJG3gAh5XJy1l4KXJ1NX2tSKdyY7bxKzB42U+A9Oyrip+CWl3YD1
 /82GCSoR5Gtf24Pt2af2ADREG1uROKH6qpmaDyTHv6X3jF7XkUNPlY+QAVZDE3lEtKMpZFTyt
 5k6kdV9R1WT575Nm0opV3OdSSg0QQXiJbzUDzcPIbXCVDZhGy0syLuy3LggOGx8Z0h4wJWXzc
 XtZ+5Mfkwvk2hqqjGuwKPe3k4Y6K9Xmv9L4MRx9bip9Oj8qrZ+sd2au8ttlYYa+B2AZxf32oU
 hg+v5Iafda16F/dCVLcSaHgP7CXanDFG5ytJy0hgDQcddkcagfVcEPCk78STUGEI2VbJMDWOx
 JOJJHx8w/J/+L3thuydmsdjkfyejJH8K2+yDQZ1/PLOFAwzn34FkXaDUa3hiXaBgYojobuoGq
 +Jg2hheC6RMrFcLTjMq0QDgd+ASi8mxYxE6m2j8KjrrFQyFSFdvP8ywDEZ0V4bSSZadUqSryy
 7iEThug/NWaA2YwNE6lOtk57eDFNTRdC5KeLvD/acwOgiEUSZCe2BWHiT+sgvyIjqtGFkAqZi
 kaUuQPyInEYUP4yztLOyxOaAjpz9Kq+1Mg3qV1/eenYLceZVcm1DB3EjT2zEDV3DK/nK4MyVf
 a1XjGHZ3R+vRgdAIyNf5pRJal6E=
Content-Transfer-Encoding: quoted-printable
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

On Mon, Aug 28, 2023 at 10:20:51PM -0700, Ira Weiny wrote:
> A Dynamic Capacity Device (DCD) (CXL 3.0 spec 9.13.3) is a CXL memory
> device that implements dynamic capacity.  Dynamic capacity feature
> allows memory capacity to change dynamically, without the need for
> resetting the device.
>
> Even though this is marked v2 by b4, this is effectively a whole new
> series for DCD support.  Quite a bit of the core support was completed
> by Navneet in [4].  However, the architecture through the CXL region,
> DAX region, and DAX Device layers is completely different.  Particular
> attention was paid to:
>
> 	1) managing skip resources in the hardware device
> 	2) ensuring the host OS only sent a release memory mailbox
> 	   response when all DAX devices are done using an extent
> 	3) allowing dax devices to span extents
> 	4) allowing dax devices to use parts of extents
>
> I could say all of the review comments from v1 are addressed but frankly
> the series has changed so much that I can't guarantee anything.
>
> The series continues to be based on the type-2 work posted from Dan.[2]
> However, my branch with that work is a bit dated.  Therefore I have
> posted this series on github here.[5]
>
> Testing was sped up with cxl-test and ndctl dcd support.  A preview of
> that work is on github.[6]  In addition Fan Ni's Qemu DCD series was
> used part of the time.[3]
>
> The major parts of this series are:
>
> - Get the dynamic capacity (DC) region information from cxl device
> - Configure device DC regions reported by hardware
> - Enhance CXL and DAX regions for DC
> 	a. maintain separation between the hardware extents and the CXL
> 	   region extents to provide for the addition of interleaving in
> 	   the future.
> - Get and maintain the hardware extent lists for each device via an
>   initial extent list and DC event records
>         a. Add capacity Events
> 	b. Add capacity response
> 	b. Release capacity events
> 	d. Release capacity response
> - Notify region layers of extent changes
> - Allow for DAX devices to be created on extents which are surfaced
> - Maintain references on extents which are in use
> 	a. Send Release capacity Response only when DAX devices are not
> 	   using memory
> - Allow DAX region extent labels to change to allow for flexibility in
>   DAX device creation in the future (further enhancements are required
>   to ndctl for this)
> - Trace Dynamic Capacity events
> - Add cxl-test infrastructure to allow for faster unit testing
>
> To: Dan Williams <dan.j.williams@intel.com>
> Cc: Navneet Singh <navneet.singh@intel.com>
> Cc: Fan Ni <fan.ni@samsung.com>
> Cc: Jonathan Cameron <Jonathan.Cameron@huawei.com>
> Cc: Davidlohr Bueso <dave@stgolabs.net>
> Cc: Dave Jiang <dave.jiang@intel.com>
> Cc: Alison Schofield <alison.schofield@intel.com>
> Cc: Vishal Verma <vishal.l.verma@intel.com>
> Cc: Ira Weiny <ira.weiny@intel.com>
> Cc: linux-cxl@vger.kernel.org
> Cc: linux-kernel@vger.kernel.org
>
> [1] https://lore.kernel.org/all/64326437c1496_934b2949f@dwillia2-mobl3.a=
mr.corp.intel.com.notmuch/
> [2] https://lore.kernel.org/all/168592149709.1948938.8663425987110396027=
.stgit@dwillia2-xfh.jf.intel.com/
> [3] https://lore.kernel.org/all/6483946e8152f_f1132294a2@iweiny-mobl.not=
much/
> [4] https://lore.kernel.org/r/20230604-dcd-type2-upstream-v1-0-71b6341ba=
e54@intel.com
> [5] https://github.com/weiny2/linux-kernel/commits/dcd-v2-2023-08-28
> [6] https://github.com/weiny2/ndctl/tree/dcd-region2
>

Hi Ira,

I tried to test the patch series with the qemu dcd patches, however, I
hit some issues, and would like to check the following with you.

1. After we create a region for DC before any extents are added, a dax
device will show under /dev. Is that what we want? If I remember it
correctly, the dax device used to show up after a dc extent is added.


2. add/release extent does not work correctly for me. The code path is
not called, and I made the following changes to make it pass.
=2D--
 drivers/cxl/cxl.h    | 3 ++-
 drivers/cxl/cxlmem.h | 1 +
 drivers/cxl/pci.c    | 7 +++++++
 3 files changed, 10 insertions(+), 1 deletion(-)

diff --git a/drivers/cxl/cxl.h b/drivers/cxl/cxl.h
index 2c73a30980b6..0d132c1739ce 100644
=2D-- a/drivers/cxl/cxl.h
+++ b/drivers/cxl/cxl.h
@@ -168,7 +168,8 @@ static inline int ways_to_eiw(unsigned int ways, u8 *e=
iw)
 #define CXLDEV_EVENT_STATUS_ALL (CXLDEV_EVENT_STATUS_INFO |	\
 				 CXLDEV_EVENT_STATUS_WARN |	\
 				 CXLDEV_EVENT_STATUS_FAIL |	\
-				 CXLDEV_EVENT_STATUS_FATAL)
+				 CXLDEV_EVENT_STATUS_FATAL| \
+				 CXLDEV_EVENT_STATUS_DCD)

 /* CXL rev 3.0 section 8.2.9.2.4; Table 8-52 */
 #define CXLDEV_EVENT_INT_MODE_MASK	GENMASK(1, 0)
diff --git a/drivers/cxl/cxlmem.h b/drivers/cxl/cxlmem.h
index 8ca81fd067c2..ae9dcb291c75 100644
=2D-- a/drivers/cxl/cxlmem.h
+++ b/drivers/cxl/cxlmem.h
@@ -235,6 +235,7 @@ struct cxl_event_interrupt_policy {
 	u8 warn_settings;
 	u8 failure_settings;
 	u8 fatal_settings;
+	u8 dyncap_settings;
 } __packed;

 /**
diff --git a/drivers/cxl/pci.c b/drivers/cxl/pci.c
index 10c1a583113c..e30fe0304514 100644
=2D-- a/drivers/cxl/pci.c
+++ b/drivers/cxl/pci.c
@@ -686,6 +686,7 @@ static int cxl_event_config_msgnums(struct cxl_memdev_=
state *mds,
 		.warn_settings =3D CXL_INT_MSI_MSIX,
 		.failure_settings =3D CXL_INT_MSI_MSIX,
 		.fatal_settings =3D CXL_INT_MSI_MSIX,
+		.dyncap_settings =3D CXL_INT_MSI_MSIX,
 	};

 	mbox_cmd =3D (struct cxl_mbox_cmd) {
@@ -739,6 +740,12 @@ static int cxl_event_irqsetup(struct cxl_memdev_state=
 *mds)
 		return rc;
 	}

+	rc =3D cxl_event_req_irq(cxlds, policy.dyncap_settings);
+	if (rc) {
+		dev_err(cxlds->dev, "Failed to get interrupt for event dyncap log\n");
+		return rc;
+	}
+
 	return 0;
 }

=2D-

3. With changes made in 2, the code for add/release dc extent can be calle=
d,
however, the system behaviour seems different from before. Previously, aft=
er a
dc extent is added, it will show up with lsmem command and listed as offli=
ne.
Now, nothing is showing. Is it expected? What should we do to make it usab=
le
as system ram?

Please let me know if I miss something or did something wrong. Thanks.

Fan



> ---
> Changes in v2:
> - iweiny: Complete rework of the entire series
> - Link to v1: https://lore.kernel.org/r/20230604-dcd-type2-upstream-v1-0=
-71b6341bae54@intel.com
>
> ---
> Ira Weiny (15):
>       cxl/hdm: Debug, use decoder name function
>       cxl/mbox: Flag support for Dynamic Capacity Devices (DCD)
>       cxl/region: Add Dynamic Capacity decoder and region modes
>       cxl/port: Add Dynamic Capacity mode support to endpoint decoders
>       cxl/port: Add Dynamic Capacity size support to endpoint decoders
>       cxl/region: Add Dynamic Capacity CXL region support
>       cxl/mem: Read extents on memory device discovery
>       cxl/mem: Handle DCD add and release capacity events.
>       cxl/region: Expose DC extents on region driver load
>       cxl/region: Notify regions of DC changes
>       dax/bus: Factor out dev dax resize logic
>       dax/region: Support DAX device creation on dynamic DAX regions
>       tools/testing/cxl: Make event logs dynamic
>       tools/testing/cxl: Add DC Regions to mock mem data
>       tools/testing/cxl: Add Dynamic Capacity events
>
> Navneet Singh (3):
>       cxl/mem: Read Dynamic capacity configuration from the device
>       cxl/mem: Expose device dynamic capacity configuration
>       cxl/mem: Trace Dynamic capacity Event Record
>
>  Documentation/ABI/testing/sysfs-bus-cxl |  56 ++-
>  drivers/cxl/core/core.h                 |   1 +
>  drivers/cxl/core/hdm.c                  | 215 ++++++++-
>  drivers/cxl/core/mbox.c                 | 646 +++++++++++++++++++++++++=
-
>  drivers/cxl/core/memdev.c               |  77 ++++
>  drivers/cxl/core/port.c                 |  19 +
>  drivers/cxl/core/region.c               | 418 +++++++++++++++--
>  drivers/cxl/core/trace.h                |  65 +++
>  drivers/cxl/cxl.h                       |  99 +++-
>  drivers/cxl/cxlmem.h                    | 138 +++++-
>  drivers/cxl/mem.c                       |  50 ++
>  drivers/cxl/pci.c                       |   8 +
>  drivers/dax/Makefile                    |   1 +
>  drivers/dax/bus.c                       | 263 ++++++++---
>  drivers/dax/bus.h                       |   1 +
>  drivers/dax/cxl.c                       | 213 ++++++++-
>  drivers/dax/dax-private.h               |  61 +++
>  drivers/dax/extent.c                    | 133 ++++++
>  tools/testing/cxl/test/mem.c            | 782 +++++++++++++++++++++++++=
++-----
>  19 files changed, 3005 insertions(+), 241 deletions(-)
> ---
> base-commit: c76cce37fb6f3796e8e146677ba98d3cca30a488
> change-id: 20230604-dcd-type2-upstream-0cd15f6216fd
>
> Best regards,
> --
> Ira Weiny <ira.weiny@intel.com>
>

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 2A0C2C83F2D
	for <linux-cxl@archiver.kernel.org>; Tue, 29 Aug 2023 05:24:59 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S235653AbjH2FYa (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 29 Aug 2023 01:24:30 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:40518 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S235671AbjH2FYQ (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 29 Aug 2023 01:24:16 -0400
Received: from mgamail.intel.com (mgamail.intel.com [134.134.136.100])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 66E8F19A;
        Mon, 28 Aug 2023 22:24:13 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1693286653; x=1724822653;
  h=from:date:subject:mime-version:content-transfer-encoding:
   message-id:references:in-reply-to:to:cc;
  bh=gXP5WNC2Pz15a9wrwWj55+o/I74sM3AzpaZcdl3sK2Y=;
  b=DbbqSL2YMa+ZGHskeVJVYdi+v4y5YPS90nwdcPYSjO6yAt6PJssEOOq+
   2x1Nwi6gDVTfOlveksx+uRBwRm026xOfzcgYXvTLyJJcZrGWsfmnzBoov
   2RAYg4xZhsPME2Hyt93UAIJisJ58BZu7BuOUhhWYMEpBTb/TQ4dNozAHw
   JRxaBfpGh0QRutJKzh7Ny+A3SfXuyIjWMlKypzB1/Cq8+miuOODqLU2B2
   EX/kr/ZVdXRQeZiaj4NoJkiZCJWQwBj2soeRLpcwW3CGSg2ldrT70lNI0
   5VtRGNCklL+FivE086I4geCYIN+8T3SMYNUKjWJC6YJ28Mc5jQW1ty49G
   Q==;
X-IronPort-AV: E=McAfee;i="6600,9927,10816"; a="441625263"
X-IronPort-AV: E=Sophos;i="6.02,208,1688454000"; 
   d="scan'208";a="441625263"
Received: from orsmga002.jf.intel.com ([10.7.209.21])
  by orsmga105.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 28 Aug 2023 22:23:51 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10816"; a="738556456"
X-IronPort-AV: E=Sophos;i="6.02,208,1688454000"; 
   d="scan'208";a="738556456"
Received: from iweiny-mobl.amr.corp.intel.com (HELO localhost) ([10.212.37.183])
  by orsmga002-auth.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 28 Aug 2023 22:23:52 -0700
From: Ira Weiny <ira.weiny@intel.com>
Date: Mon, 28 Aug 2023 22:21:08 -0700
Subject: [PATCH RFC v2 17/18] tools/testing/cxl: Add DC Regions to mock mem
 data
MIME-Version: 1.0
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: 7bit
Message-Id: <20230604-dcd-type2-upstream-v2-17-f740c47e7916@intel.com>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
In-Reply-To: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
To: Dan Williams <dan.j.williams@intel.com>
Cc: Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        Ira Weiny <ira.weiny@intel.com>, linux-cxl@vger.kernel.org,
        linux-kernel@vger.kernel.org
X-Mailer: b4 0.13-dev-c6835
X-Developer-Signature: v=1; a=ed25519-sha256; t=1693286608; l=15596;
 i=ira.weiny@intel.com; s=20221211; h=from:subject:message-id;
 bh=gXP5WNC2Pz15a9wrwWj55+o/I74sM3AzpaZcdl3sK2Y=;
 b=3ciiFjVHvCsyEd7gsv0ErxgF8LKYmsxZabyDaty18pH0sLTWtur0fsK1igLHo2UaGk3tDwVbY
 ZiqlzPOQyOKBy7IwLF6VS9IPVrBp36aAoErG7z7q4humBmJ3Ez6wKDT
X-Developer-Key: i=ira.weiny@intel.com; a=ed25519;
 pk=noldbkG+Wp1qXRrrkfY1QJpDf7QsOEthbOT7vm0PqsE=
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

To test DC regions the mock memory devices will need to store
information about the regions and manage fake extent data.

Define mock_dc_region information within the mock memory data.  Add
sysfs entries on the mock device to inject and delete extents.

The inject format is <start>:<length>:<tag>
The delete format is <start>

Add DC mailbox commands to the CEL and implement those commands.

Signed-off-by: Ira Weiny <ira.weiny@intel.com>
---
 tools/testing/cxl/test/mem.c | 449 +++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 449 insertions(+)

diff --git a/tools/testing/cxl/test/mem.c b/tools/testing/cxl/test/mem.c
index 6a036c8d215d..d6041a2145c5 100644
--- a/tools/testing/cxl/test/mem.c
+++ b/tools/testing/cxl/test/mem.c
@@ -18,6 +18,7 @@
 #define FW_SLOTS 3
 #define DEV_SIZE SZ_2G
 #define EFFECT(x) (1U << x)
+#define BASE_DYNAMIC_CAP_DPA DEV_SIZE
 
 #define MOCK_INJECT_DEV_MAX 8
 #define MOCK_INJECT_TEST_MAX 128
@@ -89,6 +90,22 @@ static struct cxl_cel_entry mock_cel[] = {
 		.effect = cpu_to_le16(EFFECT(CONF_CHANGE_COLD_RESET) |
 				      EFFECT(CONF_CHANGE_IMMEDIATE)),
 	},
+	{
+		.opcode = cpu_to_le16(CXL_MBOX_OP_GET_DC_CONFIG),
+		.effect = CXL_CMD_EFFECT_NONE,
+	},
+	{
+		.opcode = cpu_to_le16(CXL_MBOX_OP_GET_DC_EXTENT_LIST),
+		.effect = CXL_CMD_EFFECT_NONE,
+	},
+	{
+		.opcode = cpu_to_le16(CXL_MBOX_OP_ADD_DC_RESPONSE),
+		.effect = cpu_to_le16(EFFECT(CONF_CHANGE_IMMEDIATE)),
+	},
+	{
+		.opcode = cpu_to_le16(CXL_MBOX_OP_RELEASE_DC),
+		.effect = cpu_to_le16(EFFECT(CONF_CHANGE_IMMEDIATE)),
+	},
 };
 
 /* See CXL 2.0 Table 181 Get Health Info Output Payload */
@@ -147,6 +164,7 @@ struct mock_event_store {
 	u32 ev_status;
 };
 
+#define NUM_MOCK_DC_REGIONS 2
 struct cxl_mockmem_data {
 	void *lsa;
 	void *fw;
@@ -161,6 +179,10 @@ struct cxl_mockmem_data {
 	struct mock_event_store mes;
 	u8 event_buf[SZ_4K];
 	u64 timestamp;
+	struct cxl_dc_region_config dc_regions[NUM_MOCK_DC_REGIONS];
+	u32 dc_ext_generation;
+	struct xarray dc_extents;
+	struct xarray dc_accepted_exts;
 };
 
 static struct mock_event_log *event_find_log(struct device *dev, int log_type)
@@ -529,6 +551,98 @@ static void cxl_mock_event_trigger(struct device *dev)
 	cxl_mem_get_event_records(mes->mds, mes->ev_status);
 }
 
+static int devm_add_extent(struct device *dev, u64 start, u64 length,
+			   const char *tag)
+{
+	struct cxl_mockmem_data *mdata = dev_get_drvdata(dev);
+	struct cxl_dc_extent_data *extent;
+
+	extent = devm_kzalloc(dev, sizeof(*extent), GFP_KERNEL);
+	if (!extent) {
+		dev_dbg(dev, "Failed to allocate extent\n");
+		return -ENOMEM;
+	}
+	extent->dpa_start = start;
+	extent->length = length;
+	memcpy(extent->tag, tag, min(sizeof(extent->tag), strlen(tag)));
+
+	if (xa_insert(&mdata->dc_extents, start, extent, GFP_KERNEL)) {
+		devm_kfree(dev, extent);
+		dev_err(dev, "Failed xarry insert %llx\n", start);
+		return -EINVAL;
+	}
+	mdata->dc_ext_generation++;
+
+	return 0;
+}
+
+static int dc_accept_extent(struct device *dev, u64 start)
+{
+	struct cxl_mockmem_data *mdata = dev_get_drvdata(dev);
+
+	dev_dbg(dev, "Accepting extent 0x%llx\n", start);
+	return xa_insert(&mdata->dc_accepted_exts, start, (void *)start,
+			 GFP_KERNEL);
+}
+
+static void release_dc_ext(void *md)
+{
+	struct cxl_mockmem_data *mdata = md;
+
+	xa_destroy(&mdata->dc_extents);
+	xa_destroy(&mdata->dc_accepted_exts);
+}
+
+static int cxl_mock_dc_region_setup(struct device *dev)
+{
+#define DUMMY_EXT_OFFSET SZ_256M
+#define DUMMY_EXT_LENGTH SZ_256M
+	struct cxl_mockmem_data *mdata = dev_get_drvdata(dev);
+	u64 base_dpa = BASE_DYNAMIC_CAP_DPA;
+	u32 dsmad_handle = 0xFADE;
+	u64 decode_length = SZ_2G;
+	u64 block_size = SZ_512;
+	/* For testing make this smaller than decode length */
+	u64 length = SZ_1G;
+	int rc;
+
+	xa_init(&mdata->dc_extents);
+	xa_init(&mdata->dc_accepted_exts);
+
+	rc = devm_add_action_or_reset(dev, release_dc_ext, mdata);
+	if (rc)
+		return rc;
+
+	for (int i = 0; i < NUM_MOCK_DC_REGIONS; i++) {
+		struct cxl_dc_region_config *conf = &mdata->dc_regions[i];
+
+		dev_dbg(dev, "Creating DC region DC%d DPA:%llx LEN:%llx\n",
+			i, base_dpa, length);
+
+		conf->region_base = cpu_to_le64(base_dpa);
+		conf->region_decode_length = cpu_to_le64(decode_length /
+						CXL_CAPACITY_MULTIPLIER);
+		conf->region_length = cpu_to_le64(length);
+		conf->region_block_size = cpu_to_le64(block_size);
+		conf->region_dsmad_handle = cpu_to_le32(dsmad_handle);
+		dsmad_handle++;
+
+		/* Pretend we have some previous accepted extents */
+		rc = devm_add_extent(dev, base_dpa + DUMMY_EXT_OFFSET,
+				     DUMMY_EXT_LENGTH, "CXL-TEST");
+		if (rc)
+			return rc;
+
+		rc = dc_accept_extent(dev, base_dpa + DUMMY_EXT_OFFSET);
+		if (rc)
+			return rc;
+
+		base_dpa += decode_length;
+	}
+
+	return 0;
+}
+
 static int mock_gsl(struct cxl_mbox_cmd *cmd)
 {
 	if (cmd->size_out < sizeof(mock_gsl_payload))
@@ -1315,6 +1429,148 @@ static int mock_activate_fw(struct cxl_mockmem_data *mdata,
 	return -EINVAL;
 }
 
+static int mock_get_dc_config(struct device *dev,
+			      struct cxl_mbox_cmd *cmd)
+{
+	struct cxl_mbox_get_dc_config *dc_config = cmd->payload_in;
+	struct cxl_mockmem_data *mdata = dev_get_drvdata(dev);
+	u8 region_requested, region_start_idx, region_ret_cnt;
+	struct cxl_mbox_dynamic_capacity *resp;
+
+	region_requested = dc_config->region_count;
+	if (NUM_MOCK_DC_REGIONS < region_requested)
+		region_requested = NUM_MOCK_DC_REGIONS;
+
+	if (cmd->size_out < struct_size(resp, region, region_requested))
+		return -EINVAL;
+
+	memset(cmd->payload_out, 0, cmd->size_out);
+	resp = cmd->payload_out;
+
+	region_start_idx = dc_config->start_region_index;
+	region_ret_cnt = 0;
+	for (int i = 0; i < NUM_MOCK_DC_REGIONS; i++) {
+		if (i >= region_start_idx) {
+			memcpy(&resp->region[region_ret_cnt],
+				&mdata->dc_regions[i],
+				sizeof(resp->region[region_ret_cnt]));
+			region_ret_cnt++;
+		}
+	}
+	resp->avail_region_count = region_ret_cnt;
+
+	dev_dbg(dev, "Returning %d dc regions\n", region_ret_cnt);
+	return 0;
+}
+
+
+static int mock_get_dc_extent_list(struct device *dev,
+				   struct cxl_mbox_cmd *cmd)
+{
+	struct cxl_mockmem_data *mdata = dev_get_drvdata(dev);
+	struct cxl_mbox_get_dc_extent *get = cmd->payload_in;
+	struct cxl_mbox_dc_extents *resp = cmd->payload_out;
+	u32 total_avail = 0, total_ret = 0;
+	struct cxl_dc_extent_data *ext;
+	u32 ext_count, start_idx;
+	unsigned long i;
+
+	ext_count = le32_to_cpu(get->extent_cnt);
+	start_idx = le32_to_cpu(get->start_extent_index);
+
+	memset(resp, 0, sizeof(*resp));
+
+	/*
+	 * Total available needs to be calculated and returned regardless of
+	 * how many can actually be returned.
+	 */
+	xa_for_each(&mdata->dc_extents, i, ext)
+		total_avail++;
+
+	if (start_idx > total_avail)
+		return -EINVAL;
+
+	xa_for_each(&mdata->dc_extents, i, ext) {
+		if (total_ret >= ext_count)
+			break;
+
+		if (total_ret >= start_idx) {
+			resp->extent[total_ret].start_dpa =
+						cpu_to_le64(ext->dpa_start);
+			resp->extent[total_ret].length =
+						cpu_to_le64(ext->length);
+			memcpy(&resp->extent[total_ret].tag, ext->tag,
+					sizeof(resp->extent[total_ret]));
+			resp->extent[total_ret].shared_extn_seq =
+					cpu_to_le16(ext->shared_extent_seq);
+			total_ret++;
+		}
+	}
+
+	resp->ret_extent_cnt = cpu_to_le32(total_ret);
+	resp->total_extent_cnt = cpu_to_le32(total_avail);
+	resp->extent_list_num = cpu_to_le32(mdata->dc_ext_generation);
+
+	dev_dbg(dev, "Returning %d extents of %d total\n",
+		total_ret, total_avail);
+
+	return 0;
+}
+
+static int mock_add_dc_response(struct device *dev,
+				struct cxl_mbox_cmd *cmd)
+{
+	struct cxl_mbox_dc_response *req = cmd->payload_in;
+	u32 list_size = le32_to_cpu(req->extent_list_size);
+
+	for (int i = 0; i < list_size; i++) {
+		u64 start = le64_to_cpu(req->extent_list[i].dpa_start);
+		int rc;
+
+		dev_dbg(dev, "Extent 0x%llx accepted by HOST\n", start);
+		rc = dc_accept_extent(dev, start);
+		if (rc)
+			return rc;
+	}
+
+	return 0;
+}
+
+static int dc_delete_extent(struct device *dev, unsigned long long start)
+{
+	struct cxl_mockmem_data *mdata = dev_get_drvdata(dev);
+	void *ext;
+
+	dev_dbg(dev, "Deleting extent at %llx\n", start);
+
+	ext = xa_erase(&mdata->dc_extents, start);
+	if (!ext) {
+		dev_err(dev, "No extent found at %llx\n", start);
+		return -EINVAL;
+	}
+	devm_kfree(dev, ext);
+	mdata->dc_ext_generation++;
+
+	return 0;
+}
+
+static int mock_dc_release(struct device *dev,
+			   struct cxl_mbox_cmd *cmd)
+{
+	struct cxl_mockmem_data *mdata = dev_get_drvdata(dev);
+	struct cxl_mbox_dc_response *req = cmd->payload_in;
+	u32 list_size = le32_to_cpu(req->extent_list_size);
+
+	for (int i = 0; i < list_size; i++) {
+		u64 start = le64_to_cpu(req->extent_list[i].dpa_start);
+
+		dev_dbg(dev, "Extent 0x%llx released by HOST\n", start);
+		xa_erase(&mdata->dc_accepted_exts, start);
+	}
+
+	return 0;
+}
+
 static int cxl_mock_mbox_send(struct cxl_memdev_state *mds,
 			      struct cxl_mbox_cmd *cmd)
 {
@@ -1399,6 +1655,18 @@ static int cxl_mock_mbox_send(struct cxl_memdev_state *mds,
 	case CXL_MBOX_OP_ACTIVATE_FW:
 		rc = mock_activate_fw(mdata, cmd);
 		break;
+	case CXL_MBOX_OP_GET_DC_CONFIG:
+		rc = mock_get_dc_config(dev, cmd);
+		break;
+	case CXL_MBOX_OP_GET_DC_EXTENT_LIST:
+		rc = mock_get_dc_extent_list(dev, cmd);
+		break;
+	case CXL_MBOX_OP_ADD_DC_RESPONSE:
+		rc = mock_add_dc_response(dev, cmd);
+		break;
+	case CXL_MBOX_OP_RELEASE_DC:
+		rc = mock_dc_release(dev, cmd);
+		break;
 	default:
 		break;
 	}
@@ -1467,6 +1735,10 @@ static int __cxl_mock_mem_probe(struct platform_device *pdev)
 		return -ENOMEM;
 	dev_set_drvdata(dev, mdata);
 
+	rc = cxl_mock_dc_region_setup(dev);
+	if (rc)
+		return rc;
+
 	mdata->lsa = vmalloc(LSA_SIZE);
 	if (!mdata->lsa)
 		return -ENOMEM;
@@ -1515,6 +1787,10 @@ static int __cxl_mock_mem_probe(struct platform_device *pdev)
 	if (rc)
 		return rc;
 
+	rc = cxl_dev_dynamic_capacity_identify(mds);
+	if (rc)
+		return rc;
+
 	rc = cxl_mem_create_range_info(mds);
 	if (rc)
 		return rc;
@@ -1528,6 +1804,10 @@ static int __cxl_mock_mem_probe(struct platform_device *pdev)
 	if (IS_ERR(cxlmd))
 		return PTR_ERR(cxlmd);
 
+	rc = cxl_dev_get_dynamic_capacity_extents(mds);
+	if (rc)
+		return rc;
+
 	rc = cxl_memdev_setup_fw_upload(mds);
 	if (rc)
 		return rc;
@@ -1669,10 +1949,179 @@ static ssize_t fw_buf_checksum_show(struct device *dev,
 
 static DEVICE_ATTR_RO(fw_buf_checksum);
 
+/* Returns if the proposed extent is valid */
+static bool new_extent_valid(struct device *dev, size_t new_start,
+			     size_t new_len)
+{
+	struct cxl_mockmem_data *mdata = dev_get_drvdata(dev);
+	struct cxl_dc_extent_data *extent;
+	size_t new_end, i;
+
+	if (!new_len)
+		return -EINVAL;
+
+	new_end = new_start + new_len;
+
+	dev_dbg(dev, "New extent %zx-%zx\n", new_start, new_end);
+
+	/* Overlap with other extent? */
+	xa_for_each(&mdata->dc_extents, i, extent) {
+		size_t ext_end = extent->dpa_start + extent->length;
+
+		if (extent->dpa_start <= new_start && new_start < ext_end) {
+			dev_err(dev, "Extent overlap: Start %llu ?<= %zx ?<= %zx\n",
+				extent->dpa_start, new_start, ext_end);
+			return false;
+		}
+		if (extent->dpa_start <= new_end && new_end < ext_end) {
+			dev_err(dev, "Extent overlap: End %llx ?<= %zx ?<= %zx\n",
+				extent->dpa_start, new_end, ext_end);
+			return false;
+		}
+	}
+
+	/* Ensure it is in a region and is valid for that regions block size */
+	for (int i = 0; i < NUM_MOCK_DC_REGIONS; i++) {
+		struct cxl_dc_region_config *dc_region = &mdata->dc_regions[i];
+		size_t reg_start, reg_end;
+
+		reg_start = le64_to_cpu(dc_region->region_base);
+		reg_end = le64_to_cpu(dc_region->region_length);
+		reg_end += reg_start;
+
+		dev_dbg(dev, "Region %d: %zx-%zx\n", i, reg_start, reg_end);
+
+		if (reg_start >= new_start && new_end < reg_end) {
+			u64 block_size = le64_to_cpu(dc_region->region_block_size);
+
+			if (new_start % block_size || new_len % block_size) {
+				dev_err(dev, "Extent not aligned to block size: start %zx; len %zx; block_size 0x%llx\n",
+					new_start, new_len, block_size);
+				return false;
+			}
+
+			dev_dbg(dev, "Extent in region %d\n", i);
+			return true;
+		}
+	}
+
+	return false;
+}
+
+/*
+ * Format <start>:<length>:<tag>
+ *
+ * start and length must be a multiple of the configured region block size.
+ * Tag can be any string up to 16 bytes.
+ *
+ * Extents must be exclusive of other extents
+ */
+static ssize_t dc_inject_extent_store(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf, size_t count)
+{
+	char *start_str __free(kfree) = kstrdup(buf, GFP_KERNEL);
+	unsigned long long start, length;
+	char *len_str, *tag_str;
+	size_t buf_len = count;
+	int rc;
+
+	if (!start_str)
+		return -ENOMEM;
+
+	len_str = strnchr(start_str, buf_len, ':');
+	if (!len_str) {
+		dev_err(dev, "Extent failed to find len_str: %s\n", start_str);
+		return -EINVAL;
+	}
+
+	*len_str = '\0';
+	len_str += 1;
+	buf_len -= strlen(start_str);
+
+	tag_str = strnchr(len_str, buf_len, ':');
+	if (!tag_str) {
+		dev_err(dev, "Extent failed to find tag_str: %s\n", len_str);
+		return -EINVAL;
+	}
+	*tag_str = '\0';
+	tag_str += 1;
+
+	if (kstrtoull(start_str, 0, &start)) {
+		dev_err(dev, "Extent failed to parse start: %s\n", start_str);
+		return -EINVAL;
+	}
+	if (kstrtoull(len_str, 0, &length)) {
+		dev_err(dev, "Extent failed to parse length: %s\n", len_str);
+		return -EINVAL;
+	}
+
+	if (!new_extent_valid(dev, start, length))
+		return -EINVAL;
+
+	rc = devm_add_extent(dev, start, length, tag_str);
+	if (rc)
+		return rc;
+
+	return count;
+}
+static DEVICE_ATTR_WO(dc_inject_extent);
+
+static ssize_t dc_del_extent_store(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t count)
+{
+	unsigned long long start;
+	int rc;
+
+	if (kstrtoull(buf, 0, &start)) {
+		dev_err(dev, "Extent failed to parse start value\n");
+		return -EINVAL;
+	}
+
+	rc = dc_delete_extent(dev, start);
+	if (rc)
+		return rc;
+
+	return count;
+}
+static DEVICE_ATTR_WO(dc_del_extent);
+
+static ssize_t dc_force_del_extent_store(struct device *dev,
+					 struct device_attribute *attr,
+					 const char *buf, size_t count)
+{
+	struct cxl_mockmem_data *mdata = dev_get_drvdata(dev);
+	unsigned long long start;
+	void *ext;
+	int rc;
+
+	if (kstrtoull(buf, 0, &start)) {
+		dev_err(dev, "Extent failed to parse start value\n");
+		return -EINVAL;
+	}
+
+	ext = xa_erase(&mdata->dc_accepted_exts, start);
+	if (ext)
+		dev_dbg(dev, "Forcing remove of accepted extent: %llx\n",
+			start);
+
+	dev_dbg(dev, "Forcing delete of extent at %llx\n", start);
+	rc = dc_delete_extent(dev, start);
+	if (rc)
+		return rc;
+
+	return count;
+}
+static DEVICE_ATTR_WO(dc_force_del_extent);
+
 static struct attribute *cxl_mock_mem_attrs[] = {
 	&dev_attr_security_lock.attr,
 	&dev_attr_event_trigger.attr,
 	&dev_attr_fw_buf_checksum.attr,
+	&dev_attr_dc_inject_extent.attr,
+	&dev_attr_dc_del_extent.attr,
+	&dev_attr_dc_force_del_extent.attr,
 	NULL
 };
 ATTRIBUTE_GROUPS(cxl_mock_mem);

-- 
2.41.0


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 13A46C83F2B
	for <linux-cxl@archiver.kernel.org>; Tue, 29 Aug 2023 05:24:57 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S235700AbjH2FY3 (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 29 Aug 2023 01:24:29 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:40458 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S235661AbjH2FYN (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 29 Aug 2023 01:24:13 -0400
Received: from mgamail.intel.com (mgamail.intel.com [134.134.136.100])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 5052B1A2;
        Mon, 28 Aug 2023 22:24:08 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1693286648; x=1724822648;
  h=from:date:subject:mime-version:content-transfer-encoding:
   message-id:references:in-reply-to:to:cc;
  bh=L9j5X0lgccdPeWN+ZQeF2UgiQMc67ZQrTXIG3FyDxu0=;
  b=nUVh8BiMHbglwfNwsSBHFf+fjOwpWvJXT3/tt8hDiRA2mTGqsKshExDX
   k5w1R1OuZcwikwF3ZWGWlmB4V+oTV/pLyZtbZKadSQXmYL7U3l8xyXqZp
   ngs8Rg60b6Z8o5q07+Zp4HNke5wu7KnFKtHP1eKSMDW89Z7QNaR06MyWi
   vqE8i3UbUOEvuIEpU0Evq7ol7eIsuyNYiJZTvl6iFfnF+sFFcVzXPeO3b
   8z6AeaexULud4wgoVlSC9FizAzBEQ5iMtPlIED+b8KFjk1fYeMac9rJ1S
   IWu5eaiddbEAxFdjF3aHmk6oEvjvyCATJqCsmqfirQgByiypniaYDXqGe
   g==;
X-IronPort-AV: E=McAfee;i="6600,9927,10816"; a="441625234"
X-IronPort-AV: E=Sophos;i="6.02,208,1688454000"; 
   d="scan'208";a="441625234"
Received: from orsmga002.jf.intel.com ([10.7.209.21])
  by orsmga105.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 28 Aug 2023 22:23:44 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10816"; a="738556405"
X-IronPort-AV: E=Sophos;i="6.02,208,1688454000"; 
   d="scan'208";a="738556405"
Received: from iweiny-mobl.amr.corp.intel.com (HELO localhost) ([10.212.37.183])
  by orsmga002-auth.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 28 Aug 2023 22:23:44 -0700
From: Ira Weiny <ira.weiny@intel.com>
Date: Mon, 28 Aug 2023 22:21:02 -0700
Subject: [PATCH RFC v2 11/18] cxl/region: Expose DC extents on region
 driver load
MIME-Version: 1.0
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: 7bit
Message-Id: <20230604-dcd-type2-upstream-v2-11-f740c47e7916@intel.com>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
In-Reply-To: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
To: Dan Williams <dan.j.williams@intel.com>
Cc: Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        Ira Weiny <ira.weiny@intel.com>, linux-cxl@vger.kernel.org,
        linux-kernel@vger.kernel.org
X-Mailer: b4 0.13-dev-c6835
X-Developer-Signature: v=1; a=ed25519-sha256; t=1693286607; l=22228;
 i=ira.weiny@intel.com; s=20221211; h=from:subject:message-id;
 bh=L9j5X0lgccdPeWN+ZQeF2UgiQMc67ZQrTXIG3FyDxu0=;
 b=CMYAWsIpguIElaVdjBIZnW8pv+vIcI186e3PfVpVQjSKj3bleCle3Dl/SfMDqHu4Jiqx1S0jq
 14UN1ISesmMAYXbYpCuMZ6d81o3exc+Fw6pxhjuKHajdS6esOIbTduv
X-Developer-Key: i=ira.weiny@intel.com; a=ed25519;
 pk=noldbkG+Wp1qXRrrkfY1QJpDf7QsOEthbOT7vm0PqsE=
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

Ultimately user space must associate Dynamic Capacity (DC) extents with
DAX devices.  Remember also that DCD extents may have been accepted
previous to regions being created and must have references held until
all higher level regions and DAX devices are done with the memory.

On CXL region driver load scan existing device extents and create CXL
DAX region extents as needed.

Create abstractions for the extents to be used in DAX region.  This
includes a generic interface to take proper references on the lower
level CXL region extents.

Also maintain separate objects for the DAX region extent device vs the
DAX region extent.  The DAX region extent device has a shorter life span
which corresponds to the removal of an extent while a DAX device is
still using it.  In this case an extent continues to exist whilst the
ability to create new DAX devices on that extent is prevented.

NOTE: Without interleaving; the device, CXL region, and DAX region
extents have a 1:1:1 relationship.  Future support for interleaving will
maintain a 1:N relationship between CXL region extents and the hardware
extents.

While the ability to create DAX devices on an extent exists; expose the
necessary details of DAX region extents by creating a device with the
following sysfs entries.

/sys/bus/cxl/devices/dax_regionX/extentY
/sys/bus/cxl/devices/dax_regionX/extentY/length
/sys/bus/cxl/devices/dax_regionX/extentY/label

Label is a rough analogy to the DC extent tag.  As such the DC extent
tag is used to initially populate the label.  However, the label is made
writeable so that it can be adjusted in the future when forming a DAX
device.

Signed-off-by: Navneet Singh <navneet.singh@intel.com>
Co-developed-by: Navneet Singh <navneet.singh@intel.com>
Signed-off-by: Ira Weiny <ira.weiny@intel.com>

---
Changes from v1
[iweiny: move dax_region_extents to dax layer]
[iweiny: adjust for kreference of extents]
[iweiny: adjust naming to cxl_dr_extent]
[iweiny: Remove region_extent xarray; use child devices instead]
[iweiny: ensure dax region devices are destroyed on region destruction]
[iweiny: use xa_insert]
[iweiny: hpa_offset is a dr_extent parameter not an extent parameter]
[iweiny: Add dc_region_extents when the region driver is loaded]
---
 drivers/cxl/core/mbox.c   |  12 ++++
 drivers/cxl/core/region.c | 179 ++++++++++++++++++++++++++++++++++++++++++++--
 drivers/cxl/cxl.h         |  16 +++++
 drivers/cxl/cxlmem.h      |   2 +
 drivers/dax/Makefile      |   1 +
 drivers/dax/cxl.c         | 101 ++++++++++++++++++++++++--
 drivers/dax/dax-private.h |  53 ++++++++++++++
 drivers/dax/extent.c      | 119 ++++++++++++++++++++++++++++++
 8 files changed, 473 insertions(+), 10 deletions(-)

diff --git a/drivers/cxl/core/mbox.c b/drivers/cxl/core/mbox.c
index 8474a28b16ca..5472ab1d0370 100644
--- a/drivers/cxl/core/mbox.c
+++ b/drivers/cxl/core/mbox.c
@@ -1055,6 +1055,18 @@ static void dc_extent_release(struct kref *kref)
 	kfree(extent);
 }
 
+int __must_check cxl_dc_extent_get_not_zero(struct cxl_dc_extent_data *extent)
+{
+	return kref_get_unless_zero(&extent->region_ref);
+}
+EXPORT_SYMBOL_NS_GPL(cxl_dc_extent_get_not_zero, CXL);
+
+void cxl_dc_extent_get(struct cxl_dc_extent_data *extent)
+{
+	kref_get(&extent->region_ref);
+}
+EXPORT_SYMBOL_NS_GPL(cxl_dc_extent_get, CXL);
+
 void cxl_dc_extent_put(struct cxl_dc_extent_data *extent)
 {
 	kref_put(&extent->region_ref, dc_extent_release);
diff --git a/drivers/cxl/core/region.c b/drivers/cxl/core/region.c
index fc8dee469244..0aeea50550f6 100644
--- a/drivers/cxl/core/region.c
+++ b/drivers/cxl/core/region.c
@@ -1547,6 +1547,122 @@ static int cxl_region_validate_position(struct cxl_region *cxlr,
 	return 0;
 }
 
+static bool cxl_dc_extent_in_ed(struct cxl_endpoint_decoder *cxled,
+				struct cxl_dc_extent_data *extent)
+{
+	struct range dpa_range = (struct range){
+		.start = extent->dpa_start,
+		.end = extent->dpa_start + extent->length - 1,
+	};
+	struct device *dev = &cxled->cxld.dev;
+
+	dev_dbg(dev, "Checking extent DPA:%llx LEN:%llx\n",
+		extent->dpa_start, extent->length);
+
+	if (!cxled->cxld.region || !cxled->dpa_res)
+		return false;
+
+	dev_dbg(dev, "Cxled start:%llx end:%llx\n",
+		cxled->dpa_res->start, cxled->dpa_res->end);
+	return (cxled->dpa_res->start <= dpa_range.start &&
+		dpa_range.end <= cxled->dpa_res->end);
+}
+
+static int cxl_ed_add_one_extent(struct cxl_endpoint_decoder *cxled,
+				 struct cxl_dc_extent_data *extent)
+{
+	struct cxl_dr_extent *cxl_dr_ext;
+	struct cxl_dax_region *cxlr_dax;
+	resource_size_t dpa_offset, hpa;
+	struct range *ed_hpa_range;
+	struct device *dev;
+	int rc;
+
+	cxlr_dax = cxled->cxld.region->cxlr_dax;
+	dev = &cxlr_dax->dev;
+	dev_dbg(dev, "Adding DC extent DPA:%llx LEN:%llx\n",
+		extent->dpa_start, extent->length);
+
+	/*
+	 * Interleave ways == 1 means this coresponds to a 1:1 mapping between
+	 * device extents and DAX region extents.  Future implementations
+	 * should hold DC region extents here until the full dax region extent
+	 * can be realized.
+	 */
+	if (cxlr_dax->cxlr->params.interleave_ways != 1) {
+		dev_err(dev, "Interleaving DC not supported\n");
+		return -EINVAL;
+	}
+
+	cxl_dr_ext = kzalloc(sizeof(*cxl_dr_ext), GFP_KERNEL);
+	if (!cxl_dr_ext)
+		return -ENOMEM;
+
+	cxl_dr_ext->extent = extent;
+	kref_init(&cxl_dr_ext->region_ref);
+
+	/*
+	 * Without interleave...
+	 * HPA offset == DPA offset
+	 * ... but do the math anyway
+	 */
+	dpa_offset = extent->dpa_start - cxled->dpa_res->start;
+	ed_hpa_range = &cxled->cxld.hpa_range;
+	hpa = ed_hpa_range->start + dpa_offset;
+	cxl_dr_ext->hpa_offset = hpa - cxlr_dax->hpa_range.start;
+
+	/* Without interleave carry length and label through */
+	cxl_dr_ext->hpa_length = extent->length;
+	snprintf(cxl_dr_ext->label, CXL_EXTENT_LABEL_LEN, "%s",
+		 extent->tag);
+
+	dev_dbg(dev, "Inserting at HPA:%llx\n", cxl_dr_ext->hpa_offset);
+	rc = xa_insert(&cxlr_dax->extents, cxl_dr_ext->hpa_offset, cxl_dr_ext,
+		       GFP_KERNEL);
+	if (rc) {
+		dev_err(dev, "Failed to insert extent %d\n", rc);
+		kfree(cxl_dr_ext);
+		return rc;
+	}
+	/* Put in cxl_dr_release() */
+	cxl_dc_extent_get(cxl_dr_ext->extent);
+	return 0;
+}
+
+static int cxl_ed_add_extents(struct cxl_endpoint_decoder *cxled)
+{
+	struct cxl_memdev *cxlmd = cxled_to_memdev(cxled);
+	struct cxl_dev_state *cxlds = cxlmd->cxlds;
+	struct cxl_memdev_state *mds = container_of(cxlds,
+						    struct cxl_memdev_state,
+						    cxlds);
+	struct device *dev = &cxled->cxld.dev;
+	struct cxl_dc_extent_data *extent;
+	unsigned long index;
+
+	dev_dbg(dev, "Searching for DC extents\n");
+	xa_for_each(&mds->dc_extent_list, index, extent) {
+		/*
+		 * get not zero is important because this is racing with the
+		 * memory device which could be removing the extent at the same
+		 * time.
+		 */
+		if (cxl_dc_extent_get_not_zero(extent)) {
+			int rc = 0;
+
+			if (cxl_dc_extent_in_ed(cxled, extent)) {
+				dev_dbg(dev, "Found extent DPA:%llx LEN:%llx\n",
+					extent->dpa_start, extent->length);
+				rc = cxl_ed_add_one_extent(cxled, extent);
+			}
+			cxl_dc_extent_put(extent);
+			if (rc)
+				return rc;
+		}
+	}
+	return 0;
+}
+
 static int cxl_region_attach_position(struct cxl_region *cxlr,
 				      struct cxl_root_decoder *cxlrd,
 				      struct cxl_endpoint_decoder *cxled,
@@ -2702,10 +2818,44 @@ static struct cxl_pmem_region *cxl_pmem_region_alloc(struct cxl_region *cxlr)
 	return cxlr_pmem;
 }
 
+int __must_check cxl_dr_extent_get_not_zero(struct cxl_dr_extent *cxl_dr_ext)
+{
+	return kref_get_unless_zero(&cxl_dr_ext->region_ref);
+}
+EXPORT_SYMBOL_NS_GPL(cxl_dr_extent_get_not_zero, CXL);
+
+void cxl_dr_extent_get(struct cxl_dr_extent *cxl_dr_ext)
+{
+	return kref_get(&cxl_dr_ext->region_ref);
+}
+EXPORT_SYMBOL_NS_GPL(cxl_dr_extent_get, CXL);
+
+static void cxl_dr_release(struct kref *kref)
+{
+	struct cxl_dr_extent *cxl_dr_ext = container_of(kref,
+						struct cxl_dr_extent,
+						region_ref);
+
+	cxl_dc_extent_put(cxl_dr_ext->extent);
+	kfree(cxl_dr_ext);
+}
+
+void cxl_dr_extent_put(struct cxl_dr_extent *cxl_dr_ext)
+{
+	kref_put(&cxl_dr_ext->region_ref, cxl_dr_release);
+}
+EXPORT_SYMBOL_NS_GPL(cxl_dr_extent_put, CXL);
+
 static void cxl_dax_region_release(struct device *dev)
 {
 	struct cxl_dax_region *cxlr_dax = to_cxl_dax_region(dev);
+	struct cxl_dr_extent *cxl_dr_ext;
+	unsigned long index;
 
+	xa_for_each(&cxlr_dax->extents, index, cxl_dr_ext) {
+		xa_erase(&cxlr_dax->extents, index);
+		cxl_dr_extent_put(cxl_dr_ext);
+	}
 	kfree(cxlr_dax);
 }
 
@@ -2756,6 +2906,7 @@ static struct cxl_dax_region *cxl_dax_region_alloc(struct cxl_region *cxlr)
 
 	cxlr_dax->hpa_range.start = p->res->start;
 	cxlr_dax->hpa_range.end = p->res->end;
+	xa_init(&cxlr_dax->extents);
 
 	dev = &cxlr_dax->dev;
 	cxlr_dax->cxlr = cxlr;
@@ -2862,7 +3013,17 @@ static void cxlr_dax_unregister(void *_cxlr_dax)
 	device_unregister(&cxlr_dax->dev);
 }
 
-static int __devm_cxl_add_dax_region(struct cxl_region *cxlr)
+static int cxl_region_add_dc_extents(struct cxl_region *cxlr)
+{
+	for (int i = 0; i < cxlr->params.nr_targets; i++) {
+		int rc = cxl_ed_add_extents(cxlr->params.targets[i]);
+		if (rc)
+			return rc;
+	}
+	return 0;
+}
+
+static int __devm_cxl_add_dax_region(struct cxl_region *cxlr, bool is_dc)
 {
 	struct cxl_dax_region *cxlr_dax;
 	struct device *dev;
@@ -2877,6 +3038,17 @@ static int __devm_cxl_add_dax_region(struct cxl_region *cxlr)
 	if (rc)
 		goto err;
 
+	cxlr->cxlr_dax = cxlr_dax;
+	if (is_dc) {
+		/*
+		 * Process device extents prior to surfacing the device to
+		 * ensure the cxl_dax_region driver has access to prior extents
+		 */
+		rc = cxl_region_add_dc_extents(cxlr);
+		if (rc)
+			goto err;
+	}
+
 	rc = device_add(dev);
 	if (rc)
 		goto err;
@@ -2893,7 +3065,7 @@ static int __devm_cxl_add_dax_region(struct cxl_region *cxlr)
 
 static int devm_cxl_add_dax_region(struct cxl_region *cxlr)
 {
-	return __devm_cxl_add_dax_region(cxlr);
+	return __devm_cxl_add_dax_region(cxlr, false);
 }
 
 static int devm_cxl_add_dc_dax_region(struct cxl_region *cxlr)
@@ -2902,8 +3074,7 @@ static int devm_cxl_add_dc_dax_region(struct cxl_region *cxlr)
 		dev_err(&cxlr->dev, "Interleaving DC not supported\n");
 		return -EINVAL;
 	}
-
-	return __devm_cxl_add_dax_region(cxlr);
+	return __devm_cxl_add_dax_region(cxlr, true);
 }
 
 static int match_decoder_by_range(struct device *dev, void *data)
diff --git a/drivers/cxl/cxl.h b/drivers/cxl/cxl.h
index 81ca76ae1d02..177b892ac53f 100644
--- a/drivers/cxl/cxl.h
+++ b/drivers/cxl/cxl.h
@@ -555,6 +555,7 @@ struct cxl_region_params {
  * @type: Endpoint decoder target type
  * @cxl_nvb: nvdimm bridge for coordinating @cxlr_pmem setup / shutdown
  * @cxlr_pmem: (for pmem regions) cached copy of the nvdimm bridge
+ * @cxlr_dax: (for DC regions) cached copy of CXL DAX bridge
  * @flags: Region state flags
  * @params: active + config params for the region
  */
@@ -565,6 +566,7 @@ struct cxl_region {
 	enum cxl_decoder_type type;
 	struct cxl_nvdimm_bridge *cxl_nvb;
 	struct cxl_pmem_region *cxlr_pmem;
+	struct cxl_dax_region *cxlr_dax;
 	unsigned long flags;
 	struct cxl_region_params params;
 };
@@ -614,8 +616,22 @@ struct cxl_dax_region {
 	struct device dev;
 	struct cxl_region *cxlr;
 	struct range hpa_range;
+	struct xarray extents;
 };
 
+/* Interleave will manage multiple cxl_dc_extent_data objects */
+#define CXL_EXTENT_LABEL_LEN 64
+struct cxl_dr_extent {
+	struct kref region_ref;
+	u64 hpa_offset;
+	u64 hpa_length;
+	char label[CXL_EXTENT_LABEL_LEN];
+	struct cxl_dc_extent_data *extent;
+};
+int cxl_dr_extent_get_not_zero(struct cxl_dr_extent *cxl_dr_ext);
+void cxl_dr_extent_get(struct cxl_dr_extent *cxl_dr_ext);
+void cxl_dr_extent_put(struct cxl_dr_extent *cxl_dr_ext);
+
 /**
  * struct cxl_port - logical collection of upstream port devices and
  *		     downstream port devices to construct a CXL memory
diff --git a/drivers/cxl/cxlmem.h b/drivers/cxl/cxlmem.h
index 118392229174..8ca81fd067c2 100644
--- a/drivers/cxl/cxlmem.h
+++ b/drivers/cxl/cxlmem.h
@@ -1002,6 +1002,8 @@ int cxl_trigger_poison_list(struct cxl_memdev *cxlmd);
 int cxl_inject_poison(struct cxl_memdev *cxlmd, u64 dpa);
 int cxl_clear_poison(struct cxl_memdev *cxlmd, u64 dpa);
 
+int cxl_dc_extent_get_not_zero(struct cxl_dc_extent_data *extent);
+void cxl_dc_extent_get(struct cxl_dc_extent_data *extent);
 void cxl_dc_extent_put(struct cxl_dc_extent_data *extent);
 
 #ifdef CONFIG_CXL_SUSPEND
diff --git a/drivers/dax/Makefile b/drivers/dax/Makefile
index 5ed5c39857c8..38cd3c4c0898 100644
--- a/drivers/dax/Makefile
+++ b/drivers/dax/Makefile
@@ -7,6 +7,7 @@ obj-$(CONFIG_DEV_DAX_CXL) += dax_cxl.o
 
 dax-y := super.o
 dax-y += bus.o
+dax-y += extent.o
 device_dax-y := device.o
 dax_pmem-y := pmem.o
 dax_cxl-y := cxl.o
diff --git a/drivers/dax/cxl.c b/drivers/dax/cxl.c
index 147c8c69782b..057b00b1d914 100644
--- a/drivers/dax/cxl.c
+++ b/drivers/dax/cxl.c
@@ -5,6 +5,87 @@
 
 #include "../cxl/cxl.h"
 #include "bus.h"
+#include "dax-private.h"
+
+static void dax_reg_ext_get(struct dax_region_extent *dr_extent)
+{
+	kref_get(&dr_extent->ref);
+}
+
+static void dr_release(struct kref *kref)
+{
+	struct dax_region_extent *dr_extent;
+	struct cxl_dr_extent *cxl_dr_ext;
+
+	dr_extent = container_of(kref, struct dax_region_extent, ref);
+	cxl_dr_ext = dr_extent->private_data;
+	cxl_dr_extent_put(cxl_dr_ext);
+	kfree(dr_extent);
+}
+
+static void dax_reg_ext_put(struct dax_region_extent *dr_extent)
+{
+	kref_put(&dr_extent->ref, dr_release);
+}
+
+static int cxl_dax_region_create_extent(struct dax_region *dax_region,
+					struct cxl_dr_extent *cxl_dr_ext)
+{
+	struct dax_region_extent *dr_extent;
+	int rc;
+
+	dr_extent = kzalloc(sizeof(*dr_extent), GFP_KERNEL);
+	if (!dr_extent)
+		return -ENOMEM;
+
+	dr_extent->private_data = cxl_dr_ext;
+	dr_extent->get = dax_reg_ext_get;
+	dr_extent->put = dax_reg_ext_put;
+
+	/* device manages the dr_extent on success */
+	kref_init(&dr_extent->ref);
+
+	rc = dax_region_ext_create_dev(dax_region, dr_extent,
+				       cxl_dr_ext->hpa_offset,
+				       cxl_dr_ext->hpa_length,
+				       cxl_dr_ext->label);
+	if (rc) {
+		kfree(dr_extent);
+		return rc;
+	}
+
+	/* extent accepted */
+	cxl_dr_extent_get(cxl_dr_ext);
+	return 0;
+}
+
+static int cxl_dax_region_create_extents(struct cxl_dax_region *cxlr_dax)
+{
+	struct cxl_dr_extent *cxl_dr_ext;
+	unsigned long index;
+
+	dev_dbg(&cxlr_dax->dev, "Adding extents\n");
+	xa_for_each(&cxlr_dax->extents, index, cxl_dr_ext) {
+		/*
+		 * get not zero is important because this is racing with the
+		 * region driver which is racing with the memory device which
+		 * could be removing the extent at the same time.
+		 */
+		if (cxl_dr_extent_get_not_zero(cxl_dr_ext)) {
+			struct dax_region *dax_region;
+			int rc;
+
+			dax_region = dev_get_drvdata(&cxlr_dax->dev);
+			dev_dbg(&cxlr_dax->dev, "Found OFF:%llx LEN:%llx\n",
+				cxl_dr_ext->hpa_offset, cxl_dr_ext->hpa_length);
+			rc = cxl_dax_region_create_extent(dax_region, cxl_dr_ext);
+			cxl_dr_extent_put(cxl_dr_ext);
+			if (rc)
+				return rc;
+		}
+	}
+	return 0;
+}
 
 static int cxl_dax_region_probe(struct device *dev)
 {
@@ -19,20 +100,28 @@ static int cxl_dax_region_probe(struct device *dev)
 	if (nid == NUMA_NO_NODE)
 		nid = memory_add_physaddr_to_nid(cxlr_dax->hpa_range.start);
 
-	dev_size = range_len(&cxlr_dax->hpa_range);
-
 	flags = IORESOURCE_DAX_KMEM;
-	if (cxlr->mode == CXL_REGION_DC) {
-		/* Add empty seed dax device */
-		dev_size = 0;
+	if (cxlr->mode == CXL_REGION_DC)
 		flags |= IORESOURCE_DAX_DYNAMIC_CAP;
-	}
 
 	dax_region = alloc_dax_region(dev, cxlr->id, &cxlr_dax->hpa_range, nid,
 				      PMD_SIZE, flags);
 	if (!dax_region)
 		return -ENOMEM;
 
+	dev_size = range_len(&cxlr_dax->hpa_range);
+	if (cxlr->mode == CXL_REGION_DC) {
+		int rc;
+
+		/* NOTE: Depends on dax_region being set in driver data */
+		rc = cxl_dax_region_create_extents(cxlr_dax);
+		if (rc)
+			return rc;
+
+		/* Add empty seed dax device */
+		dev_size = 0;
+	}
+
 	data = (struct dev_dax_data) {
 		.dax_region = dax_region,
 		.id = -1,
diff --git a/drivers/dax/dax-private.h b/drivers/dax/dax-private.h
index 27cf2daaaa79..4dab52496c3f 100644
--- a/drivers/dax/dax-private.h
+++ b/drivers/dax/dax-private.h
@@ -5,6 +5,7 @@
 #ifndef __DAX_PRIVATE_H__
 #define __DAX_PRIVATE_H__
 
+#include <linux/pgtable.h>
 #include <linux/device.h>
 #include <linux/cdev.h>
 #include <linux/idr.h>
@@ -40,6 +41,58 @@ struct dax_region {
 	struct device *youngest;
 };
 
+/*
+ * struct dax_region_extent - extent data defined by the low level region
+ * driver.
+ * @private_data: lower level region driver data
+ * @ref: track number of dax devices which are using this extent
+ * @get: get reference to low level data
+ * @put: put reference to low level data
+ */
+struct dax_region_extent {
+	void *private_data;
+	struct kref ref;
+	void (*get)(struct dax_region_extent *dr_extent);
+	void (*put)(struct dax_region_extent *dr_extent);
+};
+
+static inline void dr_extent_get(struct dax_region_extent *dr_extent)
+{
+	if (dr_extent->get)
+		dr_extent->get(dr_extent);
+}
+
+static inline void dr_extent_put(struct dax_region_extent *dr_extent)
+{
+	if (dr_extent->put)
+		dr_extent->put(dr_extent);
+}
+
+#define DAX_EXTENT_LABEL_LEN 64
+/**
+ * struct dax_reg_ext_dev - Device object to expose extent information
+ * @dev: device representing this extent
+ * @dr_extent: reference back to private extent data
+ * @offset: offset of this extent
+ * @length: size of this extent
+ * @label: identifier to group extents
+ */
+struct dax_reg_ext_dev {
+	struct device dev;
+	struct dax_region_extent *dr_extent;
+	resource_size_t offset;
+	resource_size_t length;
+	char label[DAX_EXTENT_LABEL_LEN];
+};
+
+int dax_region_ext_create_dev(struct dax_region *dax_region,
+			      struct dax_region_extent *dr_extent,
+			      resource_size_t offset,
+			      resource_size_t length,
+			      const char *label);
+#define to_dr_ext_dev(dev)	\
+	container_of(dev, struct dax_reg_ext_dev, dev)
+
 struct dax_mapping {
 	struct device dev;
 	int range_id;
diff --git a/drivers/dax/extent.c b/drivers/dax/extent.c
new file mode 100644
index 000000000000..2075ccfb21cb
--- /dev/null
+++ b/drivers/dax/extent.c
@@ -0,0 +1,119 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright(c) 2023 Intel Corporation. All rights reserved. */
+
+#include <linux/device.h>
+#include <linux/slab.h>
+#include "dax-private.h"
+
+static ssize_t length_show(struct device *dev, struct device_attribute *attr,
+			 char *buf)
+{
+	struct dax_reg_ext_dev *dr_reg_ext_dev = to_dr_ext_dev(dev);
+
+	return sysfs_emit(buf, "%#llx\n", dr_reg_ext_dev->length);
+}
+static DEVICE_ATTR_RO(length);
+
+static ssize_t label_show(struct device *dev, struct device_attribute *attr,
+			  char *buf)
+{
+	struct dax_reg_ext_dev *dr_reg_ext_dev = to_dr_ext_dev(dev);
+
+	return sysfs_emit(buf, "%s\n", dr_reg_ext_dev->label);
+}
+
+static ssize_t label_store(struct device *dev, struct device_attribute *attr,
+			   const char *buf, size_t len)
+{
+	struct dax_reg_ext_dev *dr_reg_ext_dev = to_dr_ext_dev(dev);
+
+	snprintf(dr_reg_ext_dev->label, DAX_EXTENT_LABEL_LEN, "%s", buf);
+	return len;
+}
+static DEVICE_ATTR_RW(label);
+
+static struct attribute *dr_extent_attrs[] = {
+	&dev_attr_length.attr,
+	&dev_attr_label.attr,
+	NULL,
+};
+
+static const struct attribute_group dr_extent_attribute_group = {
+	.attrs = dr_extent_attrs,
+};
+
+static void dr_extent_release(struct device *dev)
+{
+	struct dax_reg_ext_dev *dr_reg_ext_dev = to_dr_ext_dev(dev);
+
+	kfree(dr_reg_ext_dev);
+}
+
+static const struct attribute_group *dr_extent_attribute_groups[] = {
+	&dr_extent_attribute_group,
+	NULL,
+};
+
+const struct device_type dr_extent_type = {
+	.name = "extent",
+	.release = dr_extent_release,
+	.groups = dr_extent_attribute_groups,
+};
+
+static void unregister_dr_extent(void *ext)
+{
+	struct dax_reg_ext_dev *dr_reg_ext_dev = ext;
+	struct dax_region_extent *dr_extent;
+
+	dr_extent = dr_reg_ext_dev->dr_extent;
+	dev_dbg(&dr_reg_ext_dev->dev, "Unregister DAX region ext OFF:%llx L:%s\n",
+		dr_reg_ext_dev->offset, dr_reg_ext_dev->label);
+	dr_extent_put(dr_extent);
+	device_unregister(&dr_reg_ext_dev->dev);
+}
+
+int dax_region_ext_create_dev(struct dax_region *dax_region,
+			      struct dax_region_extent *dr_extent,
+			      resource_size_t offset,
+			      resource_size_t length,
+			      const char *label)
+{
+	struct dax_reg_ext_dev *dr_reg_ext_dev;
+	struct device *dev;
+	int rc;
+
+	dr_reg_ext_dev = kzalloc(sizeof(*dr_reg_ext_dev), GFP_KERNEL);
+	if (!dr_reg_ext_dev)
+		return -ENOMEM;
+
+	dr_reg_ext_dev->dr_extent = dr_extent;
+	dr_reg_ext_dev->offset = offset;
+	dr_reg_ext_dev->length = length;
+	snprintf(dr_reg_ext_dev->label, DAX_EXTENT_LABEL_LEN, "%s", label);
+
+	dev = &dr_reg_ext_dev->dev;
+	device_initialize(dev);
+	dev->id = offset / PMD_SIZE ;
+	device_set_pm_not_required(dev);
+	dev->parent = dax_region->dev;
+	dev->type = &dr_extent_type;
+	rc = dev_set_name(dev, "extent%d", dev->id);
+	if (rc)
+		goto err;
+
+	rc = device_add(dev);
+	if (rc)
+		goto err;
+
+	dev_dbg(dev, "DAX region extent OFF:%llx LEN:%llx\n",
+		dr_reg_ext_dev->offset, dr_reg_ext_dev->length);
+	return devm_add_action_or_reset(dax_region->dev, unregister_dr_extent,
+					dr_reg_ext_dev);
+
+err:
+	dev_err(dev, "Failed to initialize DAX extent dev OFF:%llx LEN:%llx\n",
+		dr_reg_ext_dev->offset, dr_reg_ext_dev->length);
+	put_device(dev);
+	return rc;
+}
+EXPORT_SYMBOL_GPL(dax_region_ext_create_dev);

-- 
2.41.0


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id E0B28C83F17
	for <linux-cxl@archiver.kernel.org>; Tue, 29 Aug 2023 05:24:57 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S235648AbjH2FY2 (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 29 Aug 2023 01:24:28 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:40468 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S235662AbjH2FYN (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 29 Aug 2023 01:24:13 -0400
Received: from mgamail.intel.com (mgamail.intel.com [134.134.136.100])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 08F70199;
        Mon, 28 Aug 2023 22:24:10 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1693286650; x=1724822650;
  h=from:date:subject:mime-version:content-transfer-encoding:
   message-id:references:in-reply-to:to:cc;
  bh=jW5ttK5384oAyuCDjymBvEoWsT6lz5AHA/DU20rtvhA=;
  b=m/j3zsKvejYyvkzc1CO8pmyrL0T211r5U6eZY6UpqnIC0+dYGgcCRfgk
   rQ/tYZGkUzG8pWJIdBZZaCwkhQPpuEHuQbNnhn2MsKWbI3OwW9i7v1p2h
   6E2pUdDrEtFoKVJjfDGZUhmZNjs+WkJcGvj4bYMcHktoyqKu4e6Vsp65s
   wSiWMUnWrTXXmh/Kft/x+YrOP4BavD9NRumN7G29MJTluZznT7ZcRElqb
   RZ2UkquJhB99GHjx2RCmzEwxAWJkEaW03Yob4KOwIeKb1bDXLZws78EHS
   wbPIYPV5CdxmarveLJ5z1v2rMM/pCgihCsQ6/a6SLGdM279KrH14gG3F+
   Q==;
X-IronPort-AV: E=McAfee;i="6600,9927,10816"; a="441625246"
X-IronPort-AV: E=Sophos;i="6.02,208,1688454000"; 
   d="scan'208";a="441625246"
Received: from orsmga002.jf.intel.com ([10.7.209.21])
  by orsmga105.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 28 Aug 2023 22:23:48 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10816"; a="738556421"
X-IronPort-AV: E=Sophos;i="6.02,208,1688454000"; 
   d="scan'208";a="738556421"
Received: from iweiny-mobl.amr.corp.intel.com (HELO localhost) ([10.212.37.183])
  by orsmga002-auth.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 28 Aug 2023 22:23:48 -0700
From: Ira Weiny <ira.weiny@intel.com>
Date: Mon, 28 Aug 2023 22:21:05 -0700
Subject: [PATCH RFC v2 14/18] dax/region: Support DAX device creation on
 dynamic DAX regions
MIME-Version: 1.0
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: 7bit
Message-Id: <20230604-dcd-type2-upstream-v2-14-f740c47e7916@intel.com>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
In-Reply-To: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
To: Dan Williams <dan.j.williams@intel.com>
Cc: Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        Ira Weiny <ira.weiny@intel.com>, linux-cxl@vger.kernel.org,
        linux-kernel@vger.kernel.org
X-Mailer: b4 0.13-dev-c6835
X-Developer-Signature: v=1; a=ed25519-sha256; t=1693286607; l=15280;
 i=ira.weiny@intel.com; s=20221211; h=from:subject:message-id;
 bh=jW5ttK5384oAyuCDjymBvEoWsT6lz5AHA/DU20rtvhA=;
 b=Upm6KoRvNPk9sMyBoPBwy5uWJBkDrHViAzplqmE8KZQ4j/BBmZp/aOQi1+08GvVSSxqL1Fl+d
 mP/yf4X1CF1D4ekmb0WydhtDAPXLx3sC0zvGu75yAAgVRopFxVotl5d
X-Developer-Key: i=ira.weiny@intel.com; a=ed25519;
 pk=noldbkG+Wp1qXRrrkfY1QJpDf7QsOEthbOT7vm0PqsE=
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

Dynamic Capacity (DC) DAX regions have a list of extents which define
the memory of the region which is available.

Now that DAX region extents are fully realized support DAX device
creation on dynamic regions by adjusting the allocation algorithms
to account for the extents.  Remember also references must be held on
the extents until the DAX devices are done with the memory.

Redefine the region available size to include only extent space.  Reuse
the size allocation algorithm by defining sub-resources for each extent
and limiting range allocation to those extents which have space.  Do not
support direct mapping of DAX devices on dynamic devices.

Enhance DAX device range objects to hold references on the extents until
the DAX device is destroyed.

NOTE: At this time all extents within a region are created equally.
However, labels are associated with extents which can be used with
future DAX device labels to group which extents are used.

Signed-off-by: Ira Weiny <ira.weiny@intel.com>
---
 drivers/dax/bus.c         | 157 +++++++++++++++++++++++++++++++++++++++-------
 drivers/dax/cxl.c         |  44 +++++++++++++
 drivers/dax/dax-private.h |   5 ++
 3 files changed, 182 insertions(+), 24 deletions(-)

diff --git a/drivers/dax/bus.c b/drivers/dax/bus.c
index ea7ae82b4687..a9ea6a706702 100644
--- a/drivers/dax/bus.c
+++ b/drivers/dax/bus.c
@@ -280,6 +280,36 @@ static ssize_t region_align_show(struct device *dev,
 static struct device_attribute dev_attr_region_align =
 		__ATTR(align, 0400, region_align_show, NULL);
 
+#define for_each_extent_resource(extent, res) \
+	for (res = (extent)->child; res; res = res->sibling)
+
+static unsigned long long
+dr_extent_avail_size(struct dax_region_extent *dr_extent)
+{
+	unsigned long long rc;
+	struct resource *res;
+
+	rc = resource_size(dr_extent->res);
+	for_each_extent_resource(dr_extent->res, res)
+		rc -= resource_size(res);
+	return rc;
+}
+
+static int dax_region_add_dynamic_size(struct device *dev, void *data)
+{
+	unsigned long long *size = data, ext_size;
+	struct dax_reg_ext_dev *dr_reg_ext_dev;
+
+	if (!is_dr_ext_dev(dev))
+		return 0;
+
+	dr_reg_ext_dev = to_dr_ext_dev(dev);
+	ext_size = dr_extent_avail_size(dr_reg_ext_dev->dr_extent);
+	dev_dbg(dev, "size %llx\n", ext_size);
+	*size += ext_size;
+	return 0;
+}
+
 #define for_each_dax_region_resource(dax_region, res) \
 	for (res = (dax_region)->res.child; res; res = res->sibling)
 
@@ -290,8 +320,12 @@ static unsigned long long dax_region_avail_size(struct dax_region *dax_region)
 
 	device_lock_assert(dax_region->dev);
 
-	if (is_dynamic(dax_region))
-		return 0;
+	if (is_dynamic(dax_region)) {
+		size = 0;
+		device_for_each_child(dax_region->dev, &size,
+				      dax_region_add_dynamic_size);
+		return size;
+	}
 
 	for_each_dax_region_resource(dax_region, res)
 		size -= resource_size(res);
@@ -421,15 +455,24 @@ EXPORT_SYMBOL_GPL(kill_dev_dax);
 static void trim_dev_dax_range(struct dev_dax *dev_dax)
 {
 	int i = dev_dax->nr_range - 1;
-	struct range *range = &dev_dax->ranges[i].range;
+	struct dev_dax_range *dev_range = &dev_dax->ranges[i];
+	struct range *range = &dev_range->range;
 	struct dax_region *dax_region = dev_dax->region;
+	struct resource *res = &dax_region->res;
 
 	device_lock_assert(dax_region->dev);
 	dev_dbg(&dev_dax->dev, "delete range[%d]: %#llx:%#llx\n", i,
 		(unsigned long long)range->start,
 		(unsigned long long)range->end);
 
-	__release_region(&dax_region->res, range->start, range_len(range));
+	if (dev_range->dr_extent)
+		res = dev_range->dr_extent->res;
+
+	__release_region(res, range->start, range_len(range));
+
+	if (dev_range->dr_extent)
+		dr_extent_put(dev_range->dr_extent);
+
 	if (--dev_dax->nr_range == 0) {
 		kfree(dev_dax->ranges);
 		dev_dax->ranges = NULL;
@@ -818,7 +861,8 @@ static int devm_register_dax_mapping(struct dev_dax *dev_dax, int range_id)
 }
 
 static int alloc_dev_dax_range(struct resource *parent, struct dev_dax *dev_dax,
-			       u64 start, resource_size_t size)
+			       u64 start, resource_size_t size,
+			       struct dax_region_extent *dr_extent)
 {
 	struct dax_region *dax_region = dev_dax->region;
 	struct device *dev = &dev_dax->dev;
@@ -852,12 +896,15 @@ static int alloc_dev_dax_range(struct resource *parent, struct dev_dax *dev_dax,
 	for (i = 0; i < dev_dax->nr_range; i++)
 		pgoff += PHYS_PFN(range_len(&ranges[i].range));
 	dev_dax->ranges = ranges;
+	if (dr_extent)
+		dr_extent_get(dr_extent);
 	ranges[dev_dax->nr_range++] = (struct dev_dax_range) {
 		.pgoff = pgoff,
 		.range = {
 			.start = alloc->start,
 			.end = alloc->end,
 		},
+		.dr_extent = dr_extent,
 	};
 
 	dev_dbg(dev, "alloc range[%d]: %pa:%pa\n", dev_dax->nr_range - 1,
@@ -938,7 +985,8 @@ static int dev_dax_shrink(struct dev_dax *dev_dax, resource_size_t size)
 	int i;
 
 	for (i = dev_dax->nr_range - 1; i >= 0; i--) {
-		struct range *range = &dev_dax->ranges[i].range;
+		struct dev_dax_range *dev_range = &dev_dax->ranges[i];
+		struct range *range = &dev_range->range;
 		struct dax_mapping *mapping = dev_dax->ranges[i].mapping;
 		struct resource *adjust = NULL, *res;
 		resource_size_t shrink;
@@ -954,12 +1002,16 @@ static int dev_dax_shrink(struct dev_dax *dev_dax, resource_size_t size)
 			continue;
 		}
 
-		for_each_dax_region_resource(dax_region, res)
-			if (strcmp(res->name, dev_name(dev)) == 0
-					&& res->start == range->start) {
-				adjust = res;
-				break;
-			}
+		if (dev_range->dr_extent) {
+			adjust = dev_range->dr_extent->res;
+		} else {
+			for_each_dax_region_resource(dax_region, res)
+				if (strcmp(res->name, dev_name(dev)) == 0
+						&& res->start == range->start) {
+					adjust = res;
+					break;
+				}
+		}
 
 		if (dev_WARN_ONCE(dev, !adjust || i != dev_dax->nr_range - 1,
 					"failed to find matching resource\n"))
@@ -973,12 +1025,15 @@ static int dev_dax_shrink(struct dev_dax *dev_dax, resource_size_t size)
 /*
  * Only allow adjustments that preserve the relative pgoff of existing
  * allocations. I.e. the dev_dax->ranges array is ordered by increasing pgoff.
+ * Dissallow adjustments on dynamic regions as they can come from all over.
  */
 static bool adjust_ok(struct dev_dax *dev_dax, struct resource *res)
 {
 	struct dev_dax_range *last;
 	int i;
 
+	if (is_dynamic(dev_dax->region))
+		return false;
 	if (dev_dax->nr_range == 0)
 		return false;
 	if (strcmp(res->name, dev_name(&dev_dax->dev)) != 0)
@@ -997,19 +1052,21 @@ static bool adjust_ok(struct dev_dax *dev_dax, struct resource *res)
 }
 
 /*
- * dev_dax_resize_static - Expand the device into the unused portion of the
- * region. This may involve adjusting the end of an existing resource, or
- * allocating a new resource.
+ * __dev_dax_resize - Expand the device into the unused portion of the region.
+ * This may involve adjusting the end of an existing resource, or allocating a
+ * new resource.
  *
  * @parent: parent resource to allocate this range in.
  * @dev_dax: DAX device we are creating this range for
  * @to_alloc: amount of space to alloc; must be <= space available in @parent
+ * @dr_extent: if dynamic; the extent containing parent
  *
  * Return the amount of space allocated or -ERRNO on failure
  */
-static ssize_t dev_dax_resize_static(struct resource *parent,
-				     struct dev_dax *dev_dax,
-				     resource_size_t to_alloc)
+static ssize_t __dev_dax_resize(struct resource *parent,
+				struct dev_dax *dev_dax,
+				resource_size_t to_alloc,
+				struct dax_region_extent *dr_extent)
 {
 	struct resource *res, *first;
 	int rc;
@@ -1017,7 +1074,8 @@ static ssize_t dev_dax_resize_static(struct resource *parent,
 	first = parent->child;
 	if (!first) {
 		rc = alloc_dev_dax_range(parent, dev_dax,
-					   parent->start, to_alloc);
+					   parent->start, to_alloc,
+					   dr_extent);
 		if (rc)
 			return rc;
 		return to_alloc;
@@ -1031,7 +1089,8 @@ static ssize_t dev_dax_resize_static(struct resource *parent,
 		if (res == first && res->start > parent->start) {
 			alloc = min(res->start - parent->start, to_alloc);
 			rc = alloc_dev_dax_range(parent, dev_dax,
-						 parent->start, alloc);
+						 parent->start, alloc,
+						 dr_extent);
 			if (rc)
 				return rc;
 			return alloc;
@@ -1055,7 +1114,8 @@ static ssize_t dev_dax_resize_static(struct resource *parent,
 				return rc;
 			return alloc;
 		}
-		rc = alloc_dev_dax_range(parent, dev_dax, res->end + 1, alloc);
+		rc = alloc_dev_dax_range(parent, dev_dax, res->end + 1, alloc,
+					 dr_extent);
 		if (rc)
 			return rc;
 		return alloc;
@@ -1066,6 +1126,47 @@ static ssize_t dev_dax_resize_static(struct resource *parent,
 	return 0;
 }
 
+static ssize_t dev_dax_resize_static(struct dax_region *dax_region,
+				     struct dev_dax *dev_dax,
+				     resource_size_t to_alloc)
+{
+	return __dev_dax_resize(&dax_region->res, dev_dax, to_alloc, NULL);
+}
+
+static int dax_region_find_space(struct device *dev, void *data)
+{
+	struct dax_reg_ext_dev *dr_reg_ext_dev;
+
+	if (!is_dr_ext_dev(dev))
+		return 0;
+
+	dr_reg_ext_dev = to_dr_ext_dev(dev);
+	return dr_extent_avail_size(dr_reg_ext_dev->dr_extent);
+}
+
+static ssize_t dev_dax_resize_dynamic(struct dax_region *dax_region,
+				      struct dev_dax *dev_dax,
+				      resource_size_t to_alloc)
+{
+	struct dax_reg_ext_dev *dr_reg_ext_dev;
+	struct dax_region_extent *dr_extent;
+	resource_size_t alloc;
+	resource_size_t extent_max;
+	struct device *dev;
+
+	dev = device_find_child(dax_region->dev, NULL, dax_region_find_space);
+	if (dev_WARN_ONCE(dax_region->dev, !dev, "Space should be available!"))
+		return -ENOSPC;
+	dr_reg_ext_dev = to_dr_ext_dev(dev);
+	dr_extent = dr_reg_ext_dev->dr_extent;
+	extent_max = dr_extent_avail_size(dr_extent);
+	to_alloc = min(extent_max, to_alloc);
+	alloc = __dev_dax_resize(dr_extent->res, dev_dax, to_alloc, dr_extent);
+	put_device(dev);
+
+	return alloc;
+}
+
 static ssize_t dev_dax_resize(struct dax_region *dax_region,
 		struct dev_dax *dev_dax, resource_size_t size)
 {
@@ -1089,7 +1190,10 @@ static ssize_t dev_dax_resize(struct dax_region *dax_region,
 		return -ENXIO;
 
 retry:
-	alloc = dev_dax_resize_static(&dax_region->res, dev_dax, to_alloc);
+	if (is_dynamic(dax_region))
+		alloc = dev_dax_resize_dynamic(dax_region, dev_dax, to_alloc);
+	else
+		alloc = dev_dax_resize_static(dax_region, dev_dax, to_alloc);
 	if (alloc <= 0)
 		return alloc;
 	to_alloc -= alloc;
@@ -1168,6 +1272,9 @@ static ssize_t mapping_store(struct device *dev, struct device_attribute *attr,
 	struct range r;
 	ssize_t rc;
 
+	if (is_dynamic(dax_region))
+		return -EINVAL;
+
 	rc = range_parse(buf, len, &r);
 	if (rc)
 		return rc;
@@ -1183,7 +1290,7 @@ static ssize_t mapping_store(struct device *dev, struct device_attribute *attr,
 	to_alloc = range_len(&r);
 	if (alloc_is_aligned(dev_dax, to_alloc))
 		rc = alloc_dev_dax_range(&dax_region->res, dev_dax, r.start,
-					 to_alloc);
+					 to_alloc, NULL);
 	device_unlock(dev);
 	device_unlock(dax_region->dev);
 
@@ -1400,8 +1507,10 @@ struct dev_dax *devm_create_dev_dax(struct dev_dax_data *data)
 	device_initialize(dev);
 	dev_set_name(dev, "dax%d.%d", dax_region->id, dev_dax->id);
 
+	dev_WARN_ONCE(parent, is_dynamic(dax_region) && data->size,
+		      "Dynamic DAX devices are created initially with 0 size");
 	rc = alloc_dev_dax_range(&dax_region->res, dev_dax, dax_region->res.start,
-				 data->size);
+				 data->size, NULL);
 	if (rc)
 		goto err_range;
 
diff --git a/drivers/dax/cxl.c b/drivers/dax/cxl.c
index 44cbd28668f1..6394a3531e25 100644
--- a/drivers/dax/cxl.c
+++ b/drivers/dax/cxl.c
@@ -12,6 +12,17 @@ static void dax_reg_ext_get(struct dax_region_extent *dr_extent)
 	kref_get(&dr_extent->ref);
 }
 
+
+static void dax_region_rm_resource(struct dax_region_extent *dr_extent)
+{
+	struct dax_region *dax_region = dr_extent->region;
+	struct resource *res = dr_extent->res;
+	
+	dev_dbg(dax_region->dev, "Extent release resource %pR\n",
+		dr_extent->res);
+	__release_region(&dax_region->res, res->start, resource_size(res));
+}
+
 static void dr_release(struct kref *kref)
 {
 	struct dax_region_extent *dr_extent;
@@ -19,6 +30,7 @@ static void dr_release(struct kref *kref)
 
 	dr_extent = container_of(kref, struct dax_region_extent, ref);
 	cxl_dr_ext = dr_extent->private_data;
+	dax_region_rm_resource(dr_extent);
 	cxl_dr_extent_put(cxl_dr_ext);
 	kfree(dr_extent);
 }
@@ -28,6 +40,29 @@ static void dax_reg_ext_put(struct dax_region_extent *dr_extent)
 	kref_put(&dr_extent->ref, dr_release);
 }
 
+static int dax_region_add_resource(struct dax_region *dax_region,
+				   struct dax_region_extent *dr_extent,
+				   resource_size_t offset,
+				   resource_size_t length)
+{
+	resource_size_t start = dax_region->res.start + offset;
+	struct resource *ext_res;
+
+	dev_dbg(dax_region->dev, "DAX region resource %pR\n", &dax_region->res);
+	ext_res = __request_region(&dax_region->res, start, length, "extent", 0);
+	if (!ext_res) {
+		dev_err(dax_region->dev, "Failed to add extent s:%llx l:%llx\n",
+			start, length);
+		return -ENOSPC;
+	}
+
+	dr_extent->region = dax_region;
+	dr_extent->res = ext_res;
+	dev_dbg(dax_region->dev, "Extent add resource %pR\n", ext_res);
+
+	return 0;
+}
+
 static int cxl_dax_region_create_extent(struct dax_region *dax_region,
 					struct cxl_dr_extent *cxl_dr_ext)
 {
@@ -45,11 +80,20 @@ static int cxl_dax_region_create_extent(struct dax_region *dax_region,
 	/* device manages the dr_extent on success */
 	kref_init(&dr_extent->ref);
 
+	rc = dax_region_add_resource(dax_region, dr_extent,
+				     cxl_dr_ext->hpa_offset,
+				     cxl_dr_ext->hpa_length);
+	if (rc) {
+		kfree(dr_extent);
+		return rc;
+	}
+
 	rc = dax_region_ext_create_dev(dax_region, dr_extent,
 				       cxl_dr_ext->hpa_offset,
 				       cxl_dr_ext->hpa_length,
 				       cxl_dr_ext->label);
 	if (rc) {
+		dax_region_rm_resource(dr_extent);
 		kfree(dr_extent);
 		return rc;
 	}
diff --git a/drivers/dax/dax-private.h b/drivers/dax/dax-private.h
index 250babd6e470..ad73b53aa802 100644
--- a/drivers/dax/dax-private.h
+++ b/drivers/dax/dax-private.h
@@ -44,12 +44,16 @@ struct dax_region {
 /*
  * struct dax_region_extent - extent data defined by the low level region
  * driver.
+ * @region: cache of dax_region
+ * @res: cache of resource tree for this extent
  * @private_data: lower level region driver data
  * @ref: track number of dax devices which are using this extent
  * @get: get reference to low level data
  * @put: put reference to low level data
  */
 struct dax_region_extent {
+	struct dax_region *region;
+	struct resource *res;
 	void *private_data;
 	struct kref ref;
 	void (*get)(struct dax_region_extent *dr_extent);
@@ -131,6 +135,7 @@ struct dev_dax {
 		unsigned long pgoff;
 		struct range range;
 		struct dax_mapping *mapping;
+		struct dax_region_extent *dr_extent;
 	} *ranges;
 };
 

-- 
2.41.0


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id C5A83C83F2C
	for <linux-cxl@archiver.kernel.org>; Tue, 29 Aug 2023 05:24:58 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S235705AbjH2FY3 (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 29 Aug 2023 01:24:29 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:40516 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S235667AbjH2FYP (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 29 Aug 2023 01:24:15 -0400
Received: from mgamail.intel.com (mgamail.intel.com [134.134.136.100])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id DF50E199;
        Mon, 28 Aug 2023 22:24:12 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1693286652; x=1724822652;
  h=from:date:subject:mime-version:content-transfer-encoding:
   message-id:references:in-reply-to:to:cc;
  bh=UjeGgzDfDpxcCqBVnjRJhF3JRUS9A6pPcoh/q1uIkpA=;
  b=nefvNVAoruCClUpFf9ovj1iOQKTyessoBgo8fK2lSfKnl2vhi44iA688
   QzAWEGif3WFOnXwrgXoEZMv1UbvtfH1omuNdo5mvUF/OmBuo8qur1jBnJ
   W2JmrYk2Cs/5P2tIk0jEbz2PMEJxizrhLTGwI98ECBUfIQa5BETITd4eb
   XGKhmKTAJwLURDXS58RD1KUJhNFFpC/RPeX9/fQL6PtpVJBOcguZqn5bK
   AwTOnizRXGFUM6d8HW4VJrShY6Mky+WkUmkW48zEZYf2GGrfn5h36iJGE
   z/ON/775Q+g8qntfgcImLq7d1ejgEJamCDgFZWKuCq25nVKH2PW2fZ593
   A==;
X-IronPort-AV: E=McAfee;i="6600,9927,10816"; a="441625271"
X-IronPort-AV: E=Sophos;i="6.02,208,1688454000"; 
   d="scan'208";a="441625271"
Received: from orsmga002.jf.intel.com ([10.7.209.21])
  by orsmga105.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 28 Aug 2023 22:23:53 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10816"; a="738556469"
X-IronPort-AV: E=Sophos;i="6.02,208,1688454000"; 
   d="scan'208";a="738556469"
Received: from iweiny-mobl.amr.corp.intel.com (HELO localhost) ([10.212.37.183])
  by orsmga002-auth.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 28 Aug 2023 22:23:53 -0700
From: Ira Weiny <ira.weiny@intel.com>
Date: Mon, 28 Aug 2023 22:21:09 -0700
Subject: [PATCH RFC v2 18/18] tools/testing/cxl: Add Dynamic Capacity
 events
MIME-Version: 1.0
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: 7bit
Message-Id: <20230604-dcd-type2-upstream-v2-18-f740c47e7916@intel.com>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
In-Reply-To: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
To: Dan Williams <dan.j.williams@intel.com>
Cc: Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        Ira Weiny <ira.weiny@intel.com>, linux-cxl@vger.kernel.org,
        linux-kernel@vger.kernel.org
X-Mailer: b4 0.13-dev-c6835
X-Developer-Signature: v=1; a=ed25519-sha256; t=1693286608; l=3592;
 i=ira.weiny@intel.com; s=20221211; h=from:subject:message-id;
 bh=UjeGgzDfDpxcCqBVnjRJhF3JRUS9A6pPcoh/q1uIkpA=;
 b=+iYL3SbR8ycp8mDueZbDV4zygoUH8KKJqSL7gi3xjOqlj9y2o9BDuTWvxi4DLiIX024QGRss4
 YxpIjiqKZprBoaH4BkGF64eg5LaOrb8Mf6ZlyvNN4GZB0OPanRB82Qs
X-Developer-Key: i=ira.weiny@intel.com; a=ed25519;
 pk=noldbkG+Wp1qXRrrkfY1QJpDf7QsOEthbOT7vm0PqsE=
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

OS software needs to be alerted when new extents arrive on a Dynamic
Capacity Device (DCD).  On test DCDs extents are added through sysfs.

Add events on DCD extent injection.  Directly call the event irq
callback to simulate irqs to process the test extents.

Signed-off-by: Ira Weiny <ira.weiny@intel.com>
---
 tools/testing/cxl/test/mem.c | 57 ++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 57 insertions(+)

diff --git a/tools/testing/cxl/test/mem.c b/tools/testing/cxl/test/mem.c
index d6041a2145c5..20364fee9df9 100644
--- a/tools/testing/cxl/test/mem.c
+++ b/tools/testing/cxl/test/mem.c
@@ -2008,6 +2008,41 @@ static bool new_extent_valid(struct device *dev, size_t new_start,
 	return false;
 }
 
+struct dcd_event_dyn_cap dcd_event_rec_template = {
+	.hdr = {
+		.id = UUID_INIT(0xca95afa7, 0xf183, 0x4018,
+				0x8c, 0x2f, 0x95, 0x26, 0x8e, 0x10, 0x1a, 0x2a),
+		.length = sizeof(struct dcd_event_dyn_cap),
+	},
+};
+
+static int send_dc_event(struct mock_event_store *mes, enum dc_event type,
+			 u64 start, u64 length, const char *tag_str)
+{
+	struct device *dev = mes->mds->cxlds.dev;
+	struct dcd_event_dyn_cap *dcd_event_rec;
+
+	dcd_event_rec = devm_kzalloc(dev, sizeof(*dcd_event_rec), GFP_KERNEL);
+	if (!dcd_event_rec)
+		return -ENOMEM;
+
+	memcpy(dcd_event_rec, &dcd_event_rec_template, sizeof(*dcd_event_rec));
+	dcd_event_rec->data.event_type = type;
+	dcd_event_rec->data.extent.start_dpa = cpu_to_le64(start);
+	dcd_event_rec->data.extent.length = cpu_to_le64(length);
+	memcpy(dcd_event_rec->data.extent.tag, tag_str,
+	       min(sizeof(dcd_event_rec->data.extent.tag),
+		   strlen(tag_str)));
+
+	mes_add_event(mes, CXL_EVENT_TYPE_DCD,
+		      (struct cxl_event_record_raw *)dcd_event_rec);
+
+	/* Fake the irq */
+	cxl_mem_get_event_records(mes->mds, CXLDEV_EVENT_STATUS_DCD);
+
+	return 0;
+}
+
 /*
  * Format <start>:<length>:<tag>
  *
@@ -2021,6 +2056,7 @@ static ssize_t dc_inject_extent_store(struct device *dev,
 				      const char *buf, size_t count)
 {
 	char *start_str __free(kfree) = kstrdup(buf, GFP_KERNEL);
+	struct cxl_mockmem_data *mdata = dev_get_drvdata(dev);
 	unsigned long long start, length;
 	char *len_str, *tag_str;
 	size_t buf_len = count;
@@ -2063,6 +2099,13 @@ static ssize_t dc_inject_extent_store(struct device *dev,
 	if (rc)
 		return rc;
 
+	rc = send_dc_event(&mdata->mes, DCD_ADD_CAPACITY, start, length,
+			   tag_str);
+	if (rc) {
+		dev_err(dev, "Failed to add event %d\n", rc);
+		return rc;
+	}
+
 	return count;
 }
 static DEVICE_ATTR_WO(dc_inject_extent);
@@ -2071,6 +2114,7 @@ static ssize_t dc_del_extent_store(struct device *dev,
 				   struct device_attribute *attr,
 				   const char *buf, size_t count)
 {
+	struct cxl_mockmem_data *mdata = dev_get_drvdata(dev);
 	unsigned long long start;
 	int rc;
 
@@ -2083,6 +2127,12 @@ static ssize_t dc_del_extent_store(struct device *dev,
 	if (rc)
 		return rc;
 
+	rc = send_dc_event(&mdata->mes, DCD_RELEASE_CAPACITY, start, 0, "");
+	if (rc) {
+		dev_err(dev, "Failed to add event %d\n", rc);
+		return rc;
+	}
+
 	return count;
 }
 static DEVICE_ATTR_WO(dc_del_extent);
@@ -2111,6 +2161,13 @@ static ssize_t dc_force_del_extent_store(struct device *dev,
 	if (rc)
 		return rc;
 
+	rc = send_dc_event(&mdata->mes, DCD_FORCED_CAPACITY_RELEASE,
+			      start, 0, "");
+	if (rc) {
+		dev_err(dev, "Failed to add event %d\n", rc);
+		return rc;
+	}
+
 	return count;
 }
 static DEVICE_ATTR_WO(dc_force_del_extent);

-- 
2.41.0


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 03897C83F2A
	for <linux-cxl@archiver.kernel.org>; Tue, 29 Aug 2023 05:24:57 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S235704AbjH2FY3 (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 29 Aug 2023 01:24:29 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:40510 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S235670AbjH2FYP (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 29 Aug 2023 01:24:15 -0400
Received: from mgamail.intel.com (mgamail.intel.com [134.134.136.100])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id BE03D19F;
        Mon, 28 Aug 2023 22:24:11 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1693286651; x=1724822651;
  h=from:date:subject:mime-version:content-transfer-encoding:
   message-id:references:in-reply-to:to:cc;
  bh=HxC49ptcM11EQrSwTVo9fff8MdM44gflowq6hgE56Pg=;
  b=ANtBq7GrkA5d+xk+Zku/1aVhrvBY69YA9sjdk37B/oL4GswoOTQuzRtg
   J3Zq1EgSJw08P4xQp2lh1Sqq5iac/8L3Zrk5c17C/4kEzXkWOd8yhRrwM
   lFd3jyqBlF8CiUa/ekkSXrd6IU7T+gUxfqW8tXq3IflGlg5MsKv7OACk6
   8v8zaI7NGNUB5tY+bx67ADiBauvvi8786CVxGCohOl8W66ZyjvN7drUH7
   G/SuPA6QeKqxBM/lLunhi5YRF7Jwi1Y7WRmyIW/nSk9uSSL/seR3MDHK7
   cX+WcFx42qjUzYmSd4xrryAPp9SasH+oEiIykaCtM5EkS20USzk1holEW
   w==;
X-IronPort-AV: E=McAfee;i="6600,9927,10816"; a="441625259"
X-IronPort-AV: E=Sophos;i="6.02,208,1688454000"; 
   d="scan'208";a="441625259"
Received: from orsmga002.jf.intel.com ([10.7.209.21])
  by orsmga105.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 28 Aug 2023 22:23:50 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10816"; a="738556449"
X-IronPort-AV: E=Sophos;i="6.02,208,1688454000"; 
   d="scan'208";a="738556449"
Received: from iweiny-mobl.amr.corp.intel.com (HELO localhost) ([10.212.37.183])
  by orsmga002-auth.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 28 Aug 2023 22:23:51 -0700
From: Ira Weiny <ira.weiny@intel.com>
Date: Mon, 28 Aug 2023 22:21:07 -0700
Subject: [PATCH RFC v2 16/18] tools/testing/cxl: Make event logs dynamic
MIME-Version: 1.0
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: 7bit
Message-Id: <20230604-dcd-type2-upstream-v2-16-f740c47e7916@intel.com>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
In-Reply-To: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
To: Dan Williams <dan.j.williams@intel.com>
Cc: Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        Ira Weiny <ira.weiny@intel.com>, linux-cxl@vger.kernel.org,
        linux-kernel@vger.kernel.org
X-Mailer: b4 0.13-dev-c6835
X-Developer-Signature: v=1; a=ed25519-sha256; t=1693286607; l=15039;
 i=ira.weiny@intel.com; s=20221211; h=from:subject:message-id;
 bh=HxC49ptcM11EQrSwTVo9fff8MdM44gflowq6hgE56Pg=;
 b=acVEqavLR8gB4MiTLWbKow6gzi2Tq94v6Z32al0pOqE7ws7am0eqEqR/rHQN6urqtGZK8j8SC
 JCsgi7SbSvFC3f9FjXWNWK5qzCZHBV5mTTiBH9qYjuBNKj5ZUnBHPSz
X-Developer-Key: i=ira.weiny@intel.com; a=ed25519;
 pk=noldbkG+Wp1qXRrrkfY1QJpDf7QsOEthbOT7vm0PqsE=
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

The test event logs were created as static arrays as an easy way to mock
events.  Dynamic Capacity Device (DCD) test support requires events be
created dynamically when extents are created/destroyed.

Modify the event log storage to be dynamically allocated.  Thus they can
accommodate the dynamic events required by DCD.  Reuse the static event
data to create the dynamic events in the new logs without inventing
complex event injection through the test sysfs.  Simplify the processing
of the logs by using the event log array index as the handle.  Add a
lock to manage concurrency to come with DCD extent testing.

Signed-off-by: Ira Weiny <ira.weiny@intel.com>
---
 tools/testing/cxl/test/mem.c | 276 ++++++++++++++++++++++++++-----------------
 1 file changed, 170 insertions(+), 106 deletions(-)

diff --git a/tools/testing/cxl/test/mem.c b/tools/testing/cxl/test/mem.c
index 51be202fabd0..6a036c8d215d 100644
--- a/tools/testing/cxl/test/mem.c
+++ b/tools/testing/cxl/test/mem.c
@@ -118,18 +118,27 @@ static struct {
 
 #define PASS_TRY_LIMIT 3
 
-#define CXL_TEST_EVENT_CNT_MAX 15
+#define CXL_TEST_EVENT_CNT_MAX 17
 
 /* Set a number of events to return at a time for simulation.  */
 #define CXL_TEST_EVENT_CNT 3
 
+/*
+ * @next_handle: next handle (index) to be stored to
+ * @cur_handle: current handle (index) to be returned to the user on get_event
+ * @nr_events: total events in this log
+ * @nr_overflow: number of events added past the log size
+ * @lock: protect these state variables
+ * @events: array of pending events to be returned.
+ */
 struct mock_event_log {
-	u16 clear_idx;
-	u16 cur_idx;
+	u16 next_handle;
+	u16 cur_handle;
 	u16 nr_events;
 	u16 nr_overflow;
-	u16 overflow_reset;
-	struct cxl_event_record_raw *events[CXL_TEST_EVENT_CNT_MAX];
+	rwlock_t lock;
+	/* 1 extra slot to accommodate that handles can't be 0 */
+	struct cxl_event_record_raw *events[CXL_TEST_EVENT_CNT_MAX+1];
 };
 
 struct mock_event_store {
@@ -163,64 +172,76 @@ static struct mock_event_log *event_find_log(struct device *dev, int log_type)
 	return &mdata->mes.mock_logs[log_type];
 }
 
-static struct cxl_event_record_raw *event_get_current(struct mock_event_log *log)
-{
-	return log->events[log->cur_idx];
-}
-
-static void event_reset_log(struct mock_event_log *log)
-{
-	log->cur_idx = 0;
-	log->clear_idx = 0;
-	log->nr_overflow = log->overflow_reset;
-}
-
-/* Handle can never be 0 use 1 based indexing for handle */
-static u16 event_get_clear_handle(struct mock_event_log *log)
-{
-	return log->clear_idx + 1;
-}
-
 /* Handle can never be 0 use 1 based indexing for handle */
-static __le16 event_get_cur_event_handle(struct mock_event_log *log)
+static void event_inc_handle(u16 *handle)
 {
-	u16 cur_handle = log->cur_idx + 1;
-
-	return cpu_to_le16(cur_handle);
-}
-
-static bool event_log_empty(struct mock_event_log *log)
-{
-	return log->cur_idx == log->nr_events;
+	*handle = (*handle + 1) % CXL_TEST_EVENT_CNT_MAX;
+	if (!*handle)
+		*handle = *handle + 1;
 }
 
+/* Add the event or free it on 'overflow' */
 static void mes_add_event(struct mock_event_store *mes,
 			  enum cxl_event_log_type log_type,
 			  struct cxl_event_record_raw *event)
 {
+	struct device *dev = mes->mds->cxlds.dev;
 	struct mock_event_log *log;
+	u16 handle;
 
 	if (WARN_ON(log_type >= CXL_EVENT_TYPE_MAX))
 		return;
 
 	log = &mes->mock_logs[log_type];
 
-	if ((log->nr_events + 1) > CXL_TEST_EVENT_CNT_MAX) {
+	write_lock(&log->lock);
+
+	handle = log->next_handle;
+	if ((handle + 1) == log->cur_handle) {
 		log->nr_overflow++;
-		log->overflow_reset = log->nr_overflow;
-		return;
+		dev_dbg(dev, "Overflowing %d\n", log_type);
+		devm_kfree(dev, event);
+		goto unlock;
 	}
 
-	log->events[log->nr_events] = event;
+	dev_dbg(dev, "Log %d; handle %u\n", log_type, handle);
+	event->hdr.handle = cpu_to_le16(handle);
+	log->events[handle] = event;
+	event_inc_handle(&log->next_handle);
 	log->nr_events++;
+
+unlock:
+	write_unlock(&log->lock);
+}
+
+static void mes_del_event(struct device *dev,
+			  struct mock_event_log *log,
+			  u16 handle)
+{
+	struct cxl_event_record_raw *cur;
+
+	lockdep_assert(lockdep_is_held(&log->lock));
+
+	dev_dbg(dev, "Clearing event %u; cur %u\n", handle, log->cur_handle);
+	cur = log->events[handle];
+	if (!cur) {
+		dev_err(dev, "Mock event index %u empty? nr_events %u",
+			handle, log->nr_events);
+		return;
+	}
+	log->events[handle] = NULL;
+
+	event_inc_handle(&log->cur_handle);
+	log->nr_events--;
+	devm_kfree(dev, cur);
 }
 
 static int mock_get_event(struct device *dev, struct cxl_mbox_cmd *cmd)
 {
 	struct cxl_get_event_payload *pl;
 	struct mock_event_log *log;
-	u16 nr_overflow;
 	u8 log_type;
+	u16 handle;
 	int i;
 
 	if (cmd->size_in != sizeof(log_type))
@@ -233,30 +254,38 @@ static int mock_get_event(struct device *dev, struct cxl_mbox_cmd *cmd)
 	if (log_type >= CXL_EVENT_TYPE_MAX)
 		return -EINVAL;
 
-	memset(cmd->payload_out, 0, cmd->size_out);
-
 	log = event_find_log(dev, log_type);
-	if (!log || event_log_empty(log))
+	if (!log)
 		return 0;
 
+	memset(cmd->payload_out, 0, cmd->size_out);
 	pl = cmd->payload_out;
 
-	for (i = 0; i < CXL_TEST_EVENT_CNT && !event_log_empty(log); i++) {
-		memcpy(&pl->records[i], event_get_current(log),
-		       sizeof(pl->records[i]));
-		pl->records[i].hdr.handle = event_get_cur_event_handle(log);
-		log->cur_idx++;
+	read_lock(&log->lock);
+
+	handle = log->cur_handle;
+	dev_dbg(dev, "Get log %d handle %u next %u\n",
+		log_type, handle, log->next_handle);
+	for (i = 0;
+	     i < CXL_TEST_EVENT_CNT && handle != log->next_handle;
+	     i++, event_inc_handle(&handle)) {
+		struct cxl_event_record_raw *cur;
+
+		cur = log->events[handle];
+		dev_dbg(dev, "Sending event log %d handle %d idx %u\n",
+			log_type, le16_to_cpu(cur->hdr.handle), handle);
+		memcpy(&pl->records[i], cur, sizeof(pl->records[i]));
 	}
 
 	pl->record_count = cpu_to_le16(i);
-	if (!event_log_empty(log))
+	if (log->nr_events > i)
 		pl->flags |= CXL_GET_EVENT_FLAG_MORE_RECORDS;
 
 	if (log->nr_overflow) {
 		u64 ns;
 
 		pl->flags |= CXL_GET_EVENT_FLAG_OVERFLOW;
-		pl->overflow_err_count = cpu_to_le16(nr_overflow);
+		pl->overflow_err_count = cpu_to_le16(log->nr_overflow);
 		ns = ktime_get_real_ns();
 		ns -= 5000000000; /* 5s ago */
 		pl->first_overflow_timestamp = cpu_to_le64(ns);
@@ -265,16 +294,17 @@ static int mock_get_event(struct device *dev, struct cxl_mbox_cmd *cmd)
 		pl->last_overflow_timestamp = cpu_to_le64(ns);
 	}
 
+	read_unlock(&log->lock);
 	return 0;
 }
 
 static int mock_clear_event(struct device *dev, struct cxl_mbox_cmd *cmd)
 {
 	struct cxl_mbox_clear_event_payload *pl = cmd->payload_in;
-	struct mock_event_log *log;
 	u8 log_type = pl->event_log;
+	struct mock_event_log *log;
+	int nr, rc = 0;
 	u16 handle;
-	int nr;
 
 	if (log_type >= CXL_EVENT_TYPE_MAX)
 		return -EINVAL;
@@ -283,24 +313,23 @@ static int mock_clear_event(struct device *dev, struct cxl_mbox_cmd *cmd)
 	if (!log)
 		return 0; /* No mock data in this log */
 
-	/*
-	 * This check is technically not invalid per the specification AFAICS.
-	 * (The host could 'guess' handles and clear them in order).
-	 * However, this is not good behavior for the host so test it.
-	 */
-	if (log->clear_idx + pl->nr_recs > log->cur_idx) {
-		dev_err(dev,
-			"Attempting to clear more events than returned!\n");
-		return -EINVAL;
-	}
+	write_lock(&log->lock);
 
 	/* Check handle order prior to clearing events */
-	for (nr = 0, handle = event_get_clear_handle(log);
-	     nr < pl->nr_recs;
-	     nr++, handle++) {
+	handle = log->cur_handle;
+	for (nr = 0;
+	     nr < pl->nr_recs && handle != log->next_handle;
+	     nr++, event_inc_handle(&handle)) {
+
+		dev_dbg(dev, "Checking clear of %d handle %u plhandle %u\n",
+			log_type, handle,
+			le16_to_cpu(pl->handles[nr]));
+
 		if (handle != le16_to_cpu(pl->handles[nr])) {
-			dev_err(dev, "Clearing events out of order\n");
-			return -EINVAL;
+			dev_err(dev, "Clearing events out of order %u %u\n",
+				handle, le16_to_cpu(pl->handles[nr]));
+			rc = -EINVAL;
+			goto unlock;
 		}
 	}
 
@@ -308,25 +337,12 @@ static int mock_clear_event(struct device *dev, struct cxl_mbox_cmd *cmd)
 		log->nr_overflow = 0;
 
 	/* Clear events */
-	log->clear_idx += pl->nr_recs;
-	return 0;
-}
+	for (nr = 0; nr < pl->nr_recs; nr++)
+		mes_del_event(dev, log, le16_to_cpu(pl->handles[nr]));
 
-static void cxl_mock_event_trigger(struct device *dev)
-{
-	struct cxl_mockmem_data *mdata = dev_get_drvdata(dev);
-	struct mock_event_store *mes = &mdata->mes;
-	int i;
-
-	for (i = CXL_EVENT_TYPE_INFO; i < CXL_EVENT_TYPE_MAX; i++) {
-		struct mock_event_log *log;
-
-		log = event_find_log(dev, i);
-		if (log)
-			event_reset_log(log);
-	}
-
-	cxl_mem_get_event_records(mes->mds, mes->ev_status);
+unlock:
+	write_unlock(&log->lock);
+	return rc;
 }
 
 struct cxl_event_record_raw maint_needed = {
@@ -429,8 +445,29 @@ static int mock_set_timestamp(struct cxl_dev_state *cxlds,
 	return 0;
 }
 
-static void cxl_mock_add_event_logs(struct mock_event_store *mes)
+/* Create a dynamically allocated event out of a statically defined event. */
+static void add_event_from_static(struct mock_event_store *mes,
+				  enum cxl_event_log_type log_type,
+				  struct cxl_event_record_raw *raw)
+{
+	struct device *dev = mes->mds->cxlds.dev;
+	struct cxl_event_record_raw *rec;
+
+	rec = devm_kzalloc(dev, sizeof(*rec), GFP_KERNEL);
+	if (!rec) {
+		dev_err(dev, "Failed to alloc event for log\n");
+		return;
+	}
+
+	memcpy(rec, raw, sizeof(*rec));
+	mes_add_event(mes, log_type, rec);
+}
+
+static void cxl_mock_add_event_logs(struct cxl_mockmem_data *mdata)
 {
+	struct mock_event_store *mes = &mdata->mes;
+	struct device *dev = mes->mds->cxlds.dev;
+
 	put_unaligned_le16(CXL_GMER_VALID_CHANNEL | CXL_GMER_VALID_RANK,
 			   &gen_media.validity_flags);
 
@@ -438,43 +475,60 @@ static void cxl_mock_add_event_logs(struct mock_event_store *mes)
 			   CXL_DER_VALID_BANK | CXL_DER_VALID_COLUMN,
 			   &dram.validity_flags);
 
-	mes_add_event(mes, CXL_EVENT_TYPE_INFO, &maint_needed);
-	mes_add_event(mes, CXL_EVENT_TYPE_INFO,
+	dev_dbg(dev, "Generating fake event logs %d\n",
+		CXL_EVENT_TYPE_INFO);
+	add_event_from_static(mes, CXL_EVENT_TYPE_INFO, &maint_needed);
+	add_event_from_static(mes, CXL_EVENT_TYPE_INFO,
 		      (struct cxl_event_record_raw *)&gen_media);
-	mes_add_event(mes, CXL_EVENT_TYPE_INFO,
+	add_event_from_static(mes, CXL_EVENT_TYPE_INFO,
 		      (struct cxl_event_record_raw *)&mem_module);
 	mes->ev_status |= CXLDEV_EVENT_STATUS_INFO;
 
-	mes_add_event(mes, CXL_EVENT_TYPE_FAIL, &maint_needed);
-	mes_add_event(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
-	mes_add_event(mes, CXL_EVENT_TYPE_FAIL,
+	dev_dbg(dev, "Generating fake event logs %d\n",
+		CXL_EVENT_TYPE_FAIL);
+	add_event_from_static(mes, CXL_EVENT_TYPE_FAIL, &maint_needed);
+	add_event_from_static(mes, CXL_EVENT_TYPE_FAIL,
+		      (struct cxl_event_record_raw *)&mem_module);
+	add_event_from_static(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
+	add_event_from_static(mes, CXL_EVENT_TYPE_FAIL,
 		      (struct cxl_event_record_raw *)&dram);
-	mes_add_event(mes, CXL_EVENT_TYPE_FAIL,
+	add_event_from_static(mes, CXL_EVENT_TYPE_FAIL,
 		      (struct cxl_event_record_raw *)&gen_media);
-	mes_add_event(mes, CXL_EVENT_TYPE_FAIL,
+	add_event_from_static(mes, CXL_EVENT_TYPE_FAIL,
 		      (struct cxl_event_record_raw *)&mem_module);
-	mes_add_event(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
-	mes_add_event(mes, CXL_EVENT_TYPE_FAIL,
+	add_event_from_static(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
+	add_event_from_static(mes, CXL_EVENT_TYPE_FAIL,
 		      (struct cxl_event_record_raw *)&dram);
 	/* Overflow this log */
-	mes_add_event(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
-	mes_add_event(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
-	mes_add_event(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
-	mes_add_event(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
-	mes_add_event(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
-	mes_add_event(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
-	mes_add_event(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
-	mes_add_event(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
-	mes_add_event(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
-	mes_add_event(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
+	add_event_from_static(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
+	add_event_from_static(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
+	add_event_from_static(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
+	add_event_from_static(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
+	add_event_from_static(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
+	add_event_from_static(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
+	add_event_from_static(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
+	add_event_from_static(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
+	add_event_from_static(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
+	add_event_from_static(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
 	mes->ev_status |= CXLDEV_EVENT_STATUS_FAIL;
 
-	mes_add_event(mes, CXL_EVENT_TYPE_FATAL, &hardware_replace);
-	mes_add_event(mes, CXL_EVENT_TYPE_FATAL,
+	dev_dbg(dev, "Generating fake event logs %d\n",
+		CXL_EVENT_TYPE_FATAL);
+	add_event_from_static(mes, CXL_EVENT_TYPE_FATAL, &hardware_replace);
+	add_event_from_static(mes, CXL_EVENT_TYPE_FATAL,
 		      (struct cxl_event_record_raw *)&dram);
 	mes->ev_status |= CXLDEV_EVENT_STATUS_FATAL;
 }
 
+static void cxl_mock_event_trigger(struct device *dev)
+{
+	struct cxl_mockmem_data *mdata = dev_get_drvdata(dev);
+	struct mock_event_store *mes = &mdata->mes;
+
+	cxl_mock_add_event_logs(mdata);
+	cxl_mem_get_event_records(mes->mds, mes->ev_status);
+}
+
 static int mock_gsl(struct cxl_mbox_cmd *cmd)
 {
 	if (cmd->size_out < sizeof(mock_gsl_payload))
@@ -1391,6 +1445,14 @@ static ssize_t event_trigger_store(struct device *dev,
 }
 static DEVICE_ATTR_WO(event_trigger);
 
+static void init_event_log(struct mock_event_log *log)
+{
+	rwlock_init(&log->lock);
+	/* Handle can never be 0 use 1 based indexing for handle */
+	log->cur_handle = 1;
+	log->next_handle = 1;
+}
+
 static int __cxl_mock_mem_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
@@ -1458,7 +1520,9 @@ static int __cxl_mock_mem_probe(struct platform_device *pdev)
 		return rc;
 
 	mdata->mes.mds = mds;
-	cxl_mock_add_event_logs(&mdata->mes);
+	for (int i = 0; i < CXL_EVENT_TYPE_MAX; i++)
+		init_event_log(&mdata->mes.mock_logs[i]);
+	cxl_mock_add_event_logs(mdata);
 
 	cxlmd = devm_cxl_add_memdev(cxlds);
 	if (IS_ERR(cxlmd))

-- 
2.41.0


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 5C224C71153
	for <linux-cxl@archiver.kernel.org>; Tue, 29 Aug 2023 05:24:58 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S235709AbjH2FYa (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 29 Aug 2023 01:24:30 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:40500 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S235666AbjH2FYP (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 29 Aug 2023 01:24:15 -0400
Received: from mgamail.intel.com (mgamail.intel.com [134.134.136.100])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id E98BE198;
        Mon, 28 Aug 2023 22:24:11 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1693286652; x=1724822652;
  h=from:date:subject:mime-version:content-transfer-encoding:
   message-id:references:in-reply-to:to:cc;
  bh=zQkGdDHYCbC/ziYaa0AFs4TNsDCAF/BwwDD+JF1yBcU=;
  b=fildFUE6oAaTk1pnQqDIwx2obRmkDdsUBBg7rXjjTAP60BRxk9EGL8U9
   HREktQEYctl5k6H4gWQITFw5S+jOy5MOqiYKZk3PbBtIoSjBbb4LtVahu
   VwhfCGBl3ax9Olml5o9mLqVUDNgkqAA4HmqjjcrA4OSYNAJnmTplUe/rY
   LGdq+I7y9dRvNlp55NMVUOZEIVFUKFQ/YPDmAzJn1M9VvtG3rJ6pATMTA
   s+NHuxulSJVVJF2IEsMWVeXUMvxmDJg5HU5BIkocm6Xp04VAioBhQYBVo
   KrxxccXWGfPc+l0d9P0I+dXrZmXhaOQISRmDz4UlhVy9lFYCI5DqQyXAL
   w==;
X-IronPort-AV: E=McAfee;i="6600,9927,10816"; a="441625243"
X-IronPort-AV: E=Sophos;i="6.02,208,1688454000"; 
   d="scan'208";a="441625243"
Received: from orsmga002.jf.intel.com ([10.7.209.21])
  by orsmga105.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 28 Aug 2023 22:23:48 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10816"; a="738556415"
X-IronPort-AV: E=Sophos;i="6.02,208,1688454000"; 
   d="scan'208";a="738556415"
Received: from iweiny-mobl.amr.corp.intel.com (HELO localhost) ([10.212.37.183])
  by orsmga002-auth.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 28 Aug 2023 22:23:47 -0700
From: Ira Weiny <ira.weiny@intel.com>
Date: Mon, 28 Aug 2023 22:21:04 -0700
Subject: [PATCH RFC v2 13/18] dax/bus: Factor out dev dax resize logic
MIME-Version: 1.0
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: 7bit
Message-Id: <20230604-dcd-type2-upstream-v2-13-f740c47e7916@intel.com>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
In-Reply-To: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
To: Dan Williams <dan.j.williams@intel.com>
Cc: Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        Ira Weiny <ira.weiny@intel.com>, linux-cxl@vger.kernel.org,
        linux-kernel@vger.kernel.org
X-Mailer: b4 0.13-dev-c6835
X-Developer-Signature: v=1; a=ed25519-sha256; t=1693286607; l=8374;
 i=ira.weiny@intel.com; s=20221211; h=from:subject:message-id;
 bh=zQkGdDHYCbC/ziYaa0AFs4TNsDCAF/BwwDD+JF1yBcU=;
 b=SJ6URvjXJ/bWBKBHjdjLJr0jCvokK+k9hzrEC88hLUmjD3Wb76Bd8DSSOCSXchPZEmUlbiw4z
 pNq7DQSeQ2PDTv8yW+I1JRAvOztwDbYQl5CZNGlTZ8GjEhroE8Sp6BV
X-Developer-Key: i=ira.weiny@intel.com; a=ed25519;
 pk=noldbkG+Wp1qXRrrkfY1QJpDf7QsOEthbOT7vm0PqsE=
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

Dynamic Capacity regions must limit dev dax resources to those areas
which have extents backing real memory.  Four alternatives were
considered to manage the intersection of region space and extents:

1) Create a single region resource child on region creation which
   reserves the entire region.  Then as extents are added punch holes in
   this reservation.  This requires new resource manipulation to punch
   the holes and still requires an additional iteration over the extent
   areas which may already have existing dev dax resources used.

2) Maintain an ordered xarray of extents which can be queried while
   processing the resize logic.  The issue is that existing region->res
   children may artificially limit the allocation size sent to
   alloc_dev_dax_range().  IE the resource children can't be directly
   used in the resize logic to find where space in the region is.

3) Maintain a separate resource tree with extents.  This option is the
   same as 2) but with a different data structure.  Most ideally we have
   some unified representation of the resource tree.

4) Create region resource children for each extent.  Manage the dax dev
   resize logic in the same way as before but use a region child
   (extent) resource as the parents to find space within each extent.

Option 4 can leverage the existing resize algorithm to find space within
the extents.

In preparation for this change, factor out the dev_dax_resize logic.
For static regions use dax_region->res as the parent to find space for
the dax ranges.  Future patches will use the same algorithm with
individual extent resources as the parent.

Signed-off-by: Ira Weiny <ira.weiny@intel.com>
---
 drivers/dax/bus.c | 128 +++++++++++++++++++++++++++++++++---------------------
 1 file changed, 79 insertions(+), 49 deletions(-)

diff --git a/drivers/dax/bus.c b/drivers/dax/bus.c
index b76e49813a39..ea7ae82b4687 100644
--- a/drivers/dax/bus.c
+++ b/drivers/dax/bus.c
@@ -817,11 +817,10 @@ static int devm_register_dax_mapping(struct dev_dax *dev_dax, int range_id)
 	return 0;
 }
 
-static int alloc_dev_dax_range(struct dev_dax *dev_dax, u64 start,
-		resource_size_t size)
+static int alloc_dev_dax_range(struct resource *parent, struct dev_dax *dev_dax,
+			       u64 start, resource_size_t size)
 {
 	struct dax_region *dax_region = dev_dax->region;
-	struct resource *res = &dax_region->res;
 	struct device *dev = &dev_dax->dev;
 	struct dev_dax_range *ranges;
 	unsigned long pgoff = 0;
@@ -839,14 +838,14 @@ static int alloc_dev_dax_range(struct dev_dax *dev_dax, u64 start,
 		return 0;
 	}
 
-	alloc = __request_region(res, start, size, dev_name(dev), 0);
+	alloc = __request_region(parent, start, size, dev_name(dev), 0);
 	if (!alloc)
 		return -ENOMEM;
 
 	ranges = krealloc(dev_dax->ranges, sizeof(*ranges)
 			* (dev_dax->nr_range + 1), GFP_KERNEL);
 	if (!ranges) {
-		__release_region(res, alloc->start, resource_size(alloc));
+		__release_region(parent, alloc->start, resource_size(alloc));
 		return -ENOMEM;
 	}
 
@@ -997,50 +996,45 @@ static bool adjust_ok(struct dev_dax *dev_dax, struct resource *res)
 	return true;
 }
 
-static ssize_t dev_dax_resize(struct dax_region *dax_region,
-		struct dev_dax *dev_dax, resource_size_t size)
+/*
+ * dev_dax_resize_static - Expand the device into the unused portion of the
+ * region. This may involve adjusting the end of an existing resource, or
+ * allocating a new resource.
+ *
+ * @parent: parent resource to allocate this range in.
+ * @dev_dax: DAX device we are creating this range for
+ * @to_alloc: amount of space to alloc; must be <= space available in @parent
+ *
+ * Return the amount of space allocated or -ERRNO on failure
+ */
+static ssize_t dev_dax_resize_static(struct resource *parent,
+				     struct dev_dax *dev_dax,
+				     resource_size_t to_alloc)
 {
-	resource_size_t avail = dax_region_avail_size(dax_region), to_alloc;
-	resource_size_t dev_size = dev_dax_size(dev_dax);
-	struct resource *region_res = &dax_region->res;
-	struct device *dev = &dev_dax->dev;
 	struct resource *res, *first;
-	resource_size_t alloc = 0;
 	int rc;
 
-	if (dev->driver)
-		return -EBUSY;
-	if (size == dev_size)
-		return 0;
-	if (size > dev_size && size - dev_size > avail)
-		return -ENOSPC;
-	if (size < dev_size)
-		return dev_dax_shrink(dev_dax, size);
-
-	to_alloc = size - dev_size;
-	if (dev_WARN_ONCE(dev, !alloc_is_aligned(dev_dax, to_alloc),
-			"resize of %pa misaligned\n", &to_alloc))
-		return -ENXIO;
-
-	/*
-	 * Expand the device into the unused portion of the region. This
-	 * may involve adjusting the end of an existing resource, or
-	 * allocating a new resource.
-	 */
-retry:
-	first = region_res->child;
-	if (!first)
-		return alloc_dev_dax_range(dev_dax, dax_region->res.start, to_alloc);
+	first = parent->child;
+	if (!first) {
+		rc = alloc_dev_dax_range(parent, dev_dax,
+					   parent->start, to_alloc);
+		if (rc)
+			return rc;
+		return to_alloc;
+	}
 
-	rc = -ENOSPC;
 	for (res = first; res; res = res->sibling) {
 		struct resource *next = res->sibling;
+		resource_size_t alloc;
 
 		/* space at the beginning of the region */
-		if (res == first && res->start > dax_region->res.start) {
-			alloc = min(res->start - dax_region->res.start, to_alloc);
-			rc = alloc_dev_dax_range(dev_dax, dax_region->res.start, alloc);
-			break;
+		if (res == first && res->start > parent->start) {
+			alloc = min(res->start - parent->start, to_alloc);
+			rc = alloc_dev_dax_range(parent, dev_dax,
+						 parent->start, alloc);
+			if (rc)
+				return rc;
+			return alloc;
 		}
 
 		alloc = 0;
@@ -1049,21 +1043,55 @@ static ssize_t dev_dax_resize(struct dax_region *dax_region,
 			alloc = min(next->start - (res->end + 1), to_alloc);
 
 		/* space at the end of the region */
-		if (!alloc && !next && res->end < region_res->end)
-			alloc = min(region_res->end - res->end, to_alloc);
+		if (!alloc && !next && res->end < parent->end)
+			alloc = min(parent->end - res->end, to_alloc);
 
 		if (!alloc)
 			continue;
 
 		if (adjust_ok(dev_dax, res)) {
 			rc = adjust_dev_dax_range(dev_dax, res, resource_size(res) + alloc);
-			break;
+			if (rc)
+				return rc;
+			return alloc;
 		}
-		rc = alloc_dev_dax_range(dev_dax, res->end + 1, alloc);
-		break;
+		rc = alloc_dev_dax_range(parent, dev_dax, res->end + 1, alloc);
+		if (rc)
+			return rc;
+		return alloc;
 	}
-	if (rc)
-		return rc;
+
+	/* available was already calculated and should never be an issue */
+	dev_WARN_ONCE(&dev_dax->dev, 1, "space not found?");
+	return 0;
+}
+
+static ssize_t dev_dax_resize(struct dax_region *dax_region,
+		struct dev_dax *dev_dax, resource_size_t size)
+{
+	resource_size_t avail = dax_region_avail_size(dax_region), to_alloc;
+	resource_size_t dev_size = dev_dax_size(dev_dax);
+	struct device *dev = &dev_dax->dev;
+	resource_size_t alloc = 0;
+
+	if (dev->driver)
+		return -EBUSY;
+	if (size == dev_size)
+		return 0;
+	if (size > dev_size && size - dev_size > avail)
+		return -ENOSPC;
+	if (size < dev_size)
+		return dev_dax_shrink(dev_dax, size);
+
+	to_alloc = size - dev_size;
+	if (dev_WARN_ONCE(dev, !alloc_is_aligned(dev_dax, to_alloc),
+			"resize of %pa misaligned\n", &to_alloc))
+		return -ENXIO;
+
+retry:
+	alloc = dev_dax_resize_static(&dax_region->res, dev_dax, to_alloc);
+	if (alloc <= 0)
+		return alloc;
 	to_alloc -= alloc;
 	if (to_alloc)
 		goto retry;
@@ -1154,7 +1182,8 @@ static ssize_t mapping_store(struct device *dev, struct device_attribute *attr,
 
 	to_alloc = range_len(&r);
 	if (alloc_is_aligned(dev_dax, to_alloc))
-		rc = alloc_dev_dax_range(dev_dax, r.start, to_alloc);
+		rc = alloc_dev_dax_range(&dax_region->res, dev_dax, r.start,
+					 to_alloc);
 	device_unlock(dev);
 	device_unlock(dax_region->dev);
 
@@ -1371,7 +1400,8 @@ struct dev_dax *devm_create_dev_dax(struct dev_dax_data *data)
 	device_initialize(dev);
 	dev_set_name(dev, "dax%d.%d", dax_region->id, dev_dax->id);
 
-	rc = alloc_dev_dax_range(dev_dax, dax_region->res.start, data->size);
+	rc = alloc_dev_dax_range(&dax_region->res, dev_dax, dax_region->res.start,
+				 data->size);
 	if (rc)
 		goto err_range;
 

-- 
2.41.0


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id D6E46C83F26
	for <linux-cxl@archiver.kernel.org>; Tue, 29 Aug 2023 05:24:56 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S235646AbjH2FY1 (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 29 Aug 2023 01:24:27 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:40484 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S235665AbjH2FYO (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 29 Aug 2023 01:24:14 -0400
Received: from mgamail.intel.com (mgamail.intel.com [134.134.136.100])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 7185319B;
        Mon, 28 Aug 2023 22:24:11 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1693286651; x=1724822651;
  h=from:date:subject:mime-version:content-transfer-encoding:
   message-id:references:in-reply-to:to:cc;
  bh=DZMaf28aqfjymKMjlQYhoxICqfP5W5OJWqpOsQJfEv4=;
  b=d+CE8HVHwruafsvotXhxSzTxxPWOGTJvldAlsJsT5KRU3L8L9S7YECxk
   M8yebkT9AG3fC/7SzvYNkcqy7V5Op1ogX995cnadfKKXP45YgFbMtigg4
   zkUWPyUgA+tai8nmCFdHapkjbCaqZOTIk3t0XbEXIu7ATt635Usmi+OPr
   0zwCw+jaRcdV1LJWbhZUKjaxV53Rlpgcr7UyHIG8LPZbPrKWthQd/wjQ/
   6HmxlJ55Fyb0Dm5TYmQJuogO+Nge6519DiGXV7eKuyPTrkVmIDHSi3zB/
   Zs3xoIb4aPOTQTmAET+LFSgYhSK5KKEW1lMb0aBw64jO6+oSrJUImaxn5
   g==;
X-IronPort-AV: E=McAfee;i="6600,9927,10816"; a="441625251"
X-IronPort-AV: E=Sophos;i="6.02,208,1688454000"; 
   d="scan'208";a="441625251"
Received: from orsmga002.jf.intel.com ([10.7.209.21])
  by orsmga105.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 28 Aug 2023 22:23:49 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10816"; a="738556431"
X-IronPort-AV: E=Sophos;i="6.02,208,1688454000"; 
   d="scan'208";a="738556431"
Received: from iweiny-mobl.amr.corp.intel.com (HELO localhost) ([10.212.37.183])
  by orsmga002-auth.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 28 Aug 2023 22:23:49 -0700
From: ira.weiny@intel.com
Date: Mon, 28 Aug 2023 22:21:06 -0700
Subject: [PATCH RFC v2 15/18] cxl/mem: Trace Dynamic capacity Event Record
MIME-Version: 1.0
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: 7bit
Message-Id: <20230604-dcd-type2-upstream-v2-15-f740c47e7916@intel.com>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
In-Reply-To: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
To: Dan Williams <dan.j.williams@intel.com>
Cc: Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        Ira Weiny <ira.weiny@intel.com>, linux-cxl@vger.kernel.org,
        linux-kernel@vger.kernel.org
X-Mailer: b4 0.13-dev-c6835
X-Developer-Signature: v=1; a=ed25519-sha256; t=1693286607; l=3471;
 i=ira.weiny@intel.com; s=20221211; h=from:subject:message-id;
 bh=SkFWqVM1cpX13lEJuDcPSmo7A5I8/gNre3e4u4Y5C1o=;
 b=fHj3NceUK4qggURnK1NFp9VSp2SqReAkE5YbMlRMT5Nh504PzIxI1151YDCCrvlobitFjkU/Z
 jQ0JWRfjiZACR6gyzJu6+Kg7UPofwhlhi93pnLyDcPmbirDSOynxJIE
X-Developer-Key: i=ira.weiny@intel.com; a=ed25519;
 pk=noldbkG+Wp1qXRrrkfY1QJpDf7QsOEthbOT7vm0PqsE=
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

From: Navneet Singh <navneet.singh@intel.com>

CXL rev 3.0 section 8.2.9.2.1.5 defines the Dynamic Capacity Event Record
Determine if the event read is a Dynamic capacity event record and
if so trace the record for the debug purpose.

Add DC trace points to the trace log.

Signed-off-by: Navneet Singh <navneet.singh@intel.com>
Signed-off-by: Ira Weiny <ira.weiny@intel.com>

---
[iweiny: fixups]
---
 drivers/cxl/core/mbox.c  |  5 ++++
 drivers/cxl/core/trace.h | 65 ++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 70 insertions(+)

diff --git a/drivers/cxl/core/mbox.c b/drivers/cxl/core/mbox.c
index 9d9c13e13ecf..9462c34aa1dc 100644
--- a/drivers/cxl/core/mbox.c
+++ b/drivers/cxl/core/mbox.c
@@ -939,6 +939,11 @@ static void cxl_event_trace_record(const struct cxl_memdev *cxlmd,
 				(struct cxl_event_mem_module *)record;
 
 		trace_cxl_memory_module(cxlmd, type, rec);
+	} else if (uuid_equal(id, &dc_event_uuid)) {
+		struct dcd_event_dyn_cap *rec =
+				(struct dcd_event_dyn_cap *)record;
+
+		trace_cxl_dynamic_capacity(cxlmd, type, rec);
 	} else {
 		/* For unknown record types print just the header */
 		trace_cxl_generic_event(cxlmd, type, record);
diff --git a/drivers/cxl/core/trace.h b/drivers/cxl/core/trace.h
index a0b5819bc70b..1899c5cc96b9 100644
--- a/drivers/cxl/core/trace.h
+++ b/drivers/cxl/core/trace.h
@@ -703,6 +703,71 @@ TRACE_EVENT(cxl_poison,
 	)
 );
 
+/*
+ * DYNAMIC CAPACITY Event Record - DER
+ *
+ * CXL rev 3.0 section 8.2.9.2.1.5 Table 8-47
+ */
+
+#define CXL_DC_ADD_CAPACITY			0x00
+#define CXL_DC_REL_CAPACITY			0x01
+#define CXL_DC_FORCED_REL_CAPACITY		0x02
+#define CXL_DC_REG_CONF_UPDATED			0x03
+#define show_dc_evt_type(type)	__print_symbolic(type,		\
+	{ CXL_DC_ADD_CAPACITY,	"Add capacity"},		\
+	{ CXL_DC_REL_CAPACITY,	"Release capacity"},		\
+	{ CXL_DC_FORCED_REL_CAPACITY,	"Forced capacity release"},	\
+	{ CXL_DC_REG_CONF_UPDATED,	"Region Configuration Updated"	} \
+)
+
+TRACE_EVENT(cxl_dynamic_capacity,
+
+	TP_PROTO(const struct cxl_memdev *cxlmd, enum cxl_event_log_type log,
+		 struct dcd_event_dyn_cap  *rec),
+
+	TP_ARGS(cxlmd, log, rec),
+
+	TP_STRUCT__entry(
+		CXL_EVT_TP_entry
+
+		/* Dynamic capacity Event */
+		__field(u8, event_type)
+		__field(u16, hostid)
+		__field(u8, region_id)
+		__field(u64, dpa_start)
+		__field(u64, length)
+		__array(u8, tag, CXL_DC_EXTENT_TAG_LEN)
+		__field(u16, sh_extent_seq)
+	),
+
+	TP_fast_assign(
+		CXL_EVT_TP_fast_assign(cxlmd, log, rec->hdr);
+
+		/* Dynamic_capacity Event */
+		__entry->event_type = rec->data.event_type;
+
+		/* DCD event record data */
+		__entry->hostid = le16_to_cpu(rec->data.host_id);
+		__entry->region_id = rec->data.region_index;
+		__entry->dpa_start = le64_to_cpu(rec->data.extent.start_dpa);
+		__entry->length = le64_to_cpu(rec->data.extent.length);
+		memcpy(__entry->tag, &rec->data.extent.tag, CXL_DC_EXTENT_TAG_LEN);
+		__entry->sh_extent_seq = le16_to_cpu(rec->data.extent.shared_extn_seq);
+	),
+
+	CXL_EVT_TP_printk("event_type='%s' host_id='%d' region_id='%d' " \
+		"starting_dpa=%llx length=%llx tag=%s " \
+		"shared_extent_sequence=%d",
+		show_dc_evt_type(__entry->event_type),
+		__entry->hostid,
+		__entry->region_id,
+		__entry->dpa_start,
+		__entry->length,
+		__print_hex(__entry->tag, CXL_DC_EXTENT_TAG_LEN),
+		__entry->sh_extent_seq
+	)
+);
+
 #endif /* _CXL_EVENTS_H */
 
 #define TRACE_INCLUDE_FILE trace

-- 
2.41.0


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id C1315C83F27
	for <linux-cxl@archiver.kernel.org>; Tue, 29 Aug 2023 05:24:56 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S235694AbjH2FY1 (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 29 Aug 2023 01:24:27 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:40460 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S235664AbjH2FYN (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 29 Aug 2023 01:24:13 -0400
Received: from mgamail.intel.com (mgamail.intel.com [134.134.136.100])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id B7DAB198;
        Mon, 28 Aug 2023 22:24:09 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1693286649; x=1724822649;
  h=from:date:subject:mime-version:content-transfer-encoding:
   message-id:references:in-reply-to:to:cc;
  bh=R+V131ndOPIZGxf8bri6fiUZIEtyiDv+wVzl0NXO138=;
  b=LvxDdpTg+TdxEXj83u4YzwP0ACYW507zvfW9hS9oy1L7EfQVawlN7iLT
   J2Y/DzsZrVKhT/pI8j7Hndw5zNTaWpfbdmrO4pjmLbysKHZk4OeSlvykM
   XvTksIjEe7v8KqyhFu2edLwQjBKmbroZWM+LeswM/APl3tcvMIrtxVaRX
   hRKDmKVDtG5Jy8mzGuWFVz2fuKoKqRqItT74XBTQshYgNYPY4fd0cdnkz
   80UHNbh6svPN3wuF9hutwHs2SS1WTWCOqu0uG5lK26MX43HwMILLncEWa
   6/nP70dbSLHnh0p9ViLUHe4Z2isDjY22CJYWGT/kkrvhdtiVhJVe2Y30z
   w==;
X-IronPort-AV: E=McAfee;i="6600,9927,10816"; a="441625239"
X-IronPort-AV: E=Sophos;i="6.02,208,1688454000"; 
   d="scan'208";a="441625239"
Received: from orsmga002.jf.intel.com ([10.7.209.21])
  by orsmga105.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 28 Aug 2023 22:23:45 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10816"; a="738556409"
X-IronPort-AV: E=Sophos;i="6.02,208,1688454000"; 
   d="scan'208";a="738556409"
Received: from iweiny-mobl.amr.corp.intel.com (HELO localhost) ([10.212.37.183])
  by orsmga002-auth.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 28 Aug 2023 22:23:46 -0700
From: Ira Weiny <ira.weiny@intel.com>
Date: Mon, 28 Aug 2023 22:21:03 -0700
Subject: [PATCH RFC v2 12/18] cxl/region: Notify regions of DC changes
MIME-Version: 1.0
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: 7bit
Message-Id: <20230604-dcd-type2-upstream-v2-12-f740c47e7916@intel.com>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
In-Reply-To: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
To: Dan Williams <dan.j.williams@intel.com>
Cc: Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        Ira Weiny <ira.weiny@intel.com>, linux-cxl@vger.kernel.org,
        linux-kernel@vger.kernel.org
X-Mailer: b4 0.13-dev-c6835
X-Developer-Signature: v=1; a=ed25519-sha256; t=1693286607; l=18741;
 i=ira.weiny@intel.com; s=20221211; h=from:subject:message-id;
 bh=R+V131ndOPIZGxf8bri6fiUZIEtyiDv+wVzl0NXO138=;
 b=mnjz2FZBE42CM8m2cjFnKTyUsPCTL61X1w6U9V900FmgQaAivYw63dlCOFBEbuOAdlTpHFH7q
 lq4jkg7KrLNCkqQsdpK9BXFCPw+wCbSZlKwkvpeETup6pkQl4uJ0Tn6
X-Developer-Key: i=ira.weiny@intel.com; a=ed25519;
 pk=noldbkG+Wp1qXRrrkfY1QJpDf7QsOEthbOT7vm0PqsE=
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

In order for a user to use dynamic capacity effectively they need to
know when dynamic capacity is available.  Thus when Dynamic Capacity
(DC) extents are added or removed by a DC device the regions affected
need to be notified.  Ultimately the DAX region uses the memory
associated with DC extents.  However, remember that CXL DAX regions
maintain any interleave details between devices.

When a DCD event occurs, iterate all CXL endpoint decoders and notify
regions which contain the endpoints affected by the event.  In turn
notify the DAX regions of the changes to the DAX region extents.

For now interleave is handled by creating simple 1:1 mappings between
the CXL DAX region and DAX region layers.  Future implementations will
need to resolve when to actually surface a DAX region extent and pass
the notification along.

Remember that adding capacity is safe because there is no chance of the
memory being in use.  Also remember at this point releasing capacity is
straight forward because DAX devices do not yet have references to the
extents.  Future patches will handle that complication.

Signed-off-by: Ira Weiny <ira.weiny@intel.com>

---
Changes from v1:
[iweiny: Rewrite]
---
 drivers/cxl/core/mbox.c   |  39 +++++++++++++--
 drivers/cxl/core/region.c | 123 +++++++++++++++++++++++++++++++++++++++++-----
 drivers/cxl/cxl.h         |  22 +++++++++
 drivers/cxl/mem.c         |  50 +++++++++++++++++++
 drivers/dax/cxl.c         |  99 ++++++++++++++++++++++++++++++-------
 drivers/dax/dax-private.h |   3 ++
 drivers/dax/extent.c      |  14 ++++++
 7 files changed, 317 insertions(+), 33 deletions(-)

diff --git a/drivers/cxl/core/mbox.c b/drivers/cxl/core/mbox.c
index 5472ab1d0370..9d9c13e13ecf 100644
--- a/drivers/cxl/core/mbox.c
+++ b/drivers/cxl/core/mbox.c
@@ -824,6 +824,35 @@ int cxl_enumerate_cmds(struct cxl_memdev_state *mds)
 }
 EXPORT_SYMBOL_NS_GPL(cxl_enumerate_cmds, CXL);
 
+static int cxl_notify_dc_extent(struct cxl_memdev_state *mds,
+				enum dc_event event,
+				struct cxl_dc_extent_data *extent)
+{
+	struct cxl_drv_nd nd = (struct cxl_drv_nd) {
+		.event = event,
+		.extent = extent
+	};
+	struct device *dev;
+	int rc = 0;
+
+	dev = &mds->cxlds.cxlmd->dev;
+	dev_dbg(dev, "Trying notify: type %d DPA:%llx LEN:%llx\n",
+		event, extent->dpa_start, extent->length);
+
+	device_lock(dev);
+	if (dev->driver) {
+		struct cxl_driver *mem_drv = to_cxl_drv(dev->driver);
+
+		if (mem_drv->notify) {
+			dev_dbg(dev, "Notify: type %d DPA:%llx LEN:%llx\n",
+				event, extent->dpa_start, extent->length);
+			rc = mem_drv->notify(dev, &nd);
+		}
+	}
+	device_unlock(dev);
+	return rc;
+}
+
 static int cxl_store_dc_extent(struct cxl_memdev_state *mds,
 			       struct cxl_dc_extent *dc_extent)
 {
@@ -852,9 +881,10 @@ static int cxl_store_dc_extent(struct cxl_memdev_state *mds,
 			dev_warn_once(dev, "Duplicate extent DPA:%llx LEN:%llx\n",
 				      extent->dpa_start, extent->length);
 		kfree(extent);
+		return rc;
 	}
 
-	return rc;
+	return cxl_notify_dc_extent(mds, DCD_ADD_CAPACITY, extent);
 }
 
 /*
@@ -1074,7 +1104,8 @@ void cxl_dc_extent_put(struct cxl_dc_extent_data *extent)
 EXPORT_SYMBOL_NS_GPL(cxl_dc_extent_put, CXL);
 
 static int cxl_handle_dcd_release_event(struct cxl_memdev_state *mds,
-					struct cxl_dc_extent *rel_extent)
+					struct cxl_dc_extent *rel_extent,
+					enum dc_event event)
 {
 	struct device *dev = mds->cxlds.dev;
 	struct cxl_dc_extent_data *extent;
@@ -1090,6 +1121,7 @@ static int cxl_handle_dcd_release_event(struct cxl_memdev_state *mds,
 		dev_err(dev, "No extent found with DPA:0x%llx\n", dpa);
 		return -EINVAL;
 	}
+	cxl_notify_dc_extent(mds, event, extent);
 	cxl_dc_extent_put(extent);
 	return 0;
 }
@@ -1151,7 +1183,8 @@ static int cxl_handle_dcd_event_records(struct cxl_memdev_state *mds,
 		break;
 	case DCD_RELEASE_CAPACITY:
         case DCD_FORCED_CAPACITY_RELEASE:
-		rc = cxl_handle_dcd_release_event(mds, &record->data.extent);
+		rc = cxl_handle_dcd_release_event(mds, &record->data.extent,
+						  record->data.event_type);
 		break;
 	default:
 		return -EINVAL;
diff --git a/drivers/cxl/core/region.c b/drivers/cxl/core/region.c
index 0aeea50550f6..a0c1f2793dd7 100644
--- a/drivers/cxl/core/region.c
+++ b/drivers/cxl/core/region.c
@@ -1547,8 +1547,8 @@ static int cxl_region_validate_position(struct cxl_region *cxlr,
 	return 0;
 }
 
-static bool cxl_dc_extent_in_ed(struct cxl_endpoint_decoder *cxled,
-				struct cxl_dc_extent_data *extent)
+bool cxl_dc_extent_in_ed(struct cxl_endpoint_decoder *cxled,
+			 struct cxl_dc_extent_data *extent)
 {
 	struct range dpa_range = (struct range){
 		.start = extent->dpa_start,
@@ -1567,14 +1567,66 @@ static bool cxl_dc_extent_in_ed(struct cxl_endpoint_decoder *cxled,
 	return (cxled->dpa_res->start <= dpa_range.start &&
 		dpa_range.end <= cxled->dpa_res->end);
 }
+EXPORT_SYMBOL_NS_GPL(cxl_dc_extent_in_ed, CXL);
+
+static int cxl_region_notify_extent(struct cxl_endpoint_decoder *cxled,
+				    enum dc_event event,
+				    struct cxl_dr_extent *cxl_dr_ext)
+{
+	struct cxl_dax_region *cxlr_dax;
+	struct device *dev;
+	int rc = 0;
+
+	cxlr_dax = cxled->cxld.region->cxlr_dax;
+	dev = &cxlr_dax->dev;
+	dev_dbg(dev, "Trying notify: type %d HPA:%llx LEN:%llx\n",
+		event, cxl_dr_ext->hpa_offset, cxl_dr_ext->hpa_length);
+
+	device_lock(dev);
+	if (dev->driver) {
+		struct cxl_driver *reg_drv = to_cxl_drv(dev->driver);
+		struct cxl_drv_nd nd = (struct cxl_drv_nd) {
+			.event = event,
+			.cxl_dr_ext = cxl_dr_ext,
+		};
+
+		if (reg_drv->notify) {
+			dev_dbg(dev, "Notify: type %d HPA:%llx LEN:%llx\n",
+				event, cxl_dr_ext->hpa_offset,
+				cxl_dr_ext->hpa_length);
+			rc = reg_drv->notify(dev, &nd);
+		}
+	}
+	device_unlock(dev);
+	return rc;
+}
+
+static resource_size_t
+cxl_dc_extent_to_hpa_offset(struct cxl_endpoint_decoder *cxled,
+			    struct cxl_dc_extent_data *extent)
+{
+	struct cxl_dax_region *cxlr_dax;
+	resource_size_t dpa_offset, hpa;
+	struct range *ed_hpa_range;
+
+	cxlr_dax = cxled->cxld.region->cxlr_dax;
+
+	/*
+	 * Without interleave...
+	 * HPA offset == DPA offset
+	 * ... but do the math anyway
+	 */
+	dpa_offset = extent->dpa_start - cxled->dpa_res->start;
+	ed_hpa_range = &cxled->cxld.hpa_range;
+	hpa = ed_hpa_range->start + dpa_offset;
+	return hpa - cxlr_dax->hpa_range.start;
+}
 
 static int cxl_ed_add_one_extent(struct cxl_endpoint_decoder *cxled,
 				 struct cxl_dc_extent_data *extent)
 {
 	struct cxl_dr_extent *cxl_dr_ext;
 	struct cxl_dax_region *cxlr_dax;
-	resource_size_t dpa_offset, hpa;
-	struct range *ed_hpa_range;
 	struct device *dev;
 	int rc;
 
@@ -1601,15 +1653,7 @@ static int cxl_ed_add_one_extent(struct cxl_endpoint_decoder *cxled,
 	cxl_dr_ext->extent = extent;
 	kref_init(&cxl_dr_ext->region_ref);
 
-	/*
-	 * Without interleave...
-	 * HPA offset == DPA offset
-	 * ... but do the math anyway
-	 */
-	dpa_offset = extent->dpa_start - cxled->dpa_res->start;
-	ed_hpa_range = &cxled->cxld.hpa_range;
-	hpa = ed_hpa_range->start + dpa_offset;
-	cxl_dr_ext->hpa_offset = hpa - cxlr_dax->hpa_range.start;
+	cxl_dr_ext->hpa_offset = cxl_dc_extent_to_hpa_offset(cxled, extent);
 
 	/* Without interleave carry length and label through */
 	cxl_dr_ext->hpa_length = extent->length;
@@ -1626,6 +1670,7 @@ static int cxl_ed_add_one_extent(struct cxl_endpoint_decoder *cxled,
 	}
 	/* Put in cxl_dr_release() */
 	cxl_dc_extent_get(cxl_dr_ext->extent);
+	cxl_region_notify_extent(cxled, DCD_ADD_CAPACITY, cxl_dr_ext);
 	return 0;
 }
 
@@ -1663,6 +1708,58 @@ static int cxl_ed_add_extents(struct cxl_endpoint_decoder *cxled)
 	return 0;
 }
 
+static int cxl_ed_rm_dc_extent(struct cxl_endpoint_decoder *cxled,
+			       enum dc_event event,
+			       struct cxl_dc_extent_data *extent)
+{
+	struct cxl_region *cxlr = cxled->cxld.region;
+	struct cxl_dax_region *cxlr_dax = cxlr->cxlr_dax;
+	struct cxl_dr_extent *cxl_dr_ext;
+	resource_size_t hpa_offset;
+
+	hpa_offset = cxl_dc_extent_to_hpa_offset(cxled, extent);
+
+	/*
+	 * NOTE on Interleaving: There is no need to 'break up' the cxl_dr_ext.
+	 * If one of the extents comprising it is gone it should be removed
+	 * from the region to prevent future use.  Later code may save other
+	 * extents for future processing.  But for now the corelation is 1:1:1
+	 * so just erase the extent.
+	 */
+	cxl_dr_ext = xa_erase(&cxlr_dax->extents, hpa_offset);
+
+	dev_dbg(&cxlr_dax->dev, "Remove DAX region ext HPA:%llx\n",
+		cxl_dr_ext->hpa_offset);
+	cxl_region_notify_extent(cxled, event, cxl_dr_ext);
+	cxl_dr_extent_put(cxl_dr_ext);
+	return 0;
+}
+
+int cxl_ed_notify_extent(struct cxl_endpoint_decoder *cxled,
+			 struct cxl_drv_nd *nd)
+{
+	int rc = 0;
+
+	switch (nd->event) {
+	case DCD_ADD_CAPACITY:
+		if (cxl_dc_extent_get_not_zero(nd->extent)) {
+			rc = cxl_ed_add_one_extent(cxled, nd->extent);
+			if (rc)
+				cxl_dc_extent_put(nd->extent);
+		}
+		break;
+	case DCD_RELEASE_CAPACITY:
+	case DCD_FORCED_CAPACITY_RELEASE:
+		rc = cxl_ed_rm_dc_extent(cxled, nd->event, nd->extent);
+		break;
+	default:
+		dev_err(&cxled->cxld.dev, "Unknown DC event %d\n", nd->event);
+		break;
+	}
+	return rc;
+}
+EXPORT_SYMBOL_NS_GPL(cxl_ed_notify_extent, CXL);
+
 static int cxl_region_attach_position(struct cxl_region *cxlr,
 				      struct cxl_root_decoder *cxlrd,
 				      struct cxl_endpoint_decoder *cxled,
diff --git a/drivers/cxl/cxl.h b/drivers/cxl/cxl.h
index 177b892ac53f..2c73a30980b6 100644
--- a/drivers/cxl/cxl.h
+++ b/drivers/cxl/cxl.h
@@ -838,10 +838,18 @@ bool is_cxl_region(struct device *dev);
 
 extern struct bus_type cxl_bus_type;
 
+/* Driver Notifier Data */
+struct cxl_drv_nd {
+	enum dc_event event;
+	struct cxl_dc_extent_data *extent;
+	struct cxl_dr_extent *cxl_dr_ext;
+};
+
 struct cxl_driver {
 	const char *name;
 	int (*probe)(struct device *dev);
 	void (*remove)(struct device *dev);
+	int (*notify)(struct device *dev, struct cxl_drv_nd *nd);
 	struct device_driver drv;
 	int id;
 };
@@ -887,6 +895,10 @@ struct cxl_pmem_region *to_cxl_pmem_region(struct device *dev);
 int cxl_add_to_region(struct cxl_port *root,
 		      struct cxl_endpoint_decoder *cxled);
 struct cxl_dax_region *to_cxl_dax_region(struct device *dev);
+bool cxl_dc_extent_in_ed(struct cxl_endpoint_decoder *cxled,
+			 struct cxl_dc_extent_data *extent);
+int cxl_ed_notify_extent(struct cxl_endpoint_decoder *cxled,
+			 struct cxl_drv_nd *nd);
 #else
 static inline bool is_cxl_pmem_region(struct device *dev)
 {
@@ -905,6 +917,16 @@ static inline struct cxl_dax_region *to_cxl_dax_region(struct device *dev)
 {
 	return NULL;
 }
+static inline bool cxl_dc_extent_in_ed(struct cxl_endpoint_decoder *cxled,
+				       struct cxl_dc_extent_data *extent)
+{
+	return false;
+}
+static inline int cxl_ed_notify_extent(struct cxl_endpoint_decoder *cxled,
+				       struct cxl_drv_nd *nd)
+{
+	return 0;
+}
 #endif
 
 /*
diff --git a/drivers/cxl/mem.c b/drivers/cxl/mem.c
index 80cffa40e91a..d3c4c9c87392 100644
--- a/drivers/cxl/mem.c
+++ b/drivers/cxl/mem.c
@@ -104,6 +104,55 @@ static int cxl_debugfs_poison_clear(void *data, u64 dpa)
 DEFINE_DEBUGFS_ATTRIBUTE(cxl_poison_clear_fops, NULL,
 			 cxl_debugfs_poison_clear, "%llx\n");
 
+static int match_ep_decoder_by_range(struct device *dev, void *data)
+{
+	struct cxl_dc_extent_data *extent = data;
+	struct cxl_endpoint_decoder *cxled;
+
+	if (!is_endpoint_decoder(dev))
+		return 0;
+	cxled = to_cxl_endpoint_decoder(dev);
+	return cxl_dc_extent_in_ed(cxled, extent);
+}
+
+static struct cxl_endpoint_decoder *cxl_find_ed(struct cxl_memdev_state *mds,
+						struct cxl_dc_extent_data *extent)
+{
+	struct cxl_memdev *cxlmd = mds->cxlds.cxlmd;
+	struct cxl_port *endpoint = cxlmd->endpoint;
+	struct device *dev;
+
+	dev = device_find_child(&endpoint->dev, extent,
+				match_ep_decoder_by_range);
+	if (!dev) {
+		dev_dbg(mds->cxlds.dev, "Extent DPA:%llx LEN:%llx not mapped\n",
+			extent->dpa_start, extent->length);
+		return NULL;
+	}
+
+	return to_cxl_endpoint_decoder(dev);
+}
+
+static int cxl_mem_notify(struct device *dev, struct cxl_drv_nd *nd)
+{
+	struct cxl_memdev *cxlmd = to_cxl_memdev(dev);
+	struct cxl_memdev_state *mds = to_cxl_memdev_state(cxlmd->cxlds);
+	struct cxl_endpoint_decoder *cxled;
+	struct cxl_dc_extent_data *extent;
+	int rc = 0;
+
+	extent = nd->extent;
+	dev_dbg(dev, "notify DC action %d DPA:%llx LEN:%llx\n",
+		nd->event, extent->dpa_start, extent->length);
+
+	cxled = cxl_find_ed(mds, extent);
+	if (!cxled)
+		return 0;
+	rc = cxl_ed_notify_extent(cxled, nd);
+	put_device(&cxled->cxld.dev);
+	return rc;
+}
+
 static int cxl_mem_probe(struct device *dev)
 {
 	struct cxl_memdev *cxlmd = to_cxl_memdev(dev);
@@ -247,6 +296,7 @@ __ATTRIBUTE_GROUPS(cxl_mem);
 static struct cxl_driver cxl_mem_driver = {
 	.name = "cxl_mem",
 	.probe = cxl_mem_probe,
+	.notify = cxl_mem_notify,
 	.id = CXL_DEVICE_MEMORY_EXPANDER,
 	.drv = {
 		.dev_groups = cxl_mem_groups,
diff --git a/drivers/dax/cxl.c b/drivers/dax/cxl.c
index 057b00b1d914..44cbd28668f1 100644
--- a/drivers/dax/cxl.c
+++ b/drivers/dax/cxl.c
@@ -59,6 +59,29 @@ static int cxl_dax_region_create_extent(struct dax_region *dax_region,
 	return 0;
 }
 
+static int cxl_dax_region_add_extent(struct cxl_dax_region *cxlr_dax,
+				     struct cxl_dr_extent *cxl_dr_ext)
+{
+	/*
+	 * get not zero is important because this is racing with the
+	 * region driver which is racing with the memory device which
+	 * could be removing the extent at the same time.
+	 */
+	if (cxl_dr_extent_get_not_zero(cxl_dr_ext)) {
+		struct dax_region *dax_region;
+		int rc;
+
+		dax_region = dev_get_drvdata(&cxlr_dax->dev);
+		dev_dbg(&cxlr_dax->dev, "Creating HPA:%llx LEN:%llx\n",
+			cxl_dr_ext->hpa_offset, cxl_dr_ext->hpa_length);
+		rc = cxl_dax_region_create_extent(dax_region, cxl_dr_ext);
+		cxl_dr_extent_put(cxl_dr_ext);
+		if (rc)
+			return rc;
+	}
+	return 0;
+}
+
 static int cxl_dax_region_create_extents(struct cxl_dax_region *cxlr_dax)
 {
 	struct cxl_dr_extent *cxl_dr_ext;
@@ -66,27 +89,68 @@ static int cxl_dax_region_create_extents(struct cxl_dax_region *cxlr_dax)
 
 	dev_dbg(&cxlr_dax->dev, "Adding extents\n");
 	xa_for_each(&cxlr_dax->extents, index, cxl_dr_ext) {
-		/*
-		 * get not zero is important because this is racing with the
-		 * region driver which is racing with the memory device which
-		 * could be removing the extent at the same time.
-		 */
-		if (cxl_dr_extent_get_not_zero(cxl_dr_ext)) {
-			struct dax_region *dax_region;
-			int rc;
-
-			dax_region = dev_get_drvdata(&cxlr_dax->dev);
-			dev_dbg(&cxlr_dax->dev, "Found OFF:%llx LEN:%llx\n",
-				cxl_dr_ext->hpa_offset, cxl_dr_ext->hpa_length);
-			rc = cxl_dax_region_create_extent(dax_region, cxl_dr_ext);
-			cxl_dr_extent_put(cxl_dr_ext);
-			if (rc)
-				return rc;
-		}
+		int rc;
+
+		rc = cxl_dax_region_add_extent(cxlr_dax, cxl_dr_ext);
+		if (rc)
+			return rc;
 	}
 	return 0;
 }
 
+static int match_cxl_dr_extent(struct device *dev, void *data)
+{
+	struct dax_reg_ext_dev *dr_reg_ext_dev;
+	struct dax_region_extent *dr_extent;
+
+	if (!is_dr_ext_dev(dev))
+		return 0;
+
+	dr_reg_ext_dev = to_dr_ext_dev(dev);
+	dr_extent = dr_reg_ext_dev->dr_extent;
+	return data == dr_extent->private_data;
+}
+
+static int cxl_dax_region_rm_extent(struct cxl_dax_region *cxlr_dax,
+				    struct cxl_dr_extent *cxl_dr_ext)
+{
+	struct dax_reg_ext_dev *dr_reg_ext_dev;
+	struct dax_region *dax_region;
+	struct device *dev;
+
+	dev = device_find_child(&cxlr_dax->dev, cxl_dr_ext,
+				match_cxl_dr_extent);
+	if (!dev)
+		return -EINVAL;
+	dr_reg_ext_dev = to_dr_ext_dev(dev);
+	put_device(dev);
+	dax_region = dev_get_drvdata(&cxlr_dax->dev);
+	dax_region_ext_del_dev(dax_region, dr_reg_ext_dev);
+	return 0;
+}
+
+static int cxl_dax_region_notify(struct device *dev,
+				 struct cxl_drv_nd *nd)
+{
+	struct cxl_dax_region *cxlr_dax = to_cxl_dax_region(dev);
+	struct cxl_dr_extent *cxl_dr_ext = nd->cxl_dr_ext;
+	int rc = 0;
+
+	switch (nd->event) {
+	case DCD_ADD_CAPACITY:
+		rc = cxl_dax_region_add_extent(cxlr_dax, cxl_dr_ext);
+		break;
+	case DCD_RELEASE_CAPACITY:
+	case DCD_FORCED_CAPACITY_RELEASE:
+		rc = cxl_dax_region_rm_extent(cxlr_dax, cxl_dr_ext);
+		break;
+	default:
+		dev_err(&cxlr_dax->dev, "Unknown DC event %d\n", nd->event);
+		break;
+	}
+	return rc;
+}
+
 static int cxl_dax_region_probe(struct device *dev)
 {
 	struct cxl_dax_region *cxlr_dax = to_cxl_dax_region(dev);
@@ -134,6 +198,7 @@ static int cxl_dax_region_probe(struct device *dev)
 static struct cxl_driver cxl_dax_region_driver = {
 	.name = "cxl_dax_region",
 	.probe = cxl_dax_region_probe,
+	.notify = cxl_dax_region_notify,
 	.id = CXL_DEVICE_DAX_REGION,
 	.drv = {
 		.suppress_bind_attrs = true,
diff --git a/drivers/dax/dax-private.h b/drivers/dax/dax-private.h
index 4dab52496c3f..250babd6e470 100644
--- a/drivers/dax/dax-private.h
+++ b/drivers/dax/dax-private.h
@@ -90,8 +90,11 @@ int dax_region_ext_create_dev(struct dax_region *dax_region,
 			      resource_size_t offset,
 			      resource_size_t length,
 			      const char *label);
+void dax_region_ext_del_dev(struct dax_region *dax_region,
+			    struct dax_reg_ext_dev *dr_reg_ext_dev);
 #define to_dr_ext_dev(dev)	\
 	container_of(dev, struct dax_reg_ext_dev, dev)
+bool is_dr_ext_dev(struct device *dev);
 
 struct dax_mapping {
 	struct device dev;
diff --git a/drivers/dax/extent.c b/drivers/dax/extent.c
index 2075ccfb21cb..dea6d408d2c8 100644
--- a/drivers/dax/extent.c
+++ b/drivers/dax/extent.c
@@ -60,6 +60,12 @@ const struct device_type dr_extent_type = {
 	.groups = dr_extent_attribute_groups,
 };
 
+bool is_dr_ext_dev(struct device *dev)
+{
+	return dev->type == &dr_extent_type;
+}
+EXPORT_SYMBOL_GPL(is_dr_ext_dev);
+
 static void unregister_dr_extent(void *ext)
 {
 	struct dax_reg_ext_dev *dr_reg_ext_dev = ext;
@@ -117,3 +123,11 @@ int dax_region_ext_create_dev(struct dax_region *dax_region,
 	return rc;
 }
 EXPORT_SYMBOL_GPL(dax_region_ext_create_dev);
+
+void dax_region_ext_del_dev(struct dax_region *dax_region,
+			    struct dax_reg_ext_dev *dr_reg_ext_dev)
+{
+	devm_remove_action(dax_region->dev, unregister_dr_extent, dr_reg_ext_dev);
+	unregister_dr_extent(dr_reg_ext_dev);
+}
+EXPORT_SYMBOL_GPL(dax_region_ext_del_dev);

-- 
2.41.0


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 436B0C83F1D
	for <linux-cxl@archiver.kernel.org>; Tue, 29 Aug 2023 05:24:55 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S235634AbjH2FYZ (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 29 Aug 2023 01:24:25 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:53148 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S235649AbjH2FYH (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 29 Aug 2023 01:24:07 -0400
Received: from mgamail.intel.com (mgamail.intel.com [134.134.136.100])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 451A9199;
        Mon, 28 Aug 2023 22:24:03 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1693286643; x=1724822643;
  h=from:date:subject:mime-version:content-transfer-encoding:
   message-id:references:in-reply-to:to:cc;
  bh=DkfEdh76/av9XD7ZC4PTsHMwKzejFEr+yHiwm8JhB3U=;
  b=IbdFcP12AwlNRpLL6n/MPTUoxHkxB7hd0gxsp/tp52C7gJSPtgWseYUk
   nTWqxgaVyRRCd11+aUXfsyS/GO+7ROQV5UUrMJRRFnspM0j0H5fpX+DIo
   NnagdJnFk7m7TSqIrBU4nFNB7v2JzQfaRESs8/A383KDMtwaV9Zk4PKQM
   8S8Iyk4OT69OR6JZYCOO1OaY1Qhb9aqQRiTuM3pRbtKogbbc+03FEotqZ
   em8EP8IIb4wMK69cwK1MvuSgs229mxc+ZBXB/PoLFXqLsjpPnt39cqss6
   yTMP2ROB83dhGC/jtdgmrLJvBQmU7Tdyg3TtNkOEQ/NLROW7P7gcvvgRi
   w==;
X-IronPort-AV: E=McAfee;i="6600,9927,10816"; a="441625177"
X-IronPort-AV: E=Sophos;i="6.02,208,1688454000"; 
   d="scan'208";a="441625177"
Received: from orsmga002.jf.intel.com ([10.7.209.21])
  by orsmga105.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 28 Aug 2023 22:23:35 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10816"; a="738556312"
X-IronPort-AV: E=Sophos;i="6.02,208,1688454000"; 
   d="scan'208";a="738556312"
Received: from iweiny-mobl.amr.corp.intel.com (HELO localhost) ([10.212.37.183])
  by orsmga002-auth.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 28 Aug 2023 22:23:34 -0700
From: ira.weiny@intel.com
Date: Mon, 28 Aug 2023 22:20:54 -0700
Subject: [PATCH RFC v2 03/18] cxl/mem: Read Dynamic capacity configuration
 from the device
MIME-Version: 1.0
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: 7bit
Message-Id: <20230604-dcd-type2-upstream-v2-3-f740c47e7916@intel.com>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
In-Reply-To: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
To: Dan Williams <dan.j.williams@intel.com>
Cc: Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        Ira Weiny <ira.weiny@intel.com>, linux-cxl@vger.kernel.org,
        linux-kernel@vger.kernel.org
X-Mailer: b4 0.13-dev-c6835
X-Developer-Signature: v=1; a=ed25519-sha256; t=1693286607; l=22852;
 i=ira.weiny@intel.com; s=20221211; h=from:subject:message-id;
 bh=ufY+avRVbltzNFHRLYgsXhckcLjhsIcn3aqW8CpOLa8=;
 b=zI/mS7GXMZZjiB4PM20fq6gj0BCnw1DQ9BQq0u8s5LwMt+sNJj8bDGLtkK25dVfWVqt3ekAf1
 GFcr2m/M9FPD0rDuKOtVN3gBB+V1lDhyXx6VdT3NLsGxBLz1eJ6aAK1
X-Developer-Key: i=ira.weiny@intel.com; a=ed25519;
 pk=noldbkG+Wp1qXRrrkfY1QJpDf7QsOEthbOT7vm0PqsE=
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

From: Navneet Singh <navneet.singh@intel.com>

Devices can optionally support Dynamic Capacity (DC).  These devices are
known as Dynamic Capacity Devices (DCD).

Implement the DC (opcode 48XXh) mailbox commands as specified in CXL 3.0
section 8.2.9.8.9.  Read the DC configuration and store the DC region
information in the device state.

Co-developed-by: Navneet Singh <navneet.singh@intel.com>
Signed-off-by: Navneet Singh <navneet.singh@intel.com>
Signed-off-by: Ira Weiny <ira.weiny@intel.com>

---
Changes for v2
[iweiny: Rebased to latest master type2 work]
[jonathan: s/dc/dc_resp/]
[iweiny: Clean up commit message]
[iweiny: Clean kernel docs]
[djiang: Fix up cxl_is_dcd_command]
[djiang: extra blank line]
[alison: s/total_capacity/cap/ etc...]
[alison: keep partition flag with partition structures]
[alison: reformat untenanted_mem declaration]
[alison: move 'cmd' definition back]
[alison: fix comment line length]
[alison: reverse x-tree]
[jonathan: fix and adjust CXL_DC_REGION_STRLEN]
[Jonathan/iweiny: Factor out storing each DC region read from the device]
[Jonathan: place all dcr initializers together]
[Jonathan/iweiny: flip around the region DPA order check]
[jonathan: Account for short read of mailbox command]
[iweiny: use snprintf for region name]
[iweiny: use '<nil>' for missing region names]
[iweiny: factor out struct cxl_dc_region_info]
[iweiny: Split out reading CEL]
---
 drivers/cxl/core/mbox.c   | 179 +++++++++++++++++++++++++++++++++++++++++++++-
 drivers/cxl/core/region.c |  75 +++++++++++++------
 drivers/cxl/cxl.h         |  27 ++++++-
 drivers/cxl/cxlmem.h      |  55 +++++++++++++-
 drivers/cxl/pci.c         |   4 ++
 5 files changed, 314 insertions(+), 26 deletions(-)

diff --git a/drivers/cxl/core/mbox.c b/drivers/cxl/core/mbox.c
index 554ec97a7c39..d769814f80e2 100644
--- a/drivers/cxl/core/mbox.c
+++ b/drivers/cxl/core/mbox.c
@@ -1096,7 +1096,7 @@ int cxl_dev_state_identify(struct cxl_memdev_state *mds)
 	if (rc < 0)
 		return rc;
 
-	mds->total_bytes =
+	mds->static_cap =
 		le64_to_cpu(id.total_capacity) * CXL_CAPACITY_MULTIPLIER;
 	mds->volatile_only_bytes =
 		le64_to_cpu(id.volatile_capacity) * CXL_CAPACITY_MULTIPLIER;
@@ -1114,6 +1114,8 @@ int cxl_dev_state_identify(struct cxl_memdev_state *mds)
 		mds->poison.max_errors = min_t(u32, val, CXL_POISON_LIST_MAX);
 	}
 
+	mds->dc_event_log_size = le16_to_cpu(id.dc_event_log_size);
+
 	return 0;
 }
 EXPORT_SYMBOL_NS_GPL(cxl_dev_state_identify, CXL);
@@ -1178,6 +1180,165 @@ int cxl_mem_sanitize(struct cxl_memdev_state *mds, u16 cmd)
 }
 EXPORT_SYMBOL_NS_GPL(cxl_mem_sanitize, CXL);
 
+static int cxl_dc_save_region_info(struct cxl_memdev_state *mds, int index,
+				   struct cxl_dc_region_config *region_config)
+{
+	struct cxl_dc_region_info *dcr = &mds->dc_region[index];
+	struct device *dev = mds->cxlds.dev;
+
+	dcr->base = le64_to_cpu(region_config->region_base);
+	dcr->decode_len = le64_to_cpu(region_config->region_decode_length);
+	dcr->decode_len *= CXL_CAPACITY_MULTIPLIER;
+	dcr->len = le64_to_cpu(region_config->region_length);
+	dcr->blk_size = le64_to_cpu(region_config->region_block_size);
+	dcr->dsmad_handle = le32_to_cpu(region_config->region_dsmad_handle);
+	dcr->flags = region_config->flags;
+	snprintf(dcr->name, CXL_DC_REGION_STRLEN, "dc%d", index);
+
+	/* Check regions are in increasing DPA order */
+	if (index > 0) {
+		struct cxl_dc_region_info *prev_dcr = &mds->dc_region[index - 1];
+
+		if ((prev_dcr->base + prev_dcr->decode_len) > dcr->base) {
+			dev_err(dev,
+				"DPA ordering violation for DC region %d and %d\n",
+				index - 1, index);
+			return -EINVAL;
+		}
+	}
+
+	/* Check the region is 256 MB aligned */
+	if (!IS_ALIGNED(dcr->base, SZ_256M)) {
+		dev_err(dev, "DC region %d not aligned to 256MB: %#llx\n",
+			index, dcr->base);
+		return -EINVAL;
+	}
+
+	/* Check Region base and length are aligned to block size */
+	if (!IS_ALIGNED(dcr->base, dcr->blk_size) ||
+	    !IS_ALIGNED(dcr->len, dcr->blk_size)) {
+		dev_err(dev, "DC region %d not aligned to %#llx\n", index,
+			dcr->blk_size);
+		return -EINVAL;
+	}
+
+	dev_dbg(dev,
+		"DC region %s DPA: %#llx LEN: %#llx BLKSZ: %#llx\n",
+		dcr->name, dcr->base, dcr->decode_len, dcr->blk_size);
+
+	return 0;
+}
+
+/* Returns the number of regions in dc_resp or -ERRNO */
+static int cxl_get_dc_id(struct cxl_memdev_state *mds, u8 start_region,
+			 struct cxl_mbox_dynamic_capacity *dc_resp,
+			 size_t dc_resp_size)
+{
+	struct cxl_mbox_get_dc_config get_dc = (struct cxl_mbox_get_dc_config) {
+		.region_count = CXL_MAX_DC_REGION,
+		.start_region_index = start_region,
+	};
+	struct cxl_mbox_cmd mbox_cmd = (struct cxl_mbox_cmd) {
+		.opcode = CXL_MBOX_OP_GET_DC_CONFIG,
+		.payload_in = &get_dc,
+		.size_in = sizeof(get_dc),
+		.size_out = dc_resp_size,
+		.payload_out = dc_resp,
+		.min_out = 1,
+	};
+	struct device *dev = mds->cxlds.dev;
+	int rc;
+
+	rc = cxl_internal_send_cmd(mds, &mbox_cmd);
+	if (rc < 0)
+		return rc;
+
+	rc = dc_resp->avail_region_count - start_region;
+
+	/*
+	 * The number of regions in the payload may have been truncated due to
+	 * payload_size limits; if so adjust the count in this query.
+	 */
+	if (mbox_cmd.size_out < sizeof(*dc_resp))
+		rc = CXL_REGIONS_RETURNED(mbox_cmd.size_out);
+
+	dev_dbg(dev, "Read %d/%d DC regions\n", rc, dc_resp->avail_region_count);
+
+	return rc;
+}
+
+/**
+ * cxl_dev_dynamic_capacity_identify() - Reads the dynamic capacity
+ *					 information from the device.
+ * @mds: The memory device state
+ *
+ * This will dispatch the get_dynamic_capacity command to the device
+ * and on success populate structures to be exported to sysfs.
+ *
+ * Return: 0 if identify was executed successfully, -ERRNO on error.
+ */
+int cxl_dev_dynamic_capacity_identify(struct cxl_memdev_state *mds)
+{
+	struct cxl_mbox_dynamic_capacity *dc_resp;
+	struct device *dev = mds->cxlds.dev;
+	size_t dc_resp_size = mds->payload_size;
+	u8 start_region;
+	int i, rc = 0;
+
+	for (i = 0; i < CXL_MAX_DC_REGION; i++)
+		snprintf(mds->dc_region[i].name, CXL_DC_REGION_STRLEN, "<nil>");
+
+	/* Check GET_DC_CONFIG is supported by device */
+	if (!test_bit(CXL_DCD_ENABLED_GET_CONFIG, mds->dcd_cmds)) {
+		dev_dbg(dev, "unsupported cmd: get_dynamic_capacity_config\n");
+		return 0;
+	}
+
+	dc_resp = kvmalloc(dc_resp_size, GFP_KERNEL);                         
+	if (!dc_resp)                                                                
+		return -ENOMEM;                                                 
+
+	start_region = 0;
+	do {
+		int j;
+
+		rc = cxl_get_dc_id(mds, start_region, dc_resp, dc_resp_size);
+		if (rc < 0)
+			goto free_resp;
+
+		mds->nr_dc_region += rc;
+
+		if (mds->nr_dc_region < 1 || mds->nr_dc_region > CXL_MAX_DC_REGION) {
+			dev_err(dev, "Invalid num of dynamic capacity regions %d\n",
+				mds->nr_dc_region);
+			rc = -EINVAL;
+			goto free_resp;
+		}
+
+		for (i = start_region, j = 0; i < mds->nr_dc_region; i++, j++) {
+			rc = cxl_dc_save_region_info(mds, i, &dc_resp->region[j]);
+			if (rc)
+				goto free_resp;
+		}
+
+		start_region = mds->nr_dc_region;
+
+	} while (mds->nr_dc_region < dc_resp->avail_region_count);
+
+	mds->dynamic_cap =
+		mds->dc_region[mds->nr_dc_region - 1].base +
+		mds->dc_region[mds->nr_dc_region - 1].decode_len -
+		mds->dc_region[0].base;
+	dev_dbg(dev, "Total dynamic capacity: %#llx\n", mds->dynamic_cap);
+
+free_resp:
+	kfree(dc_resp);
+	if (rc)
+		dev_err(dev, "Failed to get DC info: %d\n", rc);
+	return rc;
+}
+EXPORT_SYMBOL_NS_GPL(cxl_dev_dynamic_capacity_identify, CXL);
+
 static int add_dpa_res(struct device *dev, struct resource *parent,
 		       struct resource *res, resource_size_t start,
 		       resource_size_t size, const char *type)
@@ -1208,8 +1369,12 @@ int cxl_mem_create_range_info(struct cxl_memdev_state *mds)
 {
 	struct cxl_dev_state *cxlds = &mds->cxlds;
 	struct device *dev = cxlds->dev;
+	size_t untenanted_mem;
 	int rc;
 
+	untenanted_mem = mds->dc_region[0].base - mds->static_cap;
+	mds->total_bytes = mds->static_cap + untenanted_mem + mds->dynamic_cap;
+
 	if (!cxlds->media_ready) {
 		cxlds->dpa_res = DEFINE_RES_MEM(0, 0);
 		cxlds->ram_res = DEFINE_RES_MEM(0, 0);
@@ -1217,8 +1382,16 @@ int cxl_mem_create_range_info(struct cxl_memdev_state *mds)
 		return 0;
 	}
 
-	cxlds->dpa_res =
-		(struct resource)DEFINE_RES_MEM(0, mds->total_bytes);
+	cxlds->dpa_res = (struct resource)DEFINE_RES_MEM(0, mds->total_bytes);
+
+	for (int i = 0; i < mds->nr_dc_region; i++) {
+		struct cxl_dc_region_info *dcr = &mds->dc_region[i];
+
+		rc = add_dpa_res(dev, &cxlds->dpa_res, &cxlds->dc_res[i],
+				 dcr->base, dcr->decode_len, dcr->name);
+		if (rc)
+			return rc;
+	}
 
 	if (mds->partition_align_bytes == 0) {
 		rc = add_dpa_res(dev, &cxlds->dpa_res, &cxlds->ram_res, 0,
diff --git a/drivers/cxl/core/region.c b/drivers/cxl/core/region.c
index 252bc8e1f103..75041903b72c 100644
--- a/drivers/cxl/core/region.c
+++ b/drivers/cxl/core/region.c
@@ -46,7 +46,7 @@ static ssize_t uuid_show(struct device *dev, struct device_attribute *attr,
 	rc = down_read_interruptible(&cxl_region_rwsem);
 	if (rc)
 		return rc;
-	if (cxlr->mode != CXL_DECODER_PMEM)
+	if (cxlr->mode != CXL_REGION_PMEM)
 		rc = sysfs_emit(buf, "\n");
 	else
 		rc = sysfs_emit(buf, "%pUb\n", &p->uuid);
@@ -359,7 +359,7 @@ static umode_t cxl_region_visible(struct kobject *kobj, struct attribute *a,
 	 * Support tooling that expects to find a 'uuid' attribute for all
 	 * regions regardless of mode.
 	 */
-	if (a == &dev_attr_uuid.attr && cxlr->mode != CXL_DECODER_PMEM)
+	if (a == &dev_attr_uuid.attr && cxlr->mode != CXL_REGION_PMEM)
 		return 0444;
 	return a->mode;
 }
@@ -537,7 +537,7 @@ static ssize_t mode_show(struct device *dev, struct device_attribute *attr,
 {
 	struct cxl_region *cxlr = to_cxl_region(dev);
 
-	return sysfs_emit(buf, "%s\n", cxl_decoder_mode_name(cxlr->mode));
+	return sysfs_emit(buf, "%s\n", cxl_region_mode_name(cxlr->mode));
 }
 static DEVICE_ATTR_RO(mode);
 
@@ -563,7 +563,7 @@ static int alloc_hpa(struct cxl_region *cxlr, resource_size_t size)
 
 	/* ways, granularity and uuid (if PMEM) need to be set before HPA */
 	if (!p->interleave_ways || !p->interleave_granularity ||
-	    (cxlr->mode == CXL_DECODER_PMEM && uuid_is_null(&p->uuid)))
+	    (cxlr->mode == CXL_REGION_PMEM && uuid_is_null(&p->uuid)))
 		return -ENXIO;
 
 	div_u64_rem(size, SZ_256M * p->interleave_ways, &remainder);
@@ -1765,6 +1765,17 @@ static int cxl_region_sort_targets(struct cxl_region *cxlr)
 	return rc;
 }
 
+static bool cxl_modes_compatible(enum cxl_region_mode rmode,
+				 enum cxl_decoder_mode dmode)
+{
+	if (rmode == CXL_REGION_RAM && dmode == CXL_DECODER_RAM)
+		return true;
+	if (rmode == CXL_REGION_PMEM && dmode == CXL_DECODER_PMEM)
+		return true;
+
+	return false;
+}
+
 static int cxl_region_attach(struct cxl_region *cxlr,
 			     struct cxl_endpoint_decoder *cxled, int pos)
 {
@@ -1778,9 +1789,11 @@ static int cxl_region_attach(struct cxl_region *cxlr,
 	lockdep_assert_held_write(&cxl_region_rwsem);
 	lockdep_assert_held_read(&cxl_dpa_rwsem);
 
-	if (cxled->mode != cxlr->mode) {
-		dev_dbg(&cxlr->dev, "%s region mode: %d mismatch: %d\n",
-			dev_name(&cxled->cxld.dev), cxlr->mode, cxled->mode);
+	if (!cxl_modes_compatible(cxlr->mode, cxled->mode)) {
+		dev_dbg(&cxlr->dev, "%s region mode: %s mismatch decoder: %s\n",
+			dev_name(&cxled->cxld.dev),
+			cxl_region_mode_name(cxlr->mode),
+			cxl_decoder_mode_name(cxled->mode));
 		return -EINVAL;
 	}
 
@@ -2234,7 +2247,7 @@ static struct cxl_region *cxl_region_alloc(struct cxl_root_decoder *cxlrd, int i
  * devm_cxl_add_region - Adds a region to a decoder
  * @cxlrd: root decoder
  * @id: memregion id to create, or memregion_free() on failure
- * @mode: mode for the endpoint decoders of this region
+ * @mode: mode of this region
  * @type: select whether this is an expander or accelerator (type-2 or type-3)
  *
  * This is the second step of region initialization. Regions exist within an
@@ -2245,7 +2258,7 @@ static struct cxl_region *cxl_region_alloc(struct cxl_root_decoder *cxlrd, int i
  */
 static struct cxl_region *devm_cxl_add_region(struct cxl_root_decoder *cxlrd,
 					      int id,
-					      enum cxl_decoder_mode mode,
+					      enum cxl_region_mode mode,
 					      enum cxl_decoder_type type)
 {
 	struct cxl_port *port = to_cxl_port(cxlrd->cxlsd.cxld.dev.parent);
@@ -2254,11 +2267,12 @@ static struct cxl_region *devm_cxl_add_region(struct cxl_root_decoder *cxlrd,
 	int rc;
 
 	switch (mode) {
-	case CXL_DECODER_RAM:
-	case CXL_DECODER_PMEM:
+	case CXL_REGION_RAM:
+	case CXL_REGION_PMEM:
 		break;
 	default:
-		dev_err(&cxlrd->cxlsd.cxld.dev, "unsupported mode %d\n", mode);
+		dev_err(&cxlrd->cxlsd.cxld.dev, "unsupported mode %s\n",
+			cxl_region_mode_name(mode));
 		return ERR_PTR(-EINVAL);
 	}
 
@@ -2308,7 +2322,7 @@ static ssize_t create_ram_region_show(struct device *dev,
 }
 
 static struct cxl_region *__create_region(struct cxl_root_decoder *cxlrd,
-					  int id, enum cxl_decoder_mode mode,
+					  int id, enum cxl_region_mode mode,
 					  enum cxl_decoder_type type)
 {
 	int rc;
@@ -2337,7 +2351,7 @@ static ssize_t create_pmem_region_store(struct device *dev,
 	if (rc != 1)
 		return -EINVAL;
 
-	cxlr = __create_region(cxlrd, id, CXL_DECODER_PMEM,
+	cxlr = __create_region(cxlrd, id, CXL_REGION_PMEM,
 			       CXL_DECODER_HOSTONLYMEM);
 	if (IS_ERR(cxlr))
 		return PTR_ERR(cxlr);
@@ -2358,7 +2372,7 @@ static ssize_t create_ram_region_store(struct device *dev,
 	if (rc != 1)
 		return -EINVAL;
 
-	cxlr = __create_region(cxlrd, id, CXL_DECODER_RAM,
+	cxlr = __create_region(cxlrd, id, CXL_REGION_RAM,
 			       CXL_DECODER_HOSTONLYMEM);
 	if (IS_ERR(cxlr))
 		return PTR_ERR(cxlr);
@@ -2886,10 +2900,31 @@ static void construct_region_end(void)
 	up_write(&cxl_region_rwsem);
 }
 
+static enum cxl_region_mode
+cxl_decoder_to_region_mode(enum cxl_decoder_mode mode)
+{
+	switch (mode) {
+	case CXL_DECODER_NONE:
+		return CXL_REGION_NONE;
+	case CXL_DECODER_RAM:
+		return CXL_REGION_RAM;
+	case CXL_DECODER_PMEM:
+		return CXL_REGION_PMEM;
+	case CXL_DECODER_DEAD:
+		return CXL_REGION_DEAD;
+	case CXL_DECODER_MIXED:
+	default:
+		return CXL_REGION_MIXED;
+	}
+
+	return CXL_REGION_MIXED;
+}
+
 static struct cxl_region *
 construct_region_begin(struct cxl_root_decoder *cxlrd,
 		       struct cxl_endpoint_decoder *cxled)
 {
+	enum cxl_region_mode mode = cxl_decoder_to_region_mode(cxled->mode);
 	struct cxl_memdev *cxlmd = cxled_to_memdev(cxled);
 	struct cxl_region_params *p;
 	struct cxl_region *cxlr;
@@ -2897,7 +2932,7 @@ construct_region_begin(struct cxl_root_decoder *cxlrd,
 
 	do {
 		cxlr = __create_region(cxlrd, atomic_read(&cxlrd->region_id),
-				       cxled->mode, cxled->cxld.target_type);
+				       mode, cxled->cxld.target_type);
 	} while (IS_ERR(cxlr) && PTR_ERR(cxlr) == -EBUSY);
 
 	if (IS_ERR(cxlr)) {
@@ -3200,9 +3235,9 @@ static int cxl_region_probe(struct device *dev)
 		return rc;
 
 	switch (cxlr->mode) {
-	case CXL_DECODER_PMEM:
+	case CXL_REGION_PMEM:
 		return devm_cxl_add_pmem_region(cxlr);
-	case CXL_DECODER_RAM:
+	case CXL_REGION_RAM:
 		/*
 		 * The region can not be manged by CXL if any portion of
 		 * it is already online as 'System RAM'
@@ -3223,8 +3258,8 @@ static int cxl_region_probe(struct device *dev)
 		/* HDM-H routes to device-dax */
 		return devm_cxl_add_dax_region(cxlr);
 	default:
-		dev_dbg(&cxlr->dev, "unsupported region mode: %d\n",
-			cxlr->mode);
+		dev_dbg(&cxlr->dev, "unsupported region mode: %s\n",
+			cxl_region_mode_name(cxlr->mode));
 		return -ENXIO;
 	}
 }
diff --git a/drivers/cxl/cxl.h b/drivers/cxl/cxl.h
index cd4a9ffdacc7..ed282dcd5cf5 100644
--- a/drivers/cxl/cxl.h
+++ b/drivers/cxl/cxl.h
@@ -374,6 +374,28 @@ static inline const char *cxl_decoder_mode_name(enum cxl_decoder_mode mode)
 	return "mixed";
 }
 
+enum cxl_region_mode {
+	CXL_REGION_NONE,
+	CXL_REGION_RAM,
+	CXL_REGION_PMEM,
+	CXL_REGION_MIXED,
+	CXL_REGION_DEAD,
+};
+
+static inline const char *cxl_region_mode_name(enum cxl_region_mode mode)
+{
+	static const char * const names[] = {
+		[CXL_REGION_NONE] = "none",
+		[CXL_REGION_RAM] = "ram",
+		[CXL_REGION_PMEM] = "pmem",
+		[CXL_REGION_MIXED] = "mixed",
+	};
+
+	if (mode >= CXL_REGION_NONE && mode <= CXL_REGION_MIXED)
+		return names[mode];
+	return "mixed";
+}
+
 /*
  * Track whether this decoder is reserved for region autodiscovery, or
  * free for userspace provisioning.
@@ -502,7 +524,8 @@ struct cxl_region_params {
  * struct cxl_region - CXL region
  * @dev: This region's device
  * @id: This region's id. Id is globally unique across all regions
- * @mode: Endpoint decoder allocation / access mode
+ * @mode: Region mode which defines which endpoint decoder mode the region is
+ *        compatible with
  * @type: Endpoint decoder target type
  * @cxl_nvb: nvdimm bridge for coordinating @cxlr_pmem setup / shutdown
  * @cxlr_pmem: (for pmem regions) cached copy of the nvdimm bridge
@@ -512,7 +535,7 @@ struct cxl_region_params {
 struct cxl_region {
 	struct device dev;
 	int id;
-	enum cxl_decoder_mode mode;
+	enum cxl_region_mode mode;
 	enum cxl_decoder_type type;
 	struct cxl_nvdimm_bridge *cxl_nvb;
 	struct cxl_pmem_region *cxlr_pmem;
diff --git a/drivers/cxl/cxlmem.h b/drivers/cxl/cxlmem.h
index 5f2e65204bf9..8c8f47b397ab 100644
--- a/drivers/cxl/cxlmem.h
+++ b/drivers/cxl/cxlmem.h
@@ -396,6 +396,7 @@ enum cxl_devtype {
 	CXL_DEVTYPE_CLASSMEM,
 };
 
+#define CXL_MAX_DC_REGION 8
 /**
  * struct cxl_dev_state - The driver device state
  *
@@ -412,6 +413,8 @@ enum cxl_devtype {
  * @dpa_res: Overall DPA resource tree for the device
  * @pmem_res: Active Persistent memory capacity configuration
  * @ram_res: Active Volatile memory capacity configuration
+ * @dc_res: Active Dynamic Capacity memory configuration for each possible
+ *          region
  * @component_reg_phys: register base of component registers
  * @serial: PCIe Device Serial Number
  * @type: Generic Memory Class device or Vendor Specific Memory device
@@ -426,11 +429,23 @@ struct cxl_dev_state {
 	struct resource dpa_res;
 	struct resource pmem_res;
 	struct resource ram_res;
+	struct resource dc_res[CXL_MAX_DC_REGION];
 	resource_size_t component_reg_phys;
 	u64 serial;
 	enum cxl_devtype type;
 };
 
+#define CXL_DC_REGION_STRLEN 7
+struct cxl_dc_region_info {
+	u64 base;
+	u64 decode_len;
+	u64 len;
+	u64 blk_size;
+	u32 dsmad_handle;
+	u8 flags;
+	u8 name[CXL_DC_REGION_STRLEN];
+};
+
 /**
  * struct cxl_memdev_state - Generic Type-3 Memory Device Class driver data
  *
@@ -449,6 +464,8 @@ struct cxl_dev_state {
  * @enabled_cmds: Hardware commands found enabled in CEL.
  * @exclusive_cmds: Commands that are kernel-internal only
  * @total_bytes: sum of all possible capacities
+ * @static_cap: Sum of RAM and PMEM capacities
+ * @dynamic_cap: Complete DPA range occupied by DC regions
  * @volatile_only_bytes: hard volatile capacity
  * @persistent_only_bytes: hard persistent capacity
  * @partition_align_bytes: alignment size for partition-able capacity
@@ -456,6 +473,10 @@ struct cxl_dev_state {
  * @active_persistent_bytes: sum of hard + soft persistent
  * @next_volatile_bytes: volatile capacity change pending device reset
  * @next_persistent_bytes: persistent capacity change pending device reset
+ * @nr_dc_region: number of DC regions implemented in the memory device
+ * @dc_region: array containing info about the DC regions
+ * @dc_event_log_size: The number of events the device can store in the
+ * Dynamic Capacity Event Log before it overflows
  * @event: event log driver state
  * @poison: poison driver state info
  * @fw: firmware upload / activation state
@@ -473,7 +494,10 @@ struct cxl_memdev_state {
 	DECLARE_BITMAP(dcd_cmds, CXL_DCD_ENABLED_MAX);
 	DECLARE_BITMAP(enabled_cmds, CXL_MEM_COMMAND_ID_MAX);
 	DECLARE_BITMAP(exclusive_cmds, CXL_MEM_COMMAND_ID_MAX);
+
 	u64 total_bytes;
+	u64 static_cap;
+	u64 dynamic_cap;
 	u64 volatile_only_bytes;
 	u64 persistent_only_bytes;
 	u64 partition_align_bytes;
@@ -481,6 +505,11 @@ struct cxl_memdev_state {
 	u64 active_persistent_bytes;
 	u64 next_volatile_bytes;
 	u64 next_persistent_bytes;
+
+	u8 nr_dc_region;
+	struct cxl_dc_region_info dc_region[CXL_MAX_DC_REGION];
+	size_t dc_event_log_size;
+
 	struct cxl_event_state event;
 	struct cxl_poison_state poison;
 	struct cxl_security_state security;
@@ -587,6 +616,7 @@ struct cxl_mbox_identify {
 	__le16 inject_poison_limit;
 	u8 poison_caps;
 	u8 qos_telemetry_caps;
+	__le16 dc_event_log_size;
 } __packed;
 
 /*
@@ -741,9 +771,31 @@ struct cxl_mbox_set_partition_info {
 	__le64 volatile_capacity;
 	u8 flags;
 } __packed;
-
 #define  CXL_SET_PARTITION_IMMEDIATE_FLAG	BIT(0)
 
+struct cxl_mbox_get_dc_config {
+	u8 region_count;
+	u8 start_region_index;
+} __packed;
+
+/* See CXL 3.0 Table 125 get dynamic capacity config Output Payload */
+struct cxl_mbox_dynamic_capacity {
+	u8 avail_region_count;
+	u8 rsvd[7];
+	struct cxl_dc_region_config {
+		__le64 region_base;
+		__le64 region_decode_length;
+		__le64 region_length;
+		__le64 region_block_size;
+		__le32 region_dsmad_handle;
+		u8 flags;
+		u8 rsvd[3];
+	} __packed region[];
+} __packed;
+#define CXL_DYNAMIC_CAPACITY_SANITIZE_ON_RELEASE_FLAG BIT(0)
+#define CXL_REGIONS_RETURNED(size_out) \
+	((size_out - 8) / sizeof(struct cxl_dc_region_config))
+
 /* Set Timestamp CXL 3.0 Spec 8.2.9.4.2 */
 struct cxl_mbox_set_timestamp_in {
 	__le64 timestamp;
@@ -867,6 +919,7 @@ enum {
 int cxl_internal_send_cmd(struct cxl_memdev_state *mds,
 			  struct cxl_mbox_cmd *cmd);
 int cxl_dev_state_identify(struct cxl_memdev_state *mds);
+int cxl_dev_dynamic_capacity_identify(struct cxl_memdev_state *mds);
 int cxl_await_media_ready(struct cxl_dev_state *cxlds);
 int cxl_enumerate_cmds(struct cxl_memdev_state *mds);
 int cxl_mem_create_range_info(struct cxl_memdev_state *mds);
diff --git a/drivers/cxl/pci.c b/drivers/cxl/pci.c
index 5242dbf0044d..a9b110ff1176 100644
--- a/drivers/cxl/pci.c
+++ b/drivers/cxl/pci.c
@@ -879,6 +879,10 @@ static int cxl_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	if (rc)
 		return rc;
 
+	rc = cxl_dev_dynamic_capacity_identify(mds);
+	if (rc)
+		return rc;
+
 	rc = cxl_mem_create_range_info(mds);
 	if (rc)
 		return rc;

-- 
2.41.0


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 14FE9C83F25
	for <linux-cxl@archiver.kernel.org>; Tue, 29 Aug 2023 05:24:56 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S235685AbjH2FY0 (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 29 Aug 2023 01:24:26 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:40446 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S235660AbjH2FYL (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 29 Aug 2023 01:24:11 -0400
Received: from mgamail.intel.com (mgamail.intel.com [134.134.136.100])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 3A72B19B;
        Mon, 28 Aug 2023 22:24:08 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1693286648; x=1724822648;
  h=from:date:subject:mime-version:content-transfer-encoding:
   message-id:references:in-reply-to:to:cc;
  bh=RaGculr/PnAD0FdsC4GZC3RN59KZmeYQTrpV5iUGtII=;
  b=EUmO+kW92GnQF2nDnJCJ8Zc8DEbvTIB9bn+aUL/oWBi7N+yI5UydXNQo
   9noX+soQTzNcT92KhDK4vVLUvKFOgCoJCBsqOaCVXMvJG3Oa+MCFY0+xc
   uHm8+X+ZETK8OGW8ZDR6boe4LwA+qJ5HP35BK9ruwe7KB7EGkZ/fJZ7Ic
   uzJ3HMpNLdBmjWVwfS5/58rZ0U2cmQfhVvU8Ap972aBipdpzlF4N/wbHw
   6S+VxvfzEcOZygojZMYMyS5gbqQGAqVeN/kR3+Nq2ilN+6DUPINS474Ra
   iyMhGPTLTZ+N7KmFdOUmJmZbHtosyfwiY/ESCVjWV6tX+QmDh9MPZOft+
   g==;
X-IronPort-AV: E=McAfee;i="6600,9927,10816"; a="441625229"
X-IronPort-AV: E=Sophos;i="6.02,208,1688454000"; 
   d="scan'208";a="441625229"
Received: from orsmga002.jf.intel.com ([10.7.209.21])
  by orsmga105.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 28 Aug 2023 22:23:44 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10816"; a="738556400"
X-IronPort-AV: E=Sophos;i="6.02,208,1688454000"; 
   d="scan'208";a="738556400"
Received: from iweiny-mobl.amr.corp.intel.com (HELO localhost) ([10.212.37.183])
  by orsmga002-auth.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 28 Aug 2023 22:23:43 -0700
From: Ira Weiny <ira.weiny@intel.com>
Date: Mon, 28 Aug 2023 22:21:01 -0700
Subject: [PATCH RFC v2 10/18] cxl/mem: Handle DCD add and release capacity
 events.
MIME-Version: 1.0
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: 7bit
Message-Id: <20230604-dcd-type2-upstream-v2-10-f740c47e7916@intel.com>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
In-Reply-To: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
To: Dan Williams <dan.j.williams@intel.com>
Cc: Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        Ira Weiny <ira.weiny@intel.com>, linux-cxl@vger.kernel.org,
        linux-kernel@vger.kernel.org
X-Mailer: b4 0.13-dev-c6835
X-Developer-Signature: v=1; a=ed25519-sha256; t=1693286607; l=12104;
 i=ira.weiny@intel.com; s=20221211; h=from:subject:message-id;
 bh=RaGculr/PnAD0FdsC4GZC3RN59KZmeYQTrpV5iUGtII=;
 b=+Y1T5WuDw+Tal6Z559togfIjU10J697AT986kBWJtJi9QQ38zfZN7GdtrI44ulVfQHUd6WsEb
 gFUGxbcr5bNAlopZkYq1lOoMkUkLVn/vCPE3FJ8gtqt5xis7k4nGRNJ
X-Developer-Key: i=ira.weiny@intel.com; a=ed25519;
 pk=noldbkG+Wp1qXRrrkfY1QJpDf7QsOEthbOT7vm0PqsE=
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

A Dynamic Capacity Device (DCD) utilizes events to signal the host about
the changes to the allocation of Dynamic Capacity (DC) extents. The
device communicates the state of DC extents through an extent list that
describes the starting DPA, length, and meta data of the blocks the host
can access.

Process the dynamic capacity add and release events.  The addition or
removal of extents can occur at any time.  Adding asynchronous memory is
straight forward.  Also remember the host is under no obligation to
respond to a release event until it is done with the memory.  Introduce
extent kref's to handle the delay of extent release.

In the case of a force removal, access to the memory will fail and may
cause a crash.  However, the extent tracking object is preserved for the
region to safely tear down as long as the memory is not accessed.

Signed-off-by: Navneet Singh <navneet.singh@intel.com>
Co-developed-by: Ira Weiny <ira.weiny@intel.com>
Signed-off-by: Ira Weiny <ira.weiny@intel.com>

---
changes for v2:
[iweiny: Totally new version of the patch]
[iweiny: use kref to track when to release an extent]
[iweiny: rebased to latest master/type2 work]
[iweiny: use a kref to track if extents are being referenced]
[alison: align commit message paragraphs]
[alison: remove unnecessary return]
[iweiny: Adjust for the new __devm_cxl_add_dax_region()]
[navneet: Fix debug prints in adding/releasing extent]
[alison: deal with odd if/else logic]
[alison: reverse x-tree]
[alison: reverse x-tree]
[alison: s/total_extent_cnt/count/]
[alison: make handle event reverse x-tree]
[alison: cleanup/shorten/remove handle event comment]
[iweiny/Alison: refactor cxl_handle_dcd_event_records function]
[iweiny: keep cxl_dc_extent_data local to mbox.c]
[jonathan: eliminate 'rc']
[iweiny: use proper type for mailbox size]
[jonathan: put dc_extents on the stack]
[jonathan: use direct returns instead of goto]
[iweiny: Clean up comment]
[Jonathan: define CXL_DC_EXTENT_TAG_LEN]
[Jonathan: remove extraneous changes]
[Jonathan: fix blank line issues]
---
 drivers/cxl/core/mbox.c | 186 +++++++++++++++++++++++++++++++++++++++++++++++-
 drivers/cxl/cxl.h       |   9 +++
 drivers/cxl/cxlmem.h    |  30 ++++++++
 3 files changed, 224 insertions(+), 1 deletion(-)

diff --git a/drivers/cxl/core/mbox.c b/drivers/cxl/core/mbox.c
index 9b08c40ef484..8474a28b16ca 100644
--- a/drivers/cxl/core/mbox.c
+++ b/drivers/cxl/core/mbox.c
@@ -839,6 +839,8 @@ static int cxl_store_dc_extent(struct cxl_memdev_state *mds,
 	extent->length = le64_to_cpu(dc_extent->length);
 	memcpy(extent->tag, dc_extent->tag, sizeof(extent->tag));
 	extent->shared_extent_seq = le16_to_cpu(dc_extent->shared_extn_seq);
+	kref_init(&extent->region_ref);
+	extent->mds = mds;
 
 	dev_dbg(dev, "dynamic capacity extent DPA:0x%llx LEN:%llx\n",
 		extent->dpa_start, extent->length);
@@ -879,6 +881,14 @@ static const uuid_t mem_mod_event_uuid =
 	UUID_INIT(0xfe927475, 0xdd59, 0x4339,
 		  0xa5, 0x86, 0x79, 0xba, 0xb1, 0x13, 0xb7, 0x74);
 
+/* 
+ * Dynamic Capacity Event Record
+ * CXL rev 3.0 section 8.2.9.2.1.3; Table 8-45
+ */
+static const uuid_t dc_event_uuid =
+	UUID_INIT(0xca95afa7, 0xf183, 0x4018, 0x8c,
+		  0x2f, 0x95, 0x26, 0x8e, 0x10, 0x1a, 0x2a);
+
 static void cxl_event_trace_record(const struct cxl_memdev *cxlmd,
 				   enum cxl_event_log_type type,
 				   struct cxl_event_record_raw *record)
@@ -973,6 +983,171 @@ static int cxl_clear_event_record(struct cxl_memdev_state *mds,
 	return rc;
 }
 
+static int cxl_send_dc_cap_response(struct cxl_memdev_state *mds,
+				struct cxl_mbox_dc_response *res,
+				int extent_cnt, int opcode)
+{
+	struct cxl_mbox_cmd mbox_cmd;
+	size_t size;
+
+	size = struct_size(res, extent_list, extent_cnt);
+	res->extent_list_size = cpu_to_le32(extent_cnt);
+
+	mbox_cmd = (struct cxl_mbox_cmd) {
+		.opcode = opcode,
+		.size_in = size,
+		.payload_in = res,
+	};
+
+	return cxl_internal_send_cmd(mds, &mbox_cmd);
+}
+
+static int cxl_prepare_ext_list(struct cxl_mbox_dc_response **res,
+				int *n, struct range *extent)
+{
+	struct cxl_mbox_dc_response *dc_res;
+	unsigned int size;
+
+	if (!extent)
+		size = struct_size(dc_res, extent_list, 0);
+	else
+		size = struct_size(dc_res, extent_list, *n + 1);
+
+	dc_res = krealloc(*res, size, GFP_KERNEL);
+	if (!dc_res)
+		return -ENOMEM;
+
+	if (extent) {
+		dc_res->extent_list[*n].dpa_start = cpu_to_le64(extent->start);
+		memset(dc_res->extent_list[*n].reserved, 0, 8);
+		dc_res->extent_list[*n].length = cpu_to_le64(range_len(extent));
+		(*n)++;
+	}
+
+	*res = dc_res;
+	return 0;
+}
+
+static void dc_extent_release(struct kref *kref)
+{
+	struct cxl_dc_extent_data *extent = container_of(kref,
+						struct cxl_dc_extent_data,
+						region_ref);
+	struct cxl_memdev_state *mds = extent->mds;
+	struct cxl_mbox_dc_response *dc_res = NULL;
+	struct range rel_range = (struct range) {
+		.start = extent->dpa_start,
+		.end = extent->dpa_start + extent->length - 1,
+	};
+	struct device *dev = mds->cxlds.dev;
+	int extent_cnt = 0, rc;
+
+	rc = cxl_prepare_ext_list(&dc_res, &extent_cnt, &rel_range);
+	if (rc < 0) {
+		dev_err(dev, "Failed to create release response %d\n", rc);
+		goto free_extent;
+	}
+	rc = cxl_send_dc_cap_response(mds, dc_res, extent_cnt,
+				      CXL_MBOX_OP_RELEASE_DC);
+	kfree(dc_res);
+
+free_extent:
+	kfree(extent);
+}
+
+void cxl_dc_extent_put(struct cxl_dc_extent_data *extent)
+{
+	kref_put(&extent->region_ref, dc_extent_release);
+}
+EXPORT_SYMBOL_NS_GPL(cxl_dc_extent_put, CXL);
+
+static int cxl_handle_dcd_release_event(struct cxl_memdev_state *mds,
+					struct cxl_dc_extent *rel_extent)
+{
+	struct device *dev = mds->cxlds.dev;
+	struct cxl_dc_extent_data *extent;
+	resource_size_t dpa, size;
+
+	dpa = le64_to_cpu(rel_extent->start_dpa);
+	size = le64_to_cpu(rel_extent->length);
+	dev_dbg(dev, "Release DC extent DPA:0x%llx LEN:%llx\n",
+		dpa, size);
+
+	extent = xa_erase(&mds->dc_extent_list, dpa);
+	if (!extent) {
+		dev_err(dev, "No extent found with DPA:0x%llx\n", dpa);
+		return -EINVAL;
+	}
+	cxl_dc_extent_put(extent);
+	return 0;
+}
+
+static int cxl_handle_dcd_add_event(struct cxl_memdev_state *mds,
+				    struct cxl_dc_extent *add_extent)
+{
+	struct cxl_mbox_dc_response *dc_res = NULL;
+	struct range alloc_range, *resp_range;
+	struct device *dev = mds->cxlds.dev;
+	int extent_cnt = 0;
+	int rc;
+
+	dev_dbg(dev, "Add DC extent DPA:0x%llx LEN:%llx\n",
+		le64_to_cpu(add_extent->start_dpa),
+		le64_to_cpu(add_extent->length));
+
+	alloc_range = (struct range){
+		.start = le64_to_cpu(add_extent->start_dpa),
+		.end = le64_to_cpu(add_extent->start_dpa) +
+			le64_to_cpu(add_extent->length) - 1,
+	};
+	resp_range = &alloc_range;
+
+	rc = cxl_store_dc_extent(mds, add_extent);
+	if (rc) {
+		dev_dbg(dev, "unconsumed DC extent DPA:0x%llx LEN:%llx\n",
+			le64_to_cpu(add_extent->start_dpa),
+			le64_to_cpu(add_extent->length));
+		resp_range = NULL;
+	}
+
+	rc = cxl_prepare_ext_list(&dc_res, &extent_cnt, resp_range);
+	if (rc < 0) {
+		dev_err(dev, "Couldn't create extent list %d\n", rc);
+		return rc;
+	}
+
+	rc = cxl_send_dc_cap_response(mds, dc_res, extent_cnt,
+				      CXL_MBOX_OP_ADD_DC_RESPONSE);
+	kfree(dc_res);
+	return rc;
+}
+
+/* Returns 0 if the event was handled successfully. */
+static int cxl_handle_dcd_event_records(struct cxl_memdev_state *mds,
+					struct cxl_event_record_raw *rec)
+{
+	struct dcd_event_dyn_cap *record = (struct dcd_event_dyn_cap *)rec;
+	uuid_t *id = &rec->hdr.id;
+	int rc;
+
+	if (!uuid_equal(id, &dc_event_uuid))
+		return -EINVAL;
+
+	switch (record->data.event_type) {
+	case DCD_ADD_CAPACITY:
+		rc = cxl_handle_dcd_add_event(mds, &record->data.extent);
+		break;
+	case DCD_RELEASE_CAPACITY:
+        case DCD_FORCED_CAPACITY_RELEASE:
+		rc = cxl_handle_dcd_release_event(mds, &record->data.extent);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return rc;
+}
+
 static void cxl_mem_get_records_log(struct cxl_memdev_state *mds,
 				    enum cxl_event_log_type type)
 {
@@ -1016,6 +1191,13 @@ static void cxl_mem_get_records_log(struct cxl_memdev_state *mds,
 				le16_to_cpu(payload->records[i].hdr.handle));
 			cxl_event_trace_record(cxlmd, type,
 					       &payload->records[i]);
+			if (type == CXL_EVENT_TYPE_DCD) {
+				rc = cxl_handle_dcd_event_records(mds,
+								  &payload->records[i]);
+				if (rc) 
+					dev_err_ratelimited(dev, "dcd event failed: %d\n",
+							    rc);
+			}
 		}
 
 		if (payload->flags & CXL_GET_EVENT_FLAG_OVERFLOW)
@@ -1056,6 +1238,8 @@ void cxl_mem_get_event_records(struct cxl_memdev_state *mds, u32 status)
 		cxl_mem_get_records_log(mds, CXL_EVENT_TYPE_WARN);
 	if (status & CXLDEV_EVENT_STATUS_INFO)
 		cxl_mem_get_records_log(mds, CXL_EVENT_TYPE_INFO);
+	if (status & CXLDEV_EVENT_STATUS_DCD)
+		cxl_mem_get_records_log(mds, CXL_EVENT_TYPE_DCD);
 }
 EXPORT_SYMBOL_NS_GPL(cxl_mem_get_event_records, CXL);
 
@@ -1712,7 +1896,7 @@ static void cxl_destroy_mds(void *_mds)
 
 	xa_for_each(&mds->dc_extent_list, index, extent) {
 		xa_erase(&mds->dc_extent_list, index);
-		kfree(extent);
+		cxl_dc_extent_put(extent);
 	}
 	xa_destroy(&mds->dc_extent_list);
 }
diff --git a/drivers/cxl/cxl.h b/drivers/cxl/cxl.h
index 0a225b0c20bf..81ca76ae1d02 100644
--- a/drivers/cxl/cxl.h
+++ b/drivers/cxl/cxl.h
@@ -163,6 +163,7 @@ static inline int ways_to_eiw(unsigned int ways, u8 *eiw)
 #define CXLDEV_EVENT_STATUS_WARN		BIT(1)
 #define CXLDEV_EVENT_STATUS_FAIL		BIT(2)
 #define CXLDEV_EVENT_STATUS_FATAL		BIT(3)
+#define CXLDEV_EVENT_STATUS_DCD                 BIT(4)
 
 #define CXLDEV_EVENT_STATUS_ALL (CXLDEV_EVENT_STATUS_INFO |	\
 				 CXLDEV_EVENT_STATUS_WARN |	\
@@ -601,6 +602,14 @@ struct cxl_pmem_region {
 	struct cxl_pmem_region_mapping mapping[];
 };
 
+/* See CXL 3.0 8.2.9.2.1.5 */
+enum dc_event {
+        DCD_ADD_CAPACITY,
+        DCD_RELEASE_CAPACITY,
+        DCD_FORCED_CAPACITY_RELEASE,
+        DCD_REGION_CONFIGURATION_UPDATED,
+};
+
 struct cxl_dax_region {
 	struct device dev;
 	struct cxl_region *cxlr;
diff --git a/drivers/cxl/cxlmem.h b/drivers/cxl/cxlmem.h
index ad690600c1b9..118392229174 100644
--- a/drivers/cxl/cxlmem.h
+++ b/drivers/cxl/cxlmem.h
@@ -582,6 +582,16 @@ enum cxl_opcode {
 	UUID_INIT(0xe1819d9, 0x11a9, 0x400c, 0x81, 0x1f, 0xd6, 0x07, 0x19,     \
 		  0x40, 0x3d, 0x86)
 
+struct cxl_mbox_dc_response {
+	__le32 extent_list_size;
+	u8 reserved[4];
+	struct updated_extent_list {
+		__le64 dpa_start;
+		__le64 length;
+		u8 reserved[8];
+	} __packed extent_list[];
+} __packed;
+
 struct cxl_mbox_get_supported_logs {
 	__le16 entries;
 	u8 rsvd[6];
@@ -667,6 +677,7 @@ enum cxl_event_log_type {
 	CXL_EVENT_TYPE_WARN,
 	CXL_EVENT_TYPE_FAIL,
 	CXL_EVENT_TYPE_FATAL,
+	CXL_EVENT_TYPE_DCD,
 	CXL_EVENT_TYPE_MAX
 };
 
@@ -757,6 +768,8 @@ struct cxl_dc_extent_data {
 	u64 length;
 	u8 tag[CXL_DC_EXTENT_TAG_LEN];
 	u16 shared_extent_seq;
+	struct cxl_memdev_state *mds;
+	struct kref region_ref;
 };
 
 /*
@@ -771,6 +784,21 @@ struct cxl_dc_extent {
 	u8 reserved[6];
 } __packed;
 
+struct dcd_record_data {
+	u8 event_type;
+	u8 reserved;
+	__le16 host_id;
+	u8 region_index;
+	u8 reserved1[3];
+	struct cxl_dc_extent extent;
+	u8 reserved2[32];
+} __packed;
+
+struct dcd_event_dyn_cap {
+	struct cxl_event_record_hdr hdr; 
+	struct dcd_record_data data;
+} __packed;
+
 struct cxl_mbox_get_partition_info {
 	__le64 active_volatile_cap;
 	__le64 active_persistent_cap;
@@ -974,6 +1002,8 @@ int cxl_trigger_poison_list(struct cxl_memdev *cxlmd);
 int cxl_inject_poison(struct cxl_memdev *cxlmd, u64 dpa);
 int cxl_clear_poison(struct cxl_memdev *cxlmd, u64 dpa);
 
+void cxl_dc_extent_put(struct cxl_dc_extent_data *extent);
+
 #ifdef CONFIG_CXL_SUSPEND
 void cxl_mem_active_inc(void);
 void cxl_mem_active_dec(void);

-- 
2.41.0


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 047D0C83F23
	for <linux-cxl@archiver.kernel.org>; Tue, 29 Aug 2023 05:24:55 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S235688AbjH2FY0 (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 29 Aug 2023 01:24:26 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:53258 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S235659AbjH2FYL (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 29 Aug 2023 01:24:11 -0400
Received: from mgamail.intel.com (mgamail.intel.com [134.134.136.100])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 4D62B1A1;
        Mon, 28 Aug 2023 22:24:06 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1693286648; x=1724822648;
  h=from:date:subject:mime-version:content-transfer-encoding:
   message-id:references:in-reply-to:to:cc;
  bh=sMf7HpI3l9SxR8zPU0ViBRKMt/oH1JbxsGrHT1GC9e8=;
  b=md9Pd7WYvtJQaeJG7m14DM4hZCIF5AwN9xgWGjTcuRWZd0Ot04PDhSPF
   Vz2TRYJWcETV2jN+tzpdTT+hrEfbwdjfRgCT+81xQQV/YcM+zkpMfy7VG
   9YioQ0xcd8NTeV3hjQsoSKpWmpOdcmzG63X/y8ys9CfIBXHbIj4DTNxyM
   FawdLPqjbMQOGdu00+MWsx16fvx54RhsN2cNpjvRsrozqoY0aRmlIGypJ
   /qhUvfOfJRr09rPjypkvikbjq+xPPJ9sk9DuI+q1OC9WayjYPxRT/DwN4
   uDo0fuMrnWEJPanTfcc/K1VAc3HbjnBvDw2zGGNTFpTWDeEj1sZAK5ZqU
   Q==;
X-IronPort-AV: E=McAfee;i="6600,9927,10816"; a="441625223"
X-IronPort-AV: E=Sophos;i="6.02,208,1688454000"; 
   d="scan'208";a="441625223"
Received: from orsmga002.jf.intel.com ([10.7.209.21])
  by orsmga105.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 28 Aug 2023 22:23:41 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10816"; a="738556391"
X-IronPort-AV: E=Sophos;i="6.02,208,1688454000"; 
   d="scan'208";a="738556391"
Received: from iweiny-mobl.amr.corp.intel.com (HELO localhost) ([10.212.37.183])
  by orsmga002-auth.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 28 Aug 2023 22:23:41 -0700
From: Ira Weiny <ira.weiny@intel.com>
Date: Mon, 28 Aug 2023 22:21:00 -0700
Subject: [PATCH RFC v2 09/18] cxl/mem: Read extents on memory device
 discovery
MIME-Version: 1.0
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: 7bit
Message-Id: <20230604-dcd-type2-upstream-v2-9-f740c47e7916@intel.com>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
In-Reply-To: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
To: Dan Williams <dan.j.williams@intel.com>
Cc: Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        Ira Weiny <ira.weiny@intel.com>, linux-cxl@vger.kernel.org,
        linux-kernel@vger.kernel.org
X-Mailer: b4 0.13-dev-c6835
X-Developer-Signature: v=1; a=ed25519-sha256; t=1693286607; l=10377;
 i=ira.weiny@intel.com; s=20221211; h=from:subject:message-id;
 bh=sMf7HpI3l9SxR8zPU0ViBRKMt/oH1JbxsGrHT1GC9e8=;
 b=DXdJa3GmWpDzAZB7RV8KUpBrrcL35MazB12iR+R3CCzc4WxGEkOz9Mjo6G+JAN4takuSLisFf
 eZ/GLZtVpEACC9/NQMOTNZY9eV0KcUAmKyc8J2ElDOqtt1fcEW9749l
X-Developer-Key: i=ira.weiny@intel.com; a=ed25519;
 pk=noldbkG+Wp1qXRrrkfY1QJpDf7QsOEthbOT7vm0PqsE=
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

When a Dynamic Capacity Device (DCD) is realized some extents may
already be available within the DC Regions.  This can happen if the host
has accepted extents and been rebooted or any other time the host driver
software has become out of sync with the device hardware.

Read the available extents during probe and store them for later
use.

Signed-off-by: Navneet Singh <navneet.singh@intel.com>
Co-developed-by: Navneet Singh <navneet.singh@intel.com>
Signed-off-by: Ira Weiny <ira.weiny@intel.com>

---
Change for v2:
[iweiny: new patch]
---
 drivers/cxl/core/mbox.c | 195 ++++++++++++++++++++++++++++++++++++++++++++++++
 drivers/cxl/cxlmem.h    |  36 +++++++++
 drivers/cxl/pci.c       |   4 +
 3 files changed, 235 insertions(+)

diff --git a/drivers/cxl/core/mbox.c b/drivers/cxl/core/mbox.c
index d769814f80e2..9b08c40ef484 100644
--- a/drivers/cxl/core/mbox.c
+++ b/drivers/cxl/core/mbox.c
@@ -824,6 +824,37 @@ int cxl_enumerate_cmds(struct cxl_memdev_state *mds)
 }
 EXPORT_SYMBOL_NS_GPL(cxl_enumerate_cmds, CXL);
 
+static int cxl_store_dc_extent(struct cxl_memdev_state *mds,
+			       struct cxl_dc_extent *dc_extent)
+{
+	struct device *dev = mds->cxlds.dev;
+	struct cxl_dc_extent_data *extent;
+	int rc;
+
+	extent = kzalloc(sizeof(*extent), GFP_KERNEL);
+	if (!extent)
+		return -ENOMEM;
+
+	extent->dpa_start = le64_to_cpu(dc_extent->start_dpa);
+	extent->length = le64_to_cpu(dc_extent->length);
+	memcpy(extent->tag, dc_extent->tag, sizeof(extent->tag));
+	extent->shared_extent_seq = le16_to_cpu(dc_extent->shared_extn_seq);
+
+	dev_dbg(dev, "dynamic capacity extent DPA:0x%llx LEN:%llx\n",
+		extent->dpa_start, extent->length);
+
+	rc = xa_insert(&mds->dc_extent_list, extent->dpa_start, extent,
+			 GFP_KERNEL);
+	if (rc) {
+		if (rc == -EBUSY)
+			dev_warn_once(dev, "Duplicate extent DPA:%llx LEN:%llx\n",
+				      extent->dpa_start, extent->length);
+		kfree(extent);
+	}
+
+	return rc;
+}
+
 /*
  * General Media Event Record
  * CXL rev 3.0 Section 8.2.9.2.1.1; Table 8-43
@@ -1339,6 +1370,149 @@ int cxl_dev_dynamic_capacity_identify(struct cxl_memdev_state *mds)
 }
 EXPORT_SYMBOL_NS_GPL(cxl_dev_dynamic_capacity_identify, CXL);
 
+static int cxl_dev_get_dc_extent_cnt(struct cxl_memdev_state *mds,
+				     unsigned int *extent_gen_num)
+{
+	struct cxl_mbox_get_dc_extent get_dc_extent;
+	struct cxl_mbox_dc_extents dc_extents;
+	struct device *dev = mds->cxlds.dev;
+	struct cxl_mbox_cmd mbox_cmd;
+	unsigned int count;
+	int rc;
+
+	/* Check GET_DC_EXTENT_LIST is supported by device */
+	if (!test_bit(CXL_DCD_ENABLED_GET_EXTENT_LIST, mds->dcd_cmds)) {
+		dev_dbg(dev, "unsupported cmd : get dyn cap extent list\n");
+		return 0;
+	}
+
+	get_dc_extent = (struct cxl_mbox_get_dc_extent) {
+		.extent_cnt = cpu_to_le32(0),
+		.start_extent_index = cpu_to_le32(0),
+	};
+
+	mbox_cmd = (struct cxl_mbox_cmd) {
+		.opcode = CXL_MBOX_OP_GET_DC_EXTENT_LIST,
+		.payload_in = &get_dc_extent,
+		.size_in = sizeof(get_dc_extent),
+		.size_out = mds->payload_size,
+		.payload_out = &dc_extents,
+		.min_out = 1,
+	};
+
+	rc = cxl_internal_send_cmd(mds, &mbox_cmd);
+	if (rc < 0)
+		return rc;
+
+	count = le32_to_cpu(dc_extents.total_extent_cnt);
+	*extent_gen_num = le32_to_cpu(dc_extents.extent_list_num);
+
+	return count;
+}
+
+static int cxl_dev_get_dc_extents(struct cxl_memdev_state *mds,
+				  unsigned int start_gen_num,
+				  unsigned int exp_cnt)
+{
+	struct cxl_mbox_dc_extents *dc_extents;
+	unsigned int start_index, total_read;
+	struct device *dev = mds->cxlds.dev;
+	struct cxl_mbox_cmd mbox_cmd;
+	int retry = 3;
+	int rc;
+
+	/* Check GET_DC_EXTENT_LIST is supported by device */
+	if (!test_bit(CXL_DCD_ENABLED_GET_EXTENT_LIST, mds->dcd_cmds)) {
+		dev_dbg(dev, "unsupported cmd : get dyn cap extent list\n");
+		return 0;
+	}
+
+	dc_extents = kvmalloc(mds->payload_size, GFP_KERNEL);
+	if (!dc_extents)
+		return -ENOMEM;
+
+reset:
+	total_read = 0;
+	start_index = 0;
+	do {
+		unsigned int nr_ext, total_extent_cnt, gen_num;
+		struct cxl_mbox_get_dc_extent get_dc_extent;
+
+		get_dc_extent = (struct cxl_mbox_get_dc_extent) {
+			.extent_cnt = exp_cnt - start_index,
+			.start_extent_index = start_index,
+		};
+		
+		mbox_cmd = (struct cxl_mbox_cmd) {
+			.opcode = CXL_MBOX_OP_GET_DC_EXTENT_LIST,
+			.payload_in = &get_dc_extent,
+			.size_in = sizeof(get_dc_extent),
+			.size_out = mds->payload_size,
+			.payload_out = dc_extents,
+			.min_out = 1,
+		};
+		
+		rc = cxl_internal_send_cmd(mds, &mbox_cmd);
+		if (rc < 0)
+			goto out;
+		
+		nr_ext = le32_to_cpu(dc_extents->ret_extent_cnt);
+		total_read += nr_ext;
+		total_extent_cnt = le32_to_cpu(dc_extents->total_extent_cnt);
+		gen_num = le32_to_cpu(dc_extents->extent_list_num);
+
+		dev_dbg(dev, "Get extent list count:%d generation Num:%d\n",
+			total_extent_cnt, gen_num);
+
+		if (gen_num != start_gen_num || exp_cnt != total_extent_cnt) {
+			dev_err(dev, "Extent list changed while reading; %u != %u : %u != %u\n",
+				gen_num, start_gen_num, exp_cnt, total_extent_cnt);
+			if (retry--)
+				goto reset;
+			return -EIO;
+		}
+		
+		for (int i = 0; i < nr_ext ; i++) {
+			dev_dbg(dev, "Storing extent %d/%d\n",
+				start_index + i, exp_cnt);
+			rc = cxl_store_dc_extent(mds, &dc_extents->extent[i]);
+			if (rc)
+				goto out;
+		}
+
+		start_index += nr_ext;
+	} while (exp_cnt > total_read);
+
+out:
+	kvfree(dc_extents);
+	return rc;
+}
+
+/**
+ * cxl_dev_get_dynamic_capacity_extents() - Reads the dynamic capacity
+ *					 extent list.
+ * @mds: The memory device state
+ *
+ * This will dispatch the get_dynamic_capacity_extent_list command to the device
+ * and on success add the extents to the host managed extent list.
+ *
+ * Return: 0 if command was executed successfully, -ERRNO on error.
+ */
+int cxl_dev_get_dynamic_capacity_extents(struct cxl_memdev_state *mds)
+{
+	unsigned int extent_gen_num;
+	int rc;
+
+	rc = cxl_dev_get_dc_extent_cnt(mds, &extent_gen_num);
+	dev_dbg(mds->cxlds.dev, "Extent count: %d Generation Num: %d\n",
+		rc, extent_gen_num);
+	if (rc <= 0) /* 0 == no records found */
+		return rc;
+
+	return cxl_dev_get_dc_extents(mds, extent_gen_num, rc);
+}
+EXPORT_SYMBOL_NS_GPL(cxl_dev_get_dynamic_capacity_extents, CXL);
+
 static int add_dpa_res(struct device *dev, struct resource *parent,
 		       struct resource *res, resource_size_t start,
 		       resource_size_t size, const char *type)
@@ -1530,9 +1704,23 @@ int cxl_poison_state_init(struct cxl_memdev_state *mds)
 }
 EXPORT_SYMBOL_NS_GPL(cxl_poison_state_init, CXL);
 
+static void cxl_destroy_mds(void *_mds)
+{
+	struct cxl_memdev_state *mds = _mds;
+	struct cxl_dc_extent_data *extent;
+	unsigned long index;
+
+	xa_for_each(&mds->dc_extent_list, index, extent) {
+		xa_erase(&mds->dc_extent_list, index);
+		kfree(extent);
+	}
+	xa_destroy(&mds->dc_extent_list);
+}
+
 struct cxl_memdev_state *cxl_memdev_state_create(struct device *dev)
 {
 	struct cxl_memdev_state *mds;
+	int rc;
 
 	mds = devm_kzalloc(dev, sizeof(*mds), GFP_KERNEL);
 	if (!mds) {
@@ -1544,6 +1732,13 @@ struct cxl_memdev_state *cxl_memdev_state_create(struct device *dev)
 	mutex_init(&mds->event.log_lock);
 	mds->cxlds.dev = dev;
 	mds->cxlds.type = CXL_DEVTYPE_CLASSMEM;
+	xa_init(&mds->dc_extent_list);
+
+	rc = devm_add_action_or_reset(dev, cxl_destroy_mds, mds);
+	if (rc) {
+		dev_err(dev, "Failed to set up memdev state; %d\n", rc);
+		return ERR_PTR(rc);
+	}
 
 	return mds;
 }
diff --git a/drivers/cxl/cxlmem.h b/drivers/cxl/cxlmem.h
index 8c8f47b397ab..ad690600c1b9 100644
--- a/drivers/cxl/cxlmem.h
+++ b/drivers/cxl/cxlmem.h
@@ -6,6 +6,7 @@
 #include <linux/cdev.h>
 #include <linux/uuid.h>
 #include <linux/rcuwait.h>
+#include <linux/xarray.h>
 #include "cxl.h"
 
 /* CXL 2.0 8.2.8.5.1.1 Memory Device Status Register */
@@ -509,6 +510,7 @@ struct cxl_memdev_state {
 	u8 nr_dc_region;
 	struct cxl_dc_region_info dc_region[CXL_MAX_DC_REGION];
 	size_t dc_event_log_size;
+	struct xarray dc_extent_list;
 
 	struct cxl_event_state event;
 	struct cxl_poison_state poison;
@@ -749,6 +751,26 @@ struct cxl_event_mem_module {
 	u8 reserved[0x3d];
 } __packed;
 
+#define CXL_DC_EXTENT_TAG_LEN 0x10
+struct cxl_dc_extent_data {
+	u64 dpa_start;
+	u64 length;
+	u8 tag[CXL_DC_EXTENT_TAG_LEN];
+	u16 shared_extent_seq;
+};
+
+/*
+ * Dynamic Capacity Event Record
+ * CXL rev 3.0 section 8.2.9.2.1.5; Table 8-47
+ */
+struct cxl_dc_extent {
+	__le64 start_dpa;
+	__le64 length;
+	u8 tag[CXL_DC_EXTENT_TAG_LEN];
+	__le16 shared_extn_seq;
+	u8 reserved[6];
+} __packed;
+
 struct cxl_mbox_get_partition_info {
 	__le64 active_volatile_cap;
 	__le64 active_persistent_cap;
@@ -796,6 +818,19 @@ struct cxl_mbox_dynamic_capacity {
 #define CXL_REGIONS_RETURNED(size_out) \
 	((size_out - 8) / sizeof(struct cxl_dc_region_config))
 
+struct cxl_mbox_get_dc_extent {
+	__le32 extent_cnt;
+	__le32 start_extent_index;
+} __packed;
+
+struct cxl_mbox_dc_extents {
+	__le32 ret_extent_cnt;
+	__le32 total_extent_cnt;
+	__le32 extent_list_num;
+	u8 rsvd[4];
+	struct cxl_dc_extent extent[];
+}  __packed;
+
 /* Set Timestamp CXL 3.0 Spec 8.2.9.4.2 */
 struct cxl_mbox_set_timestamp_in {
 	__le64 timestamp;
@@ -920,6 +955,7 @@ int cxl_internal_send_cmd(struct cxl_memdev_state *mds,
 			  struct cxl_mbox_cmd *cmd);
 int cxl_dev_state_identify(struct cxl_memdev_state *mds);
 int cxl_dev_dynamic_capacity_identify(struct cxl_memdev_state *mds);
+int cxl_dev_get_dynamic_capacity_extents(struct cxl_memdev_state *mds);
 int cxl_await_media_ready(struct cxl_dev_state *cxlds);
 int cxl_enumerate_cmds(struct cxl_memdev_state *mds);
 int cxl_mem_create_range_info(struct cxl_memdev_state *mds);
diff --git a/drivers/cxl/pci.c b/drivers/cxl/pci.c
index a9b110ff1176..10c1a583113c 100644
--- a/drivers/cxl/pci.c
+++ b/drivers/cxl/pci.c
@@ -930,6 +930,10 @@ static int cxl_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	if (rc)
 		dev_dbg(&pdev->dev, "No RAS reporting unmasked\n");
 
+	rc = cxl_dev_get_dynamic_capacity_extents(mds);
+	if (rc)
+		return rc;
+
 	pci_save_state(pdev);
 
 	return rc;

-- 
2.41.0


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 25A5DC83F24
	for <linux-cxl@archiver.kernel.org>; Tue, 29 Aug 2023 05:24:56 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S235681AbjH2FY0 (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 29 Aug 2023 01:24:26 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:53180 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S235650AbjH2FYI (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 29 Aug 2023 01:24:08 -0400
Received: from mgamail.intel.com (mgamail.intel.com [134.134.136.100])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 0B8E3198;
        Mon, 28 Aug 2023 22:24:05 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1693286645; x=1724822645;
  h=from:date:subject:mime-version:content-transfer-encoding:
   message-id:references:in-reply-to:to:cc;
  bh=zS3/1vUp47voXvMtZLKSXJRnsSaBhyCVW1VJ7CoL4rQ=;
  b=d6wOUtI1KyVcpIKI3nXubvYbL71BYYlkeAJYNJ0UKNbKB+LpRzwQw2mx
   vyQYmeZ4TVlFsH2D73YxVlRopGn4H4SBYXfz6XLUeydj0KLydOw+awKtR
   Wi3j5chcp+xuRj+TWhiP2TVvSHDtZRrQ+YUlLyNzkDLqpKeP1guC19fB3
   AMSNrZhFG2+nI6yMKtshG73DcyxSbjnVeJqTXLKFm5UGQ4JJk0lw+5cS1
   adbRuGy26ztPkUvpMXdPJBJoLOH2TQKHE6eEJ4Jf56abbqgS9/nqRjTgw
   mxpq9qVyX6OW1e12zRjDMyOTkYcPbjsyHll7OqDJdHFYwio7tztCFdfPc
   g==;
X-IronPort-AV: E=McAfee;i="6600,9927,10816"; a="441625198"
X-IronPort-AV: E=Sophos;i="6.02,208,1688454000"; 
   d="scan'208";a="441625198"
Received: from orsmga002.jf.intel.com ([10.7.209.21])
  by orsmga105.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 28 Aug 2023 22:23:37 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10816"; a="738556344"
X-IronPort-AV: E=Sophos;i="6.02,208,1688454000"; 
   d="scan'208";a="738556344"
Received: from iweiny-mobl.amr.corp.intel.com (HELO localhost) ([10.212.37.183])
  by orsmga002-auth.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 28 Aug 2023 22:23:38 -0700
From: Ira Weiny <ira.weiny@intel.com>
Date: Mon, 28 Aug 2023 22:20:57 -0700
Subject: [PATCH RFC v2 06/18] cxl/port: Add Dynamic Capacity size support
 to endpoint decoders
MIME-Version: 1.0
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: 7bit
Message-Id: <20230604-dcd-type2-upstream-v2-6-f740c47e7916@intel.com>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
In-Reply-To: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
To: Dan Williams <dan.j.williams@intel.com>
Cc: Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        Ira Weiny <ira.weiny@intel.com>, linux-cxl@vger.kernel.org,
        linux-kernel@vger.kernel.org
X-Mailer: b4 0.13-dev-c6835
X-Developer-Signature: v=1; a=ed25519-sha256; t=1693286607; l=14411;
 i=ira.weiny@intel.com; s=20221211; h=from:subject:message-id;
 bh=zS3/1vUp47voXvMtZLKSXJRnsSaBhyCVW1VJ7CoL4rQ=;
 b=azQURVE/COvF/9B+3h+m8DWmdFqLfYeDR5rD/b3EB98hOkSH8D/AIeoAUOS3fFfjV9QBz5S/3
 fwENwRgXPHaAqPbFVYkNFJxhY4sMr80X979GWt/KtIUky39zQbl5mJR
X-Developer-Key: i=ira.weiny@intel.com; a=ed25519;
 pk=noldbkG+Wp1qXRrrkfY1QJpDf7QsOEthbOT7vm0PqsE=
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

To support Dynamic Capacity Devices (DCD) endpoint decoders will need to
map DC Regions (partitions).  Part of this is assigning the size of the
DC Region DPA to the decoder in addition to any skip value from the
previous decoder which exists.  This must be done within a continuous
DPA space.  Two complications arise with Dynamic Capacity regions which
did not exist with Ram and PMEM partitions.  First, gaps in the DPA
space can exist between and around the DC Regions.  Second, the Linux
resource tree does not allow a resource to be marked across existing
nodes within a tree.

For clarity, below is an example of an 60GB device with 10GB of RAM,
10GB of PMEM and 10GB for each of 2 DC Regions.  The desired CXL mapping
is 5GB of RAM, 5GB of PMEM, and all 10GB of DC1.

     DPA RANGE
     (dpa_res)
0GB        10GB       20GB       30GB       40GB       50GB       60GB
|----------|----------|----------|----------|----------|----------|

RAM         PMEM                  DC0                   DC1
 (ram_res)  (pmem_res)            (dc_res[0])           (dc_res[1])
|----------|----------|   <gap>  |----------|   <gap>  |----------|

 RAM        PMEM                                        DC1
|XXXXX|----|XXXXX|----|----------|----------|----------|XXXXXXXXXX|
0GB   5GB  10GB  15GB 20GB       30GB       40GB       50GB       60GB

The previous skip resource between RAM and PMEM was always a child of
the RAM resource and fit nicely (see X below).  Because of this
simplicity this skip resource reference was not stored in any CXL state.
On release the skip range could be calculated based on the endpoint
decoders stored values.

Now when DC1 is being mapped 4 skip resources must be created as
children.  One of the PMEM resource (A), two of the parent DPA resource
(B,D), and one more child of the DC0 resource (C).

0GB        10GB       20GB       30GB       40GB       50GB       60GB
|----------|----------|----------|----------|----------|----------|
                           |                     |
|----------|----------|    |     |----------|    |     |----------|
        |          |       |          |          |
       (X)        (A)     (B)        (C)        (D)
	v          v       v          v          v
|XXXXX|----|XXXXX|----|----------|----------|----------|XXXXXXXXXX|
       skip       skip  skip        skip      skip

Expand the calculation of DPA freespace and enhance the logic to support
mapping/unmapping DC DPA space.  To track the potential of multiple skip
resources an xarray is attached to the endpoint decoder.  The existing
algorithm is consolidated with the new one to store a single skip
resource in the same way as multiple skip resources.

Co-developed-by: Navneet Singh <navneet.singh@intel.com>
Signed-off-by: Navneet Singh <navneet.singh@intel.com>
Signed-off-by: Ira Weiny <ira.weiny@intel.com>

---
An alternative of using reserve_region_with_split() was considered.
The advantage of that would be keeping all the resource information
stored solely in the resource tree rather than having separate
references to them.  However, it would best be implemented with a call
such as release_split_region() [name TBD?] which could find all the leaf
resources in the range and release them.  Furthermore, it is not clear
if reserve_region_with_split() is really intended for anything outside
of init code.  In the end this algorithm seems straight forward enough.

Changes for v2:
[iweiny: write commit message]
[iweiny: remove unneeded changes]
[iweiny: split from region creation patch]
[iweiny: Alter skip algorithm to use 'anonymous regions']
[iweiny: enhance debug messages]
[iweiny: consolidate skip resource creation]
[iweiny: ensure xa_destroy() is called]
[iweiny: consolidate region requests further]
[iweiny: ensure resource is released on xa_insert]
---
 drivers/cxl/core/hdm.c  | 188 +++++++++++++++++++++++++++++++++++++++++++-----
 drivers/cxl/core/port.c |   2 +
 drivers/cxl/cxl.h       |   2 +
 3 files changed, 176 insertions(+), 16 deletions(-)

diff --git a/drivers/cxl/core/hdm.c b/drivers/cxl/core/hdm.c
index 3f4af1f5fac8..3cd048677816 100644
--- a/drivers/cxl/core/hdm.c
+++ b/drivers/cxl/core/hdm.c
@@ -222,6 +222,25 @@ void cxl_dpa_debug(struct seq_file *file, struct cxl_dev_state *cxlds)
 }
 EXPORT_SYMBOL_NS_GPL(cxl_dpa_debug, CXL);
 
+static void cxl_skip_release(struct cxl_endpoint_decoder *cxled)
+{
+	struct cxl_dev_state *cxlds = cxled_to_memdev(cxled)->cxlds;
+	struct cxl_port *port = cxled_to_port(cxled);
+	struct device *dev = &port->dev;
+	unsigned long index;
+	void *entry;
+
+	xa_for_each(&cxled->skip_res, index, entry) {
+		struct resource *res = entry;
+
+		dev_dbg(dev, "decoder%d.%d: releasing skipped space; %pr\n",
+			port->id, cxled->cxld.id, res);
+		__release_region(&cxlds->dpa_res, res->start,
+				 resource_size(res));
+		xa_erase(&cxled->skip_res, index);
+	}
+}
+
 /*
  * Must be called in a context that synchronizes against this decoder's
  * port ->remove() callback (like an endpoint decoder sysfs attribute)
@@ -232,15 +251,11 @@ static void __cxl_dpa_release(struct cxl_endpoint_decoder *cxled)
 	struct cxl_port *port = cxled_to_port(cxled);
 	struct cxl_dev_state *cxlds = cxlmd->cxlds;
 	struct resource *res = cxled->dpa_res;
-	resource_size_t skip_start;
 
 	lockdep_assert_held_write(&cxl_dpa_rwsem);
 
-	/* save @skip_start, before @res is released */
-	skip_start = res->start - cxled->skip;
 	__release_region(&cxlds->dpa_res, res->start, resource_size(res));
-	if (cxled->skip)
-		__release_region(&cxlds->dpa_res, skip_start, cxled->skip);
+	cxl_skip_release(cxled);
 	cxled->skip = 0;
 	cxled->dpa_res = NULL;
 	put_device(&cxled->cxld.dev);
@@ -280,6 +295,98 @@ static int dc_mode_to_region_index(enum cxl_decoder_mode mode)
 	return -EINVAL;
 }
 
+static int cxl_request_skip(struct cxl_endpoint_decoder *cxled,
+			    resource_size_t skip_base, resource_size_t skip_len)
+{
+	struct cxl_dev_state *cxlds = cxled_to_memdev(cxled)->cxlds;
+	const char *name = dev_name(&cxled->cxld.dev);
+	struct cxl_port *port = cxled_to_port(cxled);
+	struct resource *dpa_res = &cxlds->dpa_res;
+	struct device *dev = &port->dev;
+	struct resource *res;
+	int rc;
+
+	res = __request_region(dpa_res, skip_base, skip_len, name, 0);
+	if (!res)
+		return -EBUSY;
+
+	rc = xa_insert(&cxled->skip_res, skip_base, res, GFP_KERNEL);
+	if (rc) {
+		__release_region(dpa_res, skip_base, skip_len);
+		return rc;
+	}
+
+	dev_dbg(dev, "decoder%d.%d: skipped space; %pr\n",
+		port->id, cxled->cxld.id, res);
+	return 0;
+}
+
+static int cxl_reserve_dpa_skip(struct cxl_endpoint_decoder *cxled,
+				resource_size_t base, resource_size_t skipped)
+{
+	struct cxl_memdev *cxlmd = cxled_to_memdev(cxled);
+	struct cxl_port *port = cxled_to_port(cxled);
+	struct cxl_dev_state *cxlds = cxlmd->cxlds;
+	resource_size_t skip_base = base - skipped;
+	resource_size_t size, skip_len = 0;
+	struct device *dev = &port->dev;
+	int rc, index;
+
+	size = resource_size(&cxlds->ram_res);
+	if (size && skip_base <= cxlds->ram_res.end) {
+		skip_len = cxlds->ram_res.end - skip_base + 1;
+		rc = cxl_request_skip(cxled, skip_base, skip_len);
+		if (rc)
+			return rc;
+		skip_base += skip_len;
+	}
+
+	if (skip_base == base) {
+		dev_dbg(dev, "skip done!\n");
+		return 0;
+	}
+
+	size = resource_size(&cxlds->pmem_res);
+	if (size && skip_base <= cxlds->pmem_res.end) {
+		skip_len = cxlds->pmem_res.end - skip_base + 1;
+		rc = cxl_request_skip(cxled, skip_base, skip_len);
+		if (rc)
+			return rc;
+		skip_base += skip_len;
+	}
+
+	index = dc_mode_to_region_index(cxled->mode);
+	for (int i = 0; i <= index; i++) {
+		struct resource *dcr = &cxlds->dc_res[i];
+
+		if (skip_base < dcr->start) {
+			skip_len = dcr->start - skip_base;
+			rc = cxl_request_skip(cxled, skip_base, skip_len);
+			if (rc)
+				return rc;
+			skip_base += skip_len;
+		}
+
+		if (skip_base == base) {
+			dev_dbg(dev, "skip done!\n");
+			break;
+		}
+
+		if (resource_size(dcr) && skip_base <= dcr->end) {
+			if (skip_base > base)
+				dev_err(dev, "Skip error\n");
+
+			skip_len = dcr->end - skip_base + 1;
+			rc = cxl_request_skip(cxled, skip_base, skip_len);
+			if (rc)
+				return rc;
+			skip_base += skip_len;
+		}
+	}
+
+	return 0;
+}
+
 static int __cxl_dpa_reserve(struct cxl_endpoint_decoder *cxled,
 			     resource_size_t base, resource_size_t len,
 			     resource_size_t skipped)
@@ -317,13 +424,12 @@ static int __cxl_dpa_reserve(struct cxl_endpoint_decoder *cxled,
 	}
 
 	if (skipped) {
-		res = __request_region(&cxlds->dpa_res, base - skipped, skipped,
-				       dev_name(&cxled->cxld.dev), 0);
-		if (!res) {
-			dev_dbg(dev,
-				"decoder%d.%d: failed to reserve skipped space\n",
-				port->id, cxled->cxld.id);
-			return -EBUSY;
+		int rc = cxl_reserve_dpa_skip(cxled, base, skipped);
+
+		if (rc) {
+			dev_dbg(dev, "decoder%d.%d: failed to reserve skipped space; %#llx - %#llx\n",
+				port->id, cxled->cxld.id, base, skipped);
+			return rc;
 		}
 	}
 	res = __request_region(&cxlds->dpa_res, base, len,
@@ -331,14 +437,20 @@ static int __cxl_dpa_reserve(struct cxl_endpoint_decoder *cxled,
 	if (!res) {
 		dev_dbg(dev, "decoder%d.%d: failed to reserve allocation\n",
 			port->id, cxled->cxld.id);
-		if (skipped)
-			__release_region(&cxlds->dpa_res, base - skipped,
-					 skipped);
+		cxl_skip_release(cxled);
 		return -EBUSY;
 	}
 	cxled->dpa_res = res;
 	cxled->skip = skipped;
 
+	for (int mode = CXL_DECODER_DC0; mode <= CXL_DECODER_DC7; mode++) {
+		int index = dc_mode_to_region_index(mode);
+
+		if (resource_contains(&cxlds->dc_res[index], res)) {
+			cxled->mode = mode;
+			goto success;
+		}
+	}
 	if (resource_contains(&cxlds->pmem_res, res))
 		cxled->mode = CXL_DECODER_PMEM;
 	else if (resource_contains(&cxlds->ram_res, res))
@@ -349,6 +461,9 @@ static int __cxl_dpa_reserve(struct cxl_endpoint_decoder *cxled,
 		cxled->mode = CXL_DECODER_MIXED;
 	}
 
+success:
+	dev_dbg(dev, "decoder%d.%d: %pr mode: %d\n", port->id, cxled->cxld.id,
+		cxled->dpa_res, cxled->mode);
 	port->hdm_end++;
 	get_device(&cxled->cxld.dev);
 	return 0;
@@ -492,11 +607,13 @@ static resource_size_t cxl_dpa_freespace(struct cxl_endpoint_decoder *cxled,
 					 resource_size_t *start_out,
 					 resource_size_t *skip_out)
 {
+	resource_size_t free_ram_start, free_pmem_start, free_dc_start;
 	struct cxl_memdev *cxlmd = cxled_to_memdev(cxled);
-	resource_size_t free_ram_start, free_pmem_start;
 	struct cxl_dev_state *cxlds = cxlmd->cxlds;
+	struct device *dev = &cxled->cxld.dev;
 	resource_size_t start, avail, skip;
 	struct resource *p, *last;
+	int index;
 
 	lockdep_assert_held(&cxl_dpa_rwsem);
 
@@ -514,6 +631,20 @@ static resource_size_t cxl_dpa_freespace(struct cxl_endpoint_decoder *cxled,
 	else
 		free_pmem_start = cxlds->pmem_res.start;
 
+	/*
+	 * Limit each decoder to a single DC region to map memory with
+	 * different DSMAS entry.
+	 */
+	index = dc_mode_to_region_index(cxled->mode);
+	if (index >= 0) {
+		if (cxlds->dc_res[index].child) {
+			dev_err(dev, "Cannot allocate DPA from DC Region: %d\n",
+				index);
+			return -EINVAL;
+		}
+		free_dc_start = cxlds->dc_res[index].start;
+	}
+
 	if (cxled->mode == CXL_DECODER_RAM) {
 		start = free_ram_start;
 		avail = cxlds->ram_res.end - start + 1;
@@ -535,6 +666,29 @@ static resource_size_t cxl_dpa_freespace(struct cxl_endpoint_decoder *cxled,
 		else
 			skip_end = start - 1;
 		skip = skip_end - skip_start + 1;
+	} else if (cxl_decoder_mode_is_dc(cxled->mode)) {
+		resource_size_t skip_start, skip_end;
+
+		start = free_dc_start;
+		avail = cxlds->dc_res[index].end - start + 1;
+		if ((resource_size(&cxlds->pmem_res) == 0) || !cxlds->pmem_res.child)
+			skip_start = free_ram_start;
+		else
+			skip_start = free_pmem_start;
+		/*
+		 * If any dc region is already mapped, then that allocation
+		 * already handled the RAM and PMEM skip.  Check for DC region
+		 * skip.
+		 */
+		for (int i = index - 1; i >= 0 ; i--) {
+			if (cxlds->dc_res[i].child) {
+				skip_start = cxlds->dc_res[i].child->end + 1;
+				break;
+			}
+		}
+
+		skip_end = start - 1;
+		skip = skip_end - skip_start + 1;
 	} else {
 		dev_dbg(cxled_dev(cxled), "mode not set\n");
 		avail = 0;
@@ -572,6 +726,8 @@ int cxl_dpa_alloc(struct cxl_endpoint_decoder *cxled, unsigned long long size)
 
 	avail = cxl_dpa_freespace(cxled, &start, &skip);
 
+	dev_dbg(dev, "DPA Allocation start: %llx len: %llx Skip: %llx\n",
+		start, size, skip);
 	if (size > avail) {
 		dev_dbg(dev, "%pa exceeds available %s capacity: %pa\n", &size,
 			cxl_decoder_mode_name(cxled->mode), &avail);
diff --git a/drivers/cxl/core/port.c b/drivers/cxl/core/port.c
index ce4a66865db3..a5db710a63bc 100644
--- a/drivers/cxl/core/port.c
+++ b/drivers/cxl/core/port.c
@@ -413,6 +413,7 @@ static void cxl_endpoint_decoder_release(struct device *dev)
 	struct cxl_endpoint_decoder *cxled = to_cxl_endpoint_decoder(dev);
 
 	__cxl_decoder_release(&cxled->cxld);
+	xa_destroy(&cxled->skip_res);
 	kfree(cxled);
 }
 
@@ -1769,6 +1770,7 @@ struct cxl_endpoint_decoder *cxl_endpoint_decoder_alloc(struct cxl_port *port)
 		return ERR_PTR(-ENOMEM);
 
 	cxled->pos = -1;
+	xa_init(&cxled->skip_res);
 	cxld = &cxled->cxld;
 	rc = cxl_decoder_init(port, cxld);
 	if (rc)	 {
diff --git a/drivers/cxl/cxl.h b/drivers/cxl/cxl.h
index d41f3f14fbe3..0a225b0c20bf 100644
--- a/drivers/cxl/cxl.h
+++ b/drivers/cxl/cxl.h
@@ -433,6 +433,7 @@ enum cxl_decoder_state {
  * @cxld: base cxl_decoder_object
  * @dpa_res: actively claimed DPA span of this decoder
  * @skip: offset into @dpa_res where @cxld.hpa_range maps
+ * @skip_res: array of skipped resources from the previous decoder end
  * @mode: which memory type / access-mode-partition this decoder targets
  * @state: autodiscovery state
  * @pos: interleave position in @cxld.region
@@ -441,6 +442,7 @@ struct cxl_endpoint_decoder {
 	struct cxl_decoder cxld;
 	struct resource *dpa_res;
 	resource_size_t skip;
+	struct xarray skip_res;
 	enum cxl_decoder_mode mode;
 	enum cxl_decoder_state state;
 	int pos;

-- 
2.41.0


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 68D1DC83F1F
	for <linux-cxl@archiver.kernel.org>; Tue, 29 Aug 2023 05:24:55 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S235635AbjH2FYY (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 29 Aug 2023 01:24:24 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:53124 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S235646AbjH2FYG (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 29 Aug 2023 01:24:06 -0400
Received: from mgamail.intel.com (mgamail.intel.com [134.134.136.100])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 2D172198;
        Mon, 28 Aug 2023 22:24:02 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1693286642; x=1724822642;
  h=from:date:subject:mime-version:content-transfer-encoding:
   message-id:references:in-reply-to:to:cc;
  bh=vIuADnUsFOHSO13BA58d0KR02uIC0W8w3AHCzp9q8Xo=;
  b=jqNIq26hbSB5VZ3Vg7tx+P0C+3K0+/XdXCFoJlWbQGEdaMl7WC/3qqTw
   TPlA+ZzSplVUTuWVOLkj0ut5KaY4ph4zKiWZ2mXUcRLG6vujPO1UuSiIP
   V4I0gzd8dkeofHX2qWGha/rLmqwh7v8tfeNm3aY7bMdagZWjk3ovPPsMe
   Zv0I5EUrcPnj0o10+V6HyWG6gKNydBoHlYOdJbeSo+97D3sj+GjdEDru/
   M/B4o8TzpjeNZwRVNE/f8uoW3/CtZlKGeuFdpOIWcr4Bzlfx5dDZQ12od
   xhe8/xE8hCQzjC/HSmXzm1oWE0+N2H1XMWivj3C7nHsCyK45m9vMv1yKp
   w==;
X-IronPort-AV: E=McAfee;i="6600,9927,10816"; a="441625168"
X-IronPort-AV: E=Sophos;i="6.02,208,1688454000"; 
   d="scan'208";a="441625168"
Received: from orsmga002.jf.intel.com ([10.7.209.21])
  by orsmga105.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 28 Aug 2023 22:23:32 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10816"; a="738556303"
X-IronPort-AV: E=Sophos;i="6.02,208,1688454000"; 
   d="scan'208";a="738556303"
Received: from iweiny-mobl.amr.corp.intel.com (HELO localhost) ([10.212.37.183])
  by orsmga002-auth.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 28 Aug 2023 22:23:32 -0700
From: Ira Weiny <ira.weiny@intel.com>
Date: Mon, 28 Aug 2023 22:20:53 -0700
Subject: [PATCH RFC v2 02/18] cxl/mbox: Flag support for Dynamic Capacity
 Devices (DCD)
MIME-Version: 1.0
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: 7bit
Message-Id: <20230604-dcd-type2-upstream-v2-2-f740c47e7916@intel.com>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
In-Reply-To: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
To: Dan Williams <dan.j.williams@intel.com>
Cc: Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        Ira Weiny <ira.weiny@intel.com>, linux-cxl@vger.kernel.org,
        linux-kernel@vger.kernel.org
X-Mailer: b4 0.13-dev-c6835
X-Developer-Signature: v=1; a=ed25519-sha256; t=1693286607; l=4400;
 i=ira.weiny@intel.com; s=20221211; h=from:subject:message-id;
 bh=vIuADnUsFOHSO13BA58d0KR02uIC0W8w3AHCzp9q8Xo=;
 b=ie3PJYt6OSaV2n9zSkSmECkucUzBHRdfgUmTcZSiR1Fevc2wie+t4Ads+h8tsA196OllPCnDq
 1JEZi/vGJMDDx7UpG6v4TOGehcg2HCigjq4xAuGZI5cN27Ap7HwTUAG
X-Developer-Key: i=ira.weiny@intel.com; a=ed25519;
 pk=noldbkG+Wp1qXRrrkfY1QJpDf7QsOEthbOT7vm0PqsE=
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

Per the CXL 3.0 specification software must check the Command Effects
Log (CEL) to know if a device supports DC.  If the device does support
DC the specifics of the DC Regions (0-7) are read through the mailbox.

Flag DC Device (DCD) commands in a device if they are supported.
Subsequent patches will key off these bits to configure a DCD.

Co-developed-by: Navneet Singh <navneet.singh@intel.com>
Signed-off-by: Navneet Singh <navneet.singh@intel.com>
Signed-off-by: Ira Weiny <ira.weiny@intel.com>

---
Changes for v2
[iweiny: new patch]
---
 drivers/cxl/core/mbox.c | 38 +++++++++++++++++++++++++++++++++++---
 drivers/cxl/cxlmem.h    | 15 +++++++++++++++
 2 files changed, 50 insertions(+), 3 deletions(-)

diff --git a/drivers/cxl/core/mbox.c b/drivers/cxl/core/mbox.c
index f052d5f174ee..554ec97a7c39 100644
--- a/drivers/cxl/core/mbox.c
+++ b/drivers/cxl/core/mbox.c
@@ -111,6 +111,34 @@ static u8 security_command_sets[] = {
 	0x46, /* Security Passthrough */
 };
 
+static bool cxl_is_dcd_command(u16 opcode)
+{
+#define CXL_MBOX_OP_DCD_CMDS 0x48
+
+	return (opcode >> 8) == CXL_MBOX_OP_DCD_CMDS;
+}
+
+static void cxl_set_dcd_cmd_enabled(struct cxl_memdev_state *mds,
+					u16 opcode)
+{
+	switch (opcode) {
+	case CXL_MBOX_OP_GET_DC_CONFIG:
+		set_bit(CXL_DCD_ENABLED_GET_CONFIG, mds->dcd_cmds);
+		break;
+	case CXL_MBOX_OP_GET_DC_EXTENT_LIST:
+		set_bit(CXL_DCD_ENABLED_GET_EXTENT_LIST, mds->dcd_cmds);
+		break;
+	case CXL_MBOX_OP_ADD_DC_RESPONSE:
+		set_bit(CXL_DCD_ENABLED_ADD_RESPONSE, mds->dcd_cmds);
+		break;
+	case CXL_MBOX_OP_RELEASE_DC:
+		set_bit(CXL_DCD_ENABLED_RELEASE, mds->dcd_cmds);
+		break;
+	default:
+		break;
+	}
+}
+
 static bool cxl_is_security_command(u16 opcode)
 {
 	int i;
@@ -677,9 +705,10 @@ static void cxl_walk_cel(struct cxl_memdev_state *mds, size_t size, u8 *cel)
 		u16 opcode = le16_to_cpu(cel_entry[i].opcode);
 		struct cxl_mem_command *cmd = cxl_mem_find_command(opcode);
 
-		if (!cmd && !cxl_is_poison_command(opcode)) {
-			dev_dbg(dev,
-				"Opcode 0x%04x unsupported by driver\n", opcode);
+		if (!cmd && !cxl_is_poison_command(opcode) &&
+		    !cxl_is_dcd_command(opcode)) {
+			dev_dbg(dev, "Opcode 0x%04x unsupported by driver\n",
+				opcode);
 			continue;
 		}
 
@@ -689,6 +718,9 @@ static void cxl_walk_cel(struct cxl_memdev_state *mds, size_t size, u8 *cel)
 		if (cxl_is_poison_command(opcode))
 			cxl_set_poison_cmd_enabled(&mds->poison, opcode);
 
+		if (cxl_is_dcd_command(opcode))
+			cxl_set_dcd_cmd_enabled(mds, opcode);
+
 		dev_dbg(dev, "Opcode 0x%04x enabled\n", opcode);
 	}
 }
diff --git a/drivers/cxl/cxlmem.h b/drivers/cxl/cxlmem.h
index adfba72445fc..5f2e65204bf9 100644
--- a/drivers/cxl/cxlmem.h
+++ b/drivers/cxl/cxlmem.h
@@ -247,6 +247,15 @@ struct cxl_event_state {
 	struct mutex log_lock;
 };
 
+/* Device enabled DCD commands */
+enum dcd_cmd_enabled_bits {
+	CXL_DCD_ENABLED_GET_CONFIG,
+	CXL_DCD_ENABLED_GET_EXTENT_LIST,
+	CXL_DCD_ENABLED_ADD_RESPONSE,
+	CXL_DCD_ENABLED_RELEASE,
+	CXL_DCD_ENABLED_MAX
+};
+
 /* Device enabled poison commands */
 enum poison_cmd_enabled_bits {
 	CXL_POISON_ENABLED_LIST,
@@ -436,6 +445,7 @@ struct cxl_dev_state {
  *                (CXL 2.0 8.2.9.5.1.1 Identify Memory Device)
  * @mbox_mutex: Mutex to synchronize mailbox access.
  * @firmware_version: Firmware version for the memory device.
+ * @dcd_cmds: List of DCD commands implemented by memory device
  * @enabled_cmds: Hardware commands found enabled in CEL.
  * @exclusive_cmds: Commands that are kernel-internal only
  * @total_bytes: sum of all possible capacities
@@ -460,6 +470,7 @@ struct cxl_memdev_state {
 	size_t lsa_size;
 	struct mutex mbox_mutex; /* Protects device mailbox and firmware */
 	char firmware_version[0x10];
+	DECLARE_BITMAP(dcd_cmds, CXL_DCD_ENABLED_MAX);
 	DECLARE_BITMAP(enabled_cmds, CXL_MEM_COMMAND_ID_MAX);
 	DECLARE_BITMAP(exclusive_cmds, CXL_MEM_COMMAND_ID_MAX);
 	u64 total_bytes;
@@ -525,6 +536,10 @@ enum cxl_opcode {
 	CXL_MBOX_OP_UNLOCK		= 0x4503,
 	CXL_MBOX_OP_FREEZE_SECURITY	= 0x4504,
 	CXL_MBOX_OP_PASSPHRASE_SECURE_ERASE	= 0x4505,
+	CXL_MBOX_OP_GET_DC_CONFIG	= 0x4800,
+	CXL_MBOX_OP_GET_DC_EXTENT_LIST	= 0x4801,
+	CXL_MBOX_OP_ADD_DC_RESPONSE	= 0x4802,
+	CXL_MBOX_OP_RELEASE_DC		= 0x4803,
 	CXL_MBOX_OP_MAX			= 0x10000
 };
 

-- 
2.41.0


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 7C046C83F22
	for <linux-cxl@archiver.kernel.org>; Tue, 29 Aug 2023 05:24:55 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S235679AbjH2FYZ (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 29 Aug 2023 01:24:25 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:53164 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S235652AbjH2FYI (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 29 Aug 2023 01:24:08 -0400
Received: from mgamail.intel.com (mgamail.intel.com [134.134.136.100])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 8AADE19F;
        Mon, 28 Aug 2023 22:24:05 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1693286645; x=1724822645;
  h=from:date:subject:mime-version:content-transfer-encoding:
   message-id:references:in-reply-to:to:cc;
  bh=eqjAzrt81I+d9AMuS1dkyNzCVMovQ02UMNJu2fNRH7k=;
  b=KeUhA/cW9TuXGx+gqvjc3Cy2kXP3W3Uoq/LVBYEdXjlu4xXD4Kp+2m9U
   VbeVl8ttwF7edltSlXYYzA3Tyi3R8F2Arii9XGh0duxQWm18lh+eS+Oen
   uRJt3cIAbZ5swnc7fBKd/F5SurTSFLEN4YXduEGgHGjgCqx9Ke9aCyqRK
   1V/B4J10lYqv+GzksD/1pqv2/GlNRkYr+2fELdxsy3Ta3b5g15eVX3Ti4
   XXErMtsXu7bRUBtiiPXAPaceMUuaaUAqEAERaR9+W9uZdoPVoffiOIz0b
   bwioPyWkoqBqlyNE2nZ73hSWXcMScUZ8NFW5bARl6g48982l+H1LUUzg4
   w==;
X-IronPort-AV: E=McAfee;i="6600,9927,10816"; a="441625204"
X-IronPort-AV: E=Sophos;i="6.02,208,1688454000"; 
   d="scan'208";a="441625204"
Received: from orsmga002.jf.intel.com ([10.7.209.21])
  by orsmga105.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 28 Aug 2023 22:23:38 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10816"; a="738556355"
X-IronPort-AV: E=Sophos;i="6.02,208,1688454000"; 
   d="scan'208";a="738556355"
Received: from iweiny-mobl.amr.corp.intel.com (HELO localhost) ([10.212.37.183])
  by orsmga002-auth.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 28 Aug 2023 22:23:39 -0700
From: ira.weiny@intel.com
Date: Mon, 28 Aug 2023 22:20:58 -0700
Subject: [PATCH RFC v2 07/18] cxl/mem: Expose device dynamic capacity
 configuration
MIME-Version: 1.0
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: 7bit
Message-Id: <20230604-dcd-type2-upstream-v2-7-f740c47e7916@intel.com>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
In-Reply-To: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
To: Dan Williams <dan.j.williams@intel.com>
Cc: Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        Ira Weiny <ira.weiny@intel.com>, linux-cxl@vger.kernel.org,
        linux-kernel@vger.kernel.org
X-Mailer: b4 0.13-dev-c6835
X-Developer-Signature: v=1; a=ed25519-sha256; t=1693286607; l=5256;
 i=ira.weiny@intel.com; s=20221211; h=from:subject:message-id;
 bh=7WyZeI7HHwXXYdsbWOXaLecKTJZGgbj+4df/Tk05OHo=;
 b=Ng6gxuVs6hObZp1XDMup9d7Jt4+YhxIKbSzV+524D2TKZYVOzwv4NsuEfZxvxWJBfvqDSV9Tp
 M+qmC/Y9zL0Bk2ciJfu5YrQNlBWD8MwP3DmnbUYE6K/2kkINQGMgDev
X-Developer-Key: i=ira.weiny@intel.com; a=ed25519;
 pk=noldbkG+Wp1qXRrrkfY1QJpDf7QsOEthbOT7vm0PqsE=
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

From: Navneet Singh <navneet.singh@intel.com>

To properly configure CXL regions on Dynamic Capacity Devices (DCD),
user space will need to know the details of the DC Regions available on
a device.

Expose driver dynamic capacity configuration through sysfs
attributes.

Co-developed-by: Navneet Singh <navneet.singh@intel.com>
Signed-off-by: Navneet Singh <navneet.singh@intel.com>
Signed-off-by: Ira Weiny <ira.weiny@intel.com>

---
Changes for v2:
[iweiny: Rebased on latest master/type2 work]
[iweiny: add documentation for sysfs entries]
[iweiny: s/dc_regions_count/region_count/]
[iweiny: s/dcY_size/regionY_size/]
[alison: change size format to %#llx]
[iweiny: change count format to %d]
[iweiny: Formatting updates]
[iweiny: Fix crash when device is not a mem device: found with cxl-test]
---
 Documentation/ABI/testing/sysfs-bus-cxl | 17 ++++++++
 drivers/cxl/core/memdev.c               | 77 +++++++++++++++++++++++++++++++++
 2 files changed, 94 insertions(+)

diff --git a/Documentation/ABI/testing/sysfs-bus-cxl b/Documentation/ABI/testing/sysfs-bus-cxl
index 2268ffcdb604..aa65dc5b4e13 100644
--- a/Documentation/ABI/testing/sysfs-bus-cxl
+++ b/Documentation/ABI/testing/sysfs-bus-cxl
@@ -37,6 +37,23 @@ Description:
 		identically named field in the Identify Memory Device Output
 		Payload in the CXL-2.0 specification.
 
+What:		/sys/bus/cxl/devices/memX/dc/region_count
+Date:		July, 2023
+KernelVersion:	v6.6
+Contact:	linux-cxl@vger.kernel.org
+Description:
+		(RO) Number of Dynamic Capacity (DC) regions supported on the
+		device.  May be 0 if the device does not support Dynamic
+		Capacity.
+
+What:		/sys/bus/cxl/devices/memX/dc/regionY_size
+Date:		July, 2023
+KernelVersion:	v6.6
+Contact:	linux-cxl@vger.kernel.org
+Description:
+		(RO) Size of the Dynamic Capacity (DC) region Y.  Only
+		available on devices which support DC and only for those
+		region indexes supported by the device.
 
 What:		/sys/bus/cxl/devices/memX/serial
 Date:		January, 2022
diff --git a/drivers/cxl/core/memdev.c b/drivers/cxl/core/memdev.c
index 492486707fd0..397262e0ebd2 100644
--- a/drivers/cxl/core/memdev.c
+++ b/drivers/cxl/core/memdev.c
@@ -101,6 +101,20 @@ static ssize_t pmem_size_show(struct device *dev, struct device_attribute *attr,
 static struct device_attribute dev_attr_pmem_size =
 	__ATTR(size, 0444, pmem_size_show, NULL);
 
+static ssize_t region_count_show(struct device *dev, struct device_attribute *attr,
+				 char *buf)
+{
+	struct cxl_memdev *cxlmd = to_cxl_memdev(dev);
+	struct cxl_memdev_state *mds = to_cxl_memdev_state(cxlmd->cxlds);
+	int len = 0;
+
+	len = sysfs_emit(buf, "%d\n", mds->nr_dc_region);
+	return len;
+}
+
+struct device_attribute dev_attr_region_count =
+	__ATTR(region_count, 0444, region_count_show, NULL);
+
 static ssize_t serial_show(struct device *dev, struct device_attribute *attr,
 			   char *buf)
 {
@@ -454,6 +468,62 @@ static struct attribute *cxl_memdev_security_attributes[] = {
 	NULL,
 };
 
+static ssize_t show_size_regionN(struct cxl_memdev *cxlmd, char *buf, int pos)
+{
+	struct cxl_memdev_state *mds = to_cxl_memdev_state(cxlmd->cxlds);
+
+	return sysfs_emit(buf, "%#llx\n", mds->dc_region[pos].decode_len);
+}
+
+#define REGION_SIZE_ATTR_RO(n)						\
+static ssize_t region##n##_size_show(struct device *dev,		\
+				     struct device_attribute *attr,	\
+				     char *buf)				\
+{									\
+	return show_size_regionN(to_cxl_memdev(dev), buf, (n));		\
+}									\
+static DEVICE_ATTR_RO(region##n##_size)
+REGION_SIZE_ATTR_RO(0);
+REGION_SIZE_ATTR_RO(1);
+REGION_SIZE_ATTR_RO(2);
+REGION_SIZE_ATTR_RO(3);
+REGION_SIZE_ATTR_RO(4);
+REGION_SIZE_ATTR_RO(5);
+REGION_SIZE_ATTR_RO(6);
+REGION_SIZE_ATTR_RO(7);
+
+static struct attribute *cxl_memdev_dc_attributes[] = {
+	&dev_attr_region0_size.attr,
+	&dev_attr_region1_size.attr,
+	&dev_attr_region2_size.attr,
+	&dev_attr_region3_size.attr,
+	&dev_attr_region4_size.attr,
+	&dev_attr_region5_size.attr,
+	&dev_attr_region6_size.attr,
+	&dev_attr_region7_size.attr,
+	&dev_attr_region_count.attr,
+	NULL,
+};
+
+static umode_t cxl_dc_visible(struct kobject *kobj, struct attribute *a, int n)
+{
+	struct device *dev = kobj_to_dev(kobj);
+	struct cxl_memdev *cxlmd = to_cxl_memdev(dev);
+	struct cxl_memdev_state *mds = to_cxl_memdev_state(cxlmd->cxlds);
+
+	/* Not a memory device */
+	if (!mds)
+		return 0;
+
+	if (a == &dev_attr_region_count.attr)
+		return a->mode;
+
+	if (n < mds->nr_dc_region)
+		return a->mode;
+
+	return 0;
+}
+
 static umode_t cxl_memdev_visible(struct kobject *kobj, struct attribute *a,
 				  int n)
 {
@@ -482,11 +552,18 @@ static struct attribute_group cxl_memdev_security_attribute_group = {
 	.attrs = cxl_memdev_security_attributes,
 };
 
+static struct attribute_group cxl_memdev_dc_attribute_group = {
+	.name = "dc",
+	.attrs = cxl_memdev_dc_attributes,
+	.is_visible = cxl_dc_visible,
+};
+
 static const struct attribute_group *cxl_memdev_attribute_groups[] = {
 	&cxl_memdev_attribute_group,
 	&cxl_memdev_ram_attribute_group,
 	&cxl_memdev_pmem_attribute_group,
 	&cxl_memdev_security_attribute_group,
+	&cxl_memdev_dc_attribute_group,
 	NULL,
 };
 

-- 
2.41.0


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 334D2C83F1E
	for <linux-cxl@archiver.kernel.org>; Tue, 29 Aug 2023 05:24:55 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S235676AbjH2FYZ (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 29 Aug 2023 01:24:25 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:53194 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S235653AbjH2FYJ (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 29 Aug 2023 01:24:09 -0400
Received: from mgamail.intel.com (mgamail.intel.com [134.134.136.100])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id C86A519B;
        Mon, 28 Aug 2023 22:24:05 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1693286645; x=1724822645;
  h=from:date:subject:mime-version:content-transfer-encoding:
   message-id:references:in-reply-to:to:cc;
  bh=yzlcZLqFahopetBdRAePxFJCGnqigkpv6DD57hteb1Q=;
  b=HTNogCkIyE3ZzsmHnFCXfDKV4/Hk9klU8haQW3t//ZP+KXAAN23LD5/Z
   Vnn0Z/yJVSBkfOBZ8i0aeMOYKChApaq/PVgOuJusGsY06U0aqaJypwyYy
   b7p5Cc6SXoYAGKsIybT8aTB2lt20gwE6/NxbpHnry5Aoyttf4VfIINepv
   mJFZsDKF+pmAqkPRu7b+zEz0YNLl9dAZtl77yZHn1678x/D7+6zXE0+Ap
   lZ87fQJdfj7sxqWhqRH6tUhAUPi/NQyE+zF6GtfR3/3KuluAFapmBueYr
   DgL79g1l0nDehRvjq1IukosG+jXpFRuyuDP5OdMMrmBytow7AaxileZd7
   A==;
X-IronPort-AV: E=McAfee;i="6600,9927,10816"; a="441625214"
X-IronPort-AV: E=Sophos;i="6.02,208,1688454000"; 
   d="scan'208";a="441625214"
Received: from orsmga002.jf.intel.com ([10.7.209.21])
  by orsmga105.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 28 Aug 2023 22:23:39 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10816"; a="738556376"
X-IronPort-AV: E=Sophos;i="6.02,208,1688454000"; 
   d="scan'208";a="738556376"
Received: from iweiny-mobl.amr.corp.intel.com (HELO localhost) ([10.212.37.183])
  by orsmga002-auth.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 28 Aug 2023 22:23:40 -0700
From: Ira Weiny <ira.weiny@intel.com>
Date: Mon, 28 Aug 2023 22:20:59 -0700
Subject: [PATCH RFC v2 08/18] cxl/region: Add Dynamic Capacity CXL region
 support
MIME-Version: 1.0
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: 7bit
Message-Id: <20230604-dcd-type2-upstream-v2-8-f740c47e7916@intel.com>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
In-Reply-To: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
To: Dan Williams <dan.j.williams@intel.com>
Cc: Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        Ira Weiny <ira.weiny@intel.com>, linux-cxl@vger.kernel.org,
        linux-kernel@vger.kernel.org
X-Mailer: b4 0.13-dev-c6835
X-Developer-Signature: v=1; a=ed25519-sha256; t=1693286607; l=10852;
 i=ira.weiny@intel.com; s=20221211; h=from:subject:message-id;
 bh=yzlcZLqFahopetBdRAePxFJCGnqigkpv6DD57hteb1Q=;
 b=XcqbgGw8G2pGMK3qbSFA1r21S1vIYM+jnQGEs1ZFpFPWyIKURVVtppnkRkU82Tv+oABlTVgvY
 t9SzX7D/PYrDlogbl7hY1ufrsjyGn8ZoX7LyXPF1zMKWK+eTG+XaX9U
X-Developer-Key: i=ira.weiny@intel.com; a=ed25519;
 pk=noldbkG+Wp1qXRrrkfY1QJpDf7QsOEthbOT7vm0PqsE=
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

CXL devices optionally support dynamic capacity.  CXL Regions must be
configured correctly to access this capacity.  Similar to ram and pmem
partitions, DC Regions represent different partitions of the DPA space.

Interleaving is deferred due to the complexity of managing extents on
multiple devices at the same time.  However, there is nothing which
directly prevents interleave support at this time.  The check allows
for early rejection.

To maintain backwards compatibility with older software, CXL regions
need a default DAX device to hold the reference for the region until it
is deleted.

Add create_dc_region sysfs entry to create DC regions.  Share the logic
of devm_cxl_add_dax_region() and region_is_system_ram().  Special case
DC capable CXL regions to create a 0 sized seed DAX device until others
can be created on dynamic space later.

Flag dax_regions to indicate 0 capacity available until dax_region
extents are supported by the region.

Co-developed-by: Navneet Singh <navneet.singh@intel.com>
Signed-off-by: Navneet Singh <navneet.singh@intel.com>
Signed-off-by: Ira Weiny <ira.weiny@intel.com>

---
changes for v2:
[iweiny: flag empty dax regions]
[iweiny: Split out anything not directly related to creating a DC CXL
	 region]
[iweiny: Separate out dev dax stuff]
[iweiny/navneet: create 0 sized DAX device by default]
[iweiny: use new DC region mode]
---
 Documentation/ABI/testing/sysfs-bus-cxl | 20 +++++-----
 drivers/cxl/core/core.h                 |  1 +
 drivers/cxl/core/port.c                 |  1 +
 drivers/cxl/core/region.c               | 71 ++++++++++++++++++++++++++++-----
 drivers/dax/bus.c                       |  8 ++++
 drivers/dax/bus.h                       |  1 +
 drivers/dax/cxl.c                       | 15 ++++++-
 7 files changed, 96 insertions(+), 21 deletions(-)

diff --git a/Documentation/ABI/testing/sysfs-bus-cxl b/Documentation/ABI/testing/sysfs-bus-cxl
index aa65dc5b4e13..a0562938ecac 100644
--- a/Documentation/ABI/testing/sysfs-bus-cxl
+++ b/Documentation/ABI/testing/sysfs-bus-cxl
@@ -351,20 +351,20 @@ Description:
 		interleave_granularity).
 
 
-What:		/sys/bus/cxl/devices/decoderX.Y/create_{pmem,ram}_region
+What:		/sys/bus/cxl/devices/decoderX.Y/create_{pmem,ram,dc}_region
 Date:		May, 2022, January, 2023
-KernelVersion:	v6.0 (pmem), v6.3 (ram)
+KernelVersion:	v6.0 (pmem), v6.3 (ram), v6.6 (dc)
 Contact:	linux-cxl@vger.kernel.org
 Description:
 		(RW) Write a string in the form 'regionZ' to start the process
-		of defining a new persistent, or volatile memory region
-		(interleave-set) within the decode range bounded by root decoder
-		'decoderX.Y'. The value written must match the current value
-		returned from reading this attribute. An atomic compare exchange
-		operation is done on write to assign the requested id to a
-		region and allocate the region-id for the next creation attempt.
-		EBUSY is returned if the region name written does not match the
-		current cached value.
+		of defining a new persistent, volatile, or Dynamic Capacity
+		(DC) memory region (interleave-set) within the decode range
+		bounded by root decoder 'decoderX.Y'. The value written must
+		match the current value returned from reading this attribute.
+		An atomic compare exchange operation is done on write to assign
+		the requested id to a region and allocate the region-id for the
+		next creation attempt.  EBUSY is returned if the region name
+		written does not match the current cached value.
 
 
 What:		/sys/bus/cxl/devices/decoderX.Y/delete_region
diff --git a/drivers/cxl/core/core.h b/drivers/cxl/core/core.h
index 45e7e044cf4a..cf3cf01cb95d 100644
--- a/drivers/cxl/core/core.h
+++ b/drivers/cxl/core/core.h
@@ -13,6 +13,7 @@ extern struct attribute_group cxl_base_attribute_group;
 #ifdef CONFIG_CXL_REGION
 extern struct device_attribute dev_attr_create_pmem_region;
 extern struct device_attribute dev_attr_create_ram_region;
+extern struct device_attribute dev_attr_create_dc_region;
 extern struct device_attribute dev_attr_delete_region;
 extern struct device_attribute dev_attr_region;
 extern const struct device_type cxl_pmem_region_type;
diff --git a/drivers/cxl/core/port.c b/drivers/cxl/core/port.c
index a5db710a63bc..608901bb7d91 100644
--- a/drivers/cxl/core/port.c
+++ b/drivers/cxl/core/port.c
@@ -314,6 +314,7 @@ static struct attribute *cxl_decoder_root_attrs[] = {
 	&dev_attr_target_list.attr,
 	SET_CXL_REGION_ATTR(create_pmem_region)
 	SET_CXL_REGION_ATTR(create_ram_region)
+	SET_CXL_REGION_ATTR(create_dc_region)
 	SET_CXL_REGION_ATTR(delete_region)
 	NULL,
 };
diff --git a/drivers/cxl/core/region.c b/drivers/cxl/core/region.c
index 69af1354bc5b..fc8dee469244 100644
--- a/drivers/cxl/core/region.c
+++ b/drivers/cxl/core/region.c
@@ -2271,6 +2271,7 @@ static struct cxl_region *devm_cxl_add_region(struct cxl_root_decoder *cxlrd,
 	switch (mode) {
 	case CXL_REGION_RAM:
 	case CXL_REGION_PMEM:
+	case CXL_REGION_DC:
 		break;
 	default:
 		dev_err(&cxlrd->cxlsd.cxld.dev, "unsupported mode %s\n",
@@ -2383,6 +2384,33 @@ static ssize_t create_ram_region_store(struct device *dev,
 }
 DEVICE_ATTR_RW(create_ram_region);
 
+static ssize_t create_dc_region_show(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	return __create_region_show(to_cxl_root_decoder(dev), buf);
+}
+
+static ssize_t create_dc_region_store(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf, size_t len)
+{
+	struct cxl_root_decoder *cxlrd = to_cxl_root_decoder(dev);
+	struct cxl_region *cxlr;
+	int rc, id;
+
+	rc = sscanf(buf, "region%d\n", &id);
+	if (rc != 1)
+		return -EINVAL;
+
+	cxlr = __create_region(cxlrd, id, CXL_REGION_DC,
+			       CXL_DECODER_HOSTONLYMEM);
+	if (IS_ERR(cxlr))
+		return PTR_ERR(cxlr);
+
+	return len;
+}
+DEVICE_ATTR_RW(create_dc_region);
+
 static ssize_t region_show(struct device *dev, struct device_attribute *attr,
 			   char *buf)
 {
@@ -2834,7 +2862,7 @@ static void cxlr_dax_unregister(void *_cxlr_dax)
 	device_unregister(&cxlr_dax->dev);
 }
 
-static int devm_cxl_add_dax_region(struct cxl_region *cxlr)
+static int __devm_cxl_add_dax_region(struct cxl_region *cxlr)
 {
 	struct cxl_dax_region *cxlr_dax;
 	struct device *dev;
@@ -2863,6 +2891,21 @@ static int devm_cxl_add_dax_region(struct cxl_region *cxlr)
 	return rc;
 }
 
+static int devm_cxl_add_dax_region(struct cxl_region *cxlr)
+{
+	return __devm_cxl_add_dax_region(cxlr);
+}
+
+static int devm_cxl_add_dc_dax_region(struct cxl_region *cxlr)
+{
+	if (cxlr->params.interleave_ways != 1) {
+		dev_err(&cxlr->dev, "Interleaving DC not supported\n");
+		return -EINVAL;
+	}
+
+	return __devm_cxl_add_dax_region(cxlr);
+}
+
 static int match_decoder_by_range(struct device *dev, void *data)
 {
 	struct range *r1, *r2 = data;
@@ -3203,6 +3246,19 @@ static int is_system_ram(struct resource *res, void *arg)
 	return 1;
 }
 
+/*
+ * The region can not be manged by CXL if any portion of
+ * it is already online as 'System RAM'
+ */
+static bool region_is_system_ram(struct cxl_region *cxlr,
+				 struct cxl_region_params *p)
+{
+	return (walk_iomem_res_desc(IORES_DESC_NONE,
+				    IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY,
+				    p->res->start, p->res->end, cxlr,
+				    is_system_ram) > 0);
+}
+
 static int cxl_region_probe(struct device *dev)
 {
 	struct cxl_region *cxlr = to_cxl_region(dev);
@@ -3242,14 +3298,7 @@ static int cxl_region_probe(struct device *dev)
 	case CXL_REGION_PMEM:
 		return devm_cxl_add_pmem_region(cxlr);
 	case CXL_REGION_RAM:
-		/*
-		 * The region can not be manged by CXL if any portion of
-		 * it is already online as 'System RAM'
-		 */
-		if (walk_iomem_res_desc(IORES_DESC_NONE,
-					IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY,
-					p->res->start, p->res->end, cxlr,
-					is_system_ram) > 0)
+		if (region_is_system_ram(cxlr, p))
 			return 0;
 
 		/*
@@ -3261,6 +3310,10 @@ static int cxl_region_probe(struct device *dev)
 
 		/* HDM-H routes to device-dax */
 		return devm_cxl_add_dax_region(cxlr);
+	case CXL_REGION_DC:
+		if (region_is_system_ram(cxlr, p))
+			return 0;
+		return devm_cxl_add_dc_dax_region(cxlr);
 	default:
 		dev_dbg(&cxlr->dev, "unsupported region mode: %s\n",
 			cxl_region_mode_name(cxlr->mode));
diff --git a/drivers/dax/bus.c b/drivers/dax/bus.c
index 0ee96e6fc426..b76e49813a39 100644
--- a/drivers/dax/bus.c
+++ b/drivers/dax/bus.c
@@ -169,6 +169,11 @@ static bool is_static(struct dax_region *dax_region)
 	return (dax_region->res.flags & IORESOURCE_DAX_STATIC) != 0;
 }
 
+static bool is_dynamic(struct dax_region *dax_region)
+{
+	return (dax_region->res.flags & IORESOURCE_DAX_DYNAMIC_CAP) != 0;
+}
+
 bool static_dev_dax(struct dev_dax *dev_dax)
 {
 	return is_static(dev_dax->region);
@@ -285,6 +290,9 @@ static unsigned long long dax_region_avail_size(struct dax_region *dax_region)
 
 	device_lock_assert(dax_region->dev);
 
+	if (is_dynamic(dax_region))
+		return 0;
+
 	for_each_dax_region_resource(dax_region, res)
 		size -= resource_size(res);
 	return size;
diff --git a/drivers/dax/bus.h b/drivers/dax/bus.h
index 1ccd23360124..74d8fe4a5532 100644
--- a/drivers/dax/bus.h
+++ b/drivers/dax/bus.h
@@ -13,6 +13,7 @@ struct dax_region;
 /* dax bus specific ioresource flags */
 #define IORESOURCE_DAX_STATIC BIT(0)
 #define IORESOURCE_DAX_KMEM BIT(1)
+#define IORESOURCE_DAX_DYNAMIC_CAP BIT(2)
 
 struct dax_region *alloc_dax_region(struct device *parent, int region_id,
 		struct range *range, int target_node, unsigned int align,
diff --git a/drivers/dax/cxl.c b/drivers/dax/cxl.c
index 8bc9d04034d6..147c8c69782b 100644
--- a/drivers/dax/cxl.c
+++ b/drivers/dax/cxl.c
@@ -13,19 +13,30 @@ static int cxl_dax_region_probe(struct device *dev)
 	struct cxl_region *cxlr = cxlr_dax->cxlr;
 	struct dax_region *dax_region;
 	struct dev_dax_data data;
+	resource_size_t dev_size;
+	unsigned long flags;
 
 	if (nid == NUMA_NO_NODE)
 		nid = memory_add_physaddr_to_nid(cxlr_dax->hpa_range.start);
 
+	dev_size = range_len(&cxlr_dax->hpa_range);
+
+	flags = IORESOURCE_DAX_KMEM;
+	if (cxlr->mode == CXL_REGION_DC) {
+		/* Add empty seed dax device */
+		dev_size = 0;
+		flags |= IORESOURCE_DAX_DYNAMIC_CAP;
+	}
+
 	dax_region = alloc_dax_region(dev, cxlr->id, &cxlr_dax->hpa_range, nid,
-				      PMD_SIZE, IORESOURCE_DAX_KMEM);
+				      PMD_SIZE, flags);
 	if (!dax_region)
 		return -ENOMEM;
 
 	data = (struct dev_dax_data) {
 		.dax_region = dax_region,
 		.id = -1,
-		.size = range_len(&cxlr_dax->hpa_range),
+		.size = dev_size,
 	};
 
 	return PTR_ERR_OR_ZERO(devm_create_dev_dax(&data));

-- 
2.41.0


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 5839CC83F20
	for <linux-cxl@archiver.kernel.org>; Tue, 29 Aug 2023 05:24:55 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S235658AbjH2FYY (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 29 Aug 2023 01:24:24 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:53140 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S235648AbjH2FYG (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 29 Aug 2023 01:24:06 -0400
Received: from mgamail.intel.com (mgamail.intel.com [134.134.136.100])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id A292919B;
        Mon, 28 Aug 2023 22:24:03 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1693286643; x=1724822643;
  h=from:date:subject:mime-version:content-transfer-encoding:
   message-id:references:in-reply-to:to:cc;
  bh=Y0/EaGIn6d0ULD53C6mJq4temH7MOkMbjaWJKl/qwig=;
  b=VkquTTYFZv2cFNHAeD0BXMn5oqtpSdGtFiWXTUu88aNUgUyVGznZ+iWR
   elWz6jWz2U0KkUBrC3euJPCwybAMazdt4sgujpPQANxkxmp37DdBWYICP
   mMxgxjmeztt0lNs82MJGtF0kk5B8CW1qq+72Cwy2YoIK95Ywn9kJwJet3
   aSCJT4t82vz1Pe9N8T+rMVD3WAfsQYPqPlCpyU8xYoBHyEmlem1ctqFe9
   zOn4hFbZ+oLsdSTTQGFD0KwrOhsSsZwCZ2y+stKPzPyZV/fNtG1SDOSD1
   H9aEMaRAaUrum2ojuA59avx1HOPvZe8pj8WVf2Svl9tcd/2bSnZvemj++
   A==;
X-IronPort-AV: E=McAfee;i="6600,9927,10816"; a="441625181"
X-IronPort-AV: E=Sophos;i="6.02,208,1688454000"; 
   d="scan'208";a="441625181"
Received: from orsmga002.jf.intel.com ([10.7.209.21])
  by orsmga105.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 28 Aug 2023 22:23:35 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10816"; a="738556324"
X-IronPort-AV: E=Sophos;i="6.02,208,1688454000"; 
   d="scan'208";a="738556324"
Received: from iweiny-mobl.amr.corp.intel.com (HELO localhost) ([10.212.37.183])
  by orsmga002-auth.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 28 Aug 2023 22:23:35 -0700
From: Ira Weiny <ira.weiny@intel.com>
Date: Mon, 28 Aug 2023 22:20:55 -0700
Subject: [PATCH RFC v2 04/18] cxl/region: Add Dynamic Capacity decoder and
 region modes
MIME-Version: 1.0
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: 7bit
Message-Id: <20230604-dcd-type2-upstream-v2-4-f740c47e7916@intel.com>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
In-Reply-To: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
To: Dan Williams <dan.j.williams@intel.com>
Cc: Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        Ira Weiny <ira.weiny@intel.com>, linux-cxl@vger.kernel.org,
        linux-kernel@vger.kernel.org
X-Mailer: b4 0.13-dev-c6835
X-Developer-Signature: v=1; a=ed25519-sha256; t=1693286607; l=3161;
 i=ira.weiny@intel.com; s=20221211; h=from:subject:message-id;
 bh=Y0/EaGIn6d0ULD53C6mJq4temH7MOkMbjaWJKl/qwig=;
 b=Om6AGvdMAJ+k9JGIwvY9O6aGs6vTH9eiO4OHZen4LtCGk/pgN8XRKj/gaPOEc3KGXsebGT7Cz
 FnApvjgwkrcBwj8p70VDFDvUgMKgZrWpiJUd144rKfeoQOqzhGTFqBl
X-Developer-Key: i=ira.weiny@intel.com; a=ed25519;
 pk=noldbkG+Wp1qXRrrkfY1QJpDf7QsOEthbOT7vm0PqsE=
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

Both regions and decoders will need a new mode to reflect the new type
of partition they are targeting on a device.  Regions reflect a dynamic
capacity type which may point to different Dynamic Capacity (DC)
Regions.  Decoder mode reflects a specific DC Region.

Define the new modes to use in subsequent patches and the helper
functions associated with them.

Co-developed-by: Navneet Singh <navneet.singh@intel.com>
Signed-off-by: Navneet Singh <navneet.singh@intel.com>
Signed-off-by: Ira Weiny <ira.weiny@intel.com>

---
Changes for v2:
[iweiny: split out from: Add dynamic capacity cxl region support.]
---
 drivers/cxl/core/region.c |  4 ++++
 drivers/cxl/cxl.h         | 23 +++++++++++++++++++++++
 2 files changed, 27 insertions(+)

diff --git a/drivers/cxl/core/region.c b/drivers/cxl/core/region.c
index 75041903b72c..69af1354bc5b 100644
--- a/drivers/cxl/core/region.c
+++ b/drivers/cxl/core/region.c
@@ -1772,6 +1772,8 @@ static bool cxl_modes_compatible(enum cxl_region_mode rmode,
 		return true;
 	if (rmode == CXL_REGION_PMEM && dmode == CXL_DECODER_PMEM)
 		return true;
+	if (rmode == CXL_REGION_DC && cxl_decoder_mode_is_dc(dmode))
+		return true;
 
 	return false;
 }
@@ -2912,6 +2914,8 @@ cxl_decoder_to_region_mode(enum cxl_decoder_mode mode)
 		return CXL_REGION_PMEM;
 	case CXL_DECODER_DEAD:
 		return CXL_REGION_DEAD;
+	case CXL_DECODER_DC0 ... CXL_DECODER_DC7:
+		return CXL_REGION_DC;
 	case CXL_DECODER_MIXED:
 	default:
 		return CXL_REGION_MIXED;
diff --git a/drivers/cxl/cxl.h b/drivers/cxl/cxl.h
index ed282dcd5cf5..d41f3f14fbe3 100644
--- a/drivers/cxl/cxl.h
+++ b/drivers/cxl/cxl.h
@@ -356,6 +356,14 @@ enum cxl_decoder_mode {
 	CXL_DECODER_NONE,
 	CXL_DECODER_RAM,
 	CXL_DECODER_PMEM,
+	CXL_DECODER_DC0,
+	CXL_DECODER_DC1,
+	CXL_DECODER_DC2,
+	CXL_DECODER_DC3,
+	CXL_DECODER_DC4,
+	CXL_DECODER_DC5,
+	CXL_DECODER_DC6,
+	CXL_DECODER_DC7,
 	CXL_DECODER_MIXED,
 	CXL_DECODER_DEAD,
 };
@@ -366,6 +374,14 @@ static inline const char *cxl_decoder_mode_name(enum cxl_decoder_mode mode)
 		[CXL_DECODER_NONE] = "none",
 		[CXL_DECODER_RAM] = "ram",
 		[CXL_DECODER_PMEM] = "pmem",
+		[CXL_DECODER_DC0] = "dc0",
+		[CXL_DECODER_DC1] = "dc1",
+		[CXL_DECODER_DC2] = "dc2",
+		[CXL_DECODER_DC3] = "dc3",
+		[CXL_DECODER_DC4] = "dc4",
+		[CXL_DECODER_DC5] = "dc5",
+		[CXL_DECODER_DC6] = "dc6",
+		[CXL_DECODER_DC7] = "dc7",
 		[CXL_DECODER_MIXED] = "mixed",
 	};
 
@@ -374,10 +390,16 @@ static inline const char *cxl_decoder_mode_name(enum cxl_decoder_mode mode)
 	return "mixed";
 }
 
+static inline bool cxl_decoder_mode_is_dc(enum cxl_decoder_mode mode)
+{
+	return (mode >= CXL_DECODER_DC0 && mode <= CXL_DECODER_DC7);
+}
+
 enum cxl_region_mode {
 	CXL_REGION_NONE,
 	CXL_REGION_RAM,
 	CXL_REGION_PMEM,
+	CXL_REGION_DC,
 	CXL_REGION_MIXED,
 	CXL_REGION_DEAD,
 };
@@ -388,6 +410,7 @@ static inline const char *cxl_region_mode_name(enum cxl_region_mode mode)
 		[CXL_REGION_NONE] = "none",
 		[CXL_REGION_RAM] = "ram",
 		[CXL_REGION_PMEM] = "pmem",
+		[CXL_REGION_DC] = "dc",
 		[CXL_REGION_MIXED] = "mixed",
 	};
 

-- 
2.41.0


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 1226CC83F1C
	for <linux-cxl@archiver.kernel.org>; Tue, 29 Aug 2023 05:24:55 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S235640AbjH2FYX (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 29 Aug 2023 01:24:23 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:32776 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S235634AbjH2FXw (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 29 Aug 2023 01:23:52 -0400
Received: from mgamail.intel.com (mgamail.intel.com [134.134.136.100])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 06F72198;
        Mon, 28 Aug 2023 22:23:49 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1693286629; x=1724822629;
  h=from:subject:date:message-id:mime-version:
   content-transfer-encoding:to:cc;
  bh=A5E1QO0Muv9CKMLT/sotcOqRhE+vFwm9Hd7FndpNHeo=;
  b=BLH28EZH68rs/EQxN5bJ+nj3FE5k1goW8jAr9OwymzzjqFrjqbgqzdAu
   z4BaAmWA1wx9w79gw/AxCTq9sb0Bo3Tos6j06mAAQijRfDf9ipWrOGHBR
   E5cv5q6cJUWbee9n0MkJg+bggpAr5o956XlkAdGuoEuMbyQXa3CEzbacJ
   zy8kREt89Wb18AhA+jpdFXWgydGu6bScI++bNgizaOCaZG5f56qwybQVu
   SHuy3rM26UrayR2VEZG1zEOOPpe+4dxLev/u2wsX+7w+7+tjmPQtQW87r
   RdwLiuCht3oJ7nFZnYg8uBmzMw3UR2eVxQOyfOeIfkAhT/i12YA37/MVB
   A==;
X-IronPort-AV: E=McAfee;i="6600,9927,10816"; a="441625153"
X-IronPort-AV: E=Sophos;i="6.02,208,1688454000"; 
   d="scan'208";a="441625153"
Received: from orsmga002.jf.intel.com ([10.7.209.21])
  by orsmga105.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 28 Aug 2023 22:23:30 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10816"; a="738556282"
X-IronPort-AV: E=Sophos;i="6.02,208,1688454000"; 
   d="scan'208";a="738556282"
Received: from iweiny-mobl.amr.corp.intel.com (HELO localhost) ([10.212.37.183])
  by orsmga002-auth.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 28 Aug 2023 22:23:30 -0700
From: Ira Weiny <ira.weiny@intel.com>
Subject: [PATCH RFC v2 00/18] DCD: Add support for Dynamic Capacity Devices
 (DCD)
Date: Mon, 28 Aug 2023 22:20:51 -0700
Message-Id: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
MIME-Version: 1.0
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: 7bit
X-B4-Tracking: v=1; b=H4sIADOA7WQC/32OzQqDMBCEX0X23C1J1BR6KhT6AL0WD/lZa6BGS
 VKpiO/e6K2XHmfmG2YWiBQcRTgXCwSaXHSDz0IcCjCd8k9CZ7MGwUTJJKvQGotpHknge4wpkOq
 RGcvrVgouWwu5qFUk1EF5023VX3oDxkCt++yrD7jfrtBks3MxDWHen0x8j/6NThwZnriWZcW1o
 rq6OJ/odTRDD826rl/jEZ2B2gAAAA==
To: Dan Williams <dan.j.williams@intel.com>
Cc: Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        Ira Weiny <ira.weiny@intel.com>, linux-cxl@vger.kernel.org,
        linux-kernel@vger.kernel.org
X-Mailer: b4 0.13-dev-c6835
X-Developer-Signature: v=1; a=ed25519-sha256; t=1693286607; l=5925;
 i=ira.weiny@intel.com; s=20221211; h=from:subject:message-id;
 bh=A5E1QO0Muv9CKMLT/sotcOqRhE+vFwm9Hd7FndpNHeo=;
 b=FfwSS3QN/OUCY00XcZhHEU4cknG+tUPOXkOrlrGwmGBg+IG4WBIOLWmPCyIGe/Ql0ScO6gPjr
 8XFaLwV+HMDCsj/PdqAjp6YBlRqpo5TUNdl63RRQSovFBK9xwF8C2wk
X-Developer-Key: i=ira.weiny@intel.com; a=ed25519;
 pk=noldbkG+Wp1qXRrrkfY1QJpDf7QsOEthbOT7vm0PqsE=
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

A Dynamic Capacity Device (DCD) (CXL 3.0 spec 9.13.3) is a CXL memory
device that implements dynamic capacity.  Dynamic capacity feature
allows memory capacity to change dynamically, without the need for
resetting the device.

Even though this is marked v2 by b4, this is effectively a whole new
series for DCD support.  Quite a bit of the core support was completed
by Navneet in [4].  However, the architecture through the CXL region,
DAX region, and DAX Device layers is completely different.  Particular
attention was paid to:

	1) managing skip resources in the hardware device
	2) ensuring the host OS only sent a release memory mailbox
	   response when all DAX devices are done using an extent
	3) allowing dax devices to span extents
	4) allowing dax devices to use parts of extents

I could say all of the review comments from v1 are addressed but frankly
the series has changed so much that I can't guarantee anything.

The series continues to be based on the type-2 work posted from Dan.[2]
However, my branch with that work is a bit dated.  Therefore I have
posted this series on github here.[5]

Testing was sped up with cxl-test and ndctl dcd support.  A preview of
that work is on github.[6]  In addition Fan Ni's Qemu DCD series was
used part of the time.[3]

The major parts of this series are:

- Get the dynamic capacity (DC) region information from cxl device
- Configure device DC regions reported by hardware
- Enhance CXL and DAX regions for DC
	a. maintain separation between the hardware extents and the CXL
	   region extents to provide for the addition of interleaving in
	   the future.
- Get and maintain the hardware extent lists for each device via an
  initial extent list and DC event records
        a. Add capacity Events
	b. Add capacity response
	b. Release capacity events
	d. Release capacity response
- Notify region layers of extent changes
- Allow for DAX devices to be created on extents which are surfaced
- Maintain references on extents which are in use
	a. Send Release capacity Response only when DAX devices are not
	   using memory
- Allow DAX region extent labels to change to allow for flexibility in
  DAX device creation in the future (further enhancements are required
  to ndctl for this)
- Trace Dynamic Capacity events
- Add cxl-test infrastructure to allow for faster unit testing

To: Dan Williams <dan.j.williams@intel.com>
Cc: Navneet Singh <navneet.singh@intel.com>
Cc: Fan Ni <fan.ni@samsung.com>
Cc: Jonathan Cameron <Jonathan.Cameron@huawei.com>
Cc: Davidlohr Bueso <dave@stgolabs.net>
Cc: Dave Jiang <dave.jiang@intel.com>
Cc: Alison Schofield <alison.schofield@intel.com>
Cc: Vishal Verma <vishal.l.verma@intel.com>
Cc: Ira Weiny <ira.weiny@intel.com>
Cc: linux-cxl@vger.kernel.org
Cc: linux-kernel@vger.kernel.org

[1] https://lore.kernel.org/all/64326437c1496_934b2949f@dwillia2-mobl3.amr.corp.intel.com.notmuch/
[2] https://lore.kernel.org/all/168592149709.1948938.8663425987110396027.stgit@dwillia2-xfh.jf.intel.com/
[3] https://lore.kernel.org/all/6483946e8152f_f1132294a2@iweiny-mobl.notmuch/
[4] https://lore.kernel.org/r/20230604-dcd-type2-upstream-v1-0-71b6341bae54@intel.com
[5] https://github.com/weiny2/linux-kernel/commits/dcd-v2-2023-08-28
[6] https://github.com/weiny2/ndctl/tree/dcd-region2

---
Changes in v2:
- iweiny: Complete rework of the entire series
- Link to v1: https://lore.kernel.org/r/20230604-dcd-type2-upstream-v1-0-71b6341bae54@intel.com

---
Ira Weiny (15):
      cxl/hdm: Debug, use decoder name function
      cxl/mbox: Flag support for Dynamic Capacity Devices (DCD)
      cxl/region: Add Dynamic Capacity decoder and region modes
      cxl/port: Add Dynamic Capacity mode support to endpoint decoders
      cxl/port: Add Dynamic Capacity size support to endpoint decoders
      cxl/region: Add Dynamic Capacity CXL region support
      cxl/mem: Read extents on memory device discovery
      cxl/mem: Handle DCD add and release capacity events.
      cxl/region: Expose DC extents on region driver load
      cxl/region: Notify regions of DC changes
      dax/bus: Factor out dev dax resize logic
      dax/region: Support DAX device creation on dynamic DAX regions
      tools/testing/cxl: Make event logs dynamic
      tools/testing/cxl: Add DC Regions to mock mem data
      tools/testing/cxl: Add Dynamic Capacity events

Navneet Singh (3):
      cxl/mem: Read Dynamic capacity configuration from the device
      cxl/mem: Expose device dynamic capacity configuration
      cxl/mem: Trace Dynamic capacity Event Record

 Documentation/ABI/testing/sysfs-bus-cxl |  56 ++-
 drivers/cxl/core/core.h                 |   1 +
 drivers/cxl/core/hdm.c                  | 215 ++++++++-
 drivers/cxl/core/mbox.c                 | 646 +++++++++++++++++++++++++-
 drivers/cxl/core/memdev.c               |  77 ++++
 drivers/cxl/core/port.c                 |  19 +
 drivers/cxl/core/region.c               | 418 +++++++++++++++--
 drivers/cxl/core/trace.h                |  65 +++
 drivers/cxl/cxl.h                       |  99 +++-
 drivers/cxl/cxlmem.h                    | 138 +++++-
 drivers/cxl/mem.c                       |  50 ++
 drivers/cxl/pci.c                       |   8 +
 drivers/dax/Makefile                    |   1 +
 drivers/dax/bus.c                       | 263 ++++++++---
 drivers/dax/bus.h                       |   1 +
 drivers/dax/cxl.c                       | 213 ++++++++-
 drivers/dax/dax-private.h               |  61 +++
 drivers/dax/extent.c                    | 133 ++++++
 tools/testing/cxl/test/mem.c            | 782 +++++++++++++++++++++++++++-----
 19 files changed, 3005 insertions(+), 241 deletions(-)
---
base-commit: c76cce37fb6f3796e8e146677ba98d3cca30a488
change-id: 20230604-dcd-type2-upstream-0cd15f6216fd

Best regards,
-- 
Ira Weiny <ira.weiny@intel.com>


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 0126AC83F1A
	for <linux-cxl@archiver.kernel.org>; Tue, 29 Aug 2023 05:24:54 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S235644AbjH2FYY (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 29 Aug 2023 01:24:24 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:53126 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S235647AbjH2FYG (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 29 Aug 2023 01:24:06 -0400
Received: from mgamail.intel.com (mgamail.intel.com [134.134.136.100])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 9B61F19A;
        Mon, 28 Aug 2023 22:24:03 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1693286643; x=1724822643;
  h=from:date:subject:mime-version:content-transfer-encoding:
   message-id:references:in-reply-to:to:cc;
  bh=CRtmUhD14GT5Q6ZjiafnJto9DQ4XwPEExp4RUj6Mt6k=;
  b=QL6VJ5Z6TEfOdCmsbyLW8f9O/yReNTz1zHH4hLYBQsGU/nZOf027Qwpr
   EH8H/rnOktPNMNlmXyvIfYWeJL4HVgGpE67j8/sDtsz/QdqH+XRS0ljAF
   tVD7VBllCmmvAFocbXvlWBGOjyh4xlketTmGhkpmf3xMd7O+zyHRbb8Rg
   o7EMXffojOfWYGF22/krkdj+YV+kj2l+0eap32XOaRQVBtB7N5n2E1G4M
   BikAHZJRBDkeSSRjjHp1vk6C+/lT0nb2nFxzJ5dve8u+HPzgimArcjVgL
   eZ/Nk/3juPH8mFirlrni5WJWmmlSVQKIeRyXhmlyz0wr2SoLaYf3ee97X
   g==;
X-IronPort-AV: E=McAfee;i="6600,9927,10816"; a="441625190"
X-IronPort-AV: E=Sophos;i="6.02,208,1688454000"; 
   d="scan'208";a="441625190"
Received: from orsmga002.jf.intel.com ([10.7.209.21])
  by orsmga105.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 28 Aug 2023 22:23:36 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10816"; a="738556335"
X-IronPort-AV: E=Sophos;i="6.02,208,1688454000"; 
   d="scan'208";a="738556335"
Received: from iweiny-mobl.amr.corp.intel.com (HELO localhost) ([10.212.37.183])
  by orsmga002-auth.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 28 Aug 2023 22:23:36 -0700
From: Ira Weiny <ira.weiny@intel.com>
Date: Mon, 28 Aug 2023 22:20:56 -0700
Subject: [PATCH RFC v2 05/18] cxl/port: Add Dynamic Capacity mode support
 to endpoint decoders
MIME-Version: 1.0
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: 7bit
Message-Id: <20230604-dcd-type2-upstream-v2-5-f740c47e7916@intel.com>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
In-Reply-To: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
To: Dan Williams <dan.j.williams@intel.com>
Cc: Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        Ira Weiny <ira.weiny@intel.com>, linux-cxl@vger.kernel.org,
        linux-kernel@vger.kernel.org
X-Mailer: b4 0.13-dev-c6835
X-Developer-Signature: v=1; a=ed25519-sha256; t=1693286607; l=4798;
 i=ira.weiny@intel.com; s=20221211; h=from:subject:message-id;
 bh=CRtmUhD14GT5Q6ZjiafnJto9DQ4XwPEExp4RUj6Mt6k=;
 b=RilpG+uu7lsmLcHfusjl1xkPACJJMfXQ69OmjoYc9afp5P/uj+9qxbjGxqbmUOLMSXihiz0RB
 dawlgwbXYxlBZbWujCu07iw8OHRgAf76AewYhBFQOQKSIBT8yZMDuTR
X-Developer-Key: i=ira.weiny@intel.com; a=ed25519;
 pk=noldbkG+Wp1qXRrrkfY1QJpDf7QsOEthbOT7vm0PqsE=
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

Endpoint decoders used to map Dynamic Capacity must be configured to
point to the correct Dynamic Capacity (DC) Region.  The decoder mode
currently represents the partition the decoder points to such as ram or
pmem.

Expand the mode to include DC Regions.

Co-developed-by: Navneet Singh <navneet.singh@intel.com>
Signed-off-by: Navneet Singh <navneet.singh@intel.com>
Signed-off-by: Ira Weiny <ira.weiny@intel.com>

---
Changes for v2:
[iweiny: split from region creation patch]
---
 Documentation/ABI/testing/sysfs-bus-cxl | 19 ++++++++++---------
 drivers/cxl/core/hdm.c                  | 24 ++++++++++++++++++++++++
 drivers/cxl/core/port.c                 | 16 ++++++++++++++++
 3 files changed, 50 insertions(+), 9 deletions(-)

diff --git a/Documentation/ABI/testing/sysfs-bus-cxl b/Documentation/ABI/testing/sysfs-bus-cxl
index 6350dd82b9a9..2268ffcdb604 100644
--- a/Documentation/ABI/testing/sysfs-bus-cxl
+++ b/Documentation/ABI/testing/sysfs-bus-cxl
@@ -257,22 +257,23 @@ Description:
 
 What:		/sys/bus/cxl/devices/decoderX.Y/mode
 Date:		May, 2022
-KernelVersion:	v6.0
+KernelVersion:	v6.0, v6.6 (dcY)
 Contact:	linux-cxl@vger.kernel.org
 Description:
 		(RW) When a CXL decoder is of devtype "cxl_decoder_endpoint" it
 		translates from a host physical address range, to a device local
 		address range. Device-local address ranges are further split
-		into a 'ram' (volatile memory) range and 'pmem' (persistent
-		memory) range. The 'mode' attribute emits one of 'ram', 'pmem',
-		'mixed', or 'none'. The 'mixed' indication is for error cases
-		when a decoder straddles the volatile/persistent partition
-		boundary, and 'none' indicates the decoder is not actively
-		decoding, or no DPA allocation policy has been set.
+		into a 'ram' (volatile memory) range, 'pmem' (persistent
+		memory) range, or Dynamic Capacity (DC) range. The 'mode'
+		attribute emits one of 'ram', 'pmem', 'dcY', 'mixed', or
+		'none'. The 'mixed' indication is for error cases when a
+		decoder straddles the volatile/persistent partition boundary,
+		and 'none' indicates the decoder is not actively decoding, or
+		no DPA allocation policy has been set.
 
 		'mode' can be written, when the decoder is in the 'disabled'
-		state, with either 'ram' or 'pmem' to set the boundaries for the
-		next allocation.
+		state, with 'ram', 'pmem', or 'dcY' to set the boundaries for
+		the next allocation.
 
 
 What:		/sys/bus/cxl/devices/decoderX.Y/dpa_resource
diff --git a/drivers/cxl/core/hdm.c b/drivers/cxl/core/hdm.c
index a254f79dd4e8..3f4af1f5fac8 100644
--- a/drivers/cxl/core/hdm.c
+++ b/drivers/cxl/core/hdm.c
@@ -267,6 +267,19 @@ static void devm_cxl_dpa_release(struct cxl_endpoint_decoder *cxled)
 	__cxl_dpa_release(cxled);
 }
 
+static int dc_mode_to_region_index(enum cxl_decoder_mode mode)
+{
+	int index = 0;
+
+	for (int i = CXL_DECODER_DC0; i <= CXL_DECODER_DC7; i++) {
+		if (mode == i)
+			return index;
+		index++;
+	}
+
+	return -EINVAL;
+}
+
 static int __cxl_dpa_reserve(struct cxl_endpoint_decoder *cxled,
 			     resource_size_t base, resource_size_t len,
 			     resource_size_t skipped)
@@ -429,6 +442,7 @@ int cxl_dpa_set_mode(struct cxl_endpoint_decoder *cxled,
 	switch (mode) {
 	case CXL_DECODER_RAM:
 	case CXL_DECODER_PMEM:
+	case CXL_DECODER_DC0 ... CXL_DECODER_DC7:
 		break;
 	default:
 		dev_dbg(dev, "unsupported mode: %d\n", mode);
@@ -456,6 +470,16 @@ int cxl_dpa_set_mode(struct cxl_endpoint_decoder *cxled,
 		goto out;
 	}
 
+	for (int i = CXL_DECODER_DC0; i <= CXL_DECODER_DC7; i++) {
+		int index = dc_mode_to_region_index(i);
+
+		if (mode == i && !resource_size(&cxlds->dc_res[index])) {
+			dev_dbg(dev, "no available dynamic capacity\n");
+			rc = -ENXIO;
+			goto out;
+		}
+	}
+
 	cxled->mode = mode;
 	rc = 0;
 out:
diff --git a/drivers/cxl/core/port.c b/drivers/cxl/core/port.c
index f58cf01f8d2c..ce4a66865db3 100644
--- a/drivers/cxl/core/port.c
+++ b/drivers/cxl/core/port.c
@@ -197,6 +197,22 @@ static ssize_t mode_store(struct device *dev, struct device_attribute *attr,
 		mode = CXL_DECODER_PMEM;
 	else if (sysfs_streq(buf, "ram"))
 		mode = CXL_DECODER_RAM;
+	else if (sysfs_streq(buf, "dc0"))
+		mode = CXL_DECODER_DC0;
+	else if (sysfs_streq(buf, "dc1"))
+		mode = CXL_DECODER_DC1;
+	else if (sysfs_streq(buf, "dc2"))
+		mode = CXL_DECODER_DC2;
+	else if (sysfs_streq(buf, "dc3"))
+		mode = CXL_DECODER_DC3;
+	else if (sysfs_streq(buf, "dc4"))
+		mode = CXL_DECODER_DC4;
+	else if (sysfs_streq(buf, "dc5"))
+		mode = CXL_DECODER_DC5;
+	else if (sysfs_streq(buf, "dc6"))
+		mode = CXL_DECODER_DC6;
+	else if (sysfs_streq(buf, "dc7"))
+		mode = CXL_DECODER_DC7;
 	else
 		return -EINVAL;
 

-- 
2.41.0


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 94650C71153
	for <linux-cxl@archiver.kernel.org>; Tue, 29 Aug 2023 05:24:54 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S235630AbjH2FYX (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 29 Aug 2023 01:24:23 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:32790 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S235635AbjH2FXw (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 29 Aug 2023 01:23:52 -0400
Received: from mgamail.intel.com (mgamail.intel.com [134.134.136.100])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 405E4199;
        Mon, 28 Aug 2023 22:23:50 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1693286630; x=1724822630;
  h=from:date:subject:mime-version:content-transfer-encoding:
   message-id:references:in-reply-to:to:cc;
  bh=e+UEGBFvflCilnFRLPXzL1BIxt/SwaAJDlJZyXVRCU4=;
  b=ia7dSFtcQGah66SLgbC+NN1d6i6qrrlmDGTtNStjQdq/iGwGED121POl
   N5IkLtF6/T3ZqUEaKl4utQa/N+DEJjnfsp5Up4GXkjIu3pUq0D04X7OB6
   smaj+GU3Uv8FjMx8v1inpPljjuXmbGjEXqKFpbHRF4BSp9QogYOXY0z92
   hzLKflbTcUEnIVub8lqHNX/Z0Qs5H3Pw6er0opSua8s/URZNwo/EHqSVS
   uwE2ArJyxcaKjAy7zfyORPc9+WkDD9mW53HK6ZvuXUkzy92sQTU/Y/pln
   dORh5Gl7F0qdkHYVun1nUy6n+p1m2+0Ar5JASaA1SEkGUqAadr7Okk+Te
   Q==;
X-IronPort-AV: E=McAfee;i="6600,9927,10816"; a="441625157"
X-IronPort-AV: E=Sophos;i="6.02,208,1688454000"; 
   d="scan'208";a="441625157"
Received: from orsmga002.jf.intel.com ([10.7.209.21])
  by orsmga105.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 28 Aug 2023 22:23:32 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10816"; a="738556292"
X-IronPort-AV: E=Sophos;i="6.02,208,1688454000"; 
   d="scan'208";a="738556292"
Received: from iweiny-mobl.amr.corp.intel.com (HELO localhost) ([10.212.37.183])
  by orsmga002-auth.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 28 Aug 2023 22:23:31 -0700
From: Ira Weiny <ira.weiny@intel.com>
Date: Mon, 28 Aug 2023 22:20:52 -0700
Subject: [PATCH RFC v2 01/18] cxl/hdm: Debug, use decoder name function
MIME-Version: 1.0
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: 7bit
Message-Id: <20230604-dcd-type2-upstream-v2-1-f740c47e7916@intel.com>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
In-Reply-To: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
To: Dan Williams <dan.j.williams@intel.com>
Cc: Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        Ira Weiny <ira.weiny@intel.com>, linux-cxl@vger.kernel.org,
        linux-kernel@vger.kernel.org
X-Mailer: b4 0.13-dev-c6835
X-Developer-Signature: v=1; a=ed25519-sha256; t=1693286607; l=875;
 i=ira.weiny@intel.com; s=20221211; h=from:subject:message-id;
 bh=e+UEGBFvflCilnFRLPXzL1BIxt/SwaAJDlJZyXVRCU4=;
 b=ndAvGjnZcDm+e2/5yUeL3cdkv1P0q8Ie8hUanJCUyRRFpxhTz82VutYuJgPTqq7SoQa7i3ThD
 2Idk86K/HcgANLPWWO+wnE80e323W9jk9du3i1AvKY6y/5zEohbxns5
X-Developer-Key: i=ira.weiny@intel.com; a=ed25519;
 pk=noldbkG+Wp1qXRrrkfY1QJpDf7QsOEthbOT7vm0PqsE=
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

The decoder enum has a name conversion function defined now.

Use that instead of open coding.

Suggested-by: Navneet Singh <navneet.singh@intel.com>
Signed-off-by: Ira Weiny <ira.weiny@intel.com>

---
Changes for v2:
[iweiny: new patch, split out]
---
 drivers/cxl/core/hdm.c | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/drivers/cxl/core/hdm.c b/drivers/cxl/core/hdm.c
index b01a77b67511..a254f79dd4e8 100644
--- a/drivers/cxl/core/hdm.c
+++ b/drivers/cxl/core/hdm.c
@@ -550,8 +550,7 @@ int cxl_dpa_alloc(struct cxl_endpoint_decoder *cxled, unsigned long long size)
 
 	if (size > avail) {
 		dev_dbg(dev, "%pa exceeds available %s capacity: %pa\n", &size,
-			cxled->mode == CXL_DECODER_RAM ? "ram" : "pmem",
-			&avail);
+			cxl_decoder_mode_name(cxled->mode), &avail);
 		rc = -ENOSPC;
 		goto out;
 	}

-- 
2.41.0


From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from lindbergh.monkeyblade.net (lindbergh.monkeyblade.net [23.128.96.19])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id CDE0A266C4
	for <linux-cxl@vger.kernel.org>; Tue, 24 Oct 2023 16:16:38 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; dkim=none
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
	by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 9FA6EA6;
	Tue, 24 Oct 2023 09:16:35 -0700 (PDT)
Received: from lhrpeml500005.china.huawei.com (unknown [172.18.147.226])
	by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4SFHDZ531bz6K66h;
	Wed, 25 Oct 2023 00:13:50 +0800 (CST)
Received: from localhost (10.202.227.76) by lhrpeml500005.china.huawei.com
 (7.191.163.240) with Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id 15.1.2507.31; Tue, 24 Oct
 2023 17:16:32 +0100
Date: Tue, 24 Oct 2023 17:16:31 +0100
From: Jonathan Cameron <Jonathan.Cameron@Huawei.com>
To: Ira Weiny <ira.weiny@intel.com>
CC: Dan Williams <dan.j.williams@intel.com>, Navneet Singh
	<navneet.singh@intel.com>, Fan Ni <fan.ni@samsung.com>, Davidlohr Bueso
	<dave@stgolabs.net>, Dave Jiang <dave.jiang@intel.com>, Alison Schofield
	<alison.schofield@intel.com>, Vishal Verma <vishal.l.verma@intel.com>,
	<linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
Subject: Re: [PATCH RFC v2 02/18] cxl/mbox: Flag support for Dynamic
 Capacity Devices (DCD)
Message-ID: <20231024171631.000066c7@Huawei.com>
In-Reply-To: <20230604-dcd-type2-upstream-v2-2-f740c47e7916@intel.com>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
	<20230604-dcd-type2-upstream-v2-2-f740c47e7916@intel.com>
Organization: Huawei Technologies Research and Development (UK) Ltd.
X-Mailer: Claws Mail 4.1.0 (GTK 3.24.33; x86_64-w64-mingw32)
Precedence: bulk
X-Mailing-List: linux-cxl@vger.kernel.org
List-Id: <linux-cxl.vger.kernel.org>
List-Subscribe: <mailto:linux-cxl+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:linux-cxl+unsubscribe@vger.kernel.org>
MIME-Version: 1.0
Content-Type: text/plain; charset="US-ASCII"
Content-Transfer-Encoding: 7bit
X-Originating-IP: [10.202.227.76]
X-ClientProxiedBy: lhrpeml100005.china.huawei.com (7.191.160.25) To
 lhrpeml500005.china.huawei.com (7.191.163.240)
X-CFilter-Loop: Reflected

On Mon, 28 Aug 2023 22:20:53 -0700
Ira Weiny <ira.weiny@intel.com> wrote:

> Per the CXL 3.0 specification software must check the Command Effects
> Log (CEL) to know if a device supports DC.  If the device does support
> DC the specifics of the DC Regions (0-7) are read through the mailbox.
> 
> Flag DC Device (DCD) commands in a device if they are supported.
> Subsequent patches will key off these bits to configure a DCD.
> 
> Co-developed-by: Navneet Singh <navneet.singh@intel.com>
> Signed-off-by: Navneet Singh <navneet.singh@intel.com>
> Signed-off-by: Ira Weiny <ira.weiny@intel.com>
> 
> ---
> Changes for v2
> [iweiny: new patch]
> ---
>  drivers/cxl/core/mbox.c | 38 +++++++++++++++++++++++++++++++++++---
>  drivers/cxl/cxlmem.h    | 15 +++++++++++++++
>  2 files changed, 50 insertions(+), 3 deletions(-)
> 
> diff --git a/drivers/cxl/core/mbox.c b/drivers/cxl/core/mbox.c
> index f052d5f174ee..554ec97a7c39 100644
> --- a/drivers/cxl/core/mbox.c
> +++ b/drivers/cxl/core/mbox.c
> @@ -111,6 +111,34 @@ static u8 security_command_sets[] = {
>  	0x46, /* Security Passthrough */
>  };
>  
Small note I noticed whilst rebasing this for some tests.
Adding this in the middle of the stuff for security commands is
a bit odd. I'd move it up or down a few lines.

> +static bool cxl_is_dcd_command(u16 opcode)
> +{
> +#define CXL_MBOX_OP_DCD_CMDS 0x48
> +
> +	return (opcode >> 8) == CXL_MBOX_OP_DCD_CMDS;
> +}
> +
> +static void cxl_set_dcd_cmd_enabled(struct cxl_memdev_state *mds,
> +					u16 opcode)
> +{
> +	switch (opcode) {
> +	case CXL_MBOX_OP_GET_DC_CONFIG:
> +		set_bit(CXL_DCD_ENABLED_GET_CONFIG, mds->dcd_cmds);
> +		break;
> +	case CXL_MBOX_OP_GET_DC_EXTENT_LIST:
> +		set_bit(CXL_DCD_ENABLED_GET_EXTENT_LIST, mds->dcd_cmds);
> +		break;
> +	case CXL_MBOX_OP_ADD_DC_RESPONSE:
> +		set_bit(CXL_DCD_ENABLED_ADD_RESPONSE, mds->dcd_cmds);
> +		break;
> +	case CXL_MBOX_OP_RELEASE_DC:
> +		set_bit(CXL_DCD_ENABLED_RELEASE, mds->dcd_cmds);
> +		break;
> +	default:
> +		break;
> +	}
> +}
> +
>  static bool cxl_is_security_command(u16 opcode)
>  {
>  	int i;
> @@ -677,9 +705,10 @@ static void cxl_walk_cel(struct cxl_memdev_state *mds, size_t size, u8 *cel)
>  		u16 opcode = le16_to_cpu(cel_entry[i].opcode);
>  		struct cxl_mem_command *cmd = cxl_mem_find_command(opcode);
>  
> -		if (!cmd && !cxl_is_poison_command(opcode)) {
> -			dev_dbg(dev,
> -				"Opcode 0x%04x unsupported by driver\n", opcode);
> +		if (!cmd && !cxl_is_poison_command(opcode) &&
> +		    !cxl_is_dcd_command(opcode)) {
> +			dev_dbg(dev, "Opcode 0x%04x unsupported by driver\n",
> +				opcode);
>  			continue;
>  		}
>  
> @@ -689,6 +718,9 @@ static void cxl_walk_cel(struct cxl_memdev_state *mds, size_t size, u8 *cel)
>  		if (cxl_is_poison_command(opcode))
>  			cxl_set_poison_cmd_enabled(&mds->poison, opcode);
>  
> +		if (cxl_is_dcd_command(opcode))
> +			cxl_set_dcd_cmd_enabled(mds, opcode);
> +
>  		dev_dbg(dev, "Opcode 0x%04x enabled\n", opcode);
>  	}
>  }
> diff --git a/drivers/cxl/cxlmem.h b/drivers/cxl/cxlmem.h
> index adfba72445fc..5f2e65204bf9 100644
> --- a/drivers/cxl/cxlmem.h
> +++ b/drivers/cxl/cxlmem.h
> @@ -247,6 +247,15 @@ struct cxl_event_state {
>  	struct mutex log_lock;
>  };
>  
> +/* Device enabled DCD commands */
> +enum dcd_cmd_enabled_bits {
> +	CXL_DCD_ENABLED_GET_CONFIG,
> +	CXL_DCD_ENABLED_GET_EXTENT_LIST,
> +	CXL_DCD_ENABLED_ADD_RESPONSE,
> +	CXL_DCD_ENABLED_RELEASE,
> +	CXL_DCD_ENABLED_MAX
> +};
> +
>  /* Device enabled poison commands */
>  enum poison_cmd_enabled_bits {
>  	CXL_POISON_ENABLED_LIST,
> @@ -436,6 +445,7 @@ struct cxl_dev_state {
>   *                (CXL 2.0 8.2.9.5.1.1 Identify Memory Device)
>   * @mbox_mutex: Mutex to synchronize mailbox access.
>   * @firmware_version: Firmware version for the memory device.
> + * @dcd_cmds: List of DCD commands implemented by memory device
>   * @enabled_cmds: Hardware commands found enabled in CEL.
>   * @exclusive_cmds: Commands that are kernel-internal only
>   * @total_bytes: sum of all possible capacities
> @@ -460,6 +470,7 @@ struct cxl_memdev_state {
>  	size_t lsa_size;
>  	struct mutex mbox_mutex; /* Protects device mailbox and firmware */
>  	char firmware_version[0x10];
> +	DECLARE_BITMAP(dcd_cmds, CXL_DCD_ENABLED_MAX);
>  	DECLARE_BITMAP(enabled_cmds, CXL_MEM_COMMAND_ID_MAX);
>  	DECLARE_BITMAP(exclusive_cmds, CXL_MEM_COMMAND_ID_MAX);
>  	u64 total_bytes;
> @@ -525,6 +536,10 @@ enum cxl_opcode {
>  	CXL_MBOX_OP_UNLOCK		= 0x4503,
>  	CXL_MBOX_OP_FREEZE_SECURITY	= 0x4504,
>  	CXL_MBOX_OP_PASSPHRASE_SECURE_ERASE	= 0x4505,
> +	CXL_MBOX_OP_GET_DC_CONFIG	= 0x4800,
> +	CXL_MBOX_OP_GET_DC_EXTENT_LIST	= 0x4801,
> +	CXL_MBOX_OP_ADD_DC_RESPONSE	= 0x4802,
> +	CXL_MBOX_OP_RELEASE_DC		= 0x4803,
>  	CXL_MBOX_OP_MAX			= 0x10000
>  };
>  
> 


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 483FACD37B0
	for <linux-cxl@archiver.kernel.org>; Mon, 18 Sep 2023 17:46:37 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S230372AbjIRRqj (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Mon, 18 Sep 2023 13:46:39 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:57400 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S230365AbjIRRqg (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Mon, 18 Sep 2023 13:46:36 -0400
Received: from mgamail.intel.com (mgamail.intel.com [192.55.52.120])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id EB699103;
        Mon, 18 Sep 2023 10:46:29 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1695059190; x=1726595190;
  h=date:from:to:cc:subject:message-id:references:
   content-transfer-encoding:in-reply-to:mime-version;
  bh=g1bOw09U1xWfJu+HrV1A8bKpnvL17/3F4+AfcXqr3Mw=;
  b=Sb1qaiyuOxtKjxijJZLr1Ur+pVKPHouQKNJ3HxWkrQdze19w15lUNFii
   DWP4A1A9F9SIByTiicRuxlx2YC8Wq001IVl2lHr441rlZD8gIi/uc1mmh
   ZUSXx93PwTEImE+gwg7gje5sAVxULjqkvW3MsHReWEAo4iN36XQT8Q1fQ
   atQFrRonyPhA1WMw7N14YoPgxXFEtKvYTal9+DUlBon9NtZSQhiJ4Zttf
   KvW4YplS3kSt5TGTv0PzwDcBCSLMf5FovP3QOmlbhFWO4tKXXr7u7RxrF
   LyecRFo4TsbhQMmZoyaBBaFI6oSse4SHgDyh1t5zuNoAbTGygrPnWF5EA
   g==;
X-IronPort-AV: E=McAfee;i="6600,9927,10837"; a="378637148"
X-IronPort-AV: E=Sophos;i="6.02,157,1688454000"; 
   d="scan'208";a="378637148"
Received: from fmsmga005.fm.intel.com ([10.253.24.32])
  by fmsmga104.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 18 Sep 2023 10:46:03 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10837"; a="1076672556"
X-IronPort-AV: E=Sophos;i="6.02,157,1688454000"; 
   d="scan'208";a="1076672556"
Received: from orsmsx602.amr.corp.intel.com ([10.22.229.15])
  by fmsmga005.fm.intel.com with ESMTP/TLS/AES256-GCM-SHA384; 18 Sep 2023 10:46:03 -0700
Received: from orsmsx610.amr.corp.intel.com (10.22.229.23) by
 ORSMSX602.amr.corp.intel.com (10.22.229.15) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.32; Mon, 18 Sep 2023 10:46:02 -0700
Received: from orsmsx602.amr.corp.intel.com (10.22.229.15) by
 ORSMSX610.amr.corp.intel.com (10.22.229.23) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.32; Mon, 18 Sep 2023 10:46:02 -0700
Received: from ORSEDG601.ED.cps.intel.com (10.7.248.6) by
 orsmsx602.amr.corp.intel.com (10.22.229.15) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.32 via Frontend Transport; Mon, 18 Sep 2023 10:46:02 -0700
Received: from NAM12-MW2-obe.outbound.protection.outlook.com (104.47.66.46) by
 edgegateway.intel.com (134.134.137.102) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.32; Mon, 18 Sep 2023 10:46:02 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=IvkFUHQq9O0FrkihrigXv5CuLhbKW2mCfvAR3Yw+OFIrF7LWoplAb4v/sRuZwbVfhF1lZTeigORDaPbF0EgpYGUtaEhMLCMm3Zzu4nbGMZ0XpCpszKcc6rZTWmWMQWZzycTTzHAy20LzEH15vaFlaTPpY5exa3yZbCjQY5fwGPcUGlXW4GoW4L0sA/LAM+LNa6AEvk27wl1SLWQUW5s4GtMp/jBqYkElXWSn4HbZ7w6Mo9YKM8HuxzkfgknZfU73rDRiSpV5cd16xY3H8V9HhN3wC7tqfLbLuqkLPkevVEaheO5LyBognZYpiRa+6Mo2RWV6pLGMT5gQ1U8kHUzzLA==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=zARtddHgh22zgMEIWy5g4AXpOFBmY/ugPr1RHMOYbGM=;
 b=b9DpDp5Qf4yeG221Nfi1qsdQhlpx8QKHVrs6uk/iD3poTRIRF1ZQ357qqyhVg32DEvaz1trdbnFW5kiub9gq+hSvDPRN2yI6e1IKsMmEdACJCbVdpPE2aRZdfOVoilhyT2U5KPlX+MwamXIwj6/X6BZCChUUUxa4fTwVPeNqhYkxMpaxJZ4qbJUHxwTuMsoLZBeFSgCriQIATQgVGEicLuHJCrQOtWRC1eKlJAcm66kNQyYDSdLJ4ZuX9KSqQIU4W1/4NFFz+TtRv1OHfcuEMZtm2e/Mj2FB53dSKq1H2VEG8m69SNYJvCQW1U2WnLLEjwIxtQuSZoBoq8LxBS+CXA==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from SA1PR11MB6733.namprd11.prod.outlook.com (2603:10b6:806:25c::17)
 by SN7PR11MB7589.namprd11.prod.outlook.com (2603:10b6:806:34a::14) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.6792.21; Mon, 18 Sep
 2023 17:45:59 +0000
Received: from SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938]) by SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938%6]) with mapi id 15.20.6792.026; Mon, 18 Sep 2023
 17:45:59 +0000
Date: Mon, 18 Sep 2023 10:45:54 -0700
From: Ira Weiny <ira.weiny@intel.com>
To: =?iso-8859-1?Q?J=F8rgen?= Hansen <Jorgen.Hansen@wdc.com>,
        Ira Weiny <ira.weiny@intel.com>,
        Dan Williams <dan.j.williams@intel.com>
CC: Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        "linux-cxl@vger.kernel.org" <linux-cxl@vger.kernel.org>,
        "linux-kernel@vger.kernel.org" <linux-kernel@vger.kernel.org>
Subject: Re: [PATCH RFC v2 12/18] cxl/region: Notify regions of DC changes
Message-ID: <65088cd28d3ab_3921be29453@iweiny-mobl.notmuch>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
 <20230604-dcd-type2-upstream-v2-12-f740c47e7916@intel.com>
 <c6d4bd17-46c5-e77b-5dc1-ca5b9c9bf5d0@wdc.com>
Content-Type: text/plain; charset="iso-8859-1"
Content-Disposition: inline
Content-Transfer-Encoding: 8bit
In-Reply-To: <c6d4bd17-46c5-e77b-5dc1-ca5b9c9bf5d0@wdc.com>
X-ClientProxiedBy: BY5PR16CA0022.namprd16.prod.outlook.com
 (2603:10b6:a03:1a0::35) To SA1PR11MB6733.namprd11.prod.outlook.com
 (2603:10b6:806:25c::17)
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: SA1PR11MB6733:EE_|SN7PR11MB7589:EE_
X-MS-Office365-Filtering-Correlation-Id: 35fc9647-49dc-420c-fb8a-08dbb86f1e3f
X-LD-Processed: 46c98d88-e344-4ed4-8496-4ed7712e255d,ExtAddr
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;
X-Microsoft-Antispam-Message-Info: er21wiqRegUquLpEnXYdk1qcuDkJ+LP7piy6DG4ocW7A5wcxFjdHugPj4MjGI5uEqxeXsta71NxssjgjZ1i8sxeenudDoEAQhESH7Q2/lpUcckSfGZRjVtY12I/yZd3glvQZHZOOFFCxAgR/qN0jmLsK0NfK3rmiVcWueeNHlucbCJKfgk7tMm4BsINmXq99ZwGFzwpdnGN7tcgVaIXpXKO+vCHSDbF4+XBIR/UlT0SWQdktsvGBrgjDRw/N/+nNO0Dx6D28iUWfhT75ha4J4get4xAqlFySVDGHfuABBAY1oBZw9EjXuy+0+CrMpEztIMcXOqu2SicPd5gsuoL9ZT4RpbbQIMODM7bE6RbtXlN6QMWkqenY2aPCEdz82rtuC3B5jYs45cwzz5M8F+3vtRzzTDL3dvjvwtdafiEH5DDwIwdZ+0SPMuXnyZxNt34Ag1wBKuDttMidvI3jcAy5oueIEjH/g9wy6pHoQ4iO5IdEbJt5HzSDsDtBp0c3qQo+T9+kr1vxNXGmB1TC3i4lPVWg8C64srAO68QdxmcN8Ws10zYCzqItWngeqWsnoF/b
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:SA1PR11MB6733.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230031)(376002)(346002)(39860400002)(136003)(366004)(396003)(186009)(1800799009)(451199024)(53546011)(6486002)(6506007)(6666004)(478600001)(83380400001)(26005)(9686003)(6512007)(66574015)(2906002)(41300700001)(66556008)(6636002)(316002)(4326008)(66476007)(44832011)(54906003)(66946007)(5660300002)(110136005)(8676002)(8936002)(86362001)(38100700002)(82960400001);DIR:OUT;SFP:1102;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?iso-8859-1?Q?5+dEsPk2RoJzltW1zV9PW52gX3vkvKPChn7wIM6bqiqni1fKHjkqpXaG2+?=
 =?iso-8859-1?Q?jJNI/Y2IWujidNq6Ku0GkCS9Rq9trYyd+ghFxjReXf8ryoGBQLb3xOnNmz?=
 =?iso-8859-1?Q?xOjN9PCGhxhWeZCA58OpKSXksVYmiOmpXZZxKWg2lfbTOYlQ2iIzWFpBK5?=
 =?iso-8859-1?Q?fsM9WhE7YZs3H+Vl3Y6lMdAOSCFDzEOC79mabrDp2Rc2Tez4JH11ZOAYCK?=
 =?iso-8859-1?Q?AReq+Hljzn63Y1TUv0GVqUUoev53onZJINAvZ5G5wPyLl4+G8BklWnByA+?=
 =?iso-8859-1?Q?LJDRATKT0ikky0ui1n7xDxP5ZZrSg6X0IXpU8p2kp05IQkbxwMF+8Pv/cX?=
 =?iso-8859-1?Q?lbGTD4nPDJanxX7uaUbxyU/V6C1yXHV711i4WXvwcBD+HRJgHLmLyM6dKx?=
 =?iso-8859-1?Q?M2iMP1RYaYIXQxBOuJdqdVstZUlhCPJGuHQmMwV8bpDYkZ5OawjOi0ImYr?=
 =?iso-8859-1?Q?wkdlJQm1mVyUUVb0EYEjf161qztiverJeOp1kUKWPNdV9Py5nbwxdZWQwb?=
 =?iso-8859-1?Q?DMcvI0TndwLVUf2kBueYfHkDU8Jjh8EvV6M/VR5+u2TbAxn3u5Law1TIL/?=
 =?iso-8859-1?Q?Rv60j1c8zIEAJ1j+aF0agaAM0XEGeKteTOpbu78IoGvJbzoyiZB62Ds9K/?=
 =?iso-8859-1?Q?D59xBkS7NNOSqgpBiD048fxTHw0NJLEROrCg60lWoHftnpDDgulAAzN48J?=
 =?iso-8859-1?Q?EFgHbEA184RTMJQQdVTaZ6XMRj8/kEfAZek19WIdpNybBEA7ylo1HS6pQI?=
 =?iso-8859-1?Q?BUjLJex7h9SF2YCHDOhszi4XQ6tc0qaBvebTOr5SaSh0BlyXwonT0xF3eN?=
 =?iso-8859-1?Q?AaLFVZu7Jl0SObi2WvNF5pAe3FoQV6NLN0CZ2qVnxKqIHEvLSsx3WpnSmu?=
 =?iso-8859-1?Q?ZRlog0t1ToK+CjoGTSpgFw+MDi+3SHRkbzkTIXHGa7uOwi7tiATMm1f34e?=
 =?iso-8859-1?Q?AXoxsMdHfWEwPM8CHDFmjNHzc2SuAbKtZJEvRKHaXptH0w333ry9dETQ2V?=
 =?iso-8859-1?Q?xQk4DKsF7CtDTKOkmP/DUii2MBVZluqPMuwU1LVWsPn0+/NUu2Ti/BFUGA?=
 =?iso-8859-1?Q?1KXJauoo6UfNjVRSsJk5E8eMWAs8nBDpL01l9uzULQZZbxed8i/tUnKssZ?=
 =?iso-8859-1?Q?wVgD/q02zyX/VxaHQPgmO7tyYgDdj5uDpAz+/9VEKBAt+G1VLMDzuTNepH?=
 =?iso-8859-1?Q?fEeSiuCXY9V8mN4mSKnS18XFuKGl6KoKpIpbtxE4AMLFHO1BbSG3owIFBI?=
 =?iso-8859-1?Q?OdFnvwUTywLS237udv/Y1bymm/YPzkGzpKy/+hKyU4fp2JyjFZNwBhtXc2?=
 =?iso-8859-1?Q?eMgCH2wI1bJrDYtKNN2kFv9zzqu8IzmadrDa77hkz0cJILwVHemZexTQDl?=
 =?iso-8859-1?Q?IYHWj92mP0qwZUi+YxF5PRg6dfwkvoUTijv6KnVqdPLp1AGCRz/jm8jxtE?=
 =?iso-8859-1?Q?YaEn7p2HP1W9qFgeVZqaD5nKfaignNZ/HJ2pYjZ3p/HWWKGi9RGRxdODKi?=
 =?iso-8859-1?Q?GB96kx1KavxuFL0ok+CF6YwIwCYSG/wi6ryR0k9G+Tfq+2/6fwFxUPv83E?=
 =?iso-8859-1?Q?stqOdJjFSfi9eZVOX31iWnHOYn+YN0XTj0IfU0PvpJ0qrLBe1Om4MmLXFV?=
 =?iso-8859-1?Q?P2L4wXCP7LmSoJtLfKvpqjzQYzvYgM2hNM?=
X-MS-Exchange-CrossTenant-Network-Message-Id: 35fc9647-49dc-420c-fb8a-08dbb86f1e3f
X-MS-Exchange-CrossTenant-AuthSource: SA1PR11MB6733.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 18 Sep 2023 17:45:59.4807
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: 4WjNux24j7x7SAeQgL3RFV8UsqGUXhsk+1V/gVfwd66nt7jNePsDGZUw9bPdmt0W6krsIiNX1cF4xK8tJALhUw==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: SN7PR11MB7589
X-OriginatorOrg: intel.com
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

Jrgen Hansen wrote:
> On 8/29/23 07:21, Ira Weiny wrote:
> > 
> > In order for a user to use dynamic capacity effectively they need to
> > know when dynamic capacity is available.  Thus when Dynamic Capacity
> > (DC) extents are added or removed by a DC device the regions affected
> > need to be notified.  Ultimately the DAX region uses the memory
> > associated with DC extents.  However, remember that CXL DAX regions
> > maintain any interleave details between devices.
> > 
> > When a DCD event occurs, iterate all CXL endpoint decoders and notify
> > regions which contain the endpoints affected by the event.  In turn
> > notify the DAX regions of the changes to the DAX region extents.
> > 
> > For now interleave is handled by creating simple 1:1 mappings between
> > the CXL DAX region and DAX region layers.  Future implementations will
> > need to resolve when to actually surface a DAX region extent and pass
> > the notification along.
> > 
> > Remember that adding capacity is safe because there is no chance of the
> > memory being in use.  Also remember at this point releasing capacity is
> > straight forward because DAX devices do not yet have references to the
> > extents.  Future patches will handle that complication.
> > 
> > Signed-off-by: Ira Weiny <ira.weiny@intel.com>
> > 
> > ---
> > Changes from v1:
> > [iweiny: Rewrite]
> > ---
> >   drivers/cxl/core/mbox.c   |  39 +++++++++++++--
> >   drivers/cxl/core/region.c | 123 +++++++++++++++++++++++++++++++++++++++++-----
> >   drivers/cxl/cxl.h         |  22 +++++++++
> >   drivers/cxl/mem.c         |  50 +++++++++++++++++++
> >   drivers/dax/cxl.c         |  99 ++++++++++++++++++++++++++++++-------
> >   drivers/dax/dax-private.h |   3 ++
> >   drivers/dax/extent.c      |  14 ++++++
> >   7 files changed, 317 insertions(+), 33 deletions(-)
> > 
> > diff --git a/drivers/cxl/core/mbox.c b/drivers/cxl/core/mbox.c
> > index 5472ab1d0370..9d9c13e13ecf 100644
> 
> [snip]
> 
> > diff --git a/drivers/cxl/core/region.c b/drivers/cxl/core/region.c
> > index 0aeea50550f6..a0c1f2793dd7 100644
> > --- a/drivers/cxl/core/region.c
> > +++ b/drivers/cxl/core/region.c
> > @@ -1547,8 +1547,8 @@ static int cxl_region_validate_position(struct cxl_region *cxlr,
> >          return 0;
> >   }
> > 
> > -static bool cxl_dc_extent_in_ed(struct cxl_endpoint_decoder *cxled,
> > -                               struct cxl_dc_extent_data *extent)
> > +bool cxl_dc_extent_in_ed(struct cxl_endpoint_decoder *cxled,
> > +                        struct cxl_dc_extent_data *extent)
> >   {
> >          struct range dpa_range = (struct range){
> >                  .start = extent->dpa_start,
> > @@ -1567,14 +1567,66 @@ static bool cxl_dc_extent_in_ed(struct cxl_endpoint_decoder *cxled,
> >          return (cxled->dpa_res->start <= dpa_range.start &&
> >                  dpa_range.end <= cxled->dpa_res->end);
> >   }
> > +EXPORT_SYMBOL_NS_GPL(cxl_dc_extent_in_ed, CXL);
> > +
> > +static int cxl_region_notify_extent(struct cxl_endpoint_decoder *cxled,
> > +                                   enum dc_event event,
> > +                                   struct cxl_dr_extent *cxl_dr_ext)
> > +{
> > +       struct cxl_dax_region *cxlr_dax;
> > +       struct device *dev;
> > +       int rc = 0;
> > +
> > +       cxlr_dax = cxled->cxld.region->cxlr_dax;
> > +       dev = &cxlr_dax->dev;
> > +       dev_dbg(dev, "Trying notify: type %d HPA:%llx LEN:%llx\n",
> > +               event, cxl_dr_ext->hpa_offset, cxl_dr_ext->hpa_length);
> > +
> > +       device_lock(dev);
> > +       if (dev->driver) {
> > +               struct cxl_driver *reg_drv = to_cxl_drv(dev->driver);
> > +               struct cxl_drv_nd nd = (struct cxl_drv_nd) {
> > +                       .event = event,
> > +                       .cxl_dr_ext = cxl_dr_ext,
> > +               };
> > +
> > +               if (reg_drv->notify) {
> > +                       dev_dbg(dev, "Notify: type %d HPA:%llx LEN:%llx\n",
> > +                               event, cxl_dr_ext->hpa_offset,
> > +                               cxl_dr_ext->hpa_length);
> > +                       rc = reg_drv->notify(dev, &nd);
> > +               }
> > +       }
> > +       device_unlock(dev);
> > +       return rc;
> > +}
> > +
> > +static resource_size_t
> > +cxl_dc_extent_to_hpa_offset(struct cxl_endpoint_decoder *cxled,
> > +                           struct cxl_dc_extent_data *extent)
> > +{
> > +       struct cxl_dax_region *cxlr_dax;
> > +       resource_size_t dpa_offset, hpa;
> > +       struct range *ed_hpa_range;
> > +
> > +       cxlr_dax = cxled->cxld.region->cxlr_dax;
> > +
> > +       /*
> > +        * Without interleave...
> > +        * HPA offset == DPA offset
> > +        * ... but do the math anyway
> > +        */
> > +       dpa_offset = extent->dpa_start - cxled->dpa_res->start;
> > +       ed_hpa_range = &cxled->cxld.hpa_range;
> > +       hpa = ed_hpa_range->start + dpa_offset;
> > +       return hpa - cxlr_dax->hpa_range.start;
> > +}
> > 
> >   static int cxl_ed_add_one_extent(struct cxl_endpoint_decoder *cxled,
> >                                   struct cxl_dc_extent_data *extent)
> >   {
> >          struct cxl_dr_extent *cxl_dr_ext;
> >          struct cxl_dax_region *cxlr_dax;
> > -       resource_size_t dpa_offset, hpa;
> > -       struct range *ed_hpa_range;
> >          struct device *dev;
> >          int rc;
> > 
> > @@ -1601,15 +1653,7 @@ static int cxl_ed_add_one_extent(struct cxl_endpoint_decoder *cxled,
> >          cxl_dr_ext->extent = extent;
> >          kref_init(&cxl_dr_ext->region_ref);
> > 
> > -       /*
> > -        * Without interleave...
> > -        * HPA offset == DPA offset
> > -        * ... but do the math anyway
> > -        */
> > -       dpa_offset = extent->dpa_start - cxled->dpa_res->start;
> > -       ed_hpa_range = &cxled->cxld.hpa_range;
> > -       hpa = ed_hpa_range->start + dpa_offset;
> > -       cxl_dr_ext->hpa_offset = hpa - cxlr_dax->hpa_range.start;
> > +       cxl_dr_ext->hpa_offset = cxl_dc_extent_to_hpa_offset(cxled, extent);
> > 
> >          /* Without interleave carry length and label through */
> >          cxl_dr_ext->hpa_length = extent->length;
> > @@ -1626,6 +1670,7 @@ static int cxl_ed_add_one_extent(struct cxl_endpoint_decoder *cxled,
> >          }
> >          /* Put in cxl_dr_release() */
> >          cxl_dc_extent_get(cxl_dr_ext->extent);
> > +       cxl_region_notify_extent(cxled, DCD_ADD_CAPACITY, cxl_dr_ext);
> >          return 0;
> >   }
> > 
> > @@ -1663,6 +1708,58 @@ static int cxl_ed_add_extents(struct cxl_endpoint_decoder *cxled)
> >          return 0;
> >   }
> > 
> > +static int cxl_ed_rm_dc_extent(struct cxl_endpoint_decoder *cxled,
> > +                              enum dc_event event,
> > +                              struct cxl_dc_extent_data *extent)
> > +{
> > +       struct cxl_region *cxlr = cxled->cxld.region;
> > +       struct cxl_dax_region *cxlr_dax = cxlr->cxlr_dax;
> > +       struct cxl_dr_extent *cxl_dr_ext;
> > +       resource_size_t hpa_offset;
> > +
> > +       hpa_offset = cxl_dc_extent_to_hpa_offset(cxled, extent);
> > +
> > +       /*
> > +        * NOTE on Interleaving: There is no need to 'break up' the cxl_dr_ext.
> > +        * If one of the extents comprising it is gone it should be removed
> > +        * from the region to prevent future use.  Later code may save other
> > +        * extents for future processing.  But for now the corelation is 1:1:1
> > +        * so just erase the extent.
> > +        */
> > +       cxl_dr_ext = xa_erase(&cxlr_dax->extents, hpa_offset);
> > +
> > +       dev_dbg(&cxlr_dax->dev, "Remove DAX region ext HPA:%llx\n",
> > +               cxl_dr_ext->hpa_offset);
> > +       cxl_region_notify_extent(cxled, event, cxl_dr_ext);
> > +       cxl_dr_extent_put(cxl_dr_ext);
> > +       return 0;
> > +}
> > +
> > +int cxl_ed_notify_extent(struct cxl_endpoint_decoder *cxled,
> > +                        struct cxl_drv_nd *nd)
> > +{
> > +       int rc = 0;
> > +
> > +       switch (nd->event) {
> > +       case DCD_ADD_CAPACITY:
> > +               if (cxl_dc_extent_get_not_zero(nd->extent)) {
> > +                       rc = cxl_ed_add_one_extent(cxled, nd->extent);
> > +                       if (rc)
> > +                               cxl_dc_extent_put(nd->extent);
> 
> Hi,
> when playing around with adding and releasing DCD extents through the 
> qmp interface for the QEMU DCD emulation, I noticed that extents weren't 
> handed back to the device. It looks like there is a refcounting issue, 
> as the kref never drops below 2 for the dc extents. So I was wondering 
> whether we should only put the dc extent here on error or maybe always 
> put it?  cxl_ed_add_one_extent() also grabs a reference to the dc 
> extent, and that one is put in cxl_dr_release(), but I couldn't find a 
> matching put for this get_not_zero.

This is a bug I have fixed in the next version.

Yes the put needs to happen regardless of the return value.

...
        case DCD_ADD_CAPACITY:
                if (cxl_dc_extent_get_not_zero(nd->extent)) {
                        rc = cxl_ed_add_one_extent(cxled, nd->extent);
                        cxl_dc_extent_put(nd->extent);
                }
...

Please let me know if that does not work.  And thanks for the testing,
Ira

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 69A00CD37B0
	for <linux-cxl@archiver.kernel.org>; Mon, 18 Sep 2023 15:23:30 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S239988AbjIRPXd (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Mon, 18 Sep 2023 11:23:33 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:60632 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S238762AbjIRPXc (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Mon, 18 Sep 2023 11:23:32 -0400
Received: from esa2.hgst.iphmx.com (esa2.hgst.iphmx.com [68.232.143.124])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 840AB103;
        Mon, 18 Sep 2023 08:19:28 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=simple/simple;
  d=wdc.com; i=@wdc.com; q=dns/txt; s=dkim.wdc.com;
  t=1695050373; x=1726586373;
  h=from:to:cc:subject:date:message-id:references:
   in-reply-to:content-id:content-transfer-encoding:
   mime-version;
  bh=BTjI7LBy/w8Rf9k0/YkJekjO9FrbviihV+vhhM5Qbis=;
  b=iMqH2c6u1BaaTkSwaA/qUobSiiQm85R+y2jebpdtKMr0jGLfm5HnEwbY
   2V0jYHyzUDv7yvt7W3F6wmZY/Yf4mmsbGifJA1F/QRB+/n4ksfvWKiHka
   fVvJfCKPUruJUavs4b4D7VWv/AwkNNcomtIT5sQhEkjkLfewFORVIHiFX
   SGLk1jp6h4jYKEoX/Ehr+TJjcMkIbLpxaFCeTKVbPG+V1wrw+AG5u8vxu
   9qJQ5OkRC04OKrutCxXEihOBWJevq5G2lFXa1njOxeTar6bh7FHSOqeiS
   BaQJsjj9fl05uGrnYsMEKw9CCvVg0EHJ6HKE5XiD9WRccZOtnNYlOjXRw
   A==;
X-CSE-ConnectionGUID: zhOGWgRgTceLbN9MplXBGw==
X-CSE-MsgGUID: 4954vEktSu+tu0nBrz5l5Q==
X-IronPort-AV: E=Sophos;i="6.02,156,1688400000"; 
   d="scan'208";a="349542247"
Received: from mail-mw2nam10lp2105.outbound.protection.outlook.com (HELO NAM10-MW2-obe.outbound.protection.outlook.com) ([104.47.55.105])
  by ob1.hgst.iphmx.com with ESMTP; 18 Sep 2023 21:56:51 +0800
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=N9/NRznSNgcubQBWfLcD+Ws9tVfNfh0W7kfwYhAvYgcpI07VUkJFioFFOZTz6wf5J9K/BRyKnnEDpBBC4pWfN6HcUi/u7PBpukoUAjCcDxsFAafjV+Jw6CsLOwGmlZ+KYAeIw2O+sL54iNmPo7DNj4XzOu62fO+Zrfjc3aVnJgklM17oO6izM9huT6g9JEHDH/4m5BjNSG9Cg+LFRYyeQbNs2zfP0e2OSP1A7jv1gxTi79j3xKnBAgOz5Bb+OIbknutzgQ8Mkn+K1ydVb9DDzTWFn4maJkdoG/9C02WaMFVPt0F3/HugxAr/+/r4vbdXLp6UrWcvhm1mwPMv+gqs+g==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=BTjI7LBy/w8Rf9k0/YkJekjO9FrbviihV+vhhM5Qbis=;
 b=JQ+84RneZd6uZDMnvGEqEXL81TPad3pNcEE43KdALkaMarEXQethgh/cJIm0HcezRltMrrmeDa+WXA+pxQ7H1lxxNbqmpgdbltXJZFAW9avciY+U5S0SpKJbKJJjCClEvtYhFijUCIvXtyR3nRwReeRC4Do2Ocbn+/3Cj/ER4UJFzo1YLJ6uT0pKYI1YhwNY9u9nHZwl6vhdNgkmlvwOFPwq3BcL7ztda3+gOjpCvFtH2ee9jmzt0YJKZozHD7xPpFrUIaaijBS7A1rISSMhXXHdLLrCa/15ikT8R70bvt8OToqIzKGp8/FM3QU5bxpa/FBOlu8WANiIZ0UJ4VDvtQ==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=wdc.com; dmarc=pass action=none header.from=wdc.com; dkim=pass
 header.d=wdc.com; arc=none
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
 d=sharedspace.onmicrosoft.com; s=selector2-sharedspace-onmicrosoft-com;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-SenderADCheck;
 bh=BTjI7LBy/w8Rf9k0/YkJekjO9FrbviihV+vhhM5Qbis=;
 b=yIFcos8p0FPlO7PAqFjgSUvX4fN3I6M/IHwSNgzQ7MWTVdwns/bPjzAxHzMD3aY3jmillLirB1S4RNpAL9d87QoHIeBNZoxN2szIfbAaFOO3Cr7DtGoEs6oo4r9/GM+O+Wqt3WtXyg11ksDQdUJq2XAdJqGSQFzXsgWl9XJQhR4=
Received: from SN4PR0401MB3582.namprd04.prod.outlook.com
 (2603:10b6:803:4c::10) by BY5PR04MB6772.namprd04.prod.outlook.com
 (2603:10b6:a03:22e::18) with Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.6813.16; Mon, 18 Sep
 2023 13:56:49 +0000
Received: from SN4PR0401MB3582.namprd04.prod.outlook.com
 ([fe80::dbfe:73d9:79a9:4da5]) by SN4PR0401MB3582.namprd04.prod.outlook.com
 ([fe80::dbfe:73d9:79a9:4da5%4]) with mapi id 15.20.6813.014; Mon, 18 Sep 2023
 13:56:49 +0000
From: =?utf-8?B?SsO4cmdlbiBIYW5zZW4=?= <Jorgen.Hansen@wdc.com>
To: Ira Weiny <ira.weiny@intel.com>,
        Dan Williams <dan.j.williams@intel.com>
CC: Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        "linux-cxl@vger.kernel.org" <linux-cxl@vger.kernel.org>,
        "linux-kernel@vger.kernel.org" <linux-kernel@vger.kernel.org>
Subject: Re: [PATCH RFC v2 12/18] cxl/region: Notify regions of DC changes
Thread-Topic: [PATCH RFC v2 12/18] cxl/region: Notify regions of DC changes
Thread-Index: AQHZ2jky8bfBQ5N5S0G/WJCUV0qwoLAgu3UA
Date: Mon, 18 Sep 2023 13:56:49 +0000
Message-ID: <c6d4bd17-46c5-e77b-5dc1-ca5b9c9bf5d0@wdc.com>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
 <20230604-dcd-type2-upstream-v2-12-f740c47e7916@intel.com>
In-Reply-To: <20230604-dcd-type2-upstream-v2-12-f740c47e7916@intel.com>
Accept-Language: en-GB, en-US
Content-Language: en-US
X-MS-Has-Attach: 
X-MS-TNEF-Correlator: 
authentication-results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=wdc.com;
x-ms-publictraffictype: Email
x-ms-traffictypediagnostic: SN4PR0401MB3582:EE_|BY5PR04MB6772:EE_
x-ms-office365-filtering-correlation-id: 7e7a889f-b6e7-428c-9703-08dbb84f1ac2
wdcipoutbound: EOP-TRUE
x-ms-exchange-senderadcheck: 1
x-ms-exchange-antispam-relay: 0
x-microsoft-antispam: BCL:0;
x-microsoft-antispam-message-info: G2KXjrXM6TKxaT/TEL89QgNJeeAS+F40Io4ABaMGwdh+TyEOt7HKl50S9m89AxRA0RNdy5WLD56sb17ICJY0UrXTDDUR5x83uV3UT0xbdpOLzYGGAz3coLaJnUO5wo+BPwwTr1ilAhvtyLJHjuo9jQdqjEtTOXWXNiDw2pLbIJPHxLmAjB4JexD+nlBV1fcTvHP+zOPeu+W0BMWG8S1k/sftn90xwlvlM8Xw8GVI53qhMrafXvvN/2utZj96+xM4zMWUx0tK1jMgfoSAHPjP8UeHJbO9uhaE7OTBTcrxoh8yJ4jQPGrDAeUJ0T5fD4CQTnxCPsjOVS8759mHyqKvWjzZP63rS2dl6VXYOKQkt9Uq8ur2v+b9AtRFfckK33tVbsw18eJbIMm40aI940Df5iuUbF5IZdr16CyMDtf8GZttIyXpbKahStZ0Ud9m5jl3UUgVTwx2M0QdKZfTVkbMT/6om+93aTQmRMxUv7j+z7fcpSIrO7pMcuhdscKQhchM1oVx3WDfylEcNBbQmiyKCY6hnEDjQzdRJj6HK8z5Ssqvq7cRPbDaUBxUpPf4KuDwPLw+Zk9a1aa2v0fTMiEUoE69Jt/jNk6OvRCg8pS6eBO3Lra7t+tju97X8kazVJ0fF93cHdD1+ax4eDMjjRBZ3g==
x-forefront-antispam-report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:SN4PR0401MB3582.namprd04.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230031)(136003)(396003)(346002)(366004)(376002)(39860400002)(451199024)(1800799009)(186009)(38070700005)(38100700002)(122000001)(82960400001)(36756003)(85182001)(85202003)(86362001)(31696002)(478600001)(66946007)(66556008)(66476007)(66446008)(64756008)(54906003)(91956017)(71200400001)(110136005)(76116006)(2906002)(6512007)(53546011)(6506007)(6486002)(8676002)(8936002)(4326008)(5660300002)(31686004)(41300700001)(7416002)(316002)(26005)(2616005)(83380400001)(45980500001);DIR:OUT;SFP:1102;
x-ms-exchange-antispam-messagedata-chunkcount: 1
x-ms-exchange-antispam-messagedata-0: =?utf-8?B?a3MyUGZFMWRydTMreWFxRm9UcHhoRVlDN3RnS3p1SkFYcHdLWW56aVdtR0hh?=
 =?utf-8?B?K2xwM2Y0SUwyUTFFY01MN2FsN2E0aXlKUU9sb3JvNlV2b05KL2NhSnA1T1Fs?=
 =?utf-8?B?MjZ1eWQxazRnbWlnZUxFcWQ2eUZrK0U5K0g1TU1iZDkzcWg4dUtMK2Y0dnMx?=
 =?utf-8?B?NW1RblZTNjFSamxQSkhDKzZUaEQxWnJnMG8vTTI5WnQ2SGtza0czLzJ2bzBK?=
 =?utf-8?B?eUF2eHBoa2ZPYlVCSVF2dkl0WitoMXJXV3lwd0VLY3MzUnc0NWhnKzdnS0Rk?=
 =?utf-8?B?eFF4NEZXQ05CMFNoN2ZYMkp0UnlHMndXUzdQSkkwTERpRFNlcDlTdGp3SFdX?=
 =?utf-8?B?OTV5K2Z5ZGw1ZlpYTEd1Q29rblV5U2UvSmtsV05ZUnhudEpDaE5EOTJ3NDBF?=
 =?utf-8?B?YW1pNjhFd0doV2R3d1BsSGsxMWhYb1lya1llbk1ER3ZxcHVCd1E1RGhFMU1Y?=
 =?utf-8?B?dndPL2N0ajZwUE4xbzZJTmJYNEFHNkVqWTV1RDJ1WHU0VWQvWElRWVovR240?=
 =?utf-8?B?djB6ZWQyQmY1ZWNhMWZIODhjbVVmVDFrcnRudEl3UmYwY2xCZkNzc09QeGtt?=
 =?utf-8?B?SXc0Tk8rNEpMZXFsaGFyWHBTVTlHdzd5dDlsdUI2VnBFTkpESGwyQkxuT0JB?=
 =?utf-8?B?djFMYnJDS0t3Qm1YYUFNbS8yTUs3eWI4RlgrTHloRzhiakhvbjVEYmV4M2c0?=
 =?utf-8?B?NEVNYmtUaEptcEh4RTFpODdOY0dtY2ZUN3VmeGw4S2plR1ZnR3pNam03L2FQ?=
 =?utf-8?B?YXovT2ZhWjhETmhscVMxdHZlUTk3cm5pM2NHS0tLWFNzYVJZZDgrYzZYRklY?=
 =?utf-8?B?UEt1UlBUMGt3VkYxM3lURVYvbGttVHNFcWJoOFlzei9NMlZXQUVEbXRzWDlS?=
 =?utf-8?B?MTBjTXB3blpPZXNxaWtucWUwM1Vpc1JqbUh4ZTA4RXJDaDdhV1NFd21LWVA1?=
 =?utf-8?B?L1dFdGJ5S3JKd0hKNFk3Rm82aytuRHEyUTE1ZmZ4VktVeXBjNi95c2JJRUNz?=
 =?utf-8?B?TGc5am5PcU9HREdsS0ZPKzZ3Q3FoK1UyS1FHMzFyYWhpOElKdlk2TnFMWHI0?=
 =?utf-8?B?ZjhKdkE5OUhBQnhLYjRrbVlsWXRRRXJCME1GcDdHaXErQ2wzUkh6NTJhbTdx?=
 =?utf-8?B?S2JoKzFDekJqRERGUTZqeDE5RVNKOWNqNzdCNlpXWWxCUFA0YSt6UjRVK1dV?=
 =?utf-8?B?c1BvdmgvZ3lJTUZwUjl0dUNuVit4cUZUZHp1bjRCOUtYMFhOcHh5QllhY0Za?=
 =?utf-8?B?WTVZdXhqRXNFWkhEa29qMktYRjFFL0ZPbXB2VlVQYVlRVVJuZXd1L1NrUUtE?=
 =?utf-8?B?NGkxQ040Wm5sQ3JWdXRGTnhXYTkySHU3ZlpaWGVHS3JEc3RRM1VqUGhCYmdv?=
 =?utf-8?B?YXN1bkpZYkZNMFlsOEsrSDhobVJXb01QcWFZZHA5b3BlOWdNSVlvK0FwMXgx?=
 =?utf-8?B?YWZTVUtXek9jY3EvSHVFcjhpem04eGJXTW11N0JwV3oxaWtGOVllOEJyY1dV?=
 =?utf-8?B?WWpuZ2M1ZTFzbEFOU00xK2w4VVV0dDdCdzB2QkVTblp4RmMzOVQ1V21UWWUw?=
 =?utf-8?B?b3BtY1F5d3hKdEd4bzBkQVp2MXU1S0hUSUk1YWJiVUgzU2hjQmxXQTQwcUdH?=
 =?utf-8?B?TXVnVitmcHBFRE9WMmdJR0tnMDJQQjF6bHdYbExBMVNNNGNJQlpBeC9YamJU?=
 =?utf-8?B?QmRaMnlJSXpRaEJqZVBkeHRmMytqdW9EWmxPeGI4SjAwdXpKelRiVXhZdWtk?=
 =?utf-8?B?M1J5WkVaZUEwMkNsRXJMRXdtV2JBMk1xMWVVOXZrekZuMDRJU1Bkbi9wTW4w?=
 =?utf-8?B?NXE4UXY1UkJKRUV4RW8wRjFSSHRiS3lzWld1Ny9qUzk1clUzU05DQkJzcVhk?=
 =?utf-8?B?WHJ4QjRJbG5tZjkxYmJtcy9CeDRUaU1RZGtwcHhUY01yTlVHU1JOTXprM1V5?=
 =?utf-8?B?OHQ2YzB2ZjkvdXBvVk5QVmlhZktmYVJJUXVUSVVQVkZyMWdBZmJkVlRJZXZv?=
 =?utf-8?B?bkc3T2Z1ZGtuTU9aV0tSYm1MRGU0WkdKYk5ZaVY4bmdyMEs4R2NPS25xTUwx?=
 =?utf-8?B?Ymt4aDhMZDhkS0ZmWHVvZmI4U3RQZjFwVjZMbDM2OWkzcitjRzN3Qk5yVVor?=
 =?utf-8?B?cVQxdzEvQzJnbGh2QXJ2M0Nzc0pVRm5LQ1h3aU40eUtTWCtJbXY2M3N6OHZr?=
 =?utf-8?B?eGc9PQ==?=
Content-Type: text/plain; charset="utf-8"
Content-ID: <8D60A0377FEC9A4B9CD3F3A4C8BE604F@namprd04.prod.outlook.com>
Content-Transfer-Encoding: base64
MIME-Version: 1.0
X-MS-Exchange-AntiSpam-ExternalHop-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-ExternalHop-MessageData-0: l5zihkQ7zaC9Ta4NJoTgFFjDEJz62Db+0VqAoVAPKVA+F8jVxtAn1JTkgoZZ/2YRsaz6VZtCrdysMTbCd/FrbQq5yUedBVcvYrHjyfZC+N9gVlL3dE9NW/pQOEfukv1pbn1XH+kB8Fk3NWU6g9jNuMFaVUQJ8P9zQ4JSTFOjTGkc3yUV4wlB2/KCzv5WVGJufrfadYfPWV3cUUvFQPGn+qZUHA1q7jy+URGurSjPR1GYvBGND7Q3aEDyWZiR9cx0Gg1COavn3zMSpxweTqUFx4+PMbLZRTk+MbcCysp/wwWFj8MhrapA0NQ2Vfzgg5E6CLpnw2VxNmvt1Ognnu2a74DWukUD1Rsb4sgatiSGRvQEFyyLTLil10NNwO380S5zI934eMVRZM+p1gKB42zYYTXrAo6Tp/LoqlOj7dqABQtJOH/XO6AzPx1KpyFuwRHdcJPAqnDX2ln+8noGtf8pBkn8m5Se5paiqD57OGgWeg6QsiKygTR/iQUb1zAWR/Muv5dAVEArB+YCdn6vmhAURLmwPpUyKF0JcCCJ4DAfSv1jMg9DnEoAz72DzxmyJVRxgR04FqsH+EBgIVMATijFK/rAux5c8K4IzfM/rbhkiRag34R0xuNCwdeCFK6xXkN/xW2n0mMbe0j/PfxhqWJrIZDvq9/jyjYvksYLkxNN74oZmSeLnOS/a2qP0RhWBnlElw7aIKhHQaatvjYBlMD3udIE6Dc93Lj4wDi/qupHZgqE+27j2fKwwrJBfAeGWIXIQB9vl3n97Yi26WyY3QoHUAhaSvUovJ8gZzdY+MM0OG7LbGI6VJdWC7Y0S16eqCs+3EuhSyKkEwKqtmyt6efuVOofBv7J5y8RH6PEjZ0OxyOGyVtDOr1X2E8e+hnozB7PoppoTWWkpVBav5fxaX4e0A==
X-OriginatorOrg: wdc.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-AuthSource: SN4PR0401MB3582.namprd04.prod.outlook.com
X-MS-Exchange-CrossTenant-Network-Message-Id: 7e7a889f-b6e7-428c-9703-08dbb84f1ac2
X-MS-Exchange-CrossTenant-originalarrivaltime: 18 Sep 2023 13:56:49.3853
 (UTC)
X-MS-Exchange-CrossTenant-fromentityheader: Hosted
X-MS-Exchange-CrossTenant-id: b61c8803-16f3-4c35-9b17-6f65f441df86
X-MS-Exchange-CrossTenant-mailboxtype: HOSTED
X-MS-Exchange-CrossTenant-userprincipalname: /plW3Cn/vf11Y7EwN05uQ5oc3sQ6XrX/oJpzQ0Ax3cLAttQYtYZPH3r9b3+m/9djywmo+S8fU49yfnqYjowIEg==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: BY5PR04MB6772
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

T24gOC8yOS8yMyAwNzoyMSwgSXJhIFdlaW55IHdyb3RlOg0KPiANCj4gSW4gb3JkZXIgZm9yIGEg
dXNlciB0byB1c2UgZHluYW1pYyBjYXBhY2l0eSBlZmZlY3RpdmVseSB0aGV5IG5lZWQgdG8NCj4g
a25vdyB3aGVuIGR5bmFtaWMgY2FwYWNpdHkgaXMgYXZhaWxhYmxlLiAgVGh1cyB3aGVuIER5bmFt
aWMgQ2FwYWNpdHkNCj4gKERDKSBleHRlbnRzIGFyZSBhZGRlZCBvciByZW1vdmVkIGJ5IGEgREMg
ZGV2aWNlIHRoZSByZWdpb25zIGFmZmVjdGVkDQo+IG5lZWQgdG8gYmUgbm90aWZpZWQuICBVbHRp
bWF0ZWx5IHRoZSBEQVggcmVnaW9uIHVzZXMgdGhlIG1lbW9yeQ0KPiBhc3NvY2lhdGVkIHdpdGgg
REMgZXh0ZW50cy4gIEhvd2V2ZXIsIHJlbWVtYmVyIHRoYXQgQ1hMIERBWCByZWdpb25zDQo+IG1h
aW50YWluIGFueSBpbnRlcmxlYXZlIGRldGFpbHMgYmV0d2VlbiBkZXZpY2VzLg0KPiANCj4gV2hl
biBhIERDRCBldmVudCBvY2N1cnMsIGl0ZXJhdGUgYWxsIENYTCBlbmRwb2ludCBkZWNvZGVycyBh
bmQgbm90aWZ5DQo+IHJlZ2lvbnMgd2hpY2ggY29udGFpbiB0aGUgZW5kcG9pbnRzIGFmZmVjdGVk
IGJ5IHRoZSBldmVudC4gIEluIHR1cm4NCj4gbm90aWZ5IHRoZSBEQVggcmVnaW9ucyBvZiB0aGUg
Y2hhbmdlcyB0byB0aGUgREFYIHJlZ2lvbiBleHRlbnRzLg0KPiANCj4gRm9yIG5vdyBpbnRlcmxl
YXZlIGlzIGhhbmRsZWQgYnkgY3JlYXRpbmcgc2ltcGxlIDE6MSBtYXBwaW5ncyBiZXR3ZWVuDQo+
IHRoZSBDWEwgREFYIHJlZ2lvbiBhbmQgREFYIHJlZ2lvbiBsYXllcnMuICBGdXR1cmUgaW1wbGVt
ZW50YXRpb25zIHdpbGwNCj4gbmVlZCB0byByZXNvbHZlIHdoZW4gdG8gYWN0dWFsbHkgc3VyZmFj
ZSBhIERBWCByZWdpb24gZXh0ZW50IGFuZCBwYXNzDQo+IHRoZSBub3RpZmljYXRpb24gYWxvbmcu
DQo+IA0KPiBSZW1lbWJlciB0aGF0IGFkZGluZyBjYXBhY2l0eSBpcyBzYWZlIGJlY2F1c2UgdGhl
cmUgaXMgbm8gY2hhbmNlIG9mIHRoZQ0KPiBtZW1vcnkgYmVpbmcgaW4gdXNlLiAgQWxzbyByZW1l
bWJlciBhdCB0aGlzIHBvaW50IHJlbGVhc2luZyBjYXBhY2l0eSBpcw0KPiBzdHJhaWdodCBmb3J3
YXJkIGJlY2F1c2UgREFYIGRldmljZXMgZG8gbm90IHlldCBoYXZlIHJlZmVyZW5jZXMgdG8gdGhl
DQo+IGV4dGVudHMuICBGdXR1cmUgcGF0Y2hlcyB3aWxsIGhhbmRsZSB0aGF0IGNvbXBsaWNhdGlv
bi4NCj4gDQo+IFNpZ25lZC1vZmYtYnk6IElyYSBXZWlueSA8aXJhLndlaW55QGludGVsLmNvbT4N
Cj4gDQo+IC0tLQ0KPiBDaGFuZ2VzIGZyb20gdjE6DQo+IFtpd2Vpbnk6IFJld3JpdGVdDQo+IC0t
LQ0KPiAgIGRyaXZlcnMvY3hsL2NvcmUvbWJveC5jICAgfCAgMzkgKysrKysrKysrKysrKy0tDQo+
ICAgZHJpdmVycy9jeGwvY29yZS9yZWdpb24uYyB8IDEyMyArKysrKysrKysrKysrKysrKysrKysr
KysrKysrKysrKysrKysrKysrKy0tLS0tDQo+ICAgZHJpdmVycy9jeGwvY3hsLmggICAgICAgICB8
ICAyMiArKysrKysrKysNCj4gICBkcml2ZXJzL2N4bC9tZW0uYyAgICAgICAgIHwgIDUwICsrKysr
KysrKysrKysrKysrKysNCj4gICBkcml2ZXJzL2RheC9jeGwuYyAgICAgICAgIHwgIDk5ICsrKysr
KysrKysrKysrKysrKysrKysrKysrKysrKy0tLS0tLS0NCj4gICBkcml2ZXJzL2RheC9kYXgtcHJp
dmF0ZS5oIHwgICAzICsrDQo+ICAgZHJpdmVycy9kYXgvZXh0ZW50LmMgICAgICB8ICAxNCArKysr
KysNCj4gICA3IGZpbGVzIGNoYW5nZWQsIDMxNyBpbnNlcnRpb25zKCspLCAzMyBkZWxldGlvbnMo
LSkNCj4gDQo+IGRpZmYgLS1naXQgYS9kcml2ZXJzL2N4bC9jb3JlL21ib3guYyBiL2RyaXZlcnMv
Y3hsL2NvcmUvbWJveC5jDQo+IGluZGV4IDU0NzJhYjFkMDM3MC4uOWQ5YzEzZTEzZWNmIDEwMDY0
NA0KDQpbc25pcF0NCg0KPiBkaWZmIC0tZ2l0IGEvZHJpdmVycy9jeGwvY29yZS9yZWdpb24uYyBi
L2RyaXZlcnMvY3hsL2NvcmUvcmVnaW9uLmMNCj4gaW5kZXggMGFlZWE1MDU1MGY2Li5hMGMxZjI3
OTNkZDcgMTAwNjQ0DQo+IC0tLSBhL2RyaXZlcnMvY3hsL2NvcmUvcmVnaW9uLmMNCj4gKysrIGIv
ZHJpdmVycy9jeGwvY29yZS9yZWdpb24uYw0KPiBAQCAtMTU0Nyw4ICsxNTQ3LDggQEAgc3RhdGlj
IGludCBjeGxfcmVnaW9uX3ZhbGlkYXRlX3Bvc2l0aW9uKHN0cnVjdCBjeGxfcmVnaW9uICpjeGxy
LA0KPiAgICAgICAgICByZXR1cm4gMDsNCj4gICB9DQo+IA0KPiAtc3RhdGljIGJvb2wgY3hsX2Rj
X2V4dGVudF9pbl9lZChzdHJ1Y3QgY3hsX2VuZHBvaW50X2RlY29kZXIgKmN4bGVkLA0KPiAtICAg
ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cnVjdCBjeGxfZGNfZXh0ZW50X2RhdGEgKmV4
dGVudCkNCj4gK2Jvb2wgY3hsX2RjX2V4dGVudF9pbl9lZChzdHJ1Y3QgY3hsX2VuZHBvaW50X2Rl
Y29kZXIgKmN4bGVkLA0KPiArICAgICAgICAgICAgICAgICAgICAgICAgc3RydWN0IGN4bF9kY19l
eHRlbnRfZGF0YSAqZXh0ZW50KQ0KPiAgIHsNCj4gICAgICAgICAgc3RydWN0IHJhbmdlIGRwYV9y
YW5nZSA9IChzdHJ1Y3QgcmFuZ2Upew0KPiAgICAgICAgICAgICAgICAgIC5zdGFydCA9IGV4dGVu
dC0+ZHBhX3N0YXJ0LA0KPiBAQCAtMTU2NywxNCArMTU2Nyw2NiBAQCBzdGF0aWMgYm9vbCBjeGxf
ZGNfZXh0ZW50X2luX2VkKHN0cnVjdCBjeGxfZW5kcG9pbnRfZGVjb2RlciAqY3hsZWQsDQo+ICAg
ICAgICAgIHJldHVybiAoY3hsZWQtPmRwYV9yZXMtPnN0YXJ0IDw9IGRwYV9yYW5nZS5zdGFydCAm
Jg0KPiAgICAgICAgICAgICAgICAgIGRwYV9yYW5nZS5lbmQgPD0gY3hsZWQtPmRwYV9yZXMtPmVu
ZCk7DQo+ICAgfQ0KPiArRVhQT1JUX1NZTUJPTF9OU19HUEwoY3hsX2RjX2V4dGVudF9pbl9lZCwg
Q1hMKTsNCj4gKw0KPiArc3RhdGljIGludCBjeGxfcmVnaW9uX25vdGlmeV9leHRlbnQoc3RydWN0
IGN4bF9lbmRwb2ludF9kZWNvZGVyICpjeGxlZCwNCj4gKyAgICAgICAgICAgICAgICAgICAgICAg
ICAgICAgICAgICAgZW51bSBkY19ldmVudCBldmVudCwNCj4gKyAgICAgICAgICAgICAgICAgICAg
ICAgICAgICAgICAgICAgc3RydWN0IGN4bF9kcl9leHRlbnQgKmN4bF9kcl9leHQpDQo+ICt7DQo+
ICsgICAgICAgc3RydWN0IGN4bF9kYXhfcmVnaW9uICpjeGxyX2RheDsNCj4gKyAgICAgICBzdHJ1
Y3QgZGV2aWNlICpkZXY7DQo+ICsgICAgICAgaW50IHJjID0gMDsNCj4gKw0KPiArICAgICAgIGN4
bHJfZGF4ID0gY3hsZWQtPmN4bGQucmVnaW9uLT5jeGxyX2RheDsNCj4gKyAgICAgICBkZXYgPSAm
Y3hscl9kYXgtPmRldjsNCj4gKyAgICAgICBkZXZfZGJnKGRldiwgIlRyeWluZyBub3RpZnk6IHR5
cGUgJWQgSFBBOiVsbHggTEVOOiVsbHhcbiIsDQo+ICsgICAgICAgICAgICAgICBldmVudCwgY3hs
X2RyX2V4dC0+aHBhX29mZnNldCwgY3hsX2RyX2V4dC0+aHBhX2xlbmd0aCk7DQo+ICsNCj4gKyAg
ICAgICBkZXZpY2VfbG9jayhkZXYpOw0KPiArICAgICAgIGlmIChkZXYtPmRyaXZlcikgew0KPiAr
ICAgICAgICAgICAgICAgc3RydWN0IGN4bF9kcml2ZXIgKnJlZ19kcnYgPSB0b19jeGxfZHJ2KGRl
di0+ZHJpdmVyKTsNCj4gKyAgICAgICAgICAgICAgIHN0cnVjdCBjeGxfZHJ2X25kIG5kID0gKHN0
cnVjdCBjeGxfZHJ2X25kKSB7DQo+ICsgICAgICAgICAgICAgICAgICAgICAgIC5ldmVudCA9IGV2
ZW50LA0KPiArICAgICAgICAgICAgICAgICAgICAgICAuY3hsX2RyX2V4dCA9IGN4bF9kcl9leHQs
DQo+ICsgICAgICAgICAgICAgICB9Ow0KPiArDQo+ICsgICAgICAgICAgICAgICBpZiAocmVnX2Ry
di0+bm90aWZ5KSB7DQo+ICsgICAgICAgICAgICAgICAgICAgICAgIGRldl9kYmcoZGV2LCAiTm90
aWZ5OiB0eXBlICVkIEhQQTolbGx4IExFTjolbGx4XG4iLA0KPiArICAgICAgICAgICAgICAgICAg
ICAgICAgICAgICAgIGV2ZW50LCBjeGxfZHJfZXh0LT5ocGFfb2Zmc2V0LA0KPiArICAgICAgICAg
ICAgICAgICAgICAgICAgICAgICAgIGN4bF9kcl9leHQtPmhwYV9sZW5ndGgpOw0KPiArICAgICAg
ICAgICAgICAgICAgICAgICByYyA9IHJlZ19kcnYtPm5vdGlmeShkZXYsICZuZCk7DQo+ICsgICAg
ICAgICAgICAgICB9DQo+ICsgICAgICAgfQ0KPiArICAgICAgIGRldmljZV91bmxvY2soZGV2KTsN
Cj4gKyAgICAgICByZXR1cm4gcmM7DQo+ICt9DQo+ICsNCj4gK3N0YXRpYyByZXNvdXJjZV9zaXpl
X3QNCj4gK2N4bF9kY19leHRlbnRfdG9faHBhX29mZnNldChzdHJ1Y3QgY3hsX2VuZHBvaW50X2Rl
Y29kZXIgKmN4bGVkLA0KPiArICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RydWN0IGN4bF9k
Y19leHRlbnRfZGF0YSAqZXh0ZW50KQ0KPiArew0KPiArICAgICAgIHN0cnVjdCBjeGxfZGF4X3Jl
Z2lvbiAqY3hscl9kYXg7DQo+ICsgICAgICAgcmVzb3VyY2Vfc2l6ZV90IGRwYV9vZmZzZXQsIGhw
YTsNCj4gKyAgICAgICBzdHJ1Y3QgcmFuZ2UgKmVkX2hwYV9yYW5nZTsNCj4gKw0KPiArICAgICAg
IGN4bHJfZGF4ID0gY3hsZWQtPmN4bGQucmVnaW9uLT5jeGxyX2RheDsNCj4gKw0KPiArICAgICAg
IC8qDQo+ICsgICAgICAgICogV2l0aG91dCBpbnRlcmxlYXZlLi4uDQo+ICsgICAgICAgICogSFBB
IG9mZnNldCA9PSBEUEEgb2Zmc2V0DQo+ICsgICAgICAgICogLi4uIGJ1dCBkbyB0aGUgbWF0aCBh
bnl3YXkNCj4gKyAgICAgICAgKi8NCj4gKyAgICAgICBkcGFfb2Zmc2V0ID0gZXh0ZW50LT5kcGFf
c3RhcnQgLSBjeGxlZC0+ZHBhX3Jlcy0+c3RhcnQ7DQo+ICsgICAgICAgZWRfaHBhX3JhbmdlID0g
JmN4bGVkLT5jeGxkLmhwYV9yYW5nZTsNCj4gKyAgICAgICBocGEgPSBlZF9ocGFfcmFuZ2UtPnN0
YXJ0ICsgZHBhX29mZnNldDsNCj4gKyAgICAgICByZXR1cm4gaHBhIC0gY3hscl9kYXgtPmhwYV9y
YW5nZS5zdGFydDsNCj4gK30NCj4gDQo+ICAgc3RhdGljIGludCBjeGxfZWRfYWRkX29uZV9leHRl
bnQoc3RydWN0IGN4bF9lbmRwb2ludF9kZWNvZGVyICpjeGxlZCwNCj4gICAgICAgICAgICAgICAg
ICAgICAgICAgICAgICAgICAgIHN0cnVjdCBjeGxfZGNfZXh0ZW50X2RhdGEgKmV4dGVudCkNCj4g
ICB7DQo+ICAgICAgICAgIHN0cnVjdCBjeGxfZHJfZXh0ZW50ICpjeGxfZHJfZXh0Ow0KPiAgICAg
ICAgICBzdHJ1Y3QgY3hsX2RheF9yZWdpb24gKmN4bHJfZGF4Ow0KPiAtICAgICAgIHJlc291cmNl
X3NpemVfdCBkcGFfb2Zmc2V0LCBocGE7DQo+IC0gICAgICAgc3RydWN0IHJhbmdlICplZF9ocGFf
cmFuZ2U7DQo+ICAgICAgICAgIHN0cnVjdCBkZXZpY2UgKmRldjsNCj4gICAgICAgICAgaW50IHJj
Ow0KPiANCj4gQEAgLTE2MDEsMTUgKzE2NTMsNyBAQCBzdGF0aWMgaW50IGN4bF9lZF9hZGRfb25l
X2V4dGVudChzdHJ1Y3QgY3hsX2VuZHBvaW50X2RlY29kZXIgKmN4bGVkLA0KPiAgICAgICAgICBj
eGxfZHJfZXh0LT5leHRlbnQgPSBleHRlbnQ7DQo+ICAgICAgICAgIGtyZWZfaW5pdCgmY3hsX2Ry
X2V4dC0+cmVnaW9uX3JlZik7DQo+IA0KPiAtICAgICAgIC8qDQo+IC0gICAgICAgICogV2l0aG91
dCBpbnRlcmxlYXZlLi4uDQo+IC0gICAgICAgICogSFBBIG9mZnNldCA9PSBEUEEgb2Zmc2V0DQo+
IC0gICAgICAgICogLi4uIGJ1dCBkbyB0aGUgbWF0aCBhbnl3YXkNCj4gLSAgICAgICAgKi8NCj4g
LSAgICAgICBkcGFfb2Zmc2V0ID0gZXh0ZW50LT5kcGFfc3RhcnQgLSBjeGxlZC0+ZHBhX3Jlcy0+
c3RhcnQ7DQo+IC0gICAgICAgZWRfaHBhX3JhbmdlID0gJmN4bGVkLT5jeGxkLmhwYV9yYW5nZTsN
Cj4gLSAgICAgICBocGEgPSBlZF9ocGFfcmFuZ2UtPnN0YXJ0ICsgZHBhX29mZnNldDsNCj4gLSAg
ICAgICBjeGxfZHJfZXh0LT5ocGFfb2Zmc2V0ID0gaHBhIC0gY3hscl9kYXgtPmhwYV9yYW5nZS5z
dGFydDsNCj4gKyAgICAgICBjeGxfZHJfZXh0LT5ocGFfb2Zmc2V0ID0gY3hsX2RjX2V4dGVudF90
b19ocGFfb2Zmc2V0KGN4bGVkLCBleHRlbnQpOw0KPiANCj4gICAgICAgICAgLyogV2l0aG91dCBp
bnRlcmxlYXZlIGNhcnJ5IGxlbmd0aCBhbmQgbGFiZWwgdGhyb3VnaCAqLw0KPiAgICAgICAgICBj
eGxfZHJfZXh0LT5ocGFfbGVuZ3RoID0gZXh0ZW50LT5sZW5ndGg7DQo+IEBAIC0xNjI2LDYgKzE2
NzAsNyBAQCBzdGF0aWMgaW50IGN4bF9lZF9hZGRfb25lX2V4dGVudChzdHJ1Y3QgY3hsX2VuZHBv
aW50X2RlY29kZXIgKmN4bGVkLA0KPiAgICAgICAgICB9DQo+ICAgICAgICAgIC8qIFB1dCBpbiBj
eGxfZHJfcmVsZWFzZSgpICovDQo+ICAgICAgICAgIGN4bF9kY19leHRlbnRfZ2V0KGN4bF9kcl9l
eHQtPmV4dGVudCk7DQo+ICsgICAgICAgY3hsX3JlZ2lvbl9ub3RpZnlfZXh0ZW50KGN4bGVkLCBE
Q0RfQUREX0NBUEFDSVRZLCBjeGxfZHJfZXh0KTsNCj4gICAgICAgICAgcmV0dXJuIDA7DQo+ICAg
fQ0KPiANCj4gQEAgLTE2NjMsNiArMTcwOCw1OCBAQCBzdGF0aWMgaW50IGN4bF9lZF9hZGRfZXh0
ZW50cyhzdHJ1Y3QgY3hsX2VuZHBvaW50X2RlY29kZXIgKmN4bGVkKQ0KPiAgICAgICAgICByZXR1
cm4gMDsNCj4gICB9DQo+IA0KPiArc3RhdGljIGludCBjeGxfZWRfcm1fZGNfZXh0ZW50KHN0cnVj
dCBjeGxfZW5kcG9pbnRfZGVjb2RlciAqY3hsZWQsDQo+ICsgICAgICAgICAgICAgICAgICAgICAg
ICAgICAgICBlbnVtIGRjX2V2ZW50IGV2ZW50LA0KPiArICAgICAgICAgICAgICAgICAgICAgICAg
ICAgICAgc3RydWN0IGN4bF9kY19leHRlbnRfZGF0YSAqZXh0ZW50KQ0KPiArew0KPiArICAgICAg
IHN0cnVjdCBjeGxfcmVnaW9uICpjeGxyID0gY3hsZWQtPmN4bGQucmVnaW9uOw0KPiArICAgICAg
IHN0cnVjdCBjeGxfZGF4X3JlZ2lvbiAqY3hscl9kYXggPSBjeGxyLT5jeGxyX2RheDsNCj4gKyAg
ICAgICBzdHJ1Y3QgY3hsX2RyX2V4dGVudCAqY3hsX2RyX2V4dDsNCj4gKyAgICAgICByZXNvdXJj
ZV9zaXplX3QgaHBhX29mZnNldDsNCj4gKw0KPiArICAgICAgIGhwYV9vZmZzZXQgPSBjeGxfZGNf
ZXh0ZW50X3RvX2hwYV9vZmZzZXQoY3hsZWQsIGV4dGVudCk7DQo+ICsNCj4gKyAgICAgICAvKg0K
PiArICAgICAgICAqIE5PVEUgb24gSW50ZXJsZWF2aW5nOiBUaGVyZSBpcyBubyBuZWVkIHRvICdi
cmVhayB1cCcgdGhlIGN4bF9kcl9leHQuDQo+ICsgICAgICAgICogSWYgb25lIG9mIHRoZSBleHRl
bnRzIGNvbXByaXNpbmcgaXQgaXMgZ29uZSBpdCBzaG91bGQgYmUgcmVtb3ZlZA0KPiArICAgICAg
ICAqIGZyb20gdGhlIHJlZ2lvbiB0byBwcmV2ZW50IGZ1dHVyZSB1c2UuICBMYXRlciBjb2RlIG1h
eSBzYXZlIG90aGVyDQo+ICsgICAgICAgICogZXh0ZW50cyBmb3IgZnV0dXJlIHByb2Nlc3Npbmcu
ICBCdXQgZm9yIG5vdyB0aGUgY29yZWxhdGlvbiBpcyAxOjE6MQ0KPiArICAgICAgICAqIHNvIGp1
c3QgZXJhc2UgdGhlIGV4dGVudC4NCj4gKyAgICAgICAgKi8NCj4gKyAgICAgICBjeGxfZHJfZXh0
ID0geGFfZXJhc2UoJmN4bHJfZGF4LT5leHRlbnRzLCBocGFfb2Zmc2V0KTsNCj4gKw0KPiArICAg
ICAgIGRldl9kYmcoJmN4bHJfZGF4LT5kZXYsICJSZW1vdmUgREFYIHJlZ2lvbiBleHQgSFBBOiVs
bHhcbiIsDQo+ICsgICAgICAgICAgICAgICBjeGxfZHJfZXh0LT5ocGFfb2Zmc2V0KTsNCj4gKyAg
ICAgICBjeGxfcmVnaW9uX25vdGlmeV9leHRlbnQoY3hsZWQsIGV2ZW50LCBjeGxfZHJfZXh0KTsN
Cj4gKyAgICAgICBjeGxfZHJfZXh0ZW50X3B1dChjeGxfZHJfZXh0KTsNCj4gKyAgICAgICByZXR1
cm4gMDsNCj4gK30NCj4gKw0KPiAraW50IGN4bF9lZF9ub3RpZnlfZXh0ZW50KHN0cnVjdCBjeGxf
ZW5kcG9pbnRfZGVjb2RlciAqY3hsZWQsDQo+ICsgICAgICAgICAgICAgICAgICAgICAgICBzdHJ1
Y3QgY3hsX2Rydl9uZCAqbmQpDQo+ICt7DQo+ICsgICAgICAgaW50IHJjID0gMDsNCj4gKw0KPiAr
ICAgICAgIHN3aXRjaCAobmQtPmV2ZW50KSB7DQo+ICsgICAgICAgY2FzZSBEQ0RfQUREX0NBUEFD
SVRZOg0KPiArICAgICAgICAgICAgICAgaWYgKGN4bF9kY19leHRlbnRfZ2V0X25vdF96ZXJvKG5k
LT5leHRlbnQpKSB7DQo+ICsgICAgICAgICAgICAgICAgICAgICAgIHJjID0gY3hsX2VkX2FkZF9v
bmVfZXh0ZW50KGN4bGVkLCBuZC0+ZXh0ZW50KTsNCj4gKyAgICAgICAgICAgICAgICAgICAgICAg
aWYgKHJjKQ0KPiArICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN4bF9kY19leHRlbnRf
cHV0KG5kLT5leHRlbnQpOw0KDQpIaSwNCndoZW4gcGxheWluZyBhcm91bmQgd2l0aCBhZGRpbmcg
YW5kIHJlbGVhc2luZyBEQ0QgZXh0ZW50cyB0aHJvdWdoIHRoZSANCnFtcCBpbnRlcmZhY2UgZm9y
IHRoZSBRRU1VIERDRCBlbXVsYXRpb24sIEkgbm90aWNlZCB0aGF0IGV4dGVudHMgd2VyZW4ndCAN
CmhhbmRlZCBiYWNrIHRvIHRoZSBkZXZpY2UuIEl0IGxvb2tzIGxpa2UgdGhlcmUgaXMgYSByZWZj
b3VudGluZyBpc3N1ZSwgDQphcyB0aGUga3JlZiBuZXZlciBkcm9wcyBiZWxvdyAyIGZvciB0aGUg
ZGMgZXh0ZW50cy4gU28gSSB3YXMgd29uZGVyaW5nIA0Kd2hldGhlciB3ZSBzaG91bGQgb25seSBw
dXQgdGhlIGRjIGV4dGVudCBoZXJlIG9uIGVycm9yIG9yIG1heWJlIGFsd2F5cyANCnB1dCBpdD8g
IGN4bF9lZF9hZGRfb25lX2V4dGVudCgpIGFsc28gZ3JhYnMgYSByZWZlcmVuY2UgdG8gdGhlIGRj
IA0KZXh0ZW50LCBhbmQgdGhhdCBvbmUgaXMgcHV0IGluIGN4bF9kcl9yZWxlYXNlKCksIGJ1dCBJ
IGNvdWxkbid0IGZpbmQgYSANCm1hdGNoaW5nIHB1dCBmb3IgdGhpcyBnZXRfbm90X3plcm8uDQoN
Cg0KPiArICAgICAgICAgICAgICAgfQ0KPiArICAgICAgICAgICAgICAgYnJlYWs7DQo+ICsgICAg
ICAgY2FzZSBEQ0RfUkVMRUFTRV9DQVBBQ0lUWToNCj4gKyAgICAgICBjYXNlIERDRF9GT1JDRURf
Q0FQQUNJVFlfUkVMRUFTRToNCj4gKyAgICAgICAgICAgICAgIHJjID0gY3hsX2VkX3JtX2RjX2V4
dGVudChjeGxlZCwgbmQtPmV2ZW50LCBuZC0+ZXh0ZW50KTsNCj4gKyAgICAgICAgICAgICAgIGJy
ZWFrOw0KPiArICAgICAgIGRlZmF1bHQ6DQo+ICsgICAgICAgICAgICAgICBkZXZfZXJyKCZjeGxl
ZC0+Y3hsZC5kZXYsICJVbmtub3duIERDIGV2ZW50ICVkXG4iLCBuZC0+ZXZlbnQpOw0KPiArICAg
ICAgICAgICAgICAgYnJlYWs7DQo+ICsgICAgICAgfQ0KPiArICAgICAgIHJldHVybiByYzsNCj4g
K30NCj4gK0VYUE9SVF9TWU1CT0xfTlNfR1BMKGN4bF9lZF9ub3RpZnlfZXh0ZW50LCBDWEwpOw0K
PiArDQo+ICAgc3RhdGljIGludCBjeGxfcmVnaW9uX2F0dGFjaF9wb3NpdGlvbihzdHJ1Y3QgY3hs
X3JlZ2lvbiAqY3hsciwNCj4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg
c3RydWN0IGN4bF9yb290X2RlY29kZXIgKmN4bHJkLA0KPiAgICAgICAgICAgICAgICAgICAgICAg
ICAgICAgICAgICAgICAgICBzdHJ1Y3QgY3hsX2VuZHBvaW50X2RlY29kZXIgKmN4bGVkLA0KDQpb
c25pcF0NCg0KPiANCj4gLS0NCj4gMi40MS4wDQo+IA0KDQpUaGFua3MsDQpKb3JnZW4=

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 42E1ACA0EC3
	for <linux-cxl@archiver.kernel.org>; Tue, 12 Sep 2023 02:21:35 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S237363AbjILCVg (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Mon, 11 Sep 2023 22:21:36 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:51716 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S237760AbjILCVY (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Mon, 11 Sep 2023 22:21:24 -0400
Received: from mgamail.intel.com (mgamail.intel.com [134.134.136.20])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 2DC2216830;
        Mon, 11 Sep 2023 18:45:06 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1694483106; x=1726019106;
  h=date:from:to:cc:subject:message-id:references:
   in-reply-to:mime-version;
  bh=7Bdw7+/vyabcvYfUj0VaxIDPDVy1P0gvVH+wu4+Gt4U=;
  b=W2qDmvHT7WgYpGAc/B1es0HcnVaQX6CCd80syTf4eamYdbe8KbHwkQ/D
   LzHUTav1YOuqvnCeenNLN5bkWflxLZxZ1GFvN8UqJaPSAzb44MXVsx/oq
   qfnmVLcOcVureaavSdbawoviVNpl9MYt/LpBZpp2/vnaQUJm2mYRAB9nE
   lY2YMIDwr48KIIP5fYr7aTzuFHOmO3EYmtqpRCyao5hH9nlYNDB/HMoFe
   aTM0gCfo0mNrN+sA9J7IwUOVJI+7o0bh3Ojeyy3B8msLaTaJ4L/M2PICM
   Uou2NCtF4ZhF9WF5ECaA8yk0h4ZCUoZRTIIoOCrkZSzLFOYlp1RlvTHOx
   g==;
X-IronPort-AV: E=McAfee;i="6600,9927,10830"; a="368506449"
X-IronPort-AV: E=Sophos;i="6.02,244,1688454000"; 
   d="scan'208";a="368506449"
Received: from fmsmga001.fm.intel.com ([10.253.24.23])
  by orsmga101.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 11 Sep 2023 18:45:05 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10830"; a="886757231"
X-IronPort-AV: E=Sophos;i="6.02,244,1688454000"; 
   d="scan'208";a="886757231"
Received: from fmsmsx601.amr.corp.intel.com ([10.18.126.81])
  by fmsmga001.fm.intel.com with ESMTP/TLS/AES256-GCM-SHA384; 11 Sep 2023 18:44:39 -0700
Received: from fmsmsx611.amr.corp.intel.com (10.18.126.91) by
 fmsmsx601.amr.corp.intel.com (10.18.126.81) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.32; Mon, 11 Sep 2023 18:45:04 -0700
Received: from fmsmsx601.amr.corp.intel.com (10.18.126.81) by
 fmsmsx611.amr.corp.intel.com (10.18.126.91) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.32; Mon, 11 Sep 2023 18:45:04 -0700
Received: from fmsedg601.ED.cps.intel.com (10.1.192.135) by
 fmsmsx601.amr.corp.intel.com (10.18.126.81) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.32 via Frontend Transport; Mon, 11 Sep 2023 18:45:04 -0700
Received: from NAM04-BN8-obe.outbound.protection.outlook.com (104.47.74.42) by
 edgegateway.intel.com (192.55.55.70) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.32; Mon, 11 Sep 2023 18:45:03 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=YVGGHsGE7W3fOXVf5fmTyIQTgIwoP6vT9UKK8fK1fRhZKq56k/2+tkBu4f7lhM+NOj/0oKz8CE4ULVU3dPRXLj94w4j+e8+qsQuUNOrl3KtYIClzxaYUGkTrq4knwkrt1q0rwVLLYHiPdhnIidgYNVi5LNlALbxk9KE8QyPp0JWAzEsdcpo9mu+hx+SeRWs8od59zOcVFc9MUgp7/56VqSHO1PVKERjsMWcO1Db7dQFrgd2l4X6+clsU5S3aWGBgVd3RZKwa83ClJybbSM5AJWJWPvFKjq8yWnV9f1pDopKRPhQ4972SSmCW3y3vnCv4a5GEH8oiolhcRgYkFcPHmA==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=HGdK2ebuL5FrckhY1dnI/RRB6/jqNQWLc63xpcagvFY=;
 b=FHwYisqyyJLdeWoihwlW3Voib4+Vv+iGkzqc5Ta/UUz1dTD4fBtcoDly1mPAHIFmSeg+qPb2VVOfgHg7gJCBr4YwLmI/c9YqX6XrraDITf6XCNrvJwwfEVPRVuh4tebdes1eB7CygqKZbUDazQo6jmbBpzXuVqwWsPEoQeF4K4fqFNx0bHc2/lmeBBVuXp+4ji09r1ErT27an8WQpbRf32taNe/i20PQLs0QE771s3XkNAdXj6OlXazlJFtr8gro7/r2dI9OLSCBC5hsM1eux463PDeMF6APqcncuo4ICj45/DRJ0q7/9JaOjL909nR8wf3y+t8HhKzFvrrd0SvUhA==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from SA1PR11MB6733.namprd11.prod.outlook.com (2603:10b6:806:25c::17)
 by PH7PR11MB6426.namprd11.prod.outlook.com (2603:10b6:510:1f6::12) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.6768.30; Tue, 12 Sep
 2023 01:45:01 +0000
Received: from SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938]) by SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938%6]) with mapi id 15.20.6768.029; Tue, 12 Sep 2023
 01:45:01 +0000
Date: Mon, 11 Sep 2023 18:44:56 -0700
From: Ira Weiny <ira.weiny@intel.com>
To: Fan Ni <fan.ni@gmx.us>, Ira Weiny <ira.weiny@intel.com>
CC: Dan Williams <dan.j.williams@intel.com>,
        Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        "Dave Jiang" <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>,
        <a.manzanares@samsung.com>, <nmtadam.samsung@gmail.com>,
        <nifan@outlook.com>
Subject: Re: [PATCH RFC v2 00/18] DCD: Add support for Dynamic Capacity
 Devices (DCD)
Message-ID: <64ffc298707ae_2f5aa3294df@iweiny-mobl.notmuch>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
 <ZPo6J3OsmD7YbYJs@debian>
Content-Type: text/plain; charset="us-ascii"
Content-Disposition: inline
In-Reply-To: <ZPo6J3OsmD7YbYJs@debian>
X-ClientProxiedBy: BYAPR08CA0045.namprd08.prod.outlook.com
 (2603:10b6:a03:117::22) To SA1PR11MB6733.namprd11.prod.outlook.com
 (2603:10b6:806:25c::17)
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: SA1PR11MB6733:EE_|PH7PR11MB6426:EE_
X-MS-Office365-Filtering-Correlation-Id: a641aacf-00e8-418f-5d11-08dbb331e0a9
X-LD-Processed: 46c98d88-e344-4ed4-8496-4ed7712e255d,ExtAddr
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;
X-Microsoft-Antispam-Message-Info: sGboGWAPheBrTEQN8h+K2VKnOvlWXVGe/Ew09vJTQssVj4nZ0extu6ix9r7cArZs8DO1hTJ4o1DK1jj15ybfdAoywOflZ4TeXhzUXgdzt/0LR8PMny1v534ztBAyZWagTWk7n3YFEl72dQnjRxt/XOVIVzWGGHwGpAg6sQokGpUrBPDpg+DNoZYyq4j8xzJUiAbPefR9gq0wNq4vq0S89mZZWJbpKkKP2RxgiGPXUOIofgFiU/OpbUlLITtponi9h3i/fF9Fcv8I88ZRJGVKuSws2bKQ0nIyx+qDJ51IezCMQBaOwEdZeBAA0Fdoom6EoGIjMcfLy+XjASu2F5pGUh9IZd9d2xzX+w8VDUjfuW+1O6K5ebm2HJZ/ko30Gln99PRHoQqi6U/bHuywT37p8naTt3krvE1UUCIBYMsID1c9mR/4We1kzh4o5M192uYtCk3RB9G0KWbWO/jEG1GHrXrqrBICxLLzKo45Agduq3LkuBhG/rPkKZBErrg5wLybI5+v+6v/0N3tPGU0D6iwawDvqD7jz8ITz6ssSxUJZOM=
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:SA1PR11MB6733.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230031)(396003)(39860400002)(346002)(136003)(376002)(366004)(1800799009)(186009)(451199024)(6486002)(6666004)(6506007)(110136005)(8676002)(478600001)(86362001)(82960400001)(38100700002)(6512007)(2906002)(966005)(9686003)(83380400001)(8936002)(66476007)(4326008)(316002)(41300700001)(44832011)(5660300002)(54906003)(66946007)(66556008);DIR:OUT;SFP:1102;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?us-ascii?Q?QcDncTLLU8N6NeIfobGO6eDg/g334xKqHK3xhkYapPp/5CH8NfQpBwkxoaQA?=
 =?us-ascii?Q?zgGmI2wlkh166HQCZzNOyqCoztkCnbCDtZi4xFAOItiK9ZW70sy8mh2lp7xL?=
 =?us-ascii?Q?BXQTPtGBbdcSmTmj0YPdEStf79Cz/ghCUK+O6CvrU4H4UfZFdIeIPEuwawct?=
 =?us-ascii?Q?tW18lX1zXWNC42bcAem045bkSBwcyOV5CgrWnvOqRb4O/fVdS2RV26PuLHpr?=
 =?us-ascii?Q?SCP2zFw9xXsp2NOyWREvasZHd2HGofZnyN04+5PDzUN8iRua1R+bb30ShasL?=
 =?us-ascii?Q?IRNQiy17z9lRmN8Ijl9DgzAZWVAB24wod/uclZwtXGjtLuprgN54P857aQgv?=
 =?us-ascii?Q?txlBJyFHAS6V1E4RJ6AYwpBbddMP8k86eoi8BY6XYiw5Ya56XW3wG9WTI+ty?=
 =?us-ascii?Q?++xfb63Ibp8ran85cqooFGnNq8giyP21SRoeLQ5dfNUEX33yUfgh7XKbxcb6?=
 =?us-ascii?Q?5evpSKQa/2ZfFd1XIvVSEMUjAz5gyD3GNn8c0sCzgWNRHNheR+LFSEnhcCTv?=
 =?us-ascii?Q?NjqjtHGxBWZhuOfB0di0YvimPF3wUD4n6rj3wf/w2gZENumtVeiWsZJEOlYD?=
 =?us-ascii?Q?TgVWjylBcpexLbSe4GlRSuUrjXvu9eRJf+BFlLOwIeT5dQIINJqMdvB88Pb+?=
 =?us-ascii?Q?PaHAXbUcQo/v1ij7th1ir3/VM8CXEsqDrcviNasYNW5yrlzzJy+LsUkNdbcu?=
 =?us-ascii?Q?lExqMbYk3T6b5cr1f5YYglZUwA8WiqmKP+0tHoXPmPFdpIwzlZ+qOxUrCZOE?=
 =?us-ascii?Q?ACPIkhjLDKDq6dXKKqT4hE84wprfE9vQ0/FzzUEcXUrMyudx1dNlgLW5exBd?=
 =?us-ascii?Q?FKMrwqArA/rIMUVmFgmhsDLBjZBS3XsVxteGHfEFAhHELDM2s6eIcFXF0rU3?=
 =?us-ascii?Q?pHZq+inttBhh+8hN8SAmgcYPX30/5CzVJh7rMHacMs7tHG/UlX1ajDAZBGyo?=
 =?us-ascii?Q?EB+/o4J8Z2B6Z1GKY/yJoDsmh9tuoONlwaQe1UhpJwM4oQr9C0uPydsPnNk0?=
 =?us-ascii?Q?S4yl5u7Y6dePZF8ei5ieARyaQmlFVecsWqr69hjZmZdzCpw0NDdHdl7QByd1?=
 =?us-ascii?Q?tntzS+x2eAVnCBXbTtSM8//8fW4Lae1U/KSZwH5cayPRs3nFsDykl8RMPaRp?=
 =?us-ascii?Q?8OMcffExTWDga0mAqim9NS6UiWMhet6TEbWnV9AmvgvTPrB+RxEHTEKardNX?=
 =?us-ascii?Q?UDf9AZGayVQvM9yao3UINGP58YJo3HHhWT4FvlPN3TKGgoSuEBtnEVGBXap/?=
 =?us-ascii?Q?9j9Mf6RcYano8LOFNhUJX0VP4YMynCfU2jqamT7HcDclpETGhbU5VkCdmQiY?=
 =?us-ascii?Q?l3iNKOa2oWIKxStypMeR+a82MuiKNAViAZY8XHvAQ3H9D4m549/KWXJz/w03?=
 =?us-ascii?Q?SyTY8cZac5/be/gBeYi0FQwLjGZMNZQXPKeAk9ncx/rINitzIGmnux/NmKV4?=
 =?us-ascii?Q?TZ+AwleomY+rZ5SOs06C+yjkpLvyZewPMSX+otea7ITTqiNmhRs8D7nwhUu3?=
 =?us-ascii?Q?Odb+4rQu8zTf/NHXB34mffUVz/3f8o0mwwFwE5m/GIvqzd8WnFE70RPST5lX?=
 =?us-ascii?Q?yFncO4VbrX9cWhnWP1gFP/D5US9+iWDS7P8oAhu8pOR5GQ4zstWX9AZYEzBp?=
 =?us-ascii?Q?SfAWM2394014xXSSSidamX7H89QFQl3vw5np1ImiGYgb?=
X-MS-Exchange-CrossTenant-Network-Message-Id: a641aacf-00e8-418f-5d11-08dbb331e0a9
X-MS-Exchange-CrossTenant-AuthSource: SA1PR11MB6733.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 12 Sep 2023 01:45:01.1109
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: l8SV6DhI6staqkkPpfDhmNHBvAczqULP1UmJxuramWiaAKx6wAX+abJGR/ZrX57pqi4CgXT6/PyWzWlpHEiNjg==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: PH7PR11MB6426
X-OriginatorOrg: intel.com
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

Fan Ni wrote:
> On Mon, Aug 28, 2023 at 10:20:51PM -0700, Ira Weiny wrote:

Sorry for the delay, I've been walking through the responses and just saw
this.

> 
> Hi Ira,
> 
> I tried to test the patch series with the qemu dcd patches, however, I
> hit some issues, and would like to check the following with you.
> 
> 1. After we create a region for DC before any extents are added, a dax
> device will show under /dev. Is that what we want?

Yes, see

cxl/region: Add Dynamic Capacity CXL region support

	"Special case DC capable CXL regions to create a 0 sized seed DAX
	device until others can be created on dynamic space later."

The seed device is required but is left empty.  It can be resized when
extents are added later.

> If I remember it
> correctly, the dax device used to show up after a dc extent is added.
> 
> 
> 2. add/release extent does not work correctly for me. The code path is
> not called, and I made the following changes to make it pass.

:-(

This is the problem with cxl_test...  I've just realized this after seeing
Jorgen's email regarding the interrupt configuration code.  I've added it
back in.  I'm not sure where it got lost along the way but it was
completely gone from this RFC v2.  Sorry about that.

> ---
>  drivers/cxl/cxl.h    | 3 ++-
>  drivers/cxl/cxlmem.h | 1 +
>  drivers/cxl/pci.c    | 7 +++++++
>  3 files changed, 10 insertions(+), 1 deletion(-)
> 
> diff --git a/drivers/cxl/cxl.h b/drivers/cxl/cxl.h
> index 2c73a30980b6..0d132c1739ce 100644
> --- a/drivers/cxl/cxl.h
> +++ b/drivers/cxl/cxl.h
> @@ -168,7 +168,8 @@ static inline int ways_to_eiw(unsigned int ways, u8 *eiw)
>  #define CXLDEV_EVENT_STATUS_ALL (CXLDEV_EVENT_STATUS_INFO |	\
>  				 CXLDEV_EVENT_STATUS_WARN |	\
>  				 CXLDEV_EVENT_STATUS_FAIL |	\
> -				 CXLDEV_EVENT_STATUS_FATAL)
> +				 CXLDEV_EVENT_STATUS_FATAL| \
> +				 CXLDEV_EVENT_STATUS_DCD)
> 
>  /* CXL rev 3.0 section 8.2.9.2.4; Table 8-52 */
>  #define CXLDEV_EVENT_INT_MODE_MASK	GENMASK(1, 0)
> diff --git a/drivers/cxl/cxlmem.h b/drivers/cxl/cxlmem.h
> index 8ca81fd067c2..ae9dcb291c75 100644
> --- a/drivers/cxl/cxlmem.h
> +++ b/drivers/cxl/cxlmem.h
> @@ -235,6 +235,7 @@ struct cxl_event_interrupt_policy {
>  	u8 warn_settings;
>  	u8 failure_settings;
>  	u8 fatal_settings;
> +	u8 dyncap_settings;
>  } __packed;
> 
>  /**
> diff --git a/drivers/cxl/pci.c b/drivers/cxl/pci.c
> index 10c1a583113c..e30fe0304514 100644
> --- a/drivers/cxl/pci.c
> +++ b/drivers/cxl/pci.c
> @@ -686,6 +686,7 @@ static int cxl_event_config_msgnums(struct cxl_memdev_state *mds,
>  		.warn_settings = CXL_INT_MSI_MSIX,
>  		.failure_settings = CXL_INT_MSI_MSIX,
>  		.fatal_settings = CXL_INT_MSI_MSIX,
> +		.dyncap_settings = CXL_INT_MSI_MSIX,
>  	};
> 
>  	mbox_cmd = (struct cxl_mbox_cmd) {
> @@ -739,6 +740,12 @@ static int cxl_event_irqsetup(struct cxl_memdev_state *mds)
>  		return rc;
>  	}
> 
> +	rc = cxl_event_req_irq(cxlds, policy.dyncap_settings);
> +	if (rc) {
> +		dev_err(cxlds->dev, "Failed to get interrupt for event dyncap log\n");
> +		return rc;
> +	}
> +
>  	return 0;
>  }
> 
> --
> 
> 3. With changes made in 2, the code for add/release dc extent can be called,
> however, the system behaviour seems different from before. Previously, after a
> dc extent is added, it will show up with lsmem command and listed as offline.
> Now, nothing is showing. Is it expected? What should we do to make it usable
> as system ram?

Yes this behavior was not correct before.  DAX devices should be flexible
to be created throughout the region.  Either within extents or across
extents.  Dave Jiang mentioned to me internally it might help to add some
ASCII art documentation regarding how this works.  Generally, the dax
region available size will increase when extents are added and new dax
devices can be created to utilize that space.

Check out the dcd-test.sh in ndctl at this link for the commands to create
a dax device in the new architecture.

https://github.com/weiny2/ndctl/tree/dcd-region2

Hope this helps.

> 
> Please let me know if I miss something or did something wrong. Thanks.

You did not.  I thought the new dax code would explain this new dax device
operation.

Some new documentation is in order.

Ira

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 2427BCA0EC3
	for <linux-cxl@archiver.kernel.org>; Tue, 12 Sep 2023 01:43:28 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S235880AbjILBn3 (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Mon, 11 Sep 2023 21:43:29 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:35838 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S235737AbjILBnL (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Mon, 11 Sep 2023 21:43:11 -0400
Received: from mgamail.intel.com (mgamail.intel.com [192.55.52.93])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 69C0611EBD0;
        Mon, 11 Sep 2023 18:19:43 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1694481583; x=1726017583;
  h=date:from:to:cc:subject:message-id:references:
   in-reply-to:mime-version;
  bh=BExOGv6tQSpQyfviRa02jiawODdESxLM3oo1hwYhE7U=;
  b=lDCGkOOCVE4jYUVfBAvLxy4XK5okUfWVtfQCuLiXd9WRXqPrvIjDdBmc
   2PtH91aiAVUxa7yk8rJUoyoynl177hWZRnpwiMGkzw/jKqK+Hxwpe+2ZP
   xfqhCiY71H+xDzKRNUct0oEVbLbs3yQmfjKlvg9F9p1I/i2YjqLUwcaZe
   sUfanUmxBkBFreo92lHK4WxJh3ZSSAo6bwWxW6lK0oIBNHt9RXoCm+LOL
   J3KbTcwPVbT8FSGEgZYNgLEvxtR+fpYaFXOlQbZBtYj5FVzwaao8o0pzE
   0zmsL+Q/O+9AUViKc73y7RO4QnvWZCDjD0BR1KUahxtmHBk2R58AcMgXx
   Q==;
X-IronPort-AV: E=McAfee;i="6600,9927,10830"; a="375581938"
X-IronPort-AV: E=Sophos;i="6.02,244,1688454000"; 
   d="scan'208";a="375581938"
Received: from orsmga007.jf.intel.com ([10.7.209.58])
  by fmsmga102.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 11 Sep 2023 18:19:42 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10830"; a="736951717"
X-IronPort-AV: E=Sophos;i="6.02,244,1688454000"; 
   d="scan'208";a="736951717"
Received: from fmsmsx602.amr.corp.intel.com ([10.18.126.82])
  by orsmga007.jf.intel.com with ESMTP/TLS/AES256-GCM-SHA384; 11 Sep 2023 18:19:42 -0700
Received: from fmsmsx611.amr.corp.intel.com (10.18.126.91) by
 fmsmsx602.amr.corp.intel.com (10.18.126.82) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.32; Mon, 11 Sep 2023 18:19:41 -0700
Received: from fmsmsx611.amr.corp.intel.com (10.18.126.91) by
 fmsmsx611.amr.corp.intel.com (10.18.126.91) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.32; Mon, 11 Sep 2023 18:19:41 -0700
Received: from fmsedg601.ED.cps.intel.com (10.1.192.135) by
 fmsmsx611.amr.corp.intel.com (10.18.126.91) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.32 via Frontend Transport; Mon, 11 Sep 2023 18:19:41 -0700
Received: from NAM12-BN8-obe.outbound.protection.outlook.com (104.47.55.170)
 by edgegateway.intel.com (192.55.55.70) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.32; Mon, 11 Sep 2023 18:19:40 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=CPlc/04hDWeXioeUDTrPoDMKlO3lZKz4qPACPASZkqnFTQdnpSy23ZS/graoH/a3QK4V7ln40PnWftKncQK0uPayAhoVJwV3Cw6yDkDABkCDFfMC4JgiDcA8nmZosFuOWMm7i/C+r5WGMUeKkFLOjY32v8PGQORXelETDZxEu7b/VxkIXMpLmFe14iReLoXA203hdRdbQMUWi3L1gD4BNppkesbyrZbYm71xGfR967uy2kelZViwmgAEhjEpzFr9O5Gg0qbtcnLmDCllmoy+q/N9Crj/lYenwRbKAQgYv/gDifAnfqSg8SFS0eGBh3Rz287OeD3zcY93AqE6Kpy2sg==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=2bSe2jBZI3oq7pIvDuYH0vUYUID1i/Mr+iDojvDy3oY=;
 b=XmklqWuJPdtgqjGu9QYxFHVQ2vImoN4AHUtFgQcAeW3mddDVa+vYd4+CHDrWRZxZonBal9AkoNScNgnh78/hsDah31fktcZ/mM01aufePJt31uhVnnWvuMq/x+p1ixAwp8z2Q6CchiKjVG07YOAIOkzYqDAJiz64rg2xXUZ356q9UJpEnmtcTjt93UDCBbpKRkgdOjezt14F4DcQ8PCYBahCck5ytLtmWLjGoUTTmzkW5br/gWEoirGDKFhrRs5niBzBMkDXbM0Jf/7T/4ioAiHh4ZPB/7xxl9ujCE5UDVR60Crz6As8n8x6yWjkmHzs7QcyTnFgs9/l0H1r5gOfPA==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from SA1PR11MB6733.namprd11.prod.outlook.com (2603:10b6:806:25c::17)
 by PH7PR11MB7478.namprd11.prod.outlook.com (2603:10b6:510:269::11) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.6768.30; Tue, 12 Sep
 2023 01:19:38 +0000
Received: from SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938]) by SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938%6]) with mapi id 15.20.6768.029; Tue, 12 Sep 2023
 01:19:38 +0000
Date: Mon, 11 Sep 2023 18:18:37 -0700
From: Ira Weiny <ira.weiny@intel.com>
To: Alison Schofield <alison.schofield@intel.com>,
        <ira.weiny@intel.com>
CC: Dan Williams <dan.j.williams@intel.com>,
        Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        "Dave Jiang" <dave.jiang@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
Subject: Re: [PATCH RFC v2 03/18] cxl/mem: Read Dynamic capacity
 configuration from the device
Message-ID: <64ffbc6d449db_2f5aa329489@iweiny-mobl.notmuch>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
 <20230604-dcd-type2-upstream-v2-3-f740c47e7916@intel.com>
 <ZPnwPDZrKYT7hp6X@aschofie-mobl2>
Content-Type: text/plain; charset="us-ascii"
Content-Disposition: inline
In-Reply-To: <ZPnwPDZrKYT7hp6X@aschofie-mobl2>
X-ClientProxiedBy: SJ0PR03CA0136.namprd03.prod.outlook.com
 (2603:10b6:a03:33c::21) To SA1PR11MB6733.namprd11.prod.outlook.com
 (2603:10b6:806:25c::17)
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: SA1PR11MB6733:EE_|PH7PR11MB7478:EE_
X-MS-Office365-Filtering-Correlation-Id: 437b3bc3-d44f-4732-1b78-08dbb32e5368
X-LD-Processed: 46c98d88-e344-4ed4-8496-4ed7712e255d,ExtAddr
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;
X-Microsoft-Antispam-Message-Info: 5DoLcr2eC0ky9eYkS1bzoxI8uuWDIlBEQd/CtWBq33NV9rdw92yb2YPq809L3X5EAR/D/5JEL0qx7UCEtTxWPiE2FtLCX+4eIa5UOQ/GIMLMjkwEX91v4nnV4sQVWRug7b/xbpAegs6o2ZoKBGPg0UvRHRRwiyLXO3kF8bG085D27GFagW1/kDAimtUagKlHnWIT2sqbJP4Zt/rnVvisHas4lsfJjLY8NTB2aI0KL5b4M3WLKlRzLF8Le2vbklUxq05zpsAsGFv5UyrwQD6g+DVfFMlkuEYxjwEsb0XuuQ/3jmVFGhiC6qfYkuJYjB28VLOVz+FSPKivBJfv5YPTZOSZklkE8jsVX1iXiNgpgqu+02IlAGsNAOjAGTs/z2DjGh8XUQgngt0CzM/bpF/3jskMWbk6GYpSo0GzSzzlc9OrptqFx4mzfPenbuJ1JsLgLD+kbYGkwJ4Q9z6EXTitv6HBHOfM3sinnyxsTg56jc7d6Lpu8Fgloca+l5UtOed0ZQTiQ96x44EpEOhNKueSzegK9YdVaCvSGV7q9rQ2CAbzup8fbaQ1LZO5GfGrpVCI
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:SA1PR11MB6733.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230031)(396003)(346002)(39860400002)(366004)(376002)(136003)(1800799009)(186009)(451199024)(6486002)(6506007)(41300700001)(316002)(478600001)(2906002)(86362001)(38100700002)(54906003)(66556008)(82960400001)(66946007)(66476007)(5660300002)(8936002)(8676002)(4326008)(44832011)(6512007)(9686003);DIR:OUT;SFP:1102;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?us-ascii?Q?4ksMjL2U7wH4uMXTelkWlLmHCqWugQzFcBBEK0zhHMwtWKR1HHjQLbQc9HyW?=
 =?us-ascii?Q?nYTK8bXmaV8m/dVzQlmjykJ/uM9PMtczv61wCPDTbwEfJTZBhqOZPwhEduDY?=
 =?us-ascii?Q?jLhANbQoditau2UlZi6sjl746xUY9YsBAOHK9wYa+Tt7unlt272SFlOZeQtK?=
 =?us-ascii?Q?VsxuCXt3n3dw1V9flz9yr0KCUBmoIPnDmb6iGUDiv92WbnmJ9OjeBTWLfH6W?=
 =?us-ascii?Q?4wwUJe491DyKX8cDiecxPYbvCsPWaaRcELD0TIGlqGca+4WajYLD2zYNcQfo?=
 =?us-ascii?Q?hUDflWo6b2IfKStgQe4yJK1KnwkuXC/qe9+TA9Ida4GGjvsS9do7cQsC2Y7E?=
 =?us-ascii?Q?UReC4PhP3YaM591M5NZ2aUCge76zKt4rGISr0tTPK+IIyKfR0QhA6aGjLzFg?=
 =?us-ascii?Q?wepN56WK6o5J7QAzDc8ksOgo6aH7/nGL94AFBhJTjax+8RSSRAf9Zb2zMuaz?=
 =?us-ascii?Q?O9rX1MF3Y5IVr4eQrSAC8swZBsYP9m8uIhUMjzYhW06zL84FEGie0EWjB1Ej?=
 =?us-ascii?Q?TE/g0ktpXSezkPS7GwSzvG7Xmhk8FvrlmrIKhp9FsDm7kgNPxrPrjoYg/x9i?=
 =?us-ascii?Q?CJZhMF0gp8C2YGsVI/XSILs2atzAPK2C6k2l1Rfa+slGMsEURGbXQTdiyE5a?=
 =?us-ascii?Q?/y8tDTXBJM5YCdFMcR99+SrA6h6mIrcFhM1fi0Bj910jy405N0FKBGUABpJw?=
 =?us-ascii?Q?cK+7rbQQi/SzgolLcPvgFv3qUfoDD2WV9L9hjtSKJ5oTSRmt+uutjRhZ2RSt?=
 =?us-ascii?Q?W6zuMN7cTNbeZXNfiOufeQDeuICiZaPWx8cnxXCBCG6NQ7Xvp3syYYUetK+4?=
 =?us-ascii?Q?4b1p6ik+l+p8ygzYSSH5aPum0JdOV9CSWd/oBU0NxYuk2EJvsqPUtzGEIrvx?=
 =?us-ascii?Q?QijJiQGtld9KuyGYcgGzH2PPuHu5u4t+shioutjJ0FihbxZGWDK6h7A2nknO?=
 =?us-ascii?Q?OirSaX5iT4wsOYjDJ46i1a9dY8vin451dyWiVz/DjwIhiy0kbk/KrVE+oFof?=
 =?us-ascii?Q?3VQGcSZ4g8Nw7TBYFv7U2ifZKD41SU/t0yrcyEX//OLhMfm3xRSRU76C4rK/?=
 =?us-ascii?Q?62kXCxhMQLJrJYz/YhqLrZNVUmRkAYLVHqyaBg4+Z834AfG2bA+op1JTDHwL?=
 =?us-ascii?Q?XlswuPC2rbVrGvdAW1oZuvV5nJwj17tQ4zn3GYIayHlYJZopmbe3EUbWok+5?=
 =?us-ascii?Q?83VTu13yTf9ySMzpNb2QMqV7msq6+dZrqz20HXUhOBKYgNL0+TQrATUP6aBr?=
 =?us-ascii?Q?Vdp/WZHxgZkdzKLp1ywlfu4nTsdS7kIDKkV/U6oFJTDpbch7u1MeioG9KZwx?=
 =?us-ascii?Q?09x/XO9qMsr6asBzruo/2+p/cCsRUPy2XATOGaEM9G5+6Jbc0J31EIIRD5Sh?=
 =?us-ascii?Q?F4Dy+wg2BdNKSWVg/CDWJ+T7NdsatS97/X2Xs0hYPIF+ZpSR07ZzwJhmYcH4?=
 =?us-ascii?Q?zZROAk0whV2XcuJfYOu+xu4ZU7kEyrTLCY5GKx9imC+dQ6pjRZPNrPFBFTxy?=
 =?us-ascii?Q?2FcSpgaCw166oEUFk+gG9MBuk8dFEAGGR82Co/dvZa+ejO3M/eTln5HiFZJy?=
 =?us-ascii?Q?HxC118W4xZZtb2V6SssVavBombd1tQCjtER8eLWtT6qybT5MKtdgwWqL6Vv+?=
 =?us-ascii?Q?MalwNATvbYWEBbJoxl8yg40Xz35TfwV7S3EAlwK0kJZK?=
X-MS-Exchange-CrossTenant-Network-Message-Id: 437b3bc3-d44f-4732-1b78-08dbb32e5368
X-MS-Exchange-CrossTenant-AuthSource: SA1PR11MB6733.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 12 Sep 2023 01:19:38.5784
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: oqPP0cu52mUH8io5nPuDFSUsQc72RpU8iYbf4jygwHtOVOaaV/Ck2CWL7P44ClSskW2IPad/qSmihFlIIZ1deg==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: PH7PR11MB7478
X-OriginatorOrg: intel.com
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

Alison Schofield wrote:
> On Mon, Aug 28, 2023 at 10:20:54PM -0700, Ira Weiny wrote:
> > From: Navneet Singh <navneet.singh@intel.com>
> > 
> > Devices can optionally support Dynamic Capacity (DC).  These devices are
> > known as Dynamic Capacity Devices (DCD).
> 
> snip
> 
> > 
> > +static enum cxl_region_mode
> > +cxl_decoder_to_region_mode(enum cxl_decoder_mode mode)
> > +{
> > +	switch (mode) {
> > +	case CXL_DECODER_NONE:
> > +		return CXL_REGION_NONE;
> > +	case CXL_DECODER_RAM:
> > +		return CXL_REGION_RAM;
> > +	case CXL_DECODER_PMEM:
> > +		return CXL_REGION_PMEM;
> > +	case CXL_DECODER_DEAD:
> > +		return CXL_REGION_DEAD;
> > +	case CXL_DECODER_MIXED:
> > +	default:
> > +		return CXL_REGION_MIXED;
> > +	}
> > +
> > +	return CXL_REGION_MIXED;
> 
> Can the paths to return _MIXED be simplified here?

I suppose:

...
	case CXL_DECODER_MIXED:
	default:
		break;
	}
	
	return CXL_REGION_MIXED;
...

I don't think that makes things any better.

> 
> 
> > +}
> > +
> snip
> 
> > diff --git a/drivers/cxl/cxl.h b/drivers/cxl/cxl.h
> > index cd4a9ffdacc7..ed282dcd5cf5 100644
> > --- a/drivers/cxl/cxl.h
> > +++ b/drivers/cxl/cxl.h
> > @@ -374,6 +374,28 @@ static inline const char *cxl_decoder_mode_name(enum cxl_decoder_mode mode)
> >  	return "mixed";
> >  }
> >  
> > +enum cxl_region_mode {
> > +	CXL_REGION_NONE,
> > +	CXL_REGION_RAM,
> > +	CXL_REGION_PMEM,
> > +	CXL_REGION_MIXED,
> > +	CXL_REGION_DEAD,
> > +};
> 
> I'm concerned about _DEAD.
> At first I was going to say name these as CXL_REGION_MODE_*, but it's
> pretty obvious that these are mode words...except for DEAD. Is that 
> an actual mode or is it some type of status? I don't think I see it
> used yet.

My first reaction was to remove this.  But I had to go back and look.  It
took me a minute to trace this.

'Dead' is not used directly.  If a decoder happens to be dead
(CXL_DECODER_DEAD) then it will eventually fail the creation of a region
with CXL_REGION_DEAD as the mode.  CXL_REGION_MIXED fails the same way but
only because mixed mode is not yet supported.  Therefore, decoder mode
DEAD indicates something different and CXL_REGION_DEAD was added to convey
this when converting.

The alternative is to be more explicit and check decoder mode to be !DEAD
prior to trying to convert.  I think I like that but I'm going to sleep on
it.

> 
> > +
> > +static inline const char *cxl_region_mode_name(enum cxl_region_mode mode)
> > +{
> > +	static const char * const names[] = {
> > +		[CXL_REGION_NONE] = "none",
> > +		[CXL_REGION_RAM] = "ram",
> > +		[CXL_REGION_PMEM] = "pmem",
> > +		[CXL_REGION_MIXED] = "mixed",
> > +	};
> > +
> > +	if (mode >= CXL_REGION_NONE && mode <= CXL_REGION_MIXED)
> > +		return names[mode];
> > +	return "mixed";
> > +}
> 
> snip
> 
> > +
> >  /**
> >   * struct cxl_memdev_state - Generic Type-3 Memory Device Class driver data
> >   *
> > @@ -449,6 +464,8 @@ struct cxl_dev_state {
> >   * @enabled_cmds: Hardware commands found enabled in CEL.
> >   * @exclusive_cmds: Commands that are kernel-internal only
> >   * @total_bytes: sum of all possible capacities
> > + * @static_cap: Sum of RAM and PMEM capacities
> > + * @dynamic_cap: Complete DPA range occupied by DC regions
> 
> Wondering about renaming RAM and PMEM caps as 'static'.
> They are changeable via set partition commands.

True but they are static compared to dynamic capacity.  I'm open to other
names but !dynamic is normally referred to as static.  :-/

Thanks for the review!
Ira

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id C043CCA0EC6
	for <linux-cxl@archiver.kernel.org>; Mon, 11 Sep 2023 22:24:49 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S239417AbjIKWWY (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Mon, 11 Sep 2023 18:22:24 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:54686 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S244411AbjIKU0V (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Mon, 11 Sep 2023 16:26:21 -0400
Received: from mgamail.intel.com (mgamail.intel.com [134.134.136.20])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id D8570185;
        Mon, 11 Sep 2023 13:26:15 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1694463975; x=1725999975;
  h=date:from:to:cc:subject:message-id:references:
   content-transfer-encoding:in-reply-to:mime-version;
  bh=4dtitF6+w6+WWJ4jlSkZV0dZS0Qx6EvYnHLGxzrehtg=;
  b=jDSqe4G2M5aMa1BHy3IG3QiRaDh1BC09RnDgSNrKTK+dJRS1BN/ikaG3
   s12k3Vg1ha9fxsDQ4vqa6yyJsteMBS2Tqsat15vYGus4w+zLcSHmJ4OI3
   eLwlyV+B2E5ZZX1v4xUThsW4be/wmKOWXewGxjFpdOXVpjXHzxoBqZ5la
   wtnURN17F9eLlj2WpObH5lTEpzGplvYhht4Qno/hLoIPcfTOzKatm1Bwl
   oY8g6IyDEU05YlzblcNaz8yb+9PXggIJENXU0pxMRftftqu3D74kX8W2O
   KDOSNYCl6JJR5uO4qEWqDhowpI6PpurpoWt/QhusXNfwWGCncQZx86p3C
   w==;
X-IronPort-AV: E=McAfee;i="6600,9927,10830"; a="368451778"
X-IronPort-AV: E=Sophos;i="6.02,244,1688454000"; 
   d="scan'208";a="368451778"
Received: from orsmga006.jf.intel.com ([10.7.209.51])
  by orsmga101.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 11 Sep 2023 13:26:15 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10830"; a="720116476"
X-IronPort-AV: E=Sophos;i="6.02,244,1688454000"; 
   d="scan'208";a="720116476"
Received: from fmsmsx603.amr.corp.intel.com ([10.18.126.83])
  by orsmga006.jf.intel.com with ESMTP/TLS/AES256-GCM-SHA384; 11 Sep 2023 13:26:15 -0700
Received: from fmsmsx610.amr.corp.intel.com (10.18.126.90) by
 fmsmsx603.amr.corp.intel.com (10.18.126.83) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.32; Mon, 11 Sep 2023 13:26:14 -0700
Received: from fmsmsx603.amr.corp.intel.com (10.18.126.83) by
 fmsmsx610.amr.corp.intel.com (10.18.126.90) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.32; Mon, 11 Sep 2023 13:26:14 -0700
Received: from FMSEDG603.ED.cps.intel.com (10.1.192.133) by
 fmsmsx603.amr.corp.intel.com (10.18.126.83) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.32 via Frontend Transport; Mon, 11 Sep 2023 13:26:14 -0700
Received: from NAM12-MW2-obe.outbound.protection.outlook.com (104.47.66.48) by
 edgegateway.intel.com (192.55.55.68) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.32; Mon, 11 Sep 2023 13:26:13 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=Un+Y/kzKKIIlUnCSI07XV1Z7NEz1Bn4YOT+hkGQzIBrSX9Kl1PZi6Gif3L9jHFsWQ1p6/QOFLb6e3+T6GOp5aWHt3fXAZL06B7nlmGQmtmyLUFAlwU0n9+ApSBE9ijbLEkZSDonzt/S1pUpno+iqYKRsCKPQsKJQ7VIZ2SAmI3c2np4Gekj1T4LPxmE1yFafH7HMoZPsD8wQRFBmnKLR8VkGDLDkOloPP6hkYMaRCZr94Q1fn+9kaYFDNidi8KZgRAssgBh7eZ0XCAZbeXOCIat9I1ADtk3oiiqgRfrOuCI2rEK3qoQklva+KAdKJm4Gu1bsMa+1K48rUOU9tQCorQ==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=wOCPYOdm4Sjko8jKfQT01goseXCazKLcGVaFw+aa3Ic=;
 b=MLlNjzHkpA81la3sr9Re0EneAP8taQGuPm116iAZJy8SKLROCEsylJcGSVtVT7cuiBEPCb4V9AIfTy/d5rgEt/tFDcIsgqZv7zvs8KDKK8FsYuXpLyH0I3/4dDOIAkfZs1V9AvQvuLCOVCOlfPrNy5wU+xwRo2J//geLIasblAwjpQghszqZiJU+nN73r3SrFawlaTH5dJWtICkLCMMNWjCpAV9EK8RLdnOsoQZaZj+FcRWsNROVbyPaKo6D/+c3fdZDNqWq4g2NVVuuCW/YDOK1gL2yxQ4V+y0sARcRpEPZkomugwo+dqm341E/BMhfXKbn9L0dkwOTki/oRrBNtQ==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from SA1PR11MB6733.namprd11.prod.outlook.com (2603:10b6:806:25c::17)
 by MW5PR11MB5811.namprd11.prod.outlook.com (2603:10b6:303:198::18) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.6768.30; Mon, 11 Sep
 2023 20:26:11 +0000
Received: from SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938]) by SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938%6]) with mapi id 15.20.6768.029; Mon, 11 Sep 2023
 20:26:11 +0000
Date: Mon, 11 Sep 2023 13:26:06 -0700
From: Ira Weiny <ira.weiny@intel.com>
To: =?iso-8859-1?Q?J=F8rgen?= Hansen <Jorgen.Hansen@wdc.com>,
        "ira.weiny@intel.com" <ira.weiny@intel.com>,
        Dan Williams <dan.j.williams@intel.com>
CC: Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        "linux-cxl@vger.kernel.org" <linux-cxl@vger.kernel.org>,
        "linux-kernel@vger.kernel.org" <linux-kernel@vger.kernel.org>
Subject: Re: [PATCH RFC v2 03/18] cxl/mem: Read Dynamic capacity
 configuration from the device
Message-ID: <64ff77de72fb9_2f5aa32945f@iweiny-mobl.notmuch>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
 <20230604-dcd-type2-upstream-v2-3-f740c47e7916@intel.com>
 <1d49b674-81ef-081e-97d0-2e0c5a54af6e@wdc.com>
Content-Type: text/plain; charset="iso-8859-1"
Content-Disposition: inline
Content-Transfer-Encoding: 8bit
In-Reply-To: <1d49b674-81ef-081e-97d0-2e0c5a54af6e@wdc.com>
X-ClientProxiedBy: BYAPR21CA0009.namprd21.prod.outlook.com
 (2603:10b6:a03:114::19) To SA1PR11MB6733.namprd11.prod.outlook.com
 (2603:10b6:806:25c::17)
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: SA1PR11MB6733:EE_|MW5PR11MB5811:EE_
X-MS-Office365-Filtering-Correlation-Id: 382e6cac-05a7-4c68-cd76-08dbb3055668
X-LD-Processed: 46c98d88-e344-4ed4-8496-4ed7712e255d,ExtAddr
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;
X-Microsoft-Antispam-Message-Info: py3p+fKGdPGvtj20jDER/PSwCXfIv0w5D1ny7AGg59hUPWc/atof3+CpYv2SfCJzbiJjrgWzxs/m0U06QZN6D0RdszPyfS+JWFXA1HnwGx8l+VwtukDf/vcRCqBeOpl95fnGPMSaZdFK6S70D7OqeSOk81IiizpD2uSN0lzTonIQ7wujUYg+RmGPc7S1+WqrLYnHyX+VA4TV8hizR6zryamVXqWLiJz0X8fabTHDc1JoQhDmoW+H1e0NfbQ+wgZV9sU1Hbay29AzTOtqpD7QAPHNoH+CXIFdbly8uUWEVuER1sljRXJTKO2LkFlExCRiXxgkPfqE1iOKneIQyGjmeF+A5viSVHdIfZqxsenyviQ2Dd5gmYe2La91VA7K50XvQ03BZ4Zs7zGadZdZtm/svQzVJ/oZoVEKZtgPiA/BDtgK4h9klzso2TXw5L9l7ROZwDfE5EbidzYgmf9QTbi1aydzoOIxLnNEz7SJ/1TGTdohXjdkYzvLTSgrzS+JZXwgBHxvhvU3+HBJiAkwPkng+vUMeNIzaYUsondphEK+6LR31YKvdFidXBDNbhZaWnFW
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:SA1PR11MB6733.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230031)(376002)(39860400002)(136003)(346002)(366004)(396003)(1800799009)(451199024)(186009)(66574015)(38100700002)(82960400001)(83380400001)(2906002)(53546011)(110136005)(54906003)(66946007)(6636002)(66476007)(66556008)(316002)(6666004)(6512007)(6506007)(478600001)(6486002)(86362001)(9686003)(44832011)(26005)(4326008)(8676002)(8936002)(5660300002)(41300700001);DIR:OUT;SFP:1102;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?iso-8859-1?Q?nGS2NMckRGgrkFDOa1IIrnUsGAu1sxACQe0WWkLOqkaqMs1U41y86nj9HZ?=
 =?iso-8859-1?Q?6ZHTZ4pkqvUPRwFz0ULvtFiSE21C0O+NCR+9mMbk+WxvDOIOfgHko8QAjy?=
 =?iso-8859-1?Q?oLCddaAzLvaPZczTFRVnFcqw2br3c9gFRWbdFNOIoBL1ZCqKhJim80iY8G?=
 =?iso-8859-1?Q?01/uJ81VzILTWjAc8SgJ+O3O/F28DAmDQ/wZEvSqqSk4oGjc5NDXOkNh0C?=
 =?iso-8859-1?Q?hm7OHr8a7cNY/oNmDKE0HYnUQAKt1PZTZzetSqZA8aHDtgCq9h9gds2GrO?=
 =?iso-8859-1?Q?mTU8zAU85mB90zQ/OrD75r5ZNMYWHZOJJIyXkcVaTI4zZtNxUI3OlSAkhO?=
 =?iso-8859-1?Q?KHldY3hGCaO4ufhRzgUPZIT3F+mz8dRZqXRJRW2ctJb/+5K+3B0TQ6VJvz?=
 =?iso-8859-1?Q?0USAKK6cYIm9dLpD1gDqWaXBKPgfQaxxxb3Ga7kEx4U4O89D1dCzmB3Kfk?=
 =?iso-8859-1?Q?C/ulfrJtBnNROJYhG9Js6VNk+OSovxGBwA94vuXvXp6M07nYWwvdAeGsIQ?=
 =?iso-8859-1?Q?CUpgVLwrbi298BOBGxNtGTznWbyNtGfACU/0A6hBr+8ql2kXl8b6kGoIZV?=
 =?iso-8859-1?Q?38PM8nXrwNXSLeQdIcg03EGqqgNIVs382rmx6/omyIKRzpxu8DBgoAis8B?=
 =?iso-8859-1?Q?5QPIkCvXMr/z3mC7MFMI1bG1cLN6fcxTKEpaJR2BGdtDrjR82pE3q/3xrB?=
 =?iso-8859-1?Q?CKm8xpQb2fsKvdtgsGvug58utqdCkszS1QxiV44d0pzVwK4ULUksnzEMci?=
 =?iso-8859-1?Q?qdBsw4WnjoSTwjvExDV591tzHLtsRJ8X/+XW5rBxA4cGYW1KpQk9lwGt/d?=
 =?iso-8859-1?Q?f4A7gDYUYnQQxzCzzrSzy6p5xZy31Jtb3OZzMTQybxu8OP6X4riucZfl8U?=
 =?iso-8859-1?Q?T/r96WJ/a2QQR0szW4OqXN9+pUbIXQfMtmkhoMy9l0T5eoCgesx8C1gvMu?=
 =?iso-8859-1?Q?2xR9G82gcJUufQCWC11bAT5Y2R0ImfCSZHide06INU850GSq1t5K3dtJNt?=
 =?iso-8859-1?Q?Vnq21XgmolWKlUsX3DjTVl1SLETOh0K4KT5mWOc5sYsFH4UncUDIPjJoLS?=
 =?iso-8859-1?Q?nImdbSs50vKNfFXklmSllzroch9nTQF+wCaXGFF3DDWrJt9tzlZUqqe42l?=
 =?iso-8859-1?Q?pZEDgVh5GUsVdlWCH1jzT6TjpYEe0G+FhLTtO2J/a/NeTbmtbN0eCXwSOz?=
 =?iso-8859-1?Q?3flxEOCV+kRdqJwFA8wFssY1Lt3t/8B1ZhQSGhl4kowz+8PKYOvP3On1wo?=
 =?iso-8859-1?Q?DheXWzNQdJ3w91wMGOIxSOeQznXhyQ9WXkN3ajgVzDdDuuuA7fY1RA+oj3?=
 =?iso-8859-1?Q?tD2wFDcUNWl9gXp9f8lSVqATST+JsW9OMkmfYraX/FmqSd+iNXoI5Cpvqn?=
 =?iso-8859-1?Q?qs0Cc1+YpFfNpYuVB8ELNPxncUIY6I2vFClr5Q/yxZIebuKU3qhIseYww/?=
 =?iso-8859-1?Q?POOA1cYZSlw6GaOMMDs9GvzQFpTulx0T2e41cSG+D9T/YJTY3SQkIGhgyH?=
 =?iso-8859-1?Q?Y5dEFBnqJaks1QNBCyJMmC2AqVGmvwk8PpVPeD1FkM/l9Cgk4RT0D5Wtrb?=
 =?iso-8859-1?Q?BtTDrTkiB8XwwranLKJDBdKqTeoaRO5zoAIXMSHjQooIMTCqt8K1+4Z7cP?=
 =?iso-8859-1?Q?EftlOmNcDM5vcfYDJ6S1QrR+lyrJCHmbKO?=
X-MS-Exchange-CrossTenant-Network-Message-Id: 382e6cac-05a7-4c68-cd76-08dbb3055668
X-MS-Exchange-CrossTenant-AuthSource: SA1PR11MB6733.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 11 Sep 2023 20:26:11.1596
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: eokr+FbCkAR2e7Lw4Wl/IY+DgVMOg+fN0DzKL8ouYpKt82UExSbuuFq4ur/R5rZtmzVyc+SLs8zXZXX6Tcj73A==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: MW5PR11MB5811
X-OriginatorOrg: intel.com
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

Jrgen Hansen wrote:
> On 8/29/23 07:20, ira.weiny@intel.com wrote:
> > From: Navneet Singh <navneet.singh@intel.com>
> > 

[snip]

> >   /**
> >    * struct cxl_memdev_state - Generic Type-3 Memory Device Class driver data
> >    *
> > @@ -449,6 +464,8 @@ struct cxl_dev_state {
> >    * @enabled_cmds: Hardware commands found enabled in CEL.
> >    * @exclusive_cmds: Commands that are kernel-internal only
> >    * @total_bytes: sum of all possible capacities
> > + * @static_cap: Sum of RAM and PMEM capacities
> > + * @dynamic_cap: Complete DPA range occupied by DC regions
> >    * @volatile_only_bytes: hard volatile capacity
> >    * @persistent_only_bytes: hard persistent capacity
> >    * @partition_align_bytes: alignment size for partition-able capacity
> > @@ -456,6 +473,10 @@ struct cxl_dev_state {
> >    * @active_persistent_bytes: sum of hard + soft persistent
> >    * @next_volatile_bytes: volatile capacity change pending device reset
> >    * @next_persistent_bytes: persistent capacity change pending device reset
> > + * @nr_dc_region: number of DC regions implemented in the memory device
> > + * @dc_region: array containing info about the DC regions
> > + * @dc_event_log_size: The number of events the device can store in the
> > + * Dynamic Capacity Event Log before it overflows
> >    * @event: event log driver state
> >    * @poison: poison driver state info
> >    * @fw: firmware upload / activation state
> > @@ -473,7 +494,10 @@ struct cxl_memdev_state {
> >          DECLARE_BITMAP(dcd_cmds, CXL_DCD_ENABLED_MAX);
> >          DECLARE_BITMAP(enabled_cmds, CXL_MEM_COMMAND_ID_MAX);
> >          DECLARE_BITMAP(exclusive_cmds, CXL_MEM_COMMAND_ID_MAX);
> > +
> >          u64 total_bytes;
> > +       u64 static_cap;
> > +       u64 dynamic_cap;
> >          u64 volatile_only_bytes;
> >          u64 persistent_only_bytes;
> >          u64 partition_align_bytes;
> > @@ -481,6 +505,11 @@ struct cxl_memdev_state {
> >          u64 active_persistent_bytes;
> >          u64 next_volatile_bytes;
> >          u64 next_persistent_bytes;
> > +
> > +       u8 nr_dc_region;
> > +       struct cxl_dc_region_info dc_region[CXL_MAX_DC_REGION];
> > +       size_t dc_event_log_size;
> > +
> >          struct cxl_event_state event;
> >          struct cxl_poison_state poison;
> >          struct cxl_security_state security;
> > @@ -587,6 +616,7 @@ struct cxl_mbox_identify {
> >          __le16 inject_poison_limit;
> >          u8 poison_caps;
> >          u8 qos_telemetry_caps;
> > +       __le16 dc_event_log_size;
> >   } __packed;
> 
> Hi,
> 
> To handle backwards compatibility with CXL 2.0 devices, 
> cxl_dev_state_identify() needs to handle both the CXL 2.0 and 3.0 
> versions of struct cxl_mbox_identify.
> The spec says that newer code can 
> use the payload size to detect the different versions, so something like 
> the following:

Software does not need to detect the different version.  The spec states
that the payload size or a zero value can be used.

	"... software written to the new definition can use the zero value
	                                                    ^^^^^^^^^^^^^^
	or the payload size to detect devices that do not support the new
	field."

A log size of 0 is valid and is indicative of no DC support.

That said the current code could interpret the log size as larger because
id is not correctly initialized.  So good catch.

However, dc_event_log_size is not used anywhere.  For this reason alone I
almost removed it from the code.  This complication gives me even more
reason to do so.

> 
> diff --git a/drivers/cxl/core/mbox.c b/drivers/cxl/core/mbox.c
> index 9462c34aa1dc..0a6f038996aa 100644
> --- a/drivers/cxl/core/mbox.c
> +++ b/drivers/cxl/core/mbox.c
> @@ -1356,6 +1356,7 @@ int cxl_dev_state_identify(struct cxl_memdev_state 
> *mds)
>                  .opcode = CXL_MBOX_OP_IDENTIFY,
>                  .size_out = sizeof(id),
>                  .payload_out = &id,
> +               .min_out = CXL_MBOX_IDENTIFY_MIN_LENGTH,
>          };
>          rc = cxl_internal_send_cmd(mds, &mbox_cmd);
>          if (rc < 0)
> @@ -1379,7 +1380,8 @@ int cxl_dev_state_identify(struct cxl_memdev_state 
> *mds)
>                  mds->poison.max_errors = min_t(u32, val, 
> CXL_POISON_LIST_MAX);
>          }
> 
> -       mds->dc_event_log_size = le16_to_cpu(id.dc_event_log_size);
> +       if (mbox_cmd.size_out >= CXL_MBOX_IDENTIFY_CXL3_LENGTH)
> +               mds->dc_event_log_size = le16_to_cpu(id.dc_event_log_size);
> 
>          return 0;
>   }
> diff --git a/drivers/cxl/cxlmem.h b/drivers/cxl/cxlmem.h
> index ae9dcb291c75..756e30db10d6 100644
> --- a/drivers/cxl/cxlmem.h
> +++ b/drivers/cxl/cxlmem.h
> @@ -629,8 +629,11 @@ struct cxl_mbox_identify {
>          __le16 inject_poison_limit;
>          u8 poison_caps;
>          u8 qos_telemetry_caps;
> +       /* CXL 3.0 additions */
>          __le16 dc_event_log_size;
>   } __packed;
> +#define CXL_MBOX_IDENTIFY_MIN_LENGTH    0x43
> +#define CXL_MBOX_IDENTIFY_CXL3_LENGTH sizeof(struct cxl_mbox_identify)
> 
>   /*
>    * Common Event Record Format
> 
> ---
> 
> Something similar needs to be handled for cxl_event_get_int_policy with 
> the addition of dyncap_settings to cxl_event_interrupt_policy, that Fan 
> Ni mentions.

Yes this needs to be handled.  I've overlooked that entire part.  I think
it had something to do with the fact the 3.0 errata was not published when
the first RFC was sent out and this version just continued with the broken
code.

Thanks for pointing this out and thanks for the review!
Ira

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id A6B30EEB565
	for <linux-cxl@archiver.kernel.org>; Fri,  8 Sep 2023 23:57:43 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1344797AbjIHX5p (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Fri, 8 Sep 2023 19:57:45 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:44026 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1344805AbjIHX5n (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Fri, 8 Sep 2023 19:57:43 -0400
Received: from mgamail.intel.com (mgamail.intel.com [134.134.136.31])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 738DE18E;
        Fri,  8 Sep 2023 16:57:32 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1694217458; x=1725753458;
  h=date:from:to:cc:subject:message-id:references:
   in-reply-to:mime-version;
  bh=SrURTqA5DSIXWSl2Bvik2uDTQ+AW7tbaZR40gZaHj8I=;
  b=dKHqhJnVvcVcbHRGgSvvRYMK0mTjWplr9ieJOds2nCw8JJoXPRxGyNjp
   pJ5jwieV1h7+yjENPSvQdVA0hnCa65RHjWVcqZJEf6NBJt9dU1zo1RLOr
   1Qcxnm3bFQD+oBJZQ8aWpuc7mcqs8AeLlMhMsHx/dyiTRoTLZ5oQ/YYmr
   S6Ex7Mj+OYfyCCi4Pu/P+32I2yWabFbDjdYxgesjeyoIn3jCPdTuVBJnz
   FnZ0R6X+3NS7W8S2LmUK3ToztL3EdJpPIi8oHrv1HL4rXDwtJvuLoy08u
   7N7yTEqRVH015YcI23yxpRWss2nIZ/is3w48vV38irLsWLgC5u7hZ5mhj
   Q==;
X-IronPort-AV: E=McAfee;i="6600,9927,10827"; a="441784449"
X-IronPort-AV: E=Sophos;i="6.02,238,1688454000"; 
   d="scan'208";a="441784449"
Received: from orsmga005.jf.intel.com ([10.7.209.41])
  by orsmga104.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 08 Sep 2023 16:57:32 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10827"; a="916360622"
X-IronPort-AV: E=Sophos;i="6.02,238,1688454000"; 
   d="scan'208";a="916360622"
Received: from fmsmsx601.amr.corp.intel.com ([10.18.126.81])
  by orsmga005.jf.intel.com with ESMTP/TLS/AES256-GCM-SHA384; 08 Sep 2023 16:57:32 -0700
Received: from fmsmsx602.amr.corp.intel.com (10.18.126.82) by
 fmsmsx601.amr.corp.intel.com (10.18.126.81) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.32; Fri, 8 Sep 2023 16:57:31 -0700
Received: from fmsedg602.ED.cps.intel.com (10.1.192.136) by
 fmsmsx602.amr.corp.intel.com (10.18.126.82) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.32 via Frontend Transport; Fri, 8 Sep 2023 16:57:31 -0700
Received: from NAM11-CO1-obe.outbound.protection.outlook.com (104.47.56.173)
 by edgegateway.intel.com (192.55.55.71) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.27; Fri, 8 Sep 2023 16:57:31 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=AePB0+t/nHPG36LsPJRPGCJ9Lv+tdlyiaNc2K+mtMTwloz6dXVPk7CLwow9zl/UdYCEfDfPfXQsVjiAL5HtmEa45w6Y4S0OWV3o9Q/dhzWXw+VX0qCVQz6QPzYEAcehcrFd8fGj09CJeRTCJXVVNmno8niuFSxbelajvteM+8xxheQQPMlxKlx8exA97Oatvkze+3/RJjIYTxpkRyhU2aT1FsS6adoYby+c2ZiOqwX3Gb+BI6moec7wTOdu/PdevcP5CyyvboIH5mlubkqRb5dIEjh2iHaghvb/giNrmxNvN4SrqK3UE5aLt7STBpMradLHgBkAE9xvCZHGQ8/fp1g==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=sROCBrKVf59nCIGJcBYA93WRrU2CveGV1dReUQcDBxQ=;
 b=VbvxQjVSBhkhIy8cQwEm7iKAhDg7YFaNC1mibVpCE6qNbGcHEtUDGeE7oIBQcvIQJFcf4U1CDDmgJAxGqSI8lVNk9JbXQcJZjm/3GFh1QEsFX4fu5WIjI/H76ReRz0qUnRLul+vIa+J6oZq3R5gt+2h98IN2Ijejv0ZzS8Cs1P6J5FxfDadlLsesyw+MhPLlVx6tU3ZkM0ykVex/dLwwkMSC9Z0tOEiOzbdcaPTq3II4t7C3hD7KbdbGAUhkxcfnHwZC5ZrPJV229KdtgnCz+bk2Bh9RJXgbKUvFnjXJod/081qNn7JpcPZ/H99WdhrbodwkVyWzMfzXjDegV0FLTQ==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from SA1PR11MB6733.namprd11.prod.outlook.com (2603:10b6:806:25c::17)
 by DS0PR11MB6399.namprd11.prod.outlook.com (2603:10b6:8:c8::5) with Microsoft
 SMTP Server (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.20.6768.30; Fri, 8 Sep 2023 23:57:24 +0000
Received: from SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938]) by SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938%6]) with mapi id 15.20.6745.034; Fri, 8 Sep 2023
 23:57:24 +0000
Date: Fri, 8 Sep 2023 16:57:20 -0700
From: Ira Weiny <ira.weiny@intel.com>
To: Dave Jiang <dave.jiang@intel.com>, Ira Weiny <ira.weiny@intel.com>,
        "Dan Williams" <dan.j.williams@intel.com>
CC: Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Alison Schofield <alison.schofield@intel.com>,
        "Vishal Verma" <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
Subject: Re: [PATCH RFC v2 11/18] cxl/region: Expose DC extents on region
 driver load
Message-ID: <64fbb4e04c39c_1e8e7829435@iweiny-mobl.notmuch>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
 <20230604-dcd-type2-upstream-v2-11-f740c47e7916@intel.com>
 <f834c62d-bcbc-899b-db72-117c6e7b13af@intel.com>
Content-Type: text/plain; charset="us-ascii"
Content-Disposition: inline
In-Reply-To: <f834c62d-bcbc-899b-db72-117c6e7b13af@intel.com>
X-ClientProxiedBy: SJ0PR03CA0359.namprd03.prod.outlook.com
 (2603:10b6:a03:39c::34) To SA1PR11MB6733.namprd11.prod.outlook.com
 (2603:10b6:806:25c::17)
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: SA1PR11MB6733:EE_|DS0PR11MB6399:EE_
X-MS-Office365-Filtering-Correlation-Id: ff7d6428-0f62-432a-fe19-08dbb0c758df
X-LD-Processed: 46c98d88-e344-4ed4-8496-4ed7712e255d,ExtAddr
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;
X-Microsoft-Antispam-Message-Info: gfFQPFCOt+4INi1rbHSqaLKY1RayhB5GiTkOAPCJLOoFp3gelRIB59I0T2Qb+CnAJTBTq8pSfs3yDN1zAh7qypzrTfYfSVA5UyFRWxhH6OFT69nKdQ3XcostDJCODAZtNYXFhXsdCcgEgssKz/KW4bOVp1MMYW1jqF9R6YStMdmRaSTGbj+Po5iDLfSth9uFL3IQRiZyE496Cf5jaxba/0AlmwsVJw9WMV3AHvb86hktkeizLhBSNQDkQ9h8D4bL392guIKhCWY/nlPFDXhuzLcoCowNytSWmamdb9VD+r1FiqsNSKppn9oyHD0Pd6nrHsmkJ3ggy2WCyjV7OgNsqlKvHWJv2CMgEMy21xz383jm0IOjswjzM7GPqw70+/r72kFGm9DBrSRyNdwervzBtbCDURbs7cdoT/8ly+FaweMOHaXO7qMlNBTwKJ/yYYj0UqvRMMA84CYBM3nkkb6so3j/QAu6hj6FgNLtcc3YShTty4BtY8avKL2S3sSj2SnZi7qRp5FdxZoJw0zpq0EFEbTHSqDh9Pqfp43sysHQ2W73Ny0yXmYQ3tWyaH+kmOPH
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:SA1PR11MB6733.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230031)(376002)(366004)(346002)(396003)(39860400002)(136003)(451199024)(186009)(1800799009)(5660300002)(44832011)(4326008)(8676002)(6486002)(6636002)(6506007)(8936002)(41300700001)(66556008)(66476007)(54906003)(66946007)(316002)(2906002)(478600001)(6666004)(53546011)(9686003)(6512007)(26005)(83380400001)(82960400001)(110136005)(38100700002)(86362001);DIR:OUT;SFP:1102;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?us-ascii?Q?aDXsgthuOCeqzEq5LxieGJ3Ch6fQNQY6AbL52NlyxV5MnRuh40MdPHF7azE9?=
 =?us-ascii?Q?P4Fg2NBlH5lMaznpUAjD71FQSMIxtM4SkzDzfZSFUENGtjcsc33yeJpc4KTj?=
 =?us-ascii?Q?e4doF9otKpn6GiERhVsIG8fXQqs5Ny/H3E0vQ82j3bzdfp+xEZVONq2YEYOh?=
 =?us-ascii?Q?1jK+zKPwzkqgbKefuR8YZ7xQgQwSCnjllY1vKJeB1pdQfueuxOyKP0Ybm2XV?=
 =?us-ascii?Q?iQ+M+2G+u6CUwSMqgjKh8qVAIZuSxN6gjLzOhBArVXwbPA2ZuXV+tmQOA/vJ?=
 =?us-ascii?Q?gCMRAVRtPdZyIZMiN9pToyvhgmteanVqLyalKm3KzhSAta75TzQKssBZMYv+?=
 =?us-ascii?Q?Hcb2Ah/bdAYGUDOxVT9gNwLPGBLhG/BuhAUbRqcDxNOWsYgWwbnS2q66fz1o?=
 =?us-ascii?Q?0tHJQCs8dkA8NrR3JMQ00X6d0Y7Ir5JuHeDmfpb5ptdzorBWspyCuswYoDkF?=
 =?us-ascii?Q?9dXexTvw5DqzRY0F2IPdByoJAJoP11zE230zlofC8UYWvMJ77gf0ryTwCzfX?=
 =?us-ascii?Q?VL8NVB5pJXumj2UUKb9IXfBuEhFyjMk1IbTAKrcH8sJOsfAi7ztZbsWIoRdO?=
 =?us-ascii?Q?jtXT9ieg3WIwD00TF0kBRnnvN/paRcFNGxpgRTcsy3Ng9kzkBwS4jsjoy2fx?=
 =?us-ascii?Q?C7pcDS1NjadxBwdDIIiz+UUevqRpkKU4tHaGglgB+9ri2XyNC0Z+yVh6o2yp?=
 =?us-ascii?Q?4xjZiLITH006XSR+ZWjgCF0xCIF7lCTA58R+qD5TXIieyEz2Q4ITo2MJVrnA?=
 =?us-ascii?Q?QVKy6eCCj80CYu1dSuojboZ9wswvt7y4Ks4S6vRq8qGiPp9lA8exQpPd3Pxu?=
 =?us-ascii?Q?5yN+tHKVtuRQKMSY4I1Xg2GjMrt8esTOZoe4yEk7YG5orko4uyXCOuFGsuif?=
 =?us-ascii?Q?uA9ef11VCZUf0WZ+qSXJaoHqkmJaSf3o9E0KSQwpJTmhHp08qsNAbD74BEYf?=
 =?us-ascii?Q?eBJYjNNeLtLuJNh0phDhAo2KtT3R80mb3E5yjwFCOMbajeE31MIaNORKTxwg?=
 =?us-ascii?Q?Hn9Ny2LXNPcnFfuc+/cGS2ey4KXfjGAbQ74SjqrfQjgZlNJnrNe51zYnEEm+?=
 =?us-ascii?Q?WpnPNnoIM7lOMOhQr8gGE8iRcB5ZD2BGEW+ULk5AF85EhfBOcyXk7caVOuV+?=
 =?us-ascii?Q?P6WA3shAysq+kx83raT/cqZvmygf8kAcMaMZezGnHosjBYym8n0p3iXZFMP6?=
 =?us-ascii?Q?l4HFM1p1Xiz9g+icbA59Apn3nRJdiNIyeA/AfGhkx1mJI63djTBtvcOIF3Bx?=
 =?us-ascii?Q?nAKnotDNz+aUVVHoQ/61MYHRur83zrY55xq73329Uj54RfN9E0F4bwzqCmjx?=
 =?us-ascii?Q?1THN8Hs6K5KWzgDNdbP/nNe0dp1ITTrR9eMjbq2thsPwkITD+sLM5p6N2MTk?=
 =?us-ascii?Q?bQodzdHUxNq5cTzBzirU5jqyrBqBjwjt+xdz3Qvm0cglY06ubnbeQAnTGOH3?=
 =?us-ascii?Q?NUH+e5Xsfz53wjM4f+FzsCktPDB/GTsjav+D3Pl9yRLpo7lqWZyont27Belb?=
 =?us-ascii?Q?Pn8GtZs5X6wIGMKZ54o4vTeSN7ZRlErYnpGtNX93Y1YjGo8W9BtWFS1is35K?=
 =?us-ascii?Q?7LJOBEw6pHQLMBRZaOrstMJIkwZQPUz/K+ztCuFv?=
X-MS-Exchange-CrossTenant-Network-Message-Id: ff7d6428-0f62-432a-fe19-08dbb0c758df
X-MS-Exchange-CrossTenant-AuthSource: SA1PR11MB6733.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 08 Sep 2023 23:57:24.1464
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: nK+tjrAVBNr7IFzS7QUJ3MpZIaGQP+6c4s4kmM4JgfuCtpZz/38gIRvd/kwhOK/Stv1xD1W4xDuAxyfF8vBjEg==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: DS0PR11MB6399
X-OriginatorOrg: intel.com
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

Dave Jiang wrote:
> 
> 
> On 8/28/23 22:21, Ira Weiny wrote:
> >   

[snip]

> > +static bool cxl_dc_extent_in_ed(struct cxl_endpoint_decoder *cxled,
> > +				struct cxl_dc_extent_data *extent)
> > +{
> > +	struct range dpa_range = (struct range){
> > +		.start = extent->dpa_start,
> > +		.end = extent->dpa_start + extent->length - 1,
> > +	};
> > +	struct device *dev = &cxled->cxld.dev;
> > +
> > +	dev_dbg(dev, "Checking extent DPA:%llx LEN:%llx\n",
> > +		extent->dpa_start, extent->length);
> > +
> > +	if (!cxled->cxld.region || !cxled->dpa_res)
> > +		return false;
> > +
> > +	dev_dbg(dev, "Cxled start:%llx end:%llx\n",
> > +		cxled->dpa_res->start, cxled->dpa_res->end);
> 
> Just use %pr?

Yep!

> 
> > +	return (cxled->dpa_res->start <= dpa_range.start &&
> > +		dpa_range.end <= cxled->dpa_res->end);
> 
> I may be easier to read for some if you have (dpa_range.start > 
> cxled->dpa_res->start && ...) instead.

<sigh>  I think about checks like this visually.

Resource
	As                        Ae
	|-------------------------|
Check
	   Bs                   Be
	   |--------------------|

	As <= Bs && Be <= Ae

I know this is odd for some but I like seeing B 'inside' A.

If others feel strongly like you I can change it but I'm inclined to leave
it.

[snip]

> > +
> > +#define DAX_EXTENT_LABEL_LEN 64
> > +/**
> > + * struct dax_reg_ext_dev - Device object to expose extent information
> > + * @dev: device representing this extent
> > + * @dr_extent: reference back to private extent data
> > + * @offset: offset of this extent
> > + * @length: size of this extent
> > + * @label: identifier to group extents
> > + */
> > +struct dax_reg_ext_dev {
> > +	struct device dev;
> > +	struct dax_region_extent *dr_extent;
> > +	resource_size_t offset;
> > +	resource_size_t length;
> > +	char label[DAX_EXTENT_LABEL_LEN];
> > +};
> > +
> > +int dax_region_ext_create_dev(struct dax_region *dax_region,
> > +			      struct dax_region_extent *dr_extent,
> > +			      resource_size_t offset,
> > +			      resource_size_t length,
> > +			      const char *label);
> > +#define to_dr_ext_dev(dev)	\
> > +	container_of(dev, struct dax_reg_ext_dev, dev)
> > +
> >   struct dax_mapping {
> >   	struct device dev;
> >   	int range_id;
> 
> 
> This is a rather large patch. Can the code below be broken out to a 
> separate patch?

Possibly.  The issue was that the natural split was to implement extents
at the CXL region level.  Then implement the dax region extents.  But
without the 2nd patch the CXL region code does not do anything.  This is
because the CXL region driver load triggers this patch to do something.
It made more sense to have the code which triggers the extent processing
bundled with the extent processing.

To split it as you suggest would still be a very large patch with this new
extent file being pretty small.  So I just combined them.

Ira

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 46ED6EEB570
	for <linux-cxl@archiver.kernel.org>; Fri,  8 Sep 2023 23:26:27 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S240184AbjIHX03 (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Fri, 8 Sep 2023 19:26:29 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:60976 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S245401AbjIHX03 (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Fri, 8 Sep 2023 19:26:29 -0400
Received: from mgamail.intel.com (mgamail.intel.com [134.134.136.126])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 5C8B018E;
        Fri,  8 Sep 2023 16:26:25 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1694215585; x=1725751585;
  h=date:from:to:cc:subject:message-id:references:
   in-reply-to:mime-version;
  bh=gplC4UL8r/hCpy+suKljMSdpfIIhE4KlcytdcQFqBYw=;
  b=a0zMCsnbA7NSHMKN68i7WFWfcPgMOY/qPoWGOkOI7dcYsE7LQanervby
   bUUvGmi1JXlfud+zZAjqyXKc2Vawv9063TxlG30CloNN/9HSusTtKvTB7
   2wKdJAiaqBFA6qtyuhHVcEA1twf6TYOlmZSMxpgxSK5xuNankoOVWLf9l
   jNeaeMGkfDv/Dd2TAu52ZBWokF5GY8neI49VCqOVW0FlwfUtVC7G1f2n8
   Xo/doWcm9lpWGI13tl0R4C2HoS0BYTtYT5RA2BFKf1bc6PQ/NlOkcc4o2
   RyBGRYlG1m2z3dkwMKAMpVG25Lg8Sd6kXrA6GGPS49cJPKpt/cKz7E5nN
   w==;
X-IronPort-AV: E=McAfee;i="6600,9927,10827"; a="362821293"
X-IronPort-AV: E=Sophos;i="6.02,238,1688454000"; 
   d="scan'208";a="362821293"
Received: from fmsmga008.fm.intel.com ([10.253.24.58])
  by orsmga106.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 08 Sep 2023 16:26:24 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10827"; a="808175381"
X-IronPort-AV: E=Sophos;i="6.02,238,1688454000"; 
   d="scan'208";a="808175381"
Received: from fmsmsx602.amr.corp.intel.com ([10.18.126.82])
  by fmsmga008.fm.intel.com with ESMTP/TLS/AES256-GCM-SHA384; 08 Sep 2023 16:26:24 -0700
Received: from fmsmsx612.amr.corp.intel.com (10.18.126.92) by
 fmsmsx602.amr.corp.intel.com (10.18.126.82) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.32; Fri, 8 Sep 2023 16:26:24 -0700
Received: from fmsmsx610.amr.corp.intel.com (10.18.126.90) by
 fmsmsx612.amr.corp.intel.com (10.18.126.92) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.32; Fri, 8 Sep 2023 16:26:23 -0700
Received: from FMSEDG603.ED.cps.intel.com (10.1.192.133) by
 fmsmsx610.amr.corp.intel.com (10.18.126.90) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.32 via Frontend Transport; Fri, 8 Sep 2023 16:26:23 -0700
Received: from NAM11-DM6-obe.outbound.protection.outlook.com (104.47.57.169)
 by edgegateway.intel.com (192.55.55.68) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.27; Fri, 8 Sep 2023 16:26:23 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=bFLaqLHYwcwunb1Jsy9slmarH1o6LoxAfUvszbMBtZTRmD+1aOdTRqh0bkLWUTWMUEFstCf99Z+l9aqT0MtxNMOs7Q6xnVPiJBtxYsnjCTwXj2LbiMf48ZM6NDD2WJgp+SCA6WSXxlXj4/d8fl8uRnEoh7oVdxydaDDUf3yUH3qR0nTyOPplLvYLPXc6T+bI+r8PeUxZ0++jabUu4pj4XPZI0OIyChW8nhn6JYgV0ZeJF6JHoGaaGiaMDyjH0pw2Vf0vKnZePqp33BudgaiiU0XM/dO7Nri3dIXGZNLwBoizWGMyJkDf58n6L0+T8KScWn2C4fVjCCqx8fekJXuGbg==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=QOxQVB1iqiRRSbp5MHuC9MtaJbO7S6w//GupyK+IDY0=;
 b=NxCcEZnsV4yy1DDNStIg95/beQdXcgvflQNdk8xI9tUGzSMZBGK0yzel6y34qIJkOkakbN3NpOm0c3RkO2cLfo1KqYbWp82niPktMOUljNr/igRQr6/u+h1OcIfNfPcERF4NYAU3PQGiqdZuuCqtuYVcA6+zaGfSLXB+OzSylRbxJik1T1kFqunZcfcFOkkiqg4itxqSSi6xuA++ZehLjMbivJwNXzO44p4eMXVFS1nEJ7dg0GvIqe+QR6FXFmliRm7p0Pt/vIxlD80TIAFOOroPBmj9/XgTZlmtqNS5+wdSelqsu5LuK1VO/5ts4cc8a/kKbztDvYwSk2OgizXFWQ==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from SA1PR11MB6733.namprd11.prod.outlook.com (2603:10b6:806:25c::17)
 by SN7PR11MB8068.namprd11.prod.outlook.com (2603:10b6:806:2e9::10) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.6768.30; Fri, 8 Sep
 2023 23:26:22 +0000
Received: from SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938]) by SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938%6]) with mapi id 15.20.6745.034; Fri, 8 Sep 2023
 23:26:22 +0000
Date: Fri, 8 Sep 2023 16:26:18 -0700
From: Ira Weiny <ira.weiny@intel.com>
To: Fan Ni <fan.ni@gmx.us>, Ira Weiny <ira.weiny@intel.com>
CC: Dan Williams <dan.j.williams@intel.com>,
        Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        "Dave Jiang" <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
Subject: Re: [PATCH RFC v2 05/18] cxl/port: Add Dynamic Capacity mode support
 to endpoint decoders
Message-ID: <64fbad9aa5f17_1e8e782945@iweiny-mobl.notmuch>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
 <20230604-dcd-type2-upstream-v2-5-f740c47e7916@intel.com>
 <ZPDNFEi1RRGoTWhr@debian>
Content-Type: text/plain; charset="us-ascii"
Content-Disposition: inline
In-Reply-To: <ZPDNFEi1RRGoTWhr@debian>
X-ClientProxiedBy: SJ0PR03CA0355.namprd03.prod.outlook.com
 (2603:10b6:a03:39c::30) To SA1PR11MB6733.namprd11.prod.outlook.com
 (2603:10b6:806:25c::17)
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: SA1PR11MB6733:EE_|SN7PR11MB8068:EE_
X-MS-Office365-Filtering-Correlation-Id: 42f0cd36-6b7d-4053-c279-08dbb0c3032e
X-LD-Processed: 46c98d88-e344-4ed4-8496-4ed7712e255d,ExtAddr
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;
X-Microsoft-Antispam-Message-Info: EBBRctyIJPxaa6D5YZP8cCjjcaOskU+oyDiMTSROyleS+r9HRI7mJ6mqHmI8UvsKW0Oh0FUwoPxok+hYw2Acg8BcpxgFVEFXsf4+DMPC81Qqq04GvA454TS7/tBf5D1ATwfK7CMfz/Lgea5oyQZsvxczf052PNXx/tbX/p6a2KTNWr/HQKfwtAqWbcEPLRtr/vxj/IeTZdhRE2kt5v4Dc0dxL4uanLDXYR/rJZTaD1y+xOkGdMZ7DEOkKH0hwwHKNGJWV6kFEkHLcbDbVqNaYhw8nat+8KpHatHjpI9jRwXwvSevNHNQcEIKu/uFTiXd/1ebh/a4+4mw5dXtkxXlOGeVy+GGn63XQc87H5ocoEeckAP7YvGvMyAYocfmD4hL7ASz06f3Q5QQtjnJok3boD+VFNWoWLdH2cu3KymPjaSHiiBCK0SgHxCAK9dAzyhL/ri+ttmHtlttZwo0rFtLCykiUWETWfC+M+2K9OPNoH+GB5T8LvCgZ2Zz51ZHpC5mWc0yB+oYHqEJny32C7oVaAJwrB26ygXhDRroaLqSnZ0Xz9Nea3+ajJPBIoHirElD
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:SA1PR11MB6733.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230031)(39860400002)(136003)(346002)(396003)(366004)(376002)(451199024)(1800799009)(186009)(5660300002)(44832011)(8936002)(8676002)(6506007)(54906003)(4744005)(316002)(66476007)(41300700001)(66556008)(6486002)(66946007)(4326008)(478600001)(2906002)(6512007)(110136005)(6666004)(9686003)(26005)(82960400001)(38100700002)(86362001);DIR:OUT;SFP:1102;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?us-ascii?Q?YLocispTLp+29DqcjgOUEk/kH+SG3zFhpp0FPbtY2AXyuemC8/Uw7DHSUPHy?=
 =?us-ascii?Q?6hJevd3lyE5NgBlKk6hnO5iMeL64SW5Fz/nYzhq9bT2gwD0tTCaIMn7tu41h?=
 =?us-ascii?Q?m/N1mS/dsOT0DdPc7Z234PYS0BO94MqJajJGbORx50qSAxu7Bh6wJGmAen6O?=
 =?us-ascii?Q?S6bYKf0sqoJgOahuGQxJYXNkGI9IZ7wECDfIkfbEPSUQ6p54BzKRMdGvkZQw?=
 =?us-ascii?Q?GaB50Chrx/F11zEoznXlGpM7wDRaTgbPxs93HDDig1PyiKSsZIeRSubmcVZh?=
 =?us-ascii?Q?nURpX/zociQk/NYSiSfSr29RQXMOt8/Cw5nVSym7BAtxKF+CdJV7YlhaXZpX?=
 =?us-ascii?Q?C7T/SJnkpBvJxRPbWluDrpCakKWeONk8skujoa11ra+UxwwQIJ7+Vq5K1BgV?=
 =?us-ascii?Q?V8UaaZX0nP0iufpS1ZTGMgNrqLThxf0xcSUyEZ7ZzApkawIuuxebHM6uX/vh?=
 =?us-ascii?Q?8MB1D6whpYt1yxBLu+woJiVvmeXiYLwTVToev1NnFVS+oXtgQfHV6OOkLoyl?=
 =?us-ascii?Q?tNtz4BRTP0HMulqo0BoqyDN6OOeBql6lPylnsT0YshZDL4GSJHSEO6C5r54b?=
 =?us-ascii?Q?zP/5XIE2hYjafRV7AIwptSR033D+eK3TG+BltSP8yl/43xMfznzgJDE693bg?=
 =?us-ascii?Q?+plikGmcf83kWF4Sj1IgHG9NMA3fz3yTI7En6Rb0b8fgcFoB37Z6RLSap+ul?=
 =?us-ascii?Q?fJU0v6DOc0CU6QRoUxq9x33RCJm+LXOczoS46qlsjZ3v7m+8/1i7tTPnIH3g?=
 =?us-ascii?Q?puSdGJvADpU4/2FnIqUz8DH62iK7tW84HNyYPvM7qMQLryL2s8xe+SpVw5CP?=
 =?us-ascii?Q?h8uDk2inE3nwkIHxoB2QsXQ9SPaq7cx7cDzajAhoQN+0xQNzLngidqi3BaHX?=
 =?us-ascii?Q?rCQ+4eZVlgyH/0INx/ZEVloSvs2Ms2XQWLrKMeQpS+yDooPmNZu/AdKz1OIP?=
 =?us-ascii?Q?NezCQzHvuhEH+XZBrakU46dWhtJY37X86sjBDrFoFrQ/Ck0qw3p8wHTcoCIe?=
 =?us-ascii?Q?jKR/yk8UokJ6QNXImqu3QsaE/Dtjre8oiGH+HqpmDu2Lx92Rcl4NjRazDo4q?=
 =?us-ascii?Q?iEjA2mgH2qQ/jMAurudXzQL2aW19Xt5O8KnOD0dLqVIzMzrgs4knndMmeYEb?=
 =?us-ascii?Q?1YXFCz1AY6cgbO5ZY43RsTEk2+IqNZpOdOnpyQXCO7Vq7cdt56xS5ABhRlYY?=
 =?us-ascii?Q?agE7yXLhjZZpYYV4RPXde+YsIDYsAC8Bo3143Vr4c+vPYiL47F/uuBfICfok?=
 =?us-ascii?Q?6SVEMGeLcX16Nod2mngWh74YMjQpULXvuxgm5ZiIm3hYIwrRb3u3LmDMnrbg?=
 =?us-ascii?Q?OHSXwoKi5LQmS3p2W22SRdhLDVKCsrvaoOEbWx+RyUQeTm/bA2LjOKSsUftU?=
 =?us-ascii?Q?+ephSqhDd5ddtPEb+vJzzQfP68SDRjEISxK/6zjFsUHI5Lk+qmETSpDK4UDv?=
 =?us-ascii?Q?bCFV07TlDVQxyBXkrUAVCxB2ZQ2KDv0AIv+h3TxSEbMRYaL8ZcmjwHzIpE4O?=
 =?us-ascii?Q?iRzLLa5KMygR4Jz+jjhw5ugBD1e7HLf8tnHQPUvvZ7e+VICyzWPAha5V6B1x?=
 =?us-ascii?Q?waRZ8r23bW4N0hoYTzojHsfzpRg2r/uyGRznZNJy?=
X-MS-Exchange-CrossTenant-Network-Message-Id: 42f0cd36-6b7d-4053-c279-08dbb0c3032e
X-MS-Exchange-CrossTenant-AuthSource: SA1PR11MB6733.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 08 Sep 2023 23:26:22.2922
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: u24eojfMgLbQtuA83fBPlkFVJbMa2XCNuyiksUULE64EAmNc6HYiUrdfiWC18iPkyqIl+wC7K1I1WT2D7EfoXg==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: SN7PR11MB8068
X-OriginatorOrg: intel.com
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

Fan Ni wrote:
> On Mon, Aug 28, 2023 at 10:20:56PM -0700, Ira Weiny wrote:
> > Endpoint decoders used to map Dynamic Capacity must be configured to
> > point to the correct Dynamic Capacity (DC) Region.  The decoder mode
> > currently represents the partition the decoder points to such as ram or
> > pmem.
> >
> > Expand the mode to include DC Regions.
> >
> > Co-developed-by: Navneet Singh <navneet.singh@intel.com>
> > Signed-off-by: Navneet Singh <navneet.singh@intel.com>
> > Signed-off-by: Ira Weiny <ira.weiny@intel.com>
> >
> 
> I have the same question about how dc_mode_to_region_index is
> implemented and used as Jonathan.

I changed it per Jonathans recommendation.  Was that satisfactory or were
you looking for more information?

> 
> Nice to see the code spit out, it is easier to review now.

Thanks,
Ira

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 894C2EEB571
	for <linux-cxl@archiver.kernel.org>; Fri,  8 Sep 2023 23:22:42 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1345204AbjIHXWl (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Fri, 8 Sep 2023 19:22:41 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:58472 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1345202AbjIHXWk (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Fri, 8 Sep 2023 19:22:40 -0400
Received: from mgamail.intel.com (mgamail.intel.com [134.134.136.31])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 522CDE45;
        Fri,  8 Sep 2023 16:22:36 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1694215356; x=1725751356;
  h=date:from:to:cc:subject:message-id:references:
   in-reply-to:mime-version;
  bh=0dgsXEABt2DuxlQF74U1aIU3r9/EwMjOUBwbuTrH6jQ=;
  b=g9pSQk57xuk9d+Nd0T5lRxokLXKoDjJaf4IuFQdPSz6vxyi2TkaYVbW/
   ejOMXKi6KM23Y6IPWP0A40NeCC0vluMV5wSiEhl56E2jpa5OUcYD9Sdhu
   02WqXvTEre1h4CZNBsU00j6Rs6rRNC41Zd9i31jo9+o4tjJoE5QXTe1B0
   4logQh2OvBgwX+RuB2Y0NYNr/x6p3kQfokj8Py7VIYMXLnEmmEo4MURu6
   0yDGdv4WZPdm/4uvXv5qSZy7SeLmR5jh/ZYhTgX/o+sMiA0fgDA6Vfl4r
   Ke1fiLbWskutx726iU1y3dJMKS/asK9zB4Q9VSevO8Tea36rpgNKzuTCo
   g==;
X-IronPort-AV: E=McAfee;i="6600,9927,10827"; a="441780007"
X-IronPort-AV: E=Sophos;i="6.02,238,1688454000"; 
   d="scan'208";a="441780007"
Received: from orsmga003.jf.intel.com ([10.7.209.27])
  by orsmga104.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 08 Sep 2023 16:22:35 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10827"; a="692425180"
X-IronPort-AV: E=Sophos;i="6.02,238,1688454000"; 
   d="scan'208";a="692425180"
Received: from orsmsx603.amr.corp.intel.com ([10.22.229.16])
  by orsmga003.jf.intel.com with ESMTP/TLS/AES256-GCM-SHA384; 08 Sep 2023 16:22:35 -0700
Received: from orsmsx610.amr.corp.intel.com (10.22.229.23) by
 ORSMSX603.amr.corp.intel.com (10.22.229.16) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.32; Fri, 8 Sep 2023 16:22:35 -0700
Received: from ORSEDG601.ED.cps.intel.com (10.7.248.6) by
 orsmsx610.amr.corp.intel.com (10.22.229.23) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.32 via Frontend Transport; Fri, 8 Sep 2023 16:22:35 -0700
Received: from NAM11-BN8-obe.outbound.protection.outlook.com (104.47.58.168)
 by edgegateway.intel.com (134.134.137.102) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.32; Fri, 8 Sep 2023 16:22:35 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=PoGhbzEfRUzzBvzMqCes+4lTGgHXY5olKLQD/gXhGaVZ5yxh/OB9Qo197cH9L8KTK6z0lVo9dsD/+Z4F7B34JWvQkue4puwjoabMVczfv5GpqeI/dfxywy/qghVHOtRsvck7Xh3AxpH7Zq0xx2ESYJTckAUyf0lmy5dyiKViSOcn45S7sWYhWkUY9WnuSbhNeCiUM9YukCsVNGZIHxGcD7CD86vPjUJS7oCmp86yXjR0THhMCZ7i+3adGDknGLyi4Zs5gGiMYTnwsnUz/5gL/r1O69nX4wL+Oro4tBZItWDnOM+Y7k/utYm2gHgFXoAr+HZG6AVQ8FjDBAPWOfE1TA==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=uhMSAU46tzBRP4Aop7TFZaZF8peeZ9t9ujEsvzsduas=;
 b=H1Md6swjHi2KF3DXyxijlZtCu3sHbUj/0e4noF+GvLq8CnoXo14mYOpSzS12ECmUlBJrk+LVXSxJ2DpB2gLexrBXRgKuLrClzZcJeoVmXrWynAyxrttZ3A36o13cmegy/GgEg1QK22uVl7GYTXdME4P3/U6fKVy88KPiu1ADTFv+X/Wxj15pUQ57WFp57Wtzc2JHE9o3Wvod2luO8l01DbVh367a1gw4IdRXcvHWMW2UmRkx91P7KOi2bFd3pPgZaxasv/Al/rOnE1Sao+04BB7zLVpsOlqn1V18eNfNJ0fVJZBulgbZPg3ljBUYS7LevEW/1EKLBmv6Dxp2phawKw==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from SA1PR11MB6733.namprd11.prod.outlook.com (2603:10b6:806:25c::17)
 by IA1PR11MB7293.namprd11.prod.outlook.com (2603:10b6:208:42a::16) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.6768.30; Fri, 8 Sep
 2023 23:22:33 +0000
Received: from SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938]) by SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938%6]) with mapi id 15.20.6745.034; Fri, 8 Sep 2023
 23:22:32 +0000
Date: Fri, 8 Sep 2023 16:22:28 -0700
From: Ira Weiny <ira.weiny@intel.com>
To: Dave Jiang <dave.jiang@intel.com>, <ira.weiny@intel.com>,
        Dan Williams <dan.j.williams@intel.com>
CC: Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Alison Schofield <alison.schofield@intel.com>,
        "Vishal Verma" <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
Subject: Re: [PATCH RFC v2 07/18] cxl/mem: Expose device dynamic capacity
 configuration
Message-ID: <64fbacb4e51d9_1e8e7829497@iweiny-mobl.notmuch>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
 <20230604-dcd-type2-upstream-v2-7-f740c47e7916@intel.com>
 <7e7dfcbd-22a0-c1c3-de1b-7a99edb7f22a@intel.com>
Content-Type: text/plain; charset="us-ascii"
Content-Disposition: inline
In-Reply-To: <7e7dfcbd-22a0-c1c3-de1b-7a99edb7f22a@intel.com>
X-ClientProxiedBy: BY5PR20CA0033.namprd20.prod.outlook.com
 (2603:10b6:a03:1f4::46) To SA1PR11MB6733.namprd11.prod.outlook.com
 (2603:10b6:806:25c::17)
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: SA1PR11MB6733:EE_|IA1PR11MB7293:EE_
X-MS-Office365-Filtering-Correlation-Id: bcbe2581-df39-457c-8565-08dbb0c27a67
X-LD-Processed: 46c98d88-e344-4ed4-8496-4ed7712e255d,ExtAddr
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;
X-Microsoft-Antispam-Message-Info: JMoWQJXh7vQKZaAkDfA1/Q0UGT3zg9xSBcfLRnrtIYDuM422/SeV6g6M3Fx/c7PzktGDS91Lkp1zi/8rDF49VHdc+0XpFwd0Ji72hQ4K+PDwbnUxvXpnsC0zm04Jen2nvvmAp00/GlUokl7x1wEjQ6FtuItx1iuL5sGfjyjFzpI1WA5u+MtA3pfInHUypEAD7q9HsiT5KAnNEf+aCpFJoTkkeSQr4oevD+XyLixrDD7NfTlUZhdaoX/0V4vLNK7mZh32Dg00Mo613ZFk9pe5kOlVcK86e3YIONxtfSM/X6UYqpE1oZAVxNOGtXqbBzEF3Sde1cKNIi8xcIofZWf5UecYXxcZFBYFUseHK2ZzsdeS55GE+A/+6Aua8vPknvxgNXdjQbcwNsIyKWFOwN1xUrpn2+qMXtkmZYkJgQvYU7BXens5WTorN3VWz3E00d7u9AawVypHHfqMwvwEvJxz6rRg0JFyXCPm7FgovKxCGrM66rqkR6ZoqR+6O+XrdApJ6itmfrNPEnSM5ZU//IkE4lPjQOqgFy6FwzCpmK+9GoUQd+2G3ZeeqB46EDl0PWKq
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:SA1PR11MB6733.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230031)(366004)(39860400002)(346002)(376002)(396003)(136003)(1800799009)(451199024)(186009)(6666004)(6512007)(53546011)(6506007)(6486002)(9686003)(41300700001)(478600001)(26005)(4744005)(66946007)(2906002)(44832011)(66476007)(66556008)(54906003)(316002)(6636002)(4326008)(8936002)(5660300002)(110136005)(8676002)(82960400001)(38100700002)(86362001);DIR:OUT;SFP:1102;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?us-ascii?Q?9WBNQhCcqiWOtZ5UMCOZos9LBGQeFYarXxzT4+THPIS/J8aniasYc7r2uY/s?=
 =?us-ascii?Q?Z5VEa1cQSg8cIOJdtU0itpUwnS4wdNA0gqgXKeBCPM5lncJgoPyRetT/aRZN?=
 =?us-ascii?Q?iLaPG7OUJzCnpFY8Wx+Q+0SUdXNEiW+V0gL1xKbV7MLdm9jyICfg6AU0NHh9?=
 =?us-ascii?Q?hPUv8yVkG1WTNz4v1nV9kVutwmpv+YE30f0PjlqlOL4O4Ufn9OxseOGHSA6D?=
 =?us-ascii?Q?cKRV9XwSDvRLTt7J7pwtU5vm3dWBpCHyUYeTZW/fIlVUAsJG3vVLD/1Qg9SI?=
 =?us-ascii?Q?l5dnE2K5wst4RsbDeBlRcv8Um6cZ88q0iYfZLYBrHrXHu42P8PIKY6V6/vEG?=
 =?us-ascii?Q?sTk7ZJOtgZLExUJ7VZsX7YEVS8qPGJ9bkcHm/rK8v4FobQ82GohksCtZjBmD?=
 =?us-ascii?Q?T8jGsOW7JriCgNpAKl+dM3bdwGtfcEL/y3ZCYirlGI5EAf1E5d1n6mN+yUxO?=
 =?us-ascii?Q?RcFSz3GYTiDBVpMSqDVDwAEn55SFOdIg++SnjIUimLmO/n3MArPiZPKwyjtx?=
 =?us-ascii?Q?AQdoUMFtgvXLyhLEmHyS+Ry1UJ24QQkR9FvxVkoOBJBwdvM4NwYRQbobLITH?=
 =?us-ascii?Q?frxaCi8tuBaIB5Zlj3z7C/L/SnQC879aY5ZCMpe3YkH7KImUxt/8lGqSFaTf?=
 =?us-ascii?Q?y/QBpHcmjdlSUO/FylVmegdDXp569k7nVQdBuXOw7h/YC7VWewF2z/7Apg0T?=
 =?us-ascii?Q?Fiv4ADbsnJQAJ8dMavexYqJIFFB9qaqiRhRNAwx04V9BDb9Gx5wpi3kEYK++?=
 =?us-ascii?Q?41sKJdu8Jc/gpA5VZh61+Dsg4i2vvPoVy7OHX2TpG7ryucPa8Veum3IA3KAX?=
 =?us-ascii?Q?yJiiH73cmKWCKpwVIImRKEugVD5IPzb9AaFMUClJNu4xhRHlg/V4FUwlZqLI?=
 =?us-ascii?Q?5upn3ja0SC8ckGOsjfyKQ2Ek5vqrBufjTuehKzFCl84gKYXpu2lir8zeXfJa?=
 =?us-ascii?Q?4ukq7u2tdYrjDTt1lJy1CHg+/TEm8GM4VKaOtPfVP/YAupajfvgPsNfFgMfF?=
 =?us-ascii?Q?54NsKnnneB/32PoaxelsMStN7YZMhzbKroKK2YDtmhzLR5T1dxiDkEOuaUsx?=
 =?us-ascii?Q?evucrLaYcoSkYG1qsYAgL/P/nIAA+63XNbxia4fN8ahVPUZUfJJCN683Ly/d?=
 =?us-ascii?Q?CVjhT2CD930Tb1dKfBXB0oXWqrSdt9CVmy0shkKPU4cLlZ2bptcyq0i4a/um?=
 =?us-ascii?Q?AZj36+w6JtLEcQfWGhglkhcCxsrLYe/P6ycOi1uCA52mAIq2N6xPFOl5GP5W?=
 =?us-ascii?Q?KlQ6KObnsB6ZzMBy+IMpd7grLOmSIi5Cv47L4w0Zw/5HYBOmAzzSCSI1f8E+?=
 =?us-ascii?Q?UHN7omZe9vyZaRYlnc00ZFNsJUT8vf150NMItHUEETdyZWJT8ekhWJBCz9w0?=
 =?us-ascii?Q?sggW7ytoGKpo0FIh5MXAy1kEAmQszMDG4Don2a2KKlOMk76cjz6WxdZqLnoF?=
 =?us-ascii?Q?5CiK8ux2jOmw7IfDtW0K+kByAVSqV+kVV0DAb2OSDev+OyDv4I1ZhXaiOlRr?=
 =?us-ascii?Q?8XHBHkMqVQzI3Stluo4369rzUB3UQawUJTb7PbL+YrDSto6SFq5oeKlRwfme?=
 =?us-ascii?Q?dJsIh6qXnjICVGhDVthhDVlRaa9yjhUv2RdyKPfd?=
X-MS-Exchange-CrossTenant-Network-Message-Id: bcbe2581-df39-457c-8565-08dbb0c27a67
X-MS-Exchange-CrossTenant-AuthSource: SA1PR11MB6733.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 08 Sep 2023 23:22:32.8602
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: 0QE6eY1Yd9BfSILhBYne8noqdPtYAPxbyRjYr6N9FZjKZzvcGvVCBci2v3GxGQi2jJFlaCW03QS4/wmnB5WGKg==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: IA1PR11MB7293
X-OriginatorOrg: intel.com
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

Dave Jiang wrote:
> 
> 
> On 8/28/23 22:20, ira.weiny@intel.com wrote:
> > From: Navneet Singh <navneet.singh@intel.com>
> > 

[snip]

> > +
> > +static umode_t cxl_dc_visible(struct kobject *kobj, struct attribute *a, int n)
> > +{
> > +	struct device *dev = kobj_to_dev(kobj);
> > +	struct cxl_memdev *cxlmd = to_cxl_memdev(dev);
> > +	struct cxl_memdev_state *mds = to_cxl_memdev_state(cxlmd->cxlds);
> > +
> > +	/* Not a memory device */
> > +	if (!mds)
> > +		return 0;
> > +
> > +	if (a == &dev_attr_region_count.attr)
> > +		return a->mode;
> > +
> > +	if (n < mds->nr_dc_region)
> > +		return a->mode;
> 
> I would add a comment on who you are checking against nr_dc_region to 
> make it obvious.

Sounds good.

Thanks!
Ira

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 79561EEB56E
	for <linux-cxl@archiver.kernel.org>; Fri,  8 Sep 2023 22:52:38 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S243525AbjIHWwk (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Fri, 8 Sep 2023 18:52:40 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:44312 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1343518AbjIHWwj (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Fri, 8 Sep 2023 18:52:39 -0400
Received: from mgamail.intel.com (mgamail.intel.com [134.134.136.24])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id B69B11FF2;
        Fri,  8 Sep 2023 15:52:23 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1694213543; x=1725749543;
  h=date:from:to:cc:subject:message-id:references:
   in-reply-to:mime-version;
  bh=GHCHiXxfnYK261wCTR7MpuONj+/ivrscm5Pcs+oQoog=;
  b=G5+kx5xeZy7/BfG6baHJzU5/7L0abHZiDWLs3q2pODlX1RWpFFvsd32M
   +tWQxXyfQIZp8SPlgRDCUGwijsC7HWa0brr0fr2VIjUiZPWNNIhwFL6v2
   jZG8MfCZS1Uvqs5YKRO/Zc1MBO+NACm0wWNmtguI9oWiGdHxLAg1TRZE7
   LrdgKiO5+Y8LS4x36sBVgIJXVxvefVZTMUxoWnyoivt3Kv1AfiF0xlISk
   jfigmsrjqyd/x93wTHRWiVT4ygpWH5uHtyBRAkbCKMKpJ7j8thY+R9o/t
   OBzRsZbb5gWsLL5yYBrd5wvzUxsMJRUyHQehtuKIJjB/lt+R1xOLQEcLo
   Q==;
X-IronPort-AV: E=McAfee;i="6600,9927,10827"; a="380494744"
X-IronPort-AV: E=Sophos;i="6.02,238,1688454000"; 
   d="scan'208";a="380494744"
Received: from orsmga005.jf.intel.com ([10.7.209.41])
  by orsmga102.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 08 Sep 2023 15:52:23 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10827"; a="916349241"
X-IronPort-AV: E=Sophos;i="6.02,238,1688454000"; 
   d="scan'208";a="916349241"
Received: from orsmsx603.amr.corp.intel.com ([10.22.229.16])
  by orsmga005.jf.intel.com with ESMTP/TLS/AES256-GCM-SHA384; 08 Sep 2023 15:52:23 -0700
Received: from orsmsx612.amr.corp.intel.com (10.22.229.25) by
 ORSMSX603.amr.corp.intel.com (10.22.229.16) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.32; Fri, 8 Sep 2023 15:52:22 -0700
Received: from orsmsx610.amr.corp.intel.com (10.22.229.23) by
 ORSMSX612.amr.corp.intel.com (10.22.229.25) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.32; Fri, 8 Sep 2023 15:52:22 -0700
Received: from ORSEDG601.ED.cps.intel.com (10.7.248.6) by
 orsmsx610.amr.corp.intel.com (10.22.229.23) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.32 via Frontend Transport; Fri, 8 Sep 2023 15:52:22 -0700
Received: from NAM11-BN8-obe.outbound.protection.outlook.com (104.47.58.168)
 by edgegateway.intel.com (134.134.137.102) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.32; Fri, 8 Sep 2023 15:52:22 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=cHcRhTlOpOGW+iUf/p6LzxGiy3o/jNhAif0Qgnqq6rKPS0HDmnTQVwOcbM8Ce+7MzPablqgjmo0XLh3Yd5hwfNJdNX4iiANIt4Diz46V3jsBYGaRBV5SYRcptCZuJgIzULDarhTeHlmxMraYamzpkV2fECaDyyP6o+XqjV3J7qwSjxWjwVWiV4V3kfhSgnjM9IJVEAFOj6AR3uGxRC3vOGlH6z/IhGNrovfZFvLj173syIuD/SEwoOmR3CEqXroMurixYFTDX5Ox3SFdOn9av87VrEDw5e2bb8k7mCO7m6bGuJRrJVYPRoFJdnJfb+CizwsAXI+lPgb2E1UP8rFzNg==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=vrbbhb9AtETDVO6W3VTyXZSUQY9QI7M0Oj/QiyKwaCU=;
 b=SWa0EXO712wLDQeorl3KQGh++gYsdhb+1zqnPsbL35BrY2GVueYNx/wWOigJg1AGjy1RuAJ1YogvUkk3AJOV4A4+ZxIEIWp1g/DU6bX73k83dTTTyHkgrTw2ZSVvYGlZpiK1Z73/TSj49LQ0XaVuXlWHu05h5br8WNt9iN8uk5CWO5C3nMTU4AsLKAM+fYjx/WuO6sy55oi4GNTcDAQWA7YO37GjR7Z2DT+vjeMf0v1nxKan+88a+wcH88k8WW3o0Jh23nlE1gtShPLS1Funy6VUk2t/WYuWazeMWooTKtjXLpVlhjbEFJrWxFG4s9+nD7gTa2NGA5ELSAtNpLkeew==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from SA1PR11MB6733.namprd11.prod.outlook.com (2603:10b6:806:25c::17)
 by DM4PR11MB5994.namprd11.prod.outlook.com (2603:10b6:8:5d::20) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.6745.32; Fri, 8 Sep
 2023 22:52:20 +0000
Received: from SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938]) by SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938%6]) with mapi id 15.20.6745.034; Fri, 8 Sep 2023
 22:52:20 +0000
Date: Fri, 8 Sep 2023 15:52:15 -0700
From: Ira Weiny <ira.weiny@intel.com>
To: Fan Ni <fan.ni@gmx.us>, <ira.weiny@intel.com>
CC: Dan Williams <dan.j.williams@intel.com>,
        Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        "Dave Jiang" <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
Subject: Re: [PATCH RFC v2 03/18] cxl/mem: Read Dynamic capacity
 configuration from the device
Message-ID: <64fba59f73319_1e8e78294e2@iweiny-mobl.notmuch>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
 <20230604-dcd-type2-upstream-v2-3-f740c47e7916@intel.com>
 <ZO+4Qql0rOslp0bl@debian>
Content-Type: text/plain; charset="us-ascii"
Content-Disposition: inline
In-Reply-To: <ZO+4Qql0rOslp0bl@debian>
X-ClientProxiedBy: SJ0PR13CA0043.namprd13.prod.outlook.com
 (2603:10b6:a03:2c2::18) To SA1PR11MB6733.namprd11.prod.outlook.com
 (2603:10b6:806:25c::17)
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: SA1PR11MB6733:EE_|DM4PR11MB5994:EE_
X-MS-Office365-Filtering-Correlation-Id: f63bc40f-aeb8-4a95-68b9-08dbb0be41e5
X-LD-Processed: 46c98d88-e344-4ed4-8496-4ed7712e255d,ExtAddr
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;
X-Microsoft-Antispam-Message-Info: 4DD+bVF9wgPWtgh2zXlLnCa3A4TPJjaKnkabjTvozSEZvUorCBCEOoHRCtGFDm3UBE9MVV4/hAqXSDbCPzTTPS5EHfn3QyR24QOFmGiyo2D/dl2VR9L+XLSfA+IbTSGe/c4IB48DVZQI0VYuQi1KfCLMaHlVzXoQePJPHDcpQifv0nY2n00dJxXAyx22b82c4NQFBwuU3dW0Ufn/CeZWdQ6KQdIiJSB90GfEWpJx5msvh3JkrZeQI5+FHHOT4/xhzm11aJagArps+NQ+k/8qMtqUgFNLGoPPoLzvPhpYjAyjN110r/jxsqj4ZivTnmzTRf33veAfWWzJXStNH8F3fi3Ght7kv0xU8TTzuTPyMEdxNXfjJ/IC6nB2gIIi2oCru39BJjjlaosSyB3YWhz+ESTTsyBVNQc1LcmuPmpowsNGUVbMqtrZxwQ/casuMV+dGeup6IN+VwxedKL0xSvM7Fz+0ffUd/Uf9bWxxDDkvWm6MJTCwSB/ttZHpL3OZOBvOxIs4T7NpEwtOZGIOfLPtw89nHm2D0d9Ea+6Vd8FmUhGO5kISdBoJpUtTLC0fwh8
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:SA1PR11MB6733.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230031)(376002)(39860400002)(396003)(136003)(366004)(346002)(1800799009)(186009)(451199024)(38100700002)(41300700001)(86362001)(82960400001)(6666004)(83380400001)(478600001)(26005)(6506007)(6512007)(6486002)(9686003)(66946007)(66476007)(8936002)(54906003)(2906002)(66556008)(316002)(8676002)(5660300002)(44832011)(4326008);DIR:OUT;SFP:1102;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?us-ascii?Q?ZwCKWlLwUgJc2TJLaczhEafqLtbjq/xT+ipbLS5WMK5HuHg6lOIkB+IO6RCu?=
 =?us-ascii?Q?R4wdeBQFg1rYIXpLCJjHbDGhZx8UMJcey7Cc07jvhAruupKguHjqNjlkLP0w?=
 =?us-ascii?Q?nOa2nPmdI/X5UeefSt97N5DC6slhzlc7+8uFdEO14RUSO3CtYFD4mme8J4Hn?=
 =?us-ascii?Q?9RSShUDSmuDLmR99VrXwkpehiLzm7MXyJmCktNWTO8gbf/3yVxh3i1ygoATm?=
 =?us-ascii?Q?fSF6tOQ4TNDKZSPeWZAM1GNdm3heANxWLPZ0YP8OjmJvE9rnYBUlSQ5ojXEK?=
 =?us-ascii?Q?rgpyWznDHjXZI4r13lm4UWw6Q3+spNKAI1d8ll4oaNTMka8VvAjgl9/Z2IOF?=
 =?us-ascii?Q?CBIa0x7H0zyoLKKZ0naROiJ1pqwvznduBnH/j3e9FzCHSB0qN8YOEwLaegG7?=
 =?us-ascii?Q?p5DP+4j+RJCwsZ+fSjQ1JQjlo8Sl+iGXBAdE7W9C7/GBPdCAwTqi8RII1P3K?=
 =?us-ascii?Q?iuMs+MxsuUW+Jv4gtu5LK+VbWakbJdEaDVpAazHcGNRTLqYiMGl/ReC3ww4i?=
 =?us-ascii?Q?QSooK7W8M/ZGSTeHi+zvFkFyakqWDS+QXJSvbpK/BGBS41RADFAU8Db2/fJD?=
 =?us-ascii?Q?I9r/BOls1rgzWRi62Lr+yXJt2mpGJggX3iNc9x70EM+nVe0KYLGKP2tGTNo1?=
 =?us-ascii?Q?iHJo3FhHqSX3ssDHUhYTMwFvOjjgqJpQN/eONM9rK0yoPStvq3V6v+QuGQ8m?=
 =?us-ascii?Q?KdcYckTPwrp86snCX8wbWDmp/ElQdpvPlvsKiAfw1xBmkxqZlr85uharLIPF?=
 =?us-ascii?Q?8ibUD4NObaUJCj0+UE7oHI+BYSAsDioZfT6kqNO0MUraiH45ERZiq6+Q5RgR?=
 =?us-ascii?Q?ptkottU3GOMUD8CuH/5IPXdW+SQ/M3njp4j41b1ikPFj+haJG1bx2g/N6CPc?=
 =?us-ascii?Q?GrXb/ughrsWh7ByONOfQIMuFHmsuOYJN+MOWO/RTEiA38HSBWlZ825MZ1zDT?=
 =?us-ascii?Q?U9K0S/3Z27B3FFTipL/nXw4hRJ3nhusauagRkpfBnJFYGZECIka0yOi3WjYQ?=
 =?us-ascii?Q?M8t55BILcQEi2DZOfZE0zUsjHJqGjU/jXhcs/uvzqpL4V6yiItj5UVsbHfIX?=
 =?us-ascii?Q?gCkY8eLGZgmhvy4H+jyADjrK2v/W1anD6xFvrOgdULCveAlIzxaimNt8yLnS?=
 =?us-ascii?Q?jXlvi24Lpfgy86/FlKYDE8YBYaVmhN+aSLBCRuMMcPlDsm4FbUFXyCV0c5Qi?=
 =?us-ascii?Q?tgqXeYaO0V7kq6t7r0KxUdfu6HWedhqciqw9n4/Gl9aGFHmTZNMfJFfZ5t/q?=
 =?us-ascii?Q?ROz1+Z7m0PQRoimF1WKJDUzy22A/onjqORuH3j14DiUrfCoPh6FlVdnUMRur?=
 =?us-ascii?Q?M/q98kF1JAb5jYLTiJ8zEDH3C1NCffEwZG9WhNu1nvBe/DcumIaQA2lomB/Z?=
 =?us-ascii?Q?MPcYF+sYAhHTlID9zNJTv/0qtdjKJbqx20fi76OD10LkL6KfY/OaIGJVZ7oS?=
 =?us-ascii?Q?s/7YUl063OJv8D5z7Y1o7wxJxVNrADZUdJ8RLTGAKpNfZ3AybO6GtH1shbiC?=
 =?us-ascii?Q?OpMMEeqBfr45zD87/2J36ktSBhjxnlcD0QyCGVTBwfv0eYQukszdU52mprcI?=
 =?us-ascii?Q?jT41s4kkEhDEkNxqYvU36UUC4OGRnEd66H6KXwyq?=
X-MS-Exchange-CrossTenant-Network-Message-Id: f63bc40f-aeb8-4a95-68b9-08dbb0be41e5
X-MS-Exchange-CrossTenant-AuthSource: SA1PR11MB6733.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 08 Sep 2023 22:52:20.0371
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: WvisdOH7/vSzN7K6P9bWh/UaXok+lbFi+yKs+xpc9EmK/nTIFJjXJoFkLExLb7iqQAtUgG75jCKlGnBEg1kFKg==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: DM4PR11MB5994
X-OriginatorOrg: intel.com
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

Fan Ni wrote:
> On Mon, Aug 28, 2023 at 10:20:54PM -0700, ira.weiny@intel.com wrote:
> > From: Navneet Singh <navneet.singh@intel.com>
> >

[snip]

> >
> > +static int cxl_dc_save_region_info(struct cxl_memdev_state *mds, int index,
> > +				   struct cxl_dc_region_config *region_config)
> > +{
> > +	struct cxl_dc_region_info *dcr = &mds->dc_region[index];
> > +	struct device *dev = mds->cxlds.dev;
> > +
> > +	dcr->base = le64_to_cpu(region_config->region_base);
> > +	dcr->decode_len = le64_to_cpu(region_config->region_decode_length);
> > +	dcr->decode_len *= CXL_CAPACITY_MULTIPLIER;
> > +	dcr->len = le64_to_cpu(region_config->region_length);
> > +	dcr->blk_size = le64_to_cpu(region_config->region_block_size);
> > +	dcr->dsmad_handle = le32_to_cpu(region_config->region_dsmad_handle);
> > +	dcr->flags = region_config->flags;
> > +	snprintf(dcr->name, CXL_DC_REGION_STRLEN, "dc%d", index);
> > +
> > +	/* Check regions are in increasing DPA order */
> > +	if (index > 0) {
> > +		struct cxl_dc_region_info *prev_dcr = &mds->dc_region[index - 1];
> > +
> > +		if ((prev_dcr->base + prev_dcr->decode_len) > dcr->base) {
> > +			dev_err(dev,
> > +				"DPA ordering violation for DC region %d and %d\n",
> > +				index - 1, index);
> > +			return -EINVAL;
> > +		}
> > +	}
> > +
> > +	/* Check the region is 256 MB aligned */
> > +	if (!IS_ALIGNED(dcr->base, SZ_256M)) {
> > +		dev_err(dev, "DC region %d not aligned to 256MB: %#llx\n",
> > +			index, dcr->base);
> > +		return -EINVAL;
> > +	}
> > +
> > +	/* Check Region base and length are aligned to block size */
> > +	if (!IS_ALIGNED(dcr->base, dcr->blk_size) ||
> > +	    !IS_ALIGNED(dcr->len, dcr->blk_size)) {
> > +		dev_err(dev, "DC region %d not aligned to %#llx\n", index,
> > +			dcr->blk_size);
> > +		return -EINVAL;
> > +	}
> 
> Based on on cxl 3.0 spec: Table 8-126, we may need some extra checks
> here:
> 1. region len <= decode_len
> 2. region block size should be power of 2 and a multiple of 40H.

Thanks for pointing these additional checks out!  I've added these.

> 
> Also, if region len or block size is 0, it mentions that DC will not be
> available, we may also need to handle that.

I've just added checks for 0 in region length, length and block size.

I don't think we need to handle this in any special way.  Any of these
checks will fail the device probe.  From my interpretation of the spec
reading these values as 0 would indicate an invalid device configuration.

That said I think the spec is a bit vague here.  On the one hand the
number of DC regions should reflect the number of valid regions.

Table 8-125 'Number of Available Regions':
	"This is the number of valid region configurations returned in
	this payload."

But it also says:
	"Each region may be unconfigured or configured with a different
	block size and capacity."

I don't believe that a 0 in the Region Decode Length, Region Length, or
Region Block Size is going to happen with the code structured the way it
is.  I believe these values are used if the host specifically requests the
configuration of a region not indicated by 'Number of Available Regions'
through the Starting Region Index in Table 8-163.  This code does not do
that.

Would you agree with this?

Thanks again,
Ira

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 8AD48EEB56E
	for <linux-cxl@archiver.kernel.org>; Fri,  8 Sep 2023 20:23:23 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S242733AbjIHUXZ (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Fri, 8 Sep 2023 16:23:25 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:59726 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S232427AbjIHUXZ (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Fri, 8 Sep 2023 16:23:25 -0400
Received: from mgamail.intel.com (mgamail.intel.com [134.134.136.65])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id E51FDA3;
        Fri,  8 Sep 2023 13:23:20 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1694204600; x=1725740600;
  h=date:from:to:cc:subject:message-id:references:
   in-reply-to:mime-version;
  bh=xsJuH3tuIhmH30Ga3GpJdVw+109BQKy/11io1KJAExA=;
  b=Qz9mtDmXpvcvDCO3YIuHYr9ymuCP+mz1KoO5CkCVthNJtBZUKMPM87kE
   urxmWmBwtfNaiVG1opxauzD9MyYFu3oZE0//GENHhugf8T4W4C0iu1CIH
   DSqTDCxVfFEqjra0zvQkIrsPCA7Zqdyw9u64DqcvBkzYM3Clkp8EXpra5
   0D4cL/YpiyeDhzj+NQk4DiYQEUZVLzzscAmRY0G1WDv5TLkkMtqhNBI55
   8/vtwt0ls6uLZBSof8QHMseX1E43lfxIHuMHu52Y5DEPIevJfMfDSAwzt
   OSLphESIRxrBJI7LLu+3wPhAFbpmNyTx9yzjL1AFYYnxEqUE+EyWNmZ6q
   g==;
X-IronPort-AV: E=McAfee;i="6600,9927,10827"; a="381561246"
X-IronPort-AV: E=Sophos;i="6.02,237,1688454000"; 
   d="scan'208";a="381561246"
Received: from orsmga008.jf.intel.com ([10.7.209.65])
  by orsmga103.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 08 Sep 2023 13:23:19 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10827"; a="771876241"
X-IronPort-AV: E=Sophos;i="6.02,237,1688454000"; 
   d="scan'208";a="771876241"
Received: from orsmsx601.amr.corp.intel.com ([10.22.229.14])
  by orsmga008.jf.intel.com with ESMTP/TLS/AES256-GCM-SHA384; 08 Sep 2023 13:23:20 -0700
Received: from orsmsx611.amr.corp.intel.com (10.22.229.24) by
 ORSMSX601.amr.corp.intel.com (10.22.229.14) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.32; Fri, 8 Sep 2023 13:23:19 -0700
Received: from orsmsx610.amr.corp.intel.com (10.22.229.23) by
 ORSMSX611.amr.corp.intel.com (10.22.229.24) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.32; Fri, 8 Sep 2023 13:23:19 -0700
Received: from ORSEDG602.ED.cps.intel.com (10.7.248.7) by
 orsmsx610.amr.corp.intel.com (10.22.229.23) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.32 via Frontend Transport; Fri, 8 Sep 2023 13:23:19 -0700
Received: from NAM04-BN8-obe.outbound.protection.outlook.com (104.47.74.46) by
 edgegateway.intel.com (134.134.137.103) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.27; Fri, 8 Sep 2023 13:23:18 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=ED/vWaDbBWCREBODp+163Tbmjsh0ZCfGaTYRNqPCk/uyi6fSLCAbxdMIyanLvnWJSle1y0rEgoDkiJisfRhMa3NTz3xsolIz1HdhDVIHRMcawIBNxys7weHqji3AKGM/QvwKnsMu+oLw34fJk/ExNzwmVylTphysRJPZOiGCuFAd5GNcamDXTnyWGzcRKMFGakTo0FlVl3KG+im1mKeHQrqp/qG518PHg5LhMxre8p8JzOkvZX27xK98MViKzTv2gCUMp3OpoI0X2GHWd5JLkivCKPIkmMqBryuojas3lgDzjkhny5n1YujRZDfN2q4W4EwVK8y8TluN2OJw6RvqHA==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=kBjUHJGwqgs7pgqJhEEzs67tPFJrhF62Y2OSVhBREc4=;
 b=ZfkXNLdHJEpUxWXzO7GmFy4DTkO6i/LWAFL9lcF9+EH7couv1CYTe+9kjl71z7n7et8zQi8Xj6w6DlPzUuuFhTPk+ney7cj2Z5sj3bPg51OgkAdS2UUXA/xZj4QmOGhk/Dwkmemn+5EdBiUh12zeaTn7HfKtlrwx2eM5nzZaQDmEUhflrlizJSkWdSUvXYBTuso3/orwUCVTQ3OPQzgC0Yah3FI1W38J9gdA0H3azZpyHslmrIKJnqgoH+92V6H/pffoV9mCAYda1XBrc9dqpSoHNHR6W6XaM3nA9LFlaUBsUtSwuJ4DhtyTgydDZNd4wYRORDfBb3/ps70nyOXZhg==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from SA1PR11MB6733.namprd11.prod.outlook.com (2603:10b6:806:25c::17)
 by SN7PR11MB6750.namprd11.prod.outlook.com (2603:10b6:806:266::21) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.6745.36; Fri, 8 Sep
 2023 20:23:16 +0000
Received: from SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938]) by SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938%6]) with mapi id 15.20.6745.034; Fri, 8 Sep 2023
 20:23:16 +0000
Date: Fri, 8 Sep 2023 13:23:10 -0700
From: Ira Weiny <ira.weiny@intel.com>
To: Dave Jiang <dave.jiang@intel.com>, <ira.weiny@intel.com>,
        Dan Williams <dan.j.williams@intel.com>
CC: Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Alison Schofield <alison.schofield@intel.com>,
        "Vishal Verma" <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
Subject: Re: [PATCH RFC v2 03/18] cxl/mem: Read Dynamic capacity
 configuration from the device
Message-ID: <64fb82aee859f_1e8e78294f9@iweiny-mobl.notmuch>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
 <20230604-dcd-type2-upstream-v2-3-f740c47e7916@intel.com>
 <db3bd5d0-640a-b121-f3e7-cfb73dc6c9ff@intel.com>
Content-Type: text/plain; charset="us-ascii"
Content-Disposition: inline
In-Reply-To: <db3bd5d0-640a-b121-f3e7-cfb73dc6c9ff@intel.com>
X-ClientProxiedBy: SJ0PR05CA0139.namprd05.prod.outlook.com
 (2603:10b6:a03:33d::24) To SA1PR11MB6733.namprd11.prod.outlook.com
 (2603:10b6:806:25c::17)
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: SA1PR11MB6733:EE_|SN7PR11MB6750:EE_
X-MS-Office365-Filtering-Correlation-Id: f58758bc-6ec3-41be-e7ff-08dbb0a96f45
X-LD-Processed: 46c98d88-e344-4ed4-8496-4ed7712e255d,ExtAddr
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;
X-Microsoft-Antispam-Message-Info: hCsPf3/TFzf94w9uxW3rkSgDUm/BY5lnwjI9lxAmLB3A4jr7UoN/3HGM7q4iqgkGKQXUVl5fHN+cHy+2kkk14R2cIKlhaXkhVt5mWjQ1YjTLDN/P2JRWDv1llQSYfO51HqtRudUHqAXA0qjzyJp/ayR1xZsqzsubpBS2AzZMgPhBRN+Ft1DIoLWXJjqwLMpb2s8cvAAGtkC8Oe8rQIgafQfjQxJwivxzO20CGLT+Qyxw7ckD8oXV+VGD1mZ4Ghio28l5mJObhZ8al2QJsHy4Zc2b8sWNL8HGXRPjx33FWWmnxJ3Xc5w/TcV4TUVXJOS7cDQEEIffEDjMMz7Kp5/G7/HFOJ3hXyZqH/G43zx2BnkACKIxHt/0up9XYbx8Kou2CbQwZIVz4kmZnQMGGi5HWXZWDKigciivmlZN4xS0aYCsx8zi+GdidhPjzsr6IN567HpgePY8TyQ9ziGsvRYuJKSSa/fomJ5YXhvbwz6VLfFYZZJYo2OhQopvspRx/gVtX/c88zwxEQi/S5/M98z9AHTkE5xzes8zK8/BA4saBrVYamQmAjPR0gjW4IoxyVet
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:SA1PR11MB6733.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230031)(346002)(396003)(376002)(39860400002)(366004)(136003)(451199024)(1800799009)(186009)(26005)(38100700002)(5660300002)(6636002)(54906003)(9686003)(66476007)(66556008)(316002)(86362001)(66946007)(110136005)(478600001)(82960400001)(6512007)(4744005)(41300700001)(8676002)(8936002)(4326008)(83380400001)(6486002)(53546011)(6506007)(6666004)(2906002)(44832011);DIR:OUT;SFP:1102;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?us-ascii?Q?ef4GnbLCLo18oCqqot+ksBiNgGZBbJx2ObAusgVbYX/vF1kqlDGzoW75mM3U?=
 =?us-ascii?Q?tXTi5wfO0X9/RQ1D+GPqnYA1dJ0kus3ZPEdQY6Ddln7ZlN0fW68wV7t6YqA9?=
 =?us-ascii?Q?LVb8TUSzq/zU7eoUHlhGHpO493qEi7rnuBOtCNPTDxOAkY0tRkKadybwOk76?=
 =?us-ascii?Q?BxfDTtkNBIn4ZeIsca+yYzlx77eRJe1CNuXUu+zkQlcWzg9njphqcEAYjadR?=
 =?us-ascii?Q?1zGcMR77ggzdKthFG+20Rlo2MN5YCth1bDck4ler5W6HThB2NT3tXn+Fe7Xw?=
 =?us-ascii?Q?BEpjE9jEpYYlpzv7Ac8Yw/MUu1op8zUF+Bl9XNN7jsZR9XhznYzfFSdboUt9?=
 =?us-ascii?Q?7VlYydhO+ehgT54MSfB7WyUELm7FSb0EXynjBbPUTK7w2PNkyBLw8sEqns0X?=
 =?us-ascii?Q?AlFs+KfZglseQ6MHBB+0ZwdanwH1DCJiLf2IP6iN1Rpg1dkRtL0myfZBAK82?=
 =?us-ascii?Q?zt88XjQGgv617QAX3K/kb0XXPwFIpKLF+CmlqK1StKKKHlWNI9KXXOBUhcFX?=
 =?us-ascii?Q?z90PP1IpVqeSFtFYWjWHmOuHJINvp1FKvq4idLa6ky1B/KeEuAT5MTMMVaGM?=
 =?us-ascii?Q?mBDKTypdt37KjQZwWk/duS+I51hOXXteopuHb4Cv10H3BKJzV5m9O+Ceki/E?=
 =?us-ascii?Q?k5Y9E/7ZZaizYc1y+KsQKFCKDIHDX8o+VKFL7LJwic6GcpIwjG70kJdavx+p?=
 =?us-ascii?Q?7T+JFF3a+AdWc14DMQ5/onSvQpgyvOEX2wV/KWzF7wgTm6LgahXXod8HVD7g?=
 =?us-ascii?Q?LT+qe0d97D4t4qODgJQQkZfkaiZ+juhvysx/NhXiKK2GUHhXMjGJZYqUx2bP?=
 =?us-ascii?Q?jjmFlcocA1yyCYduc+B9RQehPO9GoZlMPs9WGKFbBvg7oHa/zbd+S3se9kIZ?=
 =?us-ascii?Q?6m/tR/oMifoWwY47Q1K6qt9Aqv4JKIPC5BxmRlfBFvmgXoQbNci5SFjfK2rO?=
 =?us-ascii?Q?3lHWUeGgOOjfxyJOWpt+N8bj6a5e37QGrshdON+vKX0l/5iT8IZ5pfM1QMSH?=
 =?us-ascii?Q?vDxA0tvirxYB/8IkWJ0dxUKwIkQZgaB9SW0pAnP7SiXXWmfRGHrPh+klS9pz?=
 =?us-ascii?Q?Nhd/G90iwulyJHBz8Q6ZtPgcyiAMfftQ+cH/mcOeDIVHqTLqG22/CY1eEhMv?=
 =?us-ascii?Q?qdzDx4w1F0GMQKo6Jo35NseAiVUK+9ToxPuKIRa27uYsICb968azofBp8WXO?=
 =?us-ascii?Q?Ujpj7ZbryYzU2got3mwhKklQV7QYef/CekVMuv+3PrCwybYDUHkNEPyqE0Py?=
 =?us-ascii?Q?shfLh5nWbiYJ+GUAPj9qT2rl6kGeB02d0ew5IlSm/x61A0zyosJgvn70XrLr?=
 =?us-ascii?Q?iQoYdDQsBXZoOMV1ThuojzspaYm7pUP6zAuQLZ3tddc7ma5OTlg4u6xdvxab?=
 =?us-ascii?Q?oGyYrfHSxtG4z7dJiwb6ZLhgi6LE+enGAJ8JO4tfcUMVnIQDkgtEi1FLE0dD?=
 =?us-ascii?Q?XkMBTUJqD1ojNsb6G1NnvRd9mpNF5isM0ey7YLXRw/KhZgeEEnkLtXhG8hCZ?=
 =?us-ascii?Q?U6UdK+Oe9v6ej6oJNN18uouQNO8yommBuAKn2/ZohmMSZRxufhFZD5Ex0W/H?=
 =?us-ascii?Q?EJfw5Z+t5rwDiF9fQFhzY0sZj4z5w7HS/a1RB5gh?=
X-MS-Exchange-CrossTenant-Network-Message-Id: f58758bc-6ec3-41be-e7ff-08dbb0a96f45
X-MS-Exchange-CrossTenant-AuthSource: SA1PR11MB6733.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 08 Sep 2023 20:23:16.8014
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: 9jXDO1scxQ0Vys4ZNRfDIzeFPecNfqRoL02VSgTIq0Ds0xX5yIKLF/RAZ/VJLPJz0oslUcHUIYnJcTIZbxykkQ==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: SN7PR11MB6750
X-OriginatorOrg: intel.com
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

Dave Jiang wrote:
> 
> 
> On 8/28/23 22:20, ira.weiny@intel.com wrote:
> > From: Navneet Singh <navneet.singh@intel.com>
> > 
> > Devices can optionally support Dynamic Capacity (DC).  These devices are
> > known as Dynamic Capacity Devices (DCD).
> > 
> > Implement the DC (opcode 48XXh) mailbox commands as specified in CXL 3.0
> > section 8.2.9.8.9.  Read the DC configuration and store the DC region
> > information in the device state.
> > 
> > Co-developed-by: Navneet Singh <navneet.singh@intel.com>
> > Signed-off-by: Navneet Singh <navneet.singh@intel.com>
> > Signed-off-by: Ira Weiny <ira.weiny@intel.com>
> 
> Uncapitalize Dynamic in subject
> 
> Also, maybe split out the REGION vs DECODER as a prep patch.

Both done.

Thanks!
Ira

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 88338EE8013
	for <linux-cxl@archiver.kernel.org>; Fri,  8 Sep 2023 15:36:07 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S241115AbjIHPgK (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Fri, 8 Sep 2023 11:36:10 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:55754 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S232853AbjIHPgJ (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Fri, 8 Sep 2023 11:36:09 -0400
Received: from mgamail.intel.com (mgamail.intel.com [192.55.52.151])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id B2FF21BFF;
        Fri,  8 Sep 2023 08:36:05 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1694187365; x=1725723365;
  h=date:from:to:cc:subject:message-id:references:
   in-reply-to:mime-version;
  bh=z8+OgtB6PsW2OCqnA/aFlOPL5hdeI/O9/ahIRx2dXf0=;
  b=FLoVWWKZcsVbPvd2KbpBxRnSWi6u98YVh28mFP+Kv3ypAqNKLhUhU3PE
   FkIFT9k0OjJZRvGxTv8ZBh7bEcOlHXOK1W8Z1fNQhFHHh9cy4WfFAEguu
   6BCBVF3uJ9azfzn7OgRcW3ZddkVqf9Jdqk2xzpSq4SZGvH6JbBYnn8uWt
   O5CyM5VC3fOzqS8iQw41mHMBOM8QVBxdgqHQDYk6cyK7hc3wj25eQoFXn
   u5QK9EurKxuMmOvXl4LtT1HlvjYxBS2u2WWzUza+Eu848+P6tJomu9sxa
   1AK3Ql9Agxvw7wpQaOxTGjlWsgbl21bkRUJ1Wy7jbDJ4CkV0K4NXe9Grs
   A==;
X-IronPort-AV: E=McAfee;i="6600,9927,10827"; a="357978802"
X-IronPort-AV: E=Sophos;i="6.02,237,1688454000"; 
   d="scan'208";a="357978802"
Received: from fmsmga003.fm.intel.com ([10.253.24.29])
  by fmsmga107.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 08 Sep 2023 08:36:04 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10827"; a="832695267"
X-IronPort-AV: E=Sophos;i="6.02,237,1688454000"; 
   d="scan'208";a="832695267"
Received: from orsmsx602.amr.corp.intel.com ([10.22.229.15])
  by FMSMGA003.fm.intel.com with ESMTP/TLS/AES256-GCM-SHA384; 08 Sep 2023 08:36:04 -0700
Received: from orsmsx610.amr.corp.intel.com (10.22.229.23) by
 ORSMSX602.amr.corp.intel.com (10.22.229.15) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.32; Fri, 8 Sep 2023 08:36:04 -0700
Received: from orsmsx612.amr.corp.intel.com (10.22.229.25) by
 ORSMSX610.amr.corp.intel.com (10.22.229.23) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.32; Fri, 8 Sep 2023 08:36:03 -0700
Received: from orsedg603.ED.cps.intel.com (10.7.248.4) by
 orsmsx612.amr.corp.intel.com (10.22.229.25) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.32 via Frontend Transport; Fri, 8 Sep 2023 08:36:03 -0700
Received: from NAM10-BN7-obe.outbound.protection.outlook.com (104.47.70.103)
 by edgegateway.intel.com (134.134.137.100) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.27; Fri, 8 Sep 2023 08:36:01 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=jQwzolUSMXdxPN7T+22BsrQJ+GYm15RWkyZ2gurvmXqE7XOyuclDc/5+H/Ug2hRoEw+zLceZceW5opG9s0s3sH4Hyt1/TmRPXkXTkMg+cF1cBhnNd/MbgaWcTlloAZfbzB4i1SIi8hzeysBdDqXM+eikzNz9hTTbrTvoDZUhcJHzRIVkrZvSS++PuXNJ2r610ee1Q8oHiVLb5CgomQnw7Bko1ejJmdDomJ/iTLr1NBCpw60xtQTbSbUVgkLNdgdU4EclgVgBWzOSjFmieBR1c+b5eSJlADvtlwWXyRv/a2+fJ8CgwX6m2DS2OnFmRWnwrKRypVA5l3zb0eOYxNLF0Q==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=58anqLNTxzKzUGCm2Ndb/PtuVSElxyPqteXUNulTXPM=;
 b=aOFn2CmNeP4ZDwiL2+cAuan6uqatFErxIfuwWwSGkE5u3jmgX09D2mtjq7UAY1OAsPAjO39+yZ2BfnKQjBP5TlTXBkwuu64eJ/GBZwmpoho3QXSPX+rnDy+SK+NOstRP9u9KN9Rf+Pn+2D/zR39B6q1ng7WIgUQGKZ2M1ODPdHkaLc95HyqowUGZIoStJY/4XotGtb1P0oxgE44+kGRzIIuoPosaG4CUVrmShOOvvCWUHLP4pfgdbDijuwe0FNvHGtk5tMGwSRklVCyo2yOytaEkpQrdL+qdNNdCh/K8cRzgszu5dUCPrJ5S14qYpwPCaPErY4uZEpCjieKj+GUFeg==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from SA1PR11MB6733.namprd11.prod.outlook.com (2603:10b6:806:25c::17)
 by SJ2PR11MB7547.namprd11.prod.outlook.com (2603:10b6:a03:4cd::22) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.6745.34; Fri, 8 Sep
 2023 15:35:54 +0000
Received: from SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938]) by SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938%6]) with mapi id 15.20.6745.034; Fri, 8 Sep 2023
 15:35:54 +0000
Date: Fri, 8 Sep 2023 08:35:49 -0700
From: Ira Weiny <ira.weiny@intel.com>
To: Dave Jiang <dave.jiang@intel.com>, Ira Weiny <ira.weiny@intel.com>,
        "Dan Williams" <dan.j.williams@intel.com>
CC: Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Alison Schofield <alison.schofield@intel.com>,
        "Vishal Verma" <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
Subject: Re: [PATCH RFC v2 10/18] cxl/mem: Handle DCD add and release
 capacity events.
Message-ID: <64fb3f55b9392_1e8e7829433@iweiny-mobl.notmuch>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
 <20230604-dcd-type2-upstream-v2-10-f740c47e7916@intel.com>
 <3546729d-d67d-fc93-5c03-fc864fd23b4e@intel.com>
Content-Type: text/plain; charset="us-ascii"
Content-Disposition: inline
In-Reply-To: <3546729d-d67d-fc93-5c03-fc864fd23b4e@intel.com>
X-ClientProxiedBy: BYAPR04CA0023.namprd04.prod.outlook.com
 (2603:10b6:a03:40::36) To SA1PR11MB6733.namprd11.prod.outlook.com
 (2603:10b6:806:25c::17)
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: SA1PR11MB6733:EE_|SJ2PR11MB7547:EE_
X-MS-Office365-Filtering-Correlation-Id: e75dd36a-b639-486d-ebc4-08dbb08149fc
X-LD-Processed: 46c98d88-e344-4ed4-8496-4ed7712e255d,ExtAddr
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;
X-Microsoft-Antispam-Message-Info: zUU2qHJjtU5ECVH2KtOMUgYyorsKaTeW2AZnugT47KNYtIGFME9wyxZ5eq9v3n5XMNBMJOdhcR7OhoSQH/9VGGkbd02VPM2PYLEriqo/k87Xe/S6Atlk5EYDDdcvyCCfI8cgbxzwPSvOi5ytvUKa5QsOIRzA57Edv614pDFXUdfHm++XZeTyyq72frlv+Zdbtn1M4zZoaiXB0FLLW0IeNUXrSZ0FftENI69WwtTyrCye96VAsz2HKzivnpsj6o8s2DRDEZ2MhK9kNLZ+2Tlzb23J+Lz0+gZuFGz0D2kTbbyTPQAbGDMUabuWApxjzZvx8bxHpLRL1/7xpzzI8lxKtHcowkqk2qTHgEtdJpwlaFBM9OHRhi80j2IqUngrcJngk4PGglzDoZXAZaalzTmNyWF8aDUI50TIy95fuNwuJ/7MZW6zsJe9lNlWPCK6oz+pfSrQI0ma3UM+lakksJRPjtaJtnAckiUaeewPDRboDS2J50tIS6vT7OqylsI/vR8jtLuVNN31Vr0VX2Mvn+/th8/J1GO/duijzHRH9jLCh/FJVu6sg3Kzq/9wIbmQCBHQ
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:SA1PR11MB6733.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230031)(376002)(396003)(366004)(136003)(39860400002)(346002)(451199024)(186009)(1800799009)(8936002)(4326008)(8676002)(4744005)(478600001)(5660300002)(66476007)(110136005)(66556008)(44832011)(66946007)(83380400001)(2906002)(41300700001)(54906003)(316002)(86362001)(6636002)(6666004)(6486002)(53546011)(6506007)(9686003)(6512007)(26005)(82960400001)(38100700002);DIR:OUT;SFP:1102;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?us-ascii?Q?5jCV7QgJTScwwpcWaz/yNVxhEuk3vxdpEpYm9J0hDMz6/OPt4vQQ8klip+/j?=
 =?us-ascii?Q?5BDkHDBNzlOhNcCz0yfkDyZ3APu++kh24yG6eOSeTpuSu2xIH3c+Zbd1CI+4?=
 =?us-ascii?Q?0tCv9JAN0W38r0nExfv1DeqrgBkhhzCZA8RdjDHkj0M7XF3E0uUD555JT6ws?=
 =?us-ascii?Q?Xaq+vbXn1wESbJ4yGfD8k8kpN0c/jCkn5SHatNOhYJOIUW+pdh6YA0pIaM9F?=
 =?us-ascii?Q?4a9dfWu1lRS7oBR6YHBsqFymfT0rAdTDuDlsKdvdHjqCQhIc40iuKmBmE2wd?=
 =?us-ascii?Q?0+NhNUYb71zuVC/ZQ5gc8VyhyrekGFR5V5ljg0bTATxrBLX8Blm6CcDwuIJP?=
 =?us-ascii?Q?zCaGwKffk1SSiy0IMOb2qi0huqJaTQ1oR0QzCXUcQ4kv/7BoEhCatP4ZwpnT?=
 =?us-ascii?Q?Czk5ZQ9eVwjoSlLYAg5kT/rjwuMd5bDPLHkz7iVBXCEdEUH7fZ91vWCfkhKi?=
 =?us-ascii?Q?Hj7/qc6PEc5j+arqGJTW036WiOlcb5wJIWawQEvlBvt735+dL19AbCDvqelT?=
 =?us-ascii?Q?cwXrFI0xb2ox8mhVRDewHjOAnLERQ7NRea3nw/Sw+2hpil6Fd0D/UiuGVwc4?=
 =?us-ascii?Q?LqcMtmiSMN8Gov76a8DsV0rRzIHi3IY2IFG3CV0wiZaUsrqC9eENAe3j7q/7?=
 =?us-ascii?Q?L+XxgSPEopoqvyVta4dVOQTUXhNhqesU1Vo7SyMHYDPb722MvWxkZ6uMEJRw?=
 =?us-ascii?Q?vxN0/QdOvT8Mrz7PoTRroEge5YRhBzzjtInGcpCNKH9B5GbDXcrEVDvpLalA?=
 =?us-ascii?Q?bJd4t/4k3PVdzkroInu6tAevg014N/jrOztEFGuIHPrv6Z1jehnJi5BeEIXv?=
 =?us-ascii?Q?fQDnQAXrzXFkYh3UPnodecEj7dpd4oJnS+L2hYzsKlAd4YDeR6qG/t4ttY6d?=
 =?us-ascii?Q?UDqWKeCUXvo4nOkuiTcy2nAjLEIvB49XDA44zoBGVKYcLrUzJBIld8q8ffx3?=
 =?us-ascii?Q?3hlROhZQd9N5/Xk2DscUssOTW3gZVztPOuXUEZu28VJsO9ASC0M9jCeullVY?=
 =?us-ascii?Q?Gno1izYWFaek71wIEgeU3CBoCV7QHsukbc52lKv8ruoqqCYwK3qOGX9Er9YC?=
 =?us-ascii?Q?HKIKEFDSGk/8ZlBEwZkWb+cZG1xxUCe9WCG0kaGQ3cXPdr1IR0mI248YUXs1?=
 =?us-ascii?Q?RzmFO5ob+MducHB7hDCpc82MCryIyOKAtrWvix4NosFq5p8NKadTR8kbXGDR?=
 =?us-ascii?Q?SW+ygX4y478TouheK1liVm5Ih8eaTPF47ZVNYDoFPQTDzPcLOQmDLKG848yM?=
 =?us-ascii?Q?OI7r6RS0rfLbdKwGL/vvN9tGU3pqGgSQtafOqxN3IUFb9Nx702NDqWDzl/tQ?=
 =?us-ascii?Q?eu8i2hRIdGqxwgwnP5i+LbpOJ9pECWmFblPDhbZATXc9UwEurhZ6rQo+aNP1?=
 =?us-ascii?Q?7LUSflrApaBxNbPwgNjDSosuidKGZPKQ6h+rsXwk7EPt+rOIEJeNZlqXPcAm?=
 =?us-ascii?Q?sZnnn86rbS5fcOBvx4fJDkrXwSbKOQhgKUrL1bylhmT/KH8lUfRWPVsxzsmi?=
 =?us-ascii?Q?BQBz1R29bOja2jusjWToCXqAX6HhgsEe3WbFOiJqWF5auZfhpns3JWowg5qN?=
 =?us-ascii?Q?V/Wd6syX2Erged/7YuUphbzz6ImJc31OTmuHAAPo?=
X-MS-Exchange-CrossTenant-Network-Message-Id: e75dd36a-b639-486d-ebc4-08dbb08149fc
X-MS-Exchange-CrossTenant-AuthSource: SA1PR11MB6733.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 08 Sep 2023 15:35:54.4195
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: 9tNRnOG8RxP+7O1R+Vi7iLhv59sKr7mzr8IOjS5OHvv2iOO2L9bZ4hD2aNUWuUUAJBo8n3vC/xLDJqroAYAKRA==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: SJ2PR11MB7547
X-OriginatorOrg: intel.com
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

Dave Jiang wrote:
> 
> 
> On 8/28/23 22:21, Ira Weiny wrote:

[snip]

> > +
> > +/* Returns 0 if the event was handled successfully. */
> Is this comment necessary?

Not really, deleted.

> 
> > +static int cxl_handle_dcd_event_records(struct cxl_memdev_state *mds,
> > +					struct cxl_event_record_raw *rec)
> > +{
> > +	struct dcd_event_dyn_cap *record = (struct dcd_event_dyn_cap *)rec;
> > +	uuid_t *id = &rec->hdr.id;
> > +	int rc;
> > +
> > +	if (!uuid_equal(id, &dc_event_uuid))
> > +		return -EINVAL;
> > +
> > +	switch (record->data.event_type) {
> > +	case DCD_ADD_CAPACITY:
> > +		rc = cxl_handle_dcd_add_event(mds, &record->data.extent);
> 
> Just return?

Fixed from Jonathans comments

> > +		break;
> > +	case DCD_RELEASE_CAPACITY:
> > +        case DCD_FORCED_CAPACITY_RELEASE:
> 
> Extra 2 spaces of indentation?

This was a checkpatch issues.  Fixed.

> 
> > +		rc = cxl_handle_dcd_release_event(mds, &record->data.extent);
> 
> Same here about return.

Fixed from Jonathans comments

Thanks for the review!

Ira

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 15188EE7FEF
	for <linux-cxl@archiver.kernel.org>; Fri,  8 Sep 2023 12:47:06 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S243389AbjIHMrH (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Fri, 8 Sep 2023 08:47:07 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:42250 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S243317AbjIHMrF (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Fri, 8 Sep 2023 08:47:05 -0400
Received: from esa4.hgst.iphmx.com (esa4.hgst.iphmx.com [216.71.154.42])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 688521FF9;
        Fri,  8 Sep 2023 05:46:34 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=simple/simple;
  d=wdc.com; i=@wdc.com; q=dns/txt; s=dkim.wdc.com;
  t=1694177194; x=1725713194;
  h=from:to:cc:subject:date:message-id:references:
   in-reply-to:content-id:content-transfer-encoding:
   mime-version;
  bh=7ME0ZBuuwdZ+vcL0OOogmYITIM77/dJa2MhYKOEFgJ8=;
  b=ScLV3Tu4gGclI9U4ZdKLUsg4bavD3EN8rLYp0R9aL9tWrZ6lVIHzkyEl
   MCwV+asjT+1BzhOaRZZpKwz8SyoNW8DEEhcL/v75a9/JXikndn0BjzFXM
   hOxX/UNbqyzr82EYPfsjbuvYKUjYwXxHwWrHvpINtEHWV16QbmSTsedVj
   oUdFIlgp8N9MlN3vQHCTcp1bUGSp/fvwy9I646IFSPTrd1qqwofEZLiWn
   Ir7XL0AoDK4t95P6HoEVvUaiVuaBus66j7B5xtkBqrrWeRLpSAajr+0j3
   6dLh6WLswMsPz6Z8dKM0oQS47P6u7Gq/QuRu+csRrj7OPnM7jRAbln8Ua
   w==;
X-CSE-ConnectionGUID: tVFKLG6ERw22yNMEoqeRiw==
X-CSE-MsgGUID: QXjIRkeySb6p5Ej4OmKWvw==
X-IronPort-AV: E=Sophos;i="6.02,237,1688400000"; 
   d="scan'208";a="241561995"
Received: from mail-bn8nam12lp2168.outbound.protection.outlook.com (HELO NAM12-BN8-obe.outbound.protection.outlook.com) ([104.47.55.168])
  by ob1.hgst.iphmx.com with ESMTP; 08 Sep 2023 20:46:31 +0800
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=dmMDSA17jNWhhQXId5H+5+DxUIBQPnG9Fo3I077SzhVP/UUViY2wWsxvHCy54r98gREcr/seYPCTOnze4cLJAzN63WR91hDVicp64S+cICBoy7tzfnpGxZh8uDNYSyoodv0jRp1+CYozuyziievXx8JiQfDhD4W7DvQqSdsKRxsB1K+vtWGOOaB5iku86nZITKXVHI8U8oObRSQ1SEr3aWk4e5CI3sRcZfEP9k+3krzeZxQR+rTJmrmmN4kj70g8IjMVEX6op/k8LtQdnwd5bqvfSLLUG9uTNfnkocdWDiouRgZs6V6BxSYOD5qnnSCn07myIasVtxb6ZWJNJQ4+ig==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=7ME0ZBuuwdZ+vcL0OOogmYITIM77/dJa2MhYKOEFgJ8=;
 b=bTM62g4jNWXJWsY5FPuBJtKrmwdCIV54hlblrem9js5JPZjXGdUPMOA3ZOIVXjOGqvfraukorobR1cMqGWHegoQpQR+xFbufXWRvFQhg//7iw4xlF8G6zwRRqpZlkDPyqDEH7wjl5SEJ7VcvEO08g5/XBfWrx0CcoHxtX3PfR62JCosJk1FJ4k+FACbIhvtLTSr3FTWrU65iH5so6TYWPOUmWbeCgLnVWKUM3WB7wlnrfQMFI6+3qt7Si0yeD+HFPlGWB3Tj+N4glLwzuuDhteyS761MpC1WCGCGlxpcgqu0J1EjWh5I7zfiPEGhK3sYQuXRFvoR9f6W0xsHPbrVQw==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=wdc.com; dmarc=pass action=none header.from=wdc.com; dkim=pass
 header.d=wdc.com; arc=none
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
 d=sharedspace.onmicrosoft.com; s=selector2-sharedspace-onmicrosoft-com;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-SenderADCheck;
 bh=7ME0ZBuuwdZ+vcL0OOogmYITIM77/dJa2MhYKOEFgJ8=;
 b=OSl5f7vctnh718jsc0TWjw36iPshZY+W3d1VqcBNz1caujfgETogEWsG2inNIPqlmcaibMpOpTOZl7XbdhvsT4Z+rIZ2NpvXAFI6hMfGAewAGqFnDFm5X4RsQHuhANtGF2gd+2vk8+KczfG7wLAclw7YpEPa1EKMyb88McpzhwQ=
Received: from SN4PR0401MB3582.namprd04.prod.outlook.com
 (2603:10b6:803:4c::10) by SA1PR04MB8783.namprd04.prod.outlook.com
 (2603:10b6:806:378::14) with Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.6768.28; Fri, 8 Sep
 2023 12:46:29 +0000
Received: from SN4PR0401MB3582.namprd04.prod.outlook.com
 ([fe80::b35e:d4f9:1de8:f321]) by SN4PR0401MB3582.namprd04.prod.outlook.com
 ([fe80::b35e:d4f9:1de8:f321%6]) with mapi id 15.20.6792.009; Fri, 8 Sep 2023
 12:46:29 +0000
From: =?utf-8?B?SsO4cmdlbiBIYW5zZW4=?= <Jorgen.Hansen@wdc.com>
To: "ira.weiny@intel.com" <ira.weiny@intel.com>,
        Dan Williams <dan.j.williams@intel.com>
CC: Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        "linux-cxl@vger.kernel.org" <linux-cxl@vger.kernel.org>,
        "linux-kernel@vger.kernel.org" <linux-kernel@vger.kernel.org>
Subject: Re: [PATCH RFC v2 03/18] cxl/mem: Read Dynamic capacity configuration
 from the device
Thread-Topic: [PATCH RFC v2 03/18] cxl/mem: Read Dynamic capacity
 configuration from the device
Thread-Index: AQHZ2jkq4W9yk25p50CfKrd+1ysf67AQ8IUA
Date: Fri, 8 Sep 2023 12:46:29 +0000
Message-ID: <1d49b674-81ef-081e-97d0-2e0c5a54af6e@wdc.com>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
 <20230604-dcd-type2-upstream-v2-3-f740c47e7916@intel.com>
In-Reply-To: <20230604-dcd-type2-upstream-v2-3-f740c47e7916@intel.com>
Accept-Language: en-GB, en-US
Content-Language: en-US
X-MS-Has-Attach: 
X-MS-TNEF-Correlator: 
authentication-results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=wdc.com;
x-ms-publictraffictype: Email
x-ms-traffictypediagnostic: SN4PR0401MB3582:EE_|SA1PR04MB8783:EE_
x-ms-office365-filtering-correlation-id: 6a47c8f0-e6ea-4db6-4815-08dbb0699f49
wdcipoutbound: EOP-TRUE
x-ms-exchange-senderadcheck: 1
x-ms-exchange-antispam-relay: 0
x-microsoft-antispam: BCL:0;
x-microsoft-antispam-message-info: U0zydx7/UYVGlLVOR/vsQB8H7CbaQxoOSwjfQTUL7BKJ41loz58jIuHtb9bFLJxJwDLRb9yq5Gm+z8ykLDR6x/fUYAEnD9AKAy7eu7t9z7VnpyiP9oG3GmhAiTUNxRbI0V+3VJlIu06euuUZWvu7hMYpJwdCx2C4ORmH1zHofyW3DtAcJ1xfOTRsBNHeEr/fYkfv6SFFN/qTi3dSeTIqAX5GftqTWxmv2Gx0iKnAt+F6iV8UsM75LUliGt3h+zbRy8OrOrp8T/vDAZwyTSQpxfdznSvxFj3M6svbUEkjLfob4/tmamyxpklu76/r/DwGlECHyBB2aseMbaU6vUQttxA5tCt2yianR0o9xyEVdYpkoh8cPVS4djnxDMJKjI5H2X7MBant9wTQP045TylJs+VQVqRoW1w0w1FEHP9o110DWFByw5+ZWl1WP8OivP3un1zX+DHQ8XTfI2JSmO/5C5PKDhOLkS0zxYFlXWbHE2U8zGoReNEPgn5FkFmnxJRxzsVNdFjboEd72pQXMjQwBXSGOTofi3q5fcSfMxwWC5bAvj38mGcmhePnMJ0o/ocOHsHqDgaEVUVPwlLjdn0a6bNrFt1iGD6DkW/9NazvMT01VlRzO+Lp6wtEA3Y8Q/MSJmCijqKqcJaM2F5Eo+kQ0Y+GVx4AhB+Eg8A9ISvjeb39JUKh7RpCkBXKW4nv4W2o
x-forefront-antispam-report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:SN4PR0401MB3582.namprd04.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230031)(366004)(39860400002)(346002)(136003)(396003)(376002)(1800799009)(186009)(451199024)(38070700005)(82960400001)(122000001)(31686004)(53546011)(6486002)(6506007)(71200400001)(31696002)(478600001)(38100700002)(36756003)(85202003)(86362001)(85182001)(2616005)(2906002)(30864003)(26005)(6512007)(83380400001)(66476007)(4326008)(91956017)(41300700001)(5660300002)(8936002)(8676002)(64756008)(66556008)(7416002)(66446008)(316002)(54906003)(66946007)(110136005)(76116006)(461764006)(45980500001)(559001)(579004);DIR:OUT;SFP:1102;
x-ms-exchange-antispam-messagedata-chunkcount: 1
x-ms-exchange-antispam-messagedata-0: =?utf-8?B?bW5raWRnRTE3K3BwRzRubVl1bkNBVnRQekhpbGNDUUN5ZTVSeFZSVng5bEZQ?=
 =?utf-8?B?Y3hJS0xBUi9JR3dnUStVUEM2WHhLM3RLS0ZBQlorak9YSmZ0VnFpcVdZSWhJ?=
 =?utf-8?B?dWZVVTB1TnpwcE1tOXpWWDhrdmZza1BkV0lrWUlDQVJZU0NuV0swaUpQQ1dz?=
 =?utf-8?B?RVpZNEdUM2ZXZzBKNWRLQk5MdGxWMmdWbWJweEFGK1VGdm1nWUt1UWNmUWR6?=
 =?utf-8?B?S2lSc0dpZjc3cTE4bnVIVi9DWnRDTGIyZWJuUm9JTlQ2MUZqRzBpNU12RmVz?=
 =?utf-8?B?SEFWY3B0K3FGMW4xWnZQWFRZYnlhY1pqMkt2TmpkVFJJTVRHUEtVeGkzekox?=
 =?utf-8?B?Z3JSMGZYNFZqVVkyNTZwWCtPaHM3MGM2dkl6c1BkWDRjWXM4ZEoxejdXb2hn?=
 =?utf-8?B?UitDK0tkS21Ra3NwaGEwUnBSN25Dd1VIT200a29BeTBBd1BjUzBhSEJCNGRP?=
 =?utf-8?B?ZW5HYUt6YWZXRWNyTjVURFlSTkFZL0dadlVoY2JIRlh6SWh4ZURJZCsrN1ZO?=
 =?utf-8?B?WjVSSGpUKzd3UmtmbmQ5ZmJlTXBmdVNoSFdXN0lpWXI5L2xWd3pYeEJsckJz?=
 =?utf-8?B?aVpoeXpNbVdUbGdnYisrVnNob1pOa1lYSkljUHE4WG83TXpDWFBFbS9XTXBz?=
 =?utf-8?B?YVcvYmJuaEEzN3FqaGZ5Q3AybGl6WGZMb0RWOW9iaGR4d1FpZVpuWmNqVWRz?=
 =?utf-8?B?ZTRDNjJqbFZPOTZjb2lhbXg0ZElYaXZjWGFYNnp2M2FvdDZUNGhYemF3aDFM?=
 =?utf-8?B?aGk2RmJsODRGckZ4SkppZWJJZ3VhV0kvelBNZ1BmK3ZXaVRMZTh1VWVlcmZ0?=
 =?utf-8?B?QXFMN29aY1E5YlRwbVBFeVFwS3Zlci9yK2V0ZXU3NGRId25UY0M5dE9zdEFj?=
 =?utf-8?B?c1lWaDV5Rkx0UXpXTmhxZDAwYTdndnhnenRxNnhRMklZbzFYUWpkd3VFOHl0?=
 =?utf-8?B?VndPVlh2ck0wVFEwZzJ0OHIxNDJyLzdQcC9xV2x2ckxuWDh6MzBxUUJHTHNR?=
 =?utf-8?B?anRYQ1lJQjE5aXI2RHZEek1jTFFaSloxU0JUeVZoZTk2YnZMMitmWnpSM2I0?=
 =?utf-8?B?Qi95RktRd3diazY3YllNamljUUlUeVdNeFZ3K1liak9Nb1FTc1h1R1J4azU2?=
 =?utf-8?B?YkNjRFVwSXE3S1Niams1enVRQ0xpMkpza1BZYW1hdjQxZkkxdVFjSGsxUkxr?=
 =?utf-8?B?S3QzUUw0U25QOFlXTklaUVJhSkJ6VmhSL0U2WXJzYXpGRjBFc2JwRE1QZDRY?=
 =?utf-8?B?eWRHenpDdU01WDM1Y05heXhkd2FaM3dsY3VXVFRyMElQYVZzbkhlVWtnM1F2?=
 =?utf-8?B?NEtPOGJtWm4xY2QxcjgrUWlaL3NzT3NCVTJ2aVMvNm9nWEg0UlFYSkhoTzFp?=
 =?utf-8?B?enJjaFBxcCtNbGV2MUpKMmJaN0xYM1NnNmwzTVZyZDczU25PTXRjbXkvMFNG?=
 =?utf-8?B?eTRYMXkrRzRUcmxZeURtS2ZydE9mQWxmeE5kUzRTMnorbFNDVEdkT09DdS9h?=
 =?utf-8?B?NEdDWm9Wc0RONjdXTkljZklFelhEeXN3VWVKREExMVZmQzFuVzBGTGxxaUto?=
 =?utf-8?B?c2tSK0U5Nkx5MDJWbUJEQW1DZWYweFJ2bkNXMEpoVDlOeWFCV3FkRy93Mm93?=
 =?utf-8?B?VWxDMjV1UE9Ua0ZXRjhnbXd5MkxFTzdEVXQ4N09kcGcvK0ZDVmVrMzN0MDNt?=
 =?utf-8?B?UmlpcWdmRjB2NlZSMnNUTjlkOStXdUkyUHRnUWxhcnVkcVhzSHRrNUVlOUg2?=
 =?utf-8?B?amZxT2t3RnJPcWo4YlQxTjM4aEpRQnlwd3hrVGhaa3llN24wd0dCMlZUaU9K?=
 =?utf-8?B?bmFWL1MwdzhkaXJLM2tSdmNsWi80cExSalpnTjBRNkRSdlYxRXUyV0dZZzZv?=
 =?utf-8?B?bnd3RkNnUlU1elNnZ1E2QU5IN0F0Ymw4a24rcy9VcEVtMGtjaFRWQjFXdTIr?=
 =?utf-8?B?OGJrSmVxTGdzQVBRa3VITXVndkIwL0dWdzB4S3RZamM4Y0FJY09kUC9JbGhv?=
 =?utf-8?B?SXBLRTZnWDVZQzRpZ3AzQnNWdk11ckkwcGR5aVgrUDdIZzIvSkZ1V24wYTd5?=
 =?utf-8?B?ZmZxdVBubWxHS2gxcGNHVG02OXZmNjRsTjQ1QisyMHFoLzIrcnE4aWxybjZz?=
 =?utf-8?B?d2swYzhUM0tPclV2WVNIUXBmck54OVBaRnIwVzR1ai9vbDhRMlppd3NPNzBW?=
 =?utf-8?B?dUE9PQ==?=
Content-Type: text/plain; charset="utf-8"
Content-ID: <55A70CC0FF718A4999BBAA8197FA0264@namprd04.prod.outlook.com>
Content-Transfer-Encoding: base64
MIME-Version: 1.0
X-MS-Exchange-AntiSpam-ExternalHop-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-ExternalHop-MessageData-0: fHg1RjTqMp68+/1h0UW4+eGhfWc+j7NuQnCYPHshTKKBHAJ5n46h2BWedVFcsd5g0pgbeASCXYjkwrX2MRiNQQw3UXv721Ya8ssX5cxyaGvrE0Lk4FHCC/SH35nM73/PdIWl3rdXM8A4H+NqZ0VO+scw6WlApmhmk/2Ph53py3WeA64is46yhaOd3uNxZ8XyxxX2XmF9NMDNz3hHVUTUnKE65KOxttASVRkurxJHdeshwAsT+1li2CYju7mAugbpLCa0ssj5sM/nOvrl0v2nIN1QcH9xIJ4oKYHGkomG//9Cj3eE0mh8H8ACsEdOxT1xJFKjqAI/Whf6EPr5q5tC6Poj4+Ap1ewSnyPSBDlYknVvxjM2MNEnSb5BAqgcntJwzGKKj8LtJNBg/YFxsg7y1ExFY0/dDRYlb2XrboOmdy8C05VrLdERbKySjnFaM2tOhWYpkuXfSq/WULnAEIS8EJoYw9FwETioo+4HO19u63JCdPobyPlz2K0M5OilqWS08BiqDrMEkyMQp7E5SnxZmwCwmyaV89E7+mhX7uwHn7ZqlA/1vIUmfkklJpq5dFrU3r4lMIxWCNak9pSX6PW5zY5jbONBFKCzvACYBp0mZDlAtnQXMh8nnjRL8k00asMMPtqNQ++6KHmsH8g6RP3xCOt/89mJldkiDy/mlqpOG+TVa+Z6dnIyiFjelO/okvnSTF0zhSADfsvAvhNNRAuMbzVKn9hFpsv17LyTNKiIbtNPo95fiYhZlYCJNYocasfBlhuFraZ+JoYSEnHvfcGbRy2O5NjEBy8ew9EVQ0MCLob01kRnqSjIF+Vha/ZClVgC8VD0ZrhNrNJSWCEb6ivlwW0pjCjE8ZAfQfz422l9DLsvmMu8yuZubv3agfRVF4fKN7rmz3v+DketC5aaYPAFAg==
X-OriginatorOrg: wdc.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-AuthSource: SN4PR0401MB3582.namprd04.prod.outlook.com
X-MS-Exchange-CrossTenant-Network-Message-Id: 6a47c8f0-e6ea-4db6-4815-08dbb0699f49
X-MS-Exchange-CrossTenant-originalarrivaltime: 08 Sep 2023 12:46:29.2889
 (UTC)
X-MS-Exchange-CrossTenant-fromentityheader: Hosted
X-MS-Exchange-CrossTenant-id: b61c8803-16f3-4c35-9b17-6f65f441df86
X-MS-Exchange-CrossTenant-mailboxtype: HOSTED
X-MS-Exchange-CrossTenant-userprincipalname: gbjDPPQqTV6OMXnQCA92QKEwHoiLjVIUgy4OFRkOaQ8BB6urIxhPy/QcNboXz+YG6v6YrURBia4TSw2xtNmoMA==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: SA1PR04MB8783
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

T24gOC8yOS8yMyAwNzoyMCwgaXJhLndlaW55QGludGVsLmNvbSB3cm90ZToNCj4gRnJvbTogTmF2
bmVldCBTaW5naCA8bmF2bmVldC5zaW5naEBpbnRlbC5jb20+DQo+IA0KPiBEZXZpY2VzIGNhbiBv
cHRpb25hbGx5IHN1cHBvcnQgRHluYW1pYyBDYXBhY2l0eSAoREMpLiAgVGhlc2UgZGV2aWNlcyBh
cmUNCj4ga25vd24gYXMgRHluYW1pYyBDYXBhY2l0eSBEZXZpY2VzIChEQ0QpLg0KPiANCj4gSW1w
bGVtZW50IHRoZSBEQyAob3Bjb2RlIDQ4WFhoKSBtYWlsYm94IGNvbW1hbmRzIGFzIHNwZWNpZmll
ZCBpbiBDWEwgMy4wDQo+IHNlY3Rpb24gOC4yLjkuOC45LiAgUmVhZCB0aGUgREMgY29uZmlndXJh
dGlvbiBhbmQgc3RvcmUgdGhlIERDIHJlZ2lvbg0KPiBpbmZvcm1hdGlvbiBpbiB0aGUgZGV2aWNl
IHN0YXRlLg0KPiANCj4gQ28tZGV2ZWxvcGVkLWJ5OiBOYXZuZWV0IFNpbmdoIDxuYXZuZWV0LnNp
bmdoQGludGVsLmNvbT4NCj4gU2lnbmVkLW9mZi1ieTogTmF2bmVldCBTaW5naCA8bmF2bmVldC5z
aW5naEBpbnRlbC5jb20+DQo+IFNpZ25lZC1vZmYtYnk6IElyYSBXZWlueSA8aXJhLndlaW55QGlu
dGVsLmNvbT4NCj4gDQo+IC0tLQ0KPiBDaGFuZ2VzIGZvciB2Mg0KPiBbaXdlaW55OiBSZWJhc2Vk
IHRvIGxhdGVzdCBtYXN0ZXIgdHlwZTIgd29ya10NCj4gW2pvbmF0aGFuOiBzL2RjL2RjX3Jlc3Av
XQ0KPiBbaXdlaW55OiBDbGVhbiB1cCBjb21taXQgbWVzc2FnZV0NCj4gW2l3ZWlueTogQ2xlYW4g
a2VybmVsIGRvY3NdDQo+IFtkamlhbmc6IEZpeCB1cCBjeGxfaXNfZGNkX2NvbW1hbmRdDQo+IFtk
amlhbmc6IGV4dHJhIGJsYW5rIGxpbmVdDQo+IFthbGlzb246IHMvdG90YWxfY2FwYWNpdHkvY2Fw
LyBldGMuLi5dDQo+IFthbGlzb246IGtlZXAgcGFydGl0aW9uIGZsYWcgd2l0aCBwYXJ0aXRpb24g
c3RydWN0dXJlc10NCj4gW2FsaXNvbjogcmVmb3JtYXQgdW50ZW5hbnRlZF9tZW0gZGVjbGFyYXRp
b25dDQo+IFthbGlzb246IG1vdmUgJ2NtZCcgZGVmaW5pdGlvbiBiYWNrXQ0KPiBbYWxpc29uOiBm
aXggY29tbWVudCBsaW5lIGxlbmd0aF0NCj4gW2FsaXNvbjogcmV2ZXJzZSB4LXRyZWVdDQo+IFtq
b25hdGhhbjogZml4IGFuZCBhZGp1c3QgQ1hMX0RDX1JFR0lPTl9TVFJMRU5dDQo+IFtKb25hdGhh
bi9pd2Vpbnk6IEZhY3RvciBvdXQgc3RvcmluZyBlYWNoIERDIHJlZ2lvbiByZWFkIGZyb20gdGhl
IGRldmljZV0NCj4gW0pvbmF0aGFuOiBwbGFjZSBhbGwgZGNyIGluaXRpYWxpemVycyB0b2dldGhl
cl0NCj4gW0pvbmF0aGFuL2l3ZWlueTogZmxpcCBhcm91bmQgdGhlIHJlZ2lvbiBEUEEgb3JkZXIg
Y2hlY2tdDQo+IFtqb25hdGhhbjogQWNjb3VudCBmb3Igc2hvcnQgcmVhZCBvZiBtYWlsYm94IGNv
bW1hbmRdDQo+IFtpd2Vpbnk6IHVzZSBzbnByaW50ZiBmb3IgcmVnaW9uIG5hbWVdDQo+IFtpd2Vp
bnk6IHVzZSAnPG5pbD4nIGZvciBtaXNzaW5nIHJlZ2lvbiBuYW1lc10NCj4gW2l3ZWlueTogZmFj
dG9yIG91dCBzdHJ1Y3QgY3hsX2RjX3JlZ2lvbl9pbmZvXQ0KPiBbaXdlaW55OiBTcGxpdCBvdXQg
cmVhZGluZyBDRUxdDQo+IC0tLQ0KPiAgIGRyaXZlcnMvY3hsL2NvcmUvbWJveC5jICAgfCAxNzkg
KysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrLQ0KPiAgIGRyaXZl
cnMvY3hsL2NvcmUvcmVnaW9uLmMgfCAgNzUgKysrKysrKysrKysrKy0tLS0tLQ0KPiAgIGRyaXZl
cnMvY3hsL2N4bC5oICAgICAgICAgfCAgMjcgKysrKysrLQ0KPiAgIGRyaXZlcnMvY3hsL2N4bG1l
bS5oICAgICAgfCAgNTUgKysrKysrKysrKysrKy0NCj4gICBkcml2ZXJzL2N4bC9wY2kuYyAgICAg
ICAgIHwgICA0ICsrDQo+ICAgNSBmaWxlcyBjaGFuZ2VkLCAzMTQgaW5zZXJ0aW9ucygrKSwgMjYg
ZGVsZXRpb25zKC0pDQo+IA0KPiBkaWZmIC0tZ2l0IGEvZHJpdmVycy9jeGwvY29yZS9tYm94LmMg
Yi9kcml2ZXJzL2N4bC9jb3JlL21ib3guYw0KPiBpbmRleCA1NTRlYzk3YTdjMzkuLmQ3Njk4MTRm
ODBlMiAxMDA2NDQNCj4gLS0tIGEvZHJpdmVycy9jeGwvY29yZS9tYm94LmMNCj4gKysrIGIvZHJp
dmVycy9jeGwvY29yZS9tYm94LmMNCj4gQEAgLTEwOTYsNyArMTA5Niw3IEBAIGludCBjeGxfZGV2
X3N0YXRlX2lkZW50aWZ5KHN0cnVjdCBjeGxfbWVtZGV2X3N0YXRlICptZHMpDQo+ICAgICAgICAg
IGlmIChyYyA8IDApDQo+ICAgICAgICAgICAgICAgICAgcmV0dXJuIHJjOw0KPiANCj4gLSAgICAg
ICBtZHMtPnRvdGFsX2J5dGVzID0NCj4gKyAgICAgICBtZHMtPnN0YXRpY19jYXAgPQ0KPiAgICAg
ICAgICAgICAgICAgIGxlNjRfdG9fY3B1KGlkLnRvdGFsX2NhcGFjaXR5KSAqIENYTF9DQVBBQ0lU
WV9NVUxUSVBMSUVSOw0KPiAgICAgICAgICBtZHMtPnZvbGF0aWxlX29ubHlfYnl0ZXMgPQ0KPiAg
ICAgICAgICAgICAgICAgIGxlNjRfdG9fY3B1KGlkLnZvbGF0aWxlX2NhcGFjaXR5KSAqIENYTF9D
QVBBQ0lUWV9NVUxUSVBMSUVSOw0KPiBAQCAtMTExNCw2ICsxMTE0LDggQEAgaW50IGN4bF9kZXZf
c3RhdGVfaWRlbnRpZnkoc3RydWN0IGN4bF9tZW1kZXZfc3RhdGUgKm1kcykNCj4gICAgICAgICAg
ICAgICAgICBtZHMtPnBvaXNvbi5tYXhfZXJyb3JzID0gbWluX3QodTMyLCB2YWwsIENYTF9QT0lT
T05fTElTVF9NQVgpOw0KPiAgICAgICAgICB9DQo+IA0KPiArICAgICAgIG1kcy0+ZGNfZXZlbnRf
bG9nX3NpemUgPSBsZTE2X3RvX2NwdShpZC5kY19ldmVudF9sb2dfc2l6ZSk7DQo+ICsNCj4gICAg
ICAgICAgcmV0dXJuIDA7DQo+ICAgfQ0KPiAgIEVYUE9SVF9TWU1CT0xfTlNfR1BMKGN4bF9kZXZf
c3RhdGVfaWRlbnRpZnksIENYTCk7DQo+IEBAIC0xMTc4LDYgKzExODAsMTY1IEBAIGludCBjeGxf
bWVtX3Nhbml0aXplKHN0cnVjdCBjeGxfbWVtZGV2X3N0YXRlICptZHMsIHUxNiBjbWQpDQo+ICAg
fQ0KPiAgIEVYUE9SVF9TWU1CT0xfTlNfR1BMKGN4bF9tZW1fc2FuaXRpemUsIENYTCk7DQo+IA0K
PiArc3RhdGljIGludCBjeGxfZGNfc2F2ZV9yZWdpb25faW5mbyhzdHJ1Y3QgY3hsX21lbWRldl9z
dGF0ZSAqbWRzLCBpbnQgaW5kZXgsDQo+ICsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg
ICAgc3RydWN0IGN4bF9kY19yZWdpb25fY29uZmlnICpyZWdpb25fY29uZmlnKQ0KPiArew0KPiAr
ICAgICAgIHN0cnVjdCBjeGxfZGNfcmVnaW9uX2luZm8gKmRjciA9ICZtZHMtPmRjX3JlZ2lvbltp
bmRleF07DQo+ICsgICAgICAgc3RydWN0IGRldmljZSAqZGV2ID0gbWRzLT5jeGxkcy5kZXY7DQo+
ICsNCj4gKyAgICAgICBkY3ItPmJhc2UgPSBsZTY0X3RvX2NwdShyZWdpb25fY29uZmlnLT5yZWdp
b25fYmFzZSk7DQo+ICsgICAgICAgZGNyLT5kZWNvZGVfbGVuID0gbGU2NF90b19jcHUocmVnaW9u
X2NvbmZpZy0+cmVnaW9uX2RlY29kZV9sZW5ndGgpOw0KPiArICAgICAgIGRjci0+ZGVjb2RlX2xl
biAqPSBDWExfQ0FQQUNJVFlfTVVMVElQTElFUjsNCj4gKyAgICAgICBkY3ItPmxlbiA9IGxlNjRf
dG9fY3B1KHJlZ2lvbl9jb25maWctPnJlZ2lvbl9sZW5ndGgpOw0KPiArICAgICAgIGRjci0+Ymxr
X3NpemUgPSBsZTY0X3RvX2NwdShyZWdpb25fY29uZmlnLT5yZWdpb25fYmxvY2tfc2l6ZSk7DQo+
ICsgICAgICAgZGNyLT5kc21hZF9oYW5kbGUgPSBsZTMyX3RvX2NwdShyZWdpb25fY29uZmlnLT5y
ZWdpb25fZHNtYWRfaGFuZGxlKTsNCj4gKyAgICAgICBkY3ItPmZsYWdzID0gcmVnaW9uX2NvbmZp
Zy0+ZmxhZ3M7DQo+ICsgICAgICAgc25wcmludGYoZGNyLT5uYW1lLCBDWExfRENfUkVHSU9OX1NU
UkxFTiwgImRjJWQiLCBpbmRleCk7DQo+ICsNCj4gKyAgICAgICAvKiBDaGVjayByZWdpb25zIGFy
ZSBpbiBpbmNyZWFzaW5nIERQQSBvcmRlciAqLw0KPiArICAgICAgIGlmIChpbmRleCA+IDApIHsN
Cj4gKyAgICAgICAgICAgICAgIHN0cnVjdCBjeGxfZGNfcmVnaW9uX2luZm8gKnByZXZfZGNyID0g
Jm1kcy0+ZGNfcmVnaW9uW2luZGV4IC0gMV07DQo+ICsNCj4gKyAgICAgICAgICAgICAgIGlmICgo
cHJldl9kY3ItPmJhc2UgKyBwcmV2X2Rjci0+ZGVjb2RlX2xlbikgPiBkY3ItPmJhc2UpIHsNCj4g
KyAgICAgICAgICAgICAgICAgICAgICAgZGV2X2VycihkZXYsDQo+ICsgICAgICAgICAgICAgICAg
ICAgICAgICAgICAgICAgIkRQQSBvcmRlcmluZyB2aW9sYXRpb24gZm9yIERDIHJlZ2lvbiAlZCBh
bmQgJWRcbiIsDQo+ICsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggLSAxLCBp
bmRleCk7DQo+ICsgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtRUlOVkFMOw0KPiArICAg
ICAgICAgICAgICAgfQ0KPiArICAgICAgIH0NCj4gKw0KPiArICAgICAgIC8qIENoZWNrIHRoZSBy
ZWdpb24gaXMgMjU2IE1CIGFsaWduZWQgKi8NCj4gKyAgICAgICBpZiAoIUlTX0FMSUdORUQoZGNy
LT5iYXNlLCBTWl8yNTZNKSkgew0KPiArICAgICAgICAgICAgICAgZGV2X2VycihkZXYsICJEQyBy
ZWdpb24gJWQgbm90IGFsaWduZWQgdG8gMjU2TUI6ICUjbGx4XG4iLA0KPiArICAgICAgICAgICAg
ICAgICAgICAgICBpbmRleCwgZGNyLT5iYXNlKTsNCj4gKyAgICAgICAgICAgICAgIHJldHVybiAt
RUlOVkFMOw0KPiArICAgICAgIH0NCj4gKw0KPiArICAgICAgIC8qIENoZWNrIFJlZ2lvbiBiYXNl
IGFuZCBsZW5ndGggYXJlIGFsaWduZWQgdG8gYmxvY2sgc2l6ZSAqLw0KPiArICAgICAgIGlmICgh
SVNfQUxJR05FRChkY3ItPmJhc2UsIGRjci0+YmxrX3NpemUpIHx8DQo+ICsgICAgICAgICAgICFJ
U19BTElHTkVEKGRjci0+bGVuLCBkY3ItPmJsa19zaXplKSkgew0KPiArICAgICAgICAgICAgICAg
ZGV2X2VycihkZXYsICJEQyByZWdpb24gJWQgbm90IGFsaWduZWQgdG8gJSNsbHhcbiIsIGluZGV4
LA0KPiArICAgICAgICAgICAgICAgICAgICAgICBkY3ItPmJsa19zaXplKTsNCj4gKyAgICAgICAg
ICAgICAgIHJldHVybiAtRUlOVkFMOw0KPiArICAgICAgIH0NCj4gKw0KPiArICAgICAgIGRldl9k
YmcoZGV2LA0KPiArICAgICAgICAgICAgICAgIkRDIHJlZ2lvbiAlcyBEUEE6ICUjbGx4IExFTjog
JSNsbHggQkxLU1o6ICUjbGx4XG4iLA0KPiArICAgICAgICAgICAgICAgZGNyLT5uYW1lLCBkY3It
PmJhc2UsIGRjci0+ZGVjb2RlX2xlbiwgZGNyLT5ibGtfc2l6ZSk7DQo+ICsNCj4gKyAgICAgICBy
ZXR1cm4gMDsNCj4gK30NCj4gKw0KPiArLyogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHJlZ2lvbnMg
aW4gZGNfcmVzcCBvciAtRVJSTk8gKi8NCj4gK3N0YXRpYyBpbnQgY3hsX2dldF9kY19pZChzdHJ1
Y3QgY3hsX21lbWRldl9zdGF0ZSAqbWRzLCB1OCBzdGFydF9yZWdpb24sDQo+ICsgICAgICAgICAg
ICAgICAgICAgICAgICBzdHJ1Y3QgY3hsX21ib3hfZHluYW1pY19jYXBhY2l0eSAqZGNfcmVzcCwN
Cj4gKyAgICAgICAgICAgICAgICAgICAgICAgIHNpemVfdCBkY19yZXNwX3NpemUpDQo+ICt7DQo+
ICsgICAgICAgc3RydWN0IGN4bF9tYm94X2dldF9kY19jb25maWcgZ2V0X2RjID0gKHN0cnVjdCBj
eGxfbWJveF9nZXRfZGNfY29uZmlnKSB7DQo+ICsgICAgICAgICAgICAgICAucmVnaW9uX2NvdW50
ID0gQ1hMX01BWF9EQ19SRUdJT04sDQo+ICsgICAgICAgICAgICAgICAuc3RhcnRfcmVnaW9uX2lu
ZGV4ID0gc3RhcnRfcmVnaW9uLA0KPiArICAgICAgIH07DQo+ICsgICAgICAgc3RydWN0IGN4bF9t
Ym94X2NtZCBtYm94X2NtZCA9IChzdHJ1Y3QgY3hsX21ib3hfY21kKSB7DQo+ICsgICAgICAgICAg
ICAgICAub3Bjb2RlID0gQ1hMX01CT1hfT1BfR0VUX0RDX0NPTkZJRywNCj4gKyAgICAgICAgICAg
ICAgIC5wYXlsb2FkX2luID0gJmdldF9kYywNCj4gKyAgICAgICAgICAgICAgIC5zaXplX2luID0g
c2l6ZW9mKGdldF9kYyksDQo+ICsgICAgICAgICAgICAgICAuc2l6ZV9vdXQgPSBkY19yZXNwX3Np
emUsDQo+ICsgICAgICAgICAgICAgICAucGF5bG9hZF9vdXQgPSBkY19yZXNwLA0KPiArICAgICAg
ICAgICAgICAgLm1pbl9vdXQgPSAxLA0KPiArICAgICAgIH07DQo+ICsgICAgICAgc3RydWN0IGRl
dmljZSAqZGV2ID0gbWRzLT5jeGxkcy5kZXY7DQo+ICsgICAgICAgaW50IHJjOw0KPiArDQo+ICsg
ICAgICAgcmMgPSBjeGxfaW50ZXJuYWxfc2VuZF9jbWQobWRzLCAmbWJveF9jbWQpOw0KPiArICAg
ICAgIGlmIChyYyA8IDApDQo+ICsgICAgICAgICAgICAgICByZXR1cm4gcmM7DQo+ICsNCj4gKyAg
ICAgICByYyA9IGRjX3Jlc3AtPmF2YWlsX3JlZ2lvbl9jb3VudCAtIHN0YXJ0X3JlZ2lvbjsNCj4g
Kw0KPiArICAgICAgIC8qDQo+ICsgICAgICAgICogVGhlIG51bWJlciBvZiByZWdpb25zIGluIHRo
ZSBwYXlsb2FkIG1heSBoYXZlIGJlZW4gdHJ1bmNhdGVkIGR1ZSB0bw0KPiArICAgICAgICAqIHBh
eWxvYWRfc2l6ZSBsaW1pdHM7IGlmIHNvIGFkanVzdCB0aGUgY291bnQgaW4gdGhpcyBxdWVyeS4N
Cj4gKyAgICAgICAgKi8NCj4gKyAgICAgICBpZiAobWJveF9jbWQuc2l6ZV9vdXQgPCBzaXplb2Yo
KmRjX3Jlc3ApKQ0KPiArICAgICAgICAgICAgICAgcmMgPSBDWExfUkVHSU9OU19SRVRVUk5FRCht
Ym94X2NtZC5zaXplX291dCk7DQo+ICsNCj4gKyAgICAgICBkZXZfZGJnKGRldiwgIlJlYWQgJWQv
JWQgREMgcmVnaW9uc1xuIiwgcmMsIGRjX3Jlc3AtPmF2YWlsX3JlZ2lvbl9jb3VudCk7DQo+ICsN
Cj4gKyAgICAgICByZXR1cm4gcmM7DQo+ICt9DQo+ICsNCj4gKy8qKg0KPiArICogY3hsX2Rldl9k
eW5hbWljX2NhcGFjaXR5X2lkZW50aWZ5KCkgLSBSZWFkcyB0aGUgZHluYW1pYyBjYXBhY2l0eQ0K
PiArICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZm9ybWF0aW9uIGZy
b20gdGhlIGRldmljZS4NCj4gKyAqIEBtZHM6IFRoZSBtZW1vcnkgZGV2aWNlIHN0YXRlDQo+ICsg
Kg0KPiArICogVGhpcyB3aWxsIGRpc3BhdGNoIHRoZSBnZXRfZHluYW1pY19jYXBhY2l0eSBjb21t
YW5kIHRvIHRoZSBkZXZpY2UNCj4gKyAqIGFuZCBvbiBzdWNjZXNzIHBvcHVsYXRlIHN0cnVjdHVy
ZXMgdG8gYmUgZXhwb3J0ZWQgdG8gc3lzZnMuDQo+ICsgKg0KPiArICogUmV0dXJuOiAwIGlmIGlk
ZW50aWZ5IHdhcyBleGVjdXRlZCBzdWNjZXNzZnVsbHksIC1FUlJOTyBvbiBlcnJvci4NCj4gKyAq
Lw0KPiAraW50IGN4bF9kZXZfZHluYW1pY19jYXBhY2l0eV9pZGVudGlmeShzdHJ1Y3QgY3hsX21l
bWRldl9zdGF0ZSAqbWRzKQ0KPiArew0KPiArICAgICAgIHN0cnVjdCBjeGxfbWJveF9keW5hbWlj
X2NhcGFjaXR5ICpkY19yZXNwOw0KPiArICAgICAgIHN0cnVjdCBkZXZpY2UgKmRldiA9IG1kcy0+
Y3hsZHMuZGV2Ow0KPiArICAgICAgIHNpemVfdCBkY19yZXNwX3NpemUgPSBtZHMtPnBheWxvYWRf
c2l6ZTsNCj4gKyAgICAgICB1OCBzdGFydF9yZWdpb247DQo+ICsgICAgICAgaW50IGksIHJjID0g
MDsNCj4gKw0KPiArICAgICAgIGZvciAoaSA9IDA7IGkgPCBDWExfTUFYX0RDX1JFR0lPTjsgaSsr
KQ0KPiArICAgICAgICAgICAgICAgc25wcmludGYobWRzLT5kY19yZWdpb25baV0ubmFtZSwgQ1hM
X0RDX1JFR0lPTl9TVFJMRU4sICI8bmlsPiIpOw0KPiArDQo+ICsgICAgICAgLyogQ2hlY2sgR0VU
X0RDX0NPTkZJRyBpcyBzdXBwb3J0ZWQgYnkgZGV2aWNlICovDQo+ICsgICAgICAgaWYgKCF0ZXN0
X2JpdChDWExfRENEX0VOQUJMRURfR0VUX0NPTkZJRywgbWRzLT5kY2RfY21kcykpIHsNCj4gKyAg
ICAgICAgICAgICAgIGRldl9kYmcoZGV2LCAidW5zdXBwb3J0ZWQgY21kOiBnZXRfZHluYW1pY19j
YXBhY2l0eV9jb25maWdcbiIpOw0KPiArICAgICAgICAgICAgICAgcmV0dXJuIDA7DQo+ICsgICAg
ICAgfQ0KPiArDQo+ICsgICAgICAgZGNfcmVzcCA9IGt2bWFsbG9jKGRjX3Jlc3Bfc2l6ZSwgR0ZQ
X0tFUk5FTCk7DQo+ICsgICAgICAgaWYgKCFkY19yZXNwKQ0KPiArICAgICAgICAgICAgICAgcmV0
dXJuIC1FTk9NRU07DQo+ICsNCj4gKyAgICAgICBzdGFydF9yZWdpb24gPSAwOw0KPiArICAgICAg
IGRvIHsNCj4gKyAgICAgICAgICAgICAgIGludCBqOw0KPiArDQo+ICsgICAgICAgICAgICAgICBy
YyA9IGN4bF9nZXRfZGNfaWQobWRzLCBzdGFydF9yZWdpb24sIGRjX3Jlc3AsIGRjX3Jlc3Bfc2l6
ZSk7DQo+ICsgICAgICAgICAgICAgICBpZiAocmMgPCAwKQ0KPiArICAgICAgICAgICAgICAgICAg
ICAgICBnb3RvIGZyZWVfcmVzcDsNCj4gKw0KPiArICAgICAgICAgICAgICAgbWRzLT5ucl9kY19y
ZWdpb24gKz0gcmM7DQo+ICsNCj4gKyAgICAgICAgICAgICAgIGlmIChtZHMtPm5yX2RjX3JlZ2lv
biA8IDEgfHwgbWRzLT5ucl9kY19yZWdpb24gPiBDWExfTUFYX0RDX1JFR0lPTikgew0KPiArICAg
ICAgICAgICAgICAgICAgICAgICBkZXZfZXJyKGRldiwgIkludmFsaWQgbnVtIG9mIGR5bmFtaWMg
Y2FwYWNpdHkgcmVnaW9ucyAlZFxuIiwNCj4gKyAgICAgICAgICAgICAgICAgICAgICAgICAgICAg
ICBtZHMtPm5yX2RjX3JlZ2lvbik7DQo+ICsgICAgICAgICAgICAgICAgICAgICAgIHJjID0gLUVJ
TlZBTDsNCj4gKyAgICAgICAgICAgICAgICAgICAgICAgZ290byBmcmVlX3Jlc3A7DQo+ICsgICAg
ICAgICAgICAgICB9DQo+ICsNCj4gKyAgICAgICAgICAgICAgIGZvciAoaSA9IHN0YXJ0X3JlZ2lv
biwgaiA9IDA7IGkgPCBtZHMtPm5yX2RjX3JlZ2lvbjsgaSsrLCBqKyspIHsNCj4gKyAgICAgICAg
ICAgICAgICAgICAgICAgcmMgPSBjeGxfZGNfc2F2ZV9yZWdpb25faW5mbyhtZHMsIGksICZkY19y
ZXNwLT5yZWdpb25bal0pOw0KPiArICAgICAgICAgICAgICAgICAgICAgICBpZiAocmMpDQo+ICsg
ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ290byBmcmVlX3Jlc3A7DQo+ICsgICAgICAg
ICAgICAgICB9DQo+ICsNCj4gKyAgICAgICAgICAgICAgIHN0YXJ0X3JlZ2lvbiA9IG1kcy0+bnJf
ZGNfcmVnaW9uOw0KPiArDQo+ICsgICAgICAgfSB3aGlsZSAobWRzLT5ucl9kY19yZWdpb24gPCBk
Y19yZXNwLT5hdmFpbF9yZWdpb25fY291bnQpOw0KPiArDQo+ICsgICAgICAgbWRzLT5keW5hbWlj
X2NhcCA9DQo+ICsgICAgICAgICAgICAgICBtZHMtPmRjX3JlZ2lvblttZHMtPm5yX2RjX3JlZ2lv
biAtIDFdLmJhc2UgKw0KPiArICAgICAgICAgICAgICAgbWRzLT5kY19yZWdpb25bbWRzLT5ucl9k
Y19yZWdpb24gLSAxXS5kZWNvZGVfbGVuIC0NCj4gKyAgICAgICAgICAgICAgIG1kcy0+ZGNfcmVn
aW9uWzBdLmJhc2U7DQo+ICsgICAgICAgZGV2X2RiZyhkZXYsICJUb3RhbCBkeW5hbWljIGNhcGFj
aXR5OiAlI2xseFxuIiwgbWRzLT5keW5hbWljX2NhcCk7DQo+ICsNCj4gK2ZyZWVfcmVzcDoNCj4g
KyAgICAgICBrZnJlZShkY19yZXNwKTsNCj4gKyAgICAgICBpZiAocmMpDQo+ICsgICAgICAgICAg
ICAgICBkZXZfZXJyKGRldiwgIkZhaWxlZCB0byBnZXQgREMgaW5mbzogJWRcbiIsIHJjKTsNCj4g
KyAgICAgICByZXR1cm4gcmM7DQo+ICt9DQo+ICtFWFBPUlRfU1lNQk9MX05TX0dQTChjeGxfZGV2
X2R5bmFtaWNfY2FwYWNpdHlfaWRlbnRpZnksIENYTCk7DQo+ICsNCj4gICBzdGF0aWMgaW50IGFk
ZF9kcGFfcmVzKHN0cnVjdCBkZXZpY2UgKmRldiwgc3RydWN0IHJlc291cmNlICpwYXJlbnQsDQo+
ICAgICAgICAgICAgICAgICAgICAgICAgIHN0cnVjdCByZXNvdXJjZSAqcmVzLCByZXNvdXJjZV9z
aXplX3Qgc3RhcnQsDQo+ICAgICAgICAgICAgICAgICAgICAgICAgIHJlc291cmNlX3NpemVfdCBz
aXplLCBjb25zdCBjaGFyICp0eXBlKQ0KPiBAQCAtMTIwOCw4ICsxMzY5LDEyIEBAIGludCBjeGxf
bWVtX2NyZWF0ZV9yYW5nZV9pbmZvKHN0cnVjdCBjeGxfbWVtZGV2X3N0YXRlICptZHMpDQo+ICAg
ew0KPiAgICAgICAgICBzdHJ1Y3QgY3hsX2Rldl9zdGF0ZSAqY3hsZHMgPSAmbWRzLT5jeGxkczsN
Cj4gICAgICAgICAgc3RydWN0IGRldmljZSAqZGV2ID0gY3hsZHMtPmRldjsNCj4gKyAgICAgICBz
aXplX3QgdW50ZW5hbnRlZF9tZW07DQo+ICAgICAgICAgIGludCByYzsNCj4gDQo+ICsgICAgICAg
dW50ZW5hbnRlZF9tZW0gPSBtZHMtPmRjX3JlZ2lvblswXS5iYXNlIC0gbWRzLT5zdGF0aWNfY2Fw
Ow0KPiArICAgICAgIG1kcy0+dG90YWxfYnl0ZXMgPSBtZHMtPnN0YXRpY19jYXAgKyB1bnRlbmFu
dGVkX21lbSArIG1kcy0+ZHluYW1pY19jYXA7DQo+ICsNCj4gICAgICAgICAgaWYgKCFjeGxkcy0+
bWVkaWFfcmVhZHkpIHsNCj4gICAgICAgICAgICAgICAgICBjeGxkcy0+ZHBhX3JlcyA9IERFRklO
RV9SRVNfTUVNKDAsIDApOw0KPiAgICAgICAgICAgICAgICAgIGN4bGRzLT5yYW1fcmVzID0gREVG
SU5FX1JFU19NRU0oMCwgMCk7DQo+IEBAIC0xMjE3LDggKzEzODIsMTYgQEAgaW50IGN4bF9tZW1f
Y3JlYXRlX3JhbmdlX2luZm8oc3RydWN0IGN4bF9tZW1kZXZfc3RhdGUgKm1kcykNCj4gICAgICAg
ICAgICAgICAgICByZXR1cm4gMDsNCj4gICAgICAgICAgfQ0KPiANCj4gLSAgICAgICBjeGxkcy0+
ZHBhX3JlcyA9DQo+IC0gICAgICAgICAgICAgICAoc3RydWN0IHJlc291cmNlKURFRklORV9SRVNf
TUVNKDAsIG1kcy0+dG90YWxfYnl0ZXMpOw0KPiArICAgICAgIGN4bGRzLT5kcGFfcmVzID0gKHN0
cnVjdCByZXNvdXJjZSlERUZJTkVfUkVTX01FTSgwLCBtZHMtPnRvdGFsX2J5dGVzKTsNCj4gKw0K
PiArICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgbWRzLT5ucl9kY19yZWdpb247IGkrKykgew0K
PiArICAgICAgICAgICAgICAgc3RydWN0IGN4bF9kY19yZWdpb25faW5mbyAqZGNyID0gJm1kcy0+
ZGNfcmVnaW9uW2ldOw0KPiArDQo+ICsgICAgICAgICAgICAgICByYyA9IGFkZF9kcGFfcmVzKGRl
diwgJmN4bGRzLT5kcGFfcmVzLCAmY3hsZHMtPmRjX3Jlc1tpXSwNCj4gKyAgICAgICAgICAgICAg
ICAgICAgICAgICAgICAgICAgZGNyLT5iYXNlLCBkY3ItPmRlY29kZV9sZW4sIGRjci0+bmFtZSk7
DQo+ICsgICAgICAgICAgICAgICBpZiAocmMpDQo+ICsgICAgICAgICAgICAgICAgICAgICAgIHJl
dHVybiByYzsNCj4gKyAgICAgICB9DQo+IA0KPiAgICAgICAgICBpZiAobWRzLT5wYXJ0aXRpb25f
YWxpZ25fYnl0ZXMgPT0gMCkgew0KPiAgICAgICAgICAgICAgICAgIHJjID0gYWRkX2RwYV9yZXMo
ZGV2LCAmY3hsZHMtPmRwYV9yZXMsICZjeGxkcy0+cmFtX3JlcywgMCwNCj4gZGlmZiAtLWdpdCBh
L2RyaXZlcnMvY3hsL2NvcmUvcmVnaW9uLmMgYi9kcml2ZXJzL2N4bC9jb3JlL3JlZ2lvbi5jDQo+
IGluZGV4IDI1MmJjOGUxZjEwMy4uNzUwNDE5MDNiNzJjIDEwMDY0NA0KPiAtLS0gYS9kcml2ZXJz
L2N4bC9jb3JlL3JlZ2lvbi5jDQo+ICsrKyBiL2RyaXZlcnMvY3hsL2NvcmUvcmVnaW9uLmMNCj4g
QEAgLTQ2LDcgKzQ2LDcgQEAgc3RhdGljIHNzaXplX3QgdXVpZF9zaG93KHN0cnVjdCBkZXZpY2Ug
KmRldiwgc3RydWN0IGRldmljZV9hdHRyaWJ1dGUgKmF0dHIsDQo+ICAgICAgICAgIHJjID0gZG93
bl9yZWFkX2ludGVycnVwdGlibGUoJmN4bF9yZWdpb25fcndzZW0pOw0KPiAgICAgICAgICBpZiAo
cmMpDQo+ICAgICAgICAgICAgICAgICAgcmV0dXJuIHJjOw0KPiAtICAgICAgIGlmIChjeGxyLT5t
b2RlICE9IENYTF9ERUNPREVSX1BNRU0pDQo+ICsgICAgICAgaWYgKGN4bHItPm1vZGUgIT0gQ1hM
X1JFR0lPTl9QTUVNKQ0KPiAgICAgICAgICAgICAgICAgIHJjID0gc3lzZnNfZW1pdChidWYsICJc
biIpOw0KPiAgICAgICAgICBlbHNlDQo+ICAgICAgICAgICAgICAgICAgcmMgPSBzeXNmc19lbWl0
KGJ1ZiwgIiVwVWJcbiIsICZwLT51dWlkKTsNCj4gQEAgLTM1OSw3ICszNTksNyBAQCBzdGF0aWMg
dW1vZGVfdCBjeGxfcmVnaW9uX3Zpc2libGUoc3RydWN0IGtvYmplY3QgKmtvYmosIHN0cnVjdCBh
dHRyaWJ1dGUgKmEsDQo+ICAgICAgICAgICAqIFN1cHBvcnQgdG9vbGluZyB0aGF0IGV4cGVjdHMg
dG8gZmluZCBhICd1dWlkJyBhdHRyaWJ1dGUgZm9yIGFsbA0KPiAgICAgICAgICAgKiByZWdpb25z
IHJlZ2FyZGxlc3Mgb2YgbW9kZS4NCj4gICAgICAgICAgICovDQo+IC0gICAgICAgaWYgKGEgPT0g
JmRldl9hdHRyX3V1aWQuYXR0ciAmJiBjeGxyLT5tb2RlICE9IENYTF9ERUNPREVSX1BNRU0pDQo+
ICsgICAgICAgaWYgKGEgPT0gJmRldl9hdHRyX3V1aWQuYXR0ciAmJiBjeGxyLT5tb2RlICE9IENY
TF9SRUdJT05fUE1FTSkNCj4gICAgICAgICAgICAgICAgICByZXR1cm4gMDQ0NDsNCj4gICAgICAg
ICAgcmV0dXJuIGEtPm1vZGU7DQo+ICAgfQ0KPiBAQCAtNTM3LDcgKzUzNyw3IEBAIHN0YXRpYyBz
c2l6ZV90IG1vZGVfc2hvdyhzdHJ1Y3QgZGV2aWNlICpkZXYsIHN0cnVjdCBkZXZpY2VfYXR0cmli
dXRlICphdHRyLA0KPiAgIHsNCj4gICAgICAgICAgc3RydWN0IGN4bF9yZWdpb24gKmN4bHIgPSB0
b19jeGxfcmVnaW9uKGRldik7DQo+IA0KPiAtICAgICAgIHJldHVybiBzeXNmc19lbWl0KGJ1Ziwg
IiVzXG4iLCBjeGxfZGVjb2Rlcl9tb2RlX25hbWUoY3hsci0+bW9kZSkpOw0KPiArICAgICAgIHJl
dHVybiBzeXNmc19lbWl0KGJ1ZiwgIiVzXG4iLCBjeGxfcmVnaW9uX21vZGVfbmFtZShjeGxyLT5t
b2RlKSk7DQo+ICAgfQ0KPiAgIHN0YXRpYyBERVZJQ0VfQVRUUl9STyhtb2RlKTsNCj4gDQo+IEBA
IC01NjMsNyArNTYzLDcgQEAgc3RhdGljIGludCBhbGxvY19ocGEoc3RydWN0IGN4bF9yZWdpb24g
KmN4bHIsIHJlc291cmNlX3NpemVfdCBzaXplKQ0KPiANCj4gICAgICAgICAgLyogd2F5cywgZ3Jh
bnVsYXJpdHkgYW5kIHV1aWQgKGlmIFBNRU0pIG5lZWQgdG8gYmUgc2V0IGJlZm9yZSBIUEEgKi8N
Cj4gICAgICAgICAgaWYgKCFwLT5pbnRlcmxlYXZlX3dheXMgfHwgIXAtPmludGVybGVhdmVfZ3Jh
bnVsYXJpdHkgfHwNCj4gLSAgICAgICAgICAgKGN4bHItPm1vZGUgPT0gQ1hMX0RFQ09ERVJfUE1F
TSAmJiB1dWlkX2lzX251bGwoJnAtPnV1aWQpKSkNCj4gKyAgICAgICAgICAgKGN4bHItPm1vZGUg
PT0gQ1hMX1JFR0lPTl9QTUVNICYmIHV1aWRfaXNfbnVsbCgmcC0+dXVpZCkpKQ0KPiAgICAgICAg
ICAgICAgICAgIHJldHVybiAtRU5YSU87DQo+IA0KPiAgICAgICAgICBkaXZfdTY0X3JlbShzaXpl
LCBTWl8yNTZNICogcC0+aW50ZXJsZWF2ZV93YXlzLCAmcmVtYWluZGVyKTsNCj4gQEAgLTE3NjUs
NiArMTc2NSwxNyBAQCBzdGF0aWMgaW50IGN4bF9yZWdpb25fc29ydF90YXJnZXRzKHN0cnVjdCBj
eGxfcmVnaW9uICpjeGxyKQ0KPiAgICAgICAgICByZXR1cm4gcmM7DQo+ICAgfQ0KPiANCj4gK3N0
YXRpYyBib29sIGN4bF9tb2Rlc19jb21wYXRpYmxlKGVudW0gY3hsX3JlZ2lvbl9tb2RlIHJtb2Rl
LA0KPiArICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnVtIGN4bF9kZWNvZGVyX21v
ZGUgZG1vZGUpDQo+ICt7DQo+ICsgICAgICAgaWYgKHJtb2RlID09IENYTF9SRUdJT05fUkFNICYm
IGRtb2RlID09IENYTF9ERUNPREVSX1JBTSkNCj4gKyAgICAgICAgICAgICAgIHJldHVybiB0cnVl
Ow0KPiArICAgICAgIGlmIChybW9kZSA9PSBDWExfUkVHSU9OX1BNRU0gJiYgZG1vZGUgPT0gQ1hM
X0RFQ09ERVJfUE1FTSkNCj4gKyAgICAgICAgICAgICAgIHJldHVybiB0cnVlOw0KPiArDQo+ICsg
ICAgICAgcmV0dXJuIGZhbHNlOw0KPiArfQ0KPiArDQo+ICAgc3RhdGljIGludCBjeGxfcmVnaW9u
X2F0dGFjaChzdHJ1Y3QgY3hsX3JlZ2lvbiAqY3hsciwNCj4gICAgICAgICAgICAgICAgICAgICAg
ICAgICAgICAgc3RydWN0IGN4bF9lbmRwb2ludF9kZWNvZGVyICpjeGxlZCwgaW50IHBvcykNCj4g
ICB7DQo+IEBAIC0xNzc4LDkgKzE3ODksMTEgQEAgc3RhdGljIGludCBjeGxfcmVnaW9uX2F0dGFj
aChzdHJ1Y3QgY3hsX3JlZ2lvbiAqY3hsciwNCj4gICAgICAgICAgbG9ja2RlcF9hc3NlcnRfaGVs
ZF93cml0ZSgmY3hsX3JlZ2lvbl9yd3NlbSk7DQo+ICAgICAgICAgIGxvY2tkZXBfYXNzZXJ0X2hl
bGRfcmVhZCgmY3hsX2RwYV9yd3NlbSk7DQo+IA0KPiAtICAgICAgIGlmIChjeGxlZC0+bW9kZSAh
PSBjeGxyLT5tb2RlKSB7DQo+IC0gICAgICAgICAgICAgICBkZXZfZGJnKCZjeGxyLT5kZXYsICIl
cyByZWdpb24gbW9kZTogJWQgbWlzbWF0Y2g6ICVkXG4iLA0KPiAtICAgICAgICAgICAgICAgICAg
ICAgICBkZXZfbmFtZSgmY3hsZWQtPmN4bGQuZGV2KSwgY3hsci0+bW9kZSwgY3hsZWQtPm1vZGUp
Ow0KPiArICAgICAgIGlmICghY3hsX21vZGVzX2NvbXBhdGlibGUoY3hsci0+bW9kZSwgY3hsZWQt
Pm1vZGUpKSB7DQo+ICsgICAgICAgICAgICAgICBkZXZfZGJnKCZjeGxyLT5kZXYsICIlcyByZWdp
b24gbW9kZTogJXMgbWlzbWF0Y2ggZGVjb2RlcjogJXNcbiIsDQo+ICsgICAgICAgICAgICAgICAg
ICAgICAgIGRldl9uYW1lKCZjeGxlZC0+Y3hsZC5kZXYpLA0KPiArICAgICAgICAgICAgICAgICAg
ICAgICBjeGxfcmVnaW9uX21vZGVfbmFtZShjeGxyLT5tb2RlKSwNCj4gKyAgICAgICAgICAgICAg
ICAgICAgICAgY3hsX2RlY29kZXJfbW9kZV9uYW1lKGN4bGVkLT5tb2RlKSk7DQo+ICAgICAgICAg
ICAgICAgICAgcmV0dXJuIC1FSU5WQUw7DQo+ICAgICAgICAgIH0NCj4gDQo+IEBAIC0yMjM0LDcg
KzIyNDcsNyBAQCBzdGF0aWMgc3RydWN0IGN4bF9yZWdpb24gKmN4bF9yZWdpb25fYWxsb2Moc3Ry
dWN0IGN4bF9yb290X2RlY29kZXIgKmN4bHJkLCBpbnQgaQ0KPiAgICAqIGRldm1fY3hsX2FkZF9y
ZWdpb24gLSBBZGRzIGEgcmVnaW9uIHRvIGEgZGVjb2Rlcg0KPiAgICAqIEBjeGxyZDogcm9vdCBk
ZWNvZGVyDQo+ICAgICogQGlkOiBtZW1yZWdpb24gaWQgdG8gY3JlYXRlLCBvciBtZW1yZWdpb25f
ZnJlZSgpIG9uIGZhaWx1cmUNCj4gLSAqIEBtb2RlOiBtb2RlIGZvciB0aGUgZW5kcG9pbnQgZGVj
b2RlcnMgb2YgdGhpcyByZWdpb24NCj4gKyAqIEBtb2RlOiBtb2RlIG9mIHRoaXMgcmVnaW9uDQo+
ICAgICogQHR5cGU6IHNlbGVjdCB3aGV0aGVyIHRoaXMgaXMgYW4gZXhwYW5kZXIgb3IgYWNjZWxl
cmF0b3IgKHR5cGUtMiBvciB0eXBlLTMpDQo+ICAgICoNCj4gICAgKiBUaGlzIGlzIHRoZSBzZWNv
bmQgc3RlcCBvZiByZWdpb24gaW5pdGlhbGl6YXRpb24uIFJlZ2lvbnMgZXhpc3Qgd2l0aGluIGFu
DQo+IEBAIC0yMjQ1LDcgKzIyNTgsNyBAQCBzdGF0aWMgc3RydWN0IGN4bF9yZWdpb24gKmN4bF9y
ZWdpb25fYWxsb2Moc3RydWN0IGN4bF9yb290X2RlY29kZXIgKmN4bHJkLCBpbnQgaQ0KPiAgICAq
Lw0KPiAgIHN0YXRpYyBzdHJ1Y3QgY3hsX3JlZ2lvbiAqZGV2bV9jeGxfYWRkX3JlZ2lvbihzdHJ1
Y3QgY3hsX3Jvb3RfZGVjb2RlciAqY3hscmQsDQo+ICAgICAgICAgICAgICAgICAgICAgICAgICAg
ICAgICAgICAgICAgICAgICAgICAgaW50IGlkLA0KPiAtICAgICAgICAgICAgICAgICAgICAgICAg
ICAgICAgICAgICAgICAgICAgICAgZW51bSBjeGxfZGVjb2Rlcl9tb2RlIG1vZGUsDQo+ICsgICAg
ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnVtIGN4bF9yZWdpb25f
bW9kZSBtb2RlLA0KPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg
ICAgIGVudW0gY3hsX2RlY29kZXJfdHlwZSB0eXBlKQ0KPiAgIHsNCj4gICAgICAgICAgc3RydWN0
IGN4bF9wb3J0ICpwb3J0ID0gdG9fY3hsX3BvcnQoY3hscmQtPmN4bHNkLmN4bGQuZGV2LnBhcmVu
dCk7DQo+IEBAIC0yMjU0LDExICsyMjY3LDEyIEBAIHN0YXRpYyBzdHJ1Y3QgY3hsX3JlZ2lvbiAq
ZGV2bV9jeGxfYWRkX3JlZ2lvbihzdHJ1Y3QgY3hsX3Jvb3RfZGVjb2RlciAqY3hscmQsDQo+ICAg
ICAgICAgIGludCByYzsNCj4gDQo+ICAgICAgICAgIHN3aXRjaCAobW9kZSkgew0KPiAtICAgICAg
IGNhc2UgQ1hMX0RFQ09ERVJfUkFNOg0KPiAtICAgICAgIGNhc2UgQ1hMX0RFQ09ERVJfUE1FTToN
Cj4gKyAgICAgICBjYXNlIENYTF9SRUdJT05fUkFNOg0KPiArICAgICAgIGNhc2UgQ1hMX1JFR0lP
Tl9QTUVNOg0KPiAgICAgICAgICAgICAgICAgIGJyZWFrOw0KPiAgICAgICAgICBkZWZhdWx0Og0K
PiAtICAgICAgICAgICAgICAgZGV2X2VycigmY3hscmQtPmN4bHNkLmN4bGQuZGV2LCAidW5zdXBw
b3J0ZWQgbW9kZSAlZFxuIiwgbW9kZSk7DQo+ICsgICAgICAgICAgICAgICBkZXZfZXJyKCZjeGxy
ZC0+Y3hsc2QuY3hsZC5kZXYsICJ1bnN1cHBvcnRlZCBtb2RlICVzXG4iLA0KPiArICAgICAgICAg
ICAgICAgICAgICAgICBjeGxfcmVnaW9uX21vZGVfbmFtZShtb2RlKSk7DQo+ICAgICAgICAgICAg
ICAgICAgcmV0dXJuIEVSUl9QVFIoLUVJTlZBTCk7DQo+ICAgICAgICAgIH0NCj4gDQo+IEBAIC0y
MzA4LDcgKzIzMjIsNyBAQCBzdGF0aWMgc3NpemVfdCBjcmVhdGVfcmFtX3JlZ2lvbl9zaG93KHN0
cnVjdCBkZXZpY2UgKmRldiwNCj4gICB9DQo+IA0KPiAgIHN0YXRpYyBzdHJ1Y3QgY3hsX3JlZ2lv
biAqX19jcmVhdGVfcmVnaW9uKHN0cnVjdCBjeGxfcm9vdF9kZWNvZGVyICpjeGxyZCwNCj4gLSAg
ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50IGlkLCBlbnVtIGN4bF9k
ZWNvZGVyX21vZGUgbW9kZSwNCj4gKyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg
ICAgICAgaW50IGlkLCBlbnVtIGN4bF9yZWdpb25fbW9kZSBtb2RlLA0KPiAgICAgICAgICAgICAg
ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW51bSBjeGxfZGVjb2Rlcl90eXBlIHR5cGUp
DQo+ICAgew0KPiAgICAgICAgICBpbnQgcmM7DQo+IEBAIC0yMzM3LDcgKzIzNTEsNyBAQCBzdGF0
aWMgc3NpemVfdCBjcmVhdGVfcG1lbV9yZWdpb25fc3RvcmUoc3RydWN0IGRldmljZSAqZGV2LA0K
PiAgICAgICAgICBpZiAocmMgIT0gMSkNCj4gICAgICAgICAgICAgICAgICByZXR1cm4gLUVJTlZB
TDsNCj4gDQo+IC0gICAgICAgY3hsciA9IF9fY3JlYXRlX3JlZ2lvbihjeGxyZCwgaWQsIENYTF9E
RUNPREVSX1BNRU0sDQo+ICsgICAgICAgY3hsciA9IF9fY3JlYXRlX3JlZ2lvbihjeGxyZCwgaWQs
IENYTF9SRUdJT05fUE1FTSwNCj4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDWExf
REVDT0RFUl9IT1NUT05MWU1FTSk7DQo+ICAgICAgICAgIGlmIChJU19FUlIoY3hscikpDQo+ICAg
ICAgICAgICAgICAgICAgcmV0dXJuIFBUUl9FUlIoY3hscik7DQo+IEBAIC0yMzU4LDcgKzIzNzIs
NyBAQCBzdGF0aWMgc3NpemVfdCBjcmVhdGVfcmFtX3JlZ2lvbl9zdG9yZShzdHJ1Y3QgZGV2aWNl
ICpkZXYsDQo+ICAgICAgICAgIGlmIChyYyAhPSAxKQ0KPiAgICAgICAgICAgICAgICAgIHJldHVy
biAtRUlOVkFMOw0KPiANCj4gLSAgICAgICBjeGxyID0gX19jcmVhdGVfcmVnaW9uKGN4bHJkLCBp
ZCwgQ1hMX0RFQ09ERVJfUkFNLA0KPiArICAgICAgIGN4bHIgPSBfX2NyZWF0ZV9yZWdpb24oY3hs
cmQsIGlkLCBDWExfUkVHSU9OX1JBTSwNCj4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg
ICBDWExfREVDT0RFUl9IT1NUT05MWU1FTSk7DQo+ICAgICAgICAgIGlmIChJU19FUlIoY3hscikp
DQo+ICAgICAgICAgICAgICAgICAgcmV0dXJuIFBUUl9FUlIoY3hscik7DQo+IEBAIC0yODg2LDEw
ICsyOTAwLDMxIEBAIHN0YXRpYyB2b2lkIGNvbnN0cnVjdF9yZWdpb25fZW5kKHZvaWQpDQo+ICAg
ICAgICAgIHVwX3dyaXRlKCZjeGxfcmVnaW9uX3J3c2VtKTsNCj4gICB9DQo+IA0KPiArc3RhdGlj
IGVudW0gY3hsX3JlZ2lvbl9tb2RlDQo+ICtjeGxfZGVjb2Rlcl90b19yZWdpb25fbW9kZShlbnVt
IGN4bF9kZWNvZGVyX21vZGUgbW9kZSkNCj4gK3sNCj4gKyAgICAgICBzd2l0Y2ggKG1vZGUpIHsN
Cj4gKyAgICAgICBjYXNlIENYTF9ERUNPREVSX05PTkU6DQo+ICsgICAgICAgICAgICAgICByZXR1
cm4gQ1hMX1JFR0lPTl9OT05FOw0KPiArICAgICAgIGNhc2UgQ1hMX0RFQ09ERVJfUkFNOg0KPiAr
ICAgICAgICAgICAgICAgcmV0dXJuIENYTF9SRUdJT05fUkFNOw0KPiArICAgICAgIGNhc2UgQ1hM
X0RFQ09ERVJfUE1FTToNCj4gKyAgICAgICAgICAgICAgIHJldHVybiBDWExfUkVHSU9OX1BNRU07
DQo+ICsgICAgICAgY2FzZSBDWExfREVDT0RFUl9ERUFEOg0KPiArICAgICAgICAgICAgICAgcmV0
dXJuIENYTF9SRUdJT05fREVBRDsNCj4gKyAgICAgICBjYXNlIENYTF9ERUNPREVSX01JWEVEOg0K
PiArICAgICAgIGRlZmF1bHQ6DQo+ICsgICAgICAgICAgICAgICByZXR1cm4gQ1hMX1JFR0lPTl9N
SVhFRDsNCj4gKyAgICAgICB9DQo+ICsNCj4gKyAgICAgICByZXR1cm4gQ1hMX1JFR0lPTl9NSVhF
RDsNCj4gK30NCj4gKw0KPiAgIHN0YXRpYyBzdHJ1Y3QgY3hsX3JlZ2lvbiAqDQo+ICAgY29uc3Ry
dWN0X3JlZ2lvbl9iZWdpbihzdHJ1Y3QgY3hsX3Jvb3RfZGVjb2RlciAqY3hscmQsDQo+ICAgICAg
ICAgICAgICAgICAgICAgICAgIHN0cnVjdCBjeGxfZW5kcG9pbnRfZGVjb2RlciAqY3hsZWQpDQo+
ICAgew0KPiArICAgICAgIGVudW0gY3hsX3JlZ2lvbl9tb2RlIG1vZGUgPSBjeGxfZGVjb2Rlcl90
b19yZWdpb25fbW9kZShjeGxlZC0+bW9kZSk7DQo+ICAgICAgICAgIHN0cnVjdCBjeGxfbWVtZGV2
ICpjeGxtZCA9IGN4bGVkX3RvX21lbWRldihjeGxlZCk7DQo+ICAgICAgICAgIHN0cnVjdCBjeGxf
cmVnaW9uX3BhcmFtcyAqcDsNCj4gICAgICAgICAgc3RydWN0IGN4bF9yZWdpb24gKmN4bHI7DQo+
IEBAIC0yODk3LDcgKzI5MzIsNyBAQCBjb25zdHJ1Y3RfcmVnaW9uX2JlZ2luKHN0cnVjdCBjeGxf
cm9vdF9kZWNvZGVyICpjeGxyZCwNCj4gDQo+ICAgICAgICAgIGRvIHsNCj4gICAgICAgICAgICAg
ICAgICBjeGxyID0gX19jcmVhdGVfcmVnaW9uKGN4bHJkLCBhdG9taWNfcmVhZCgmY3hscmQtPnJl
Z2lvbl9pZCksDQo+IC0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN4bGVk
LT5tb2RlLCBjeGxlZC0+Y3hsZC50YXJnZXRfdHlwZSk7DQo+ICsgICAgICAgICAgICAgICAgICAg
ICAgICAgICAgICAgICAgICAgIG1vZGUsIGN4bGVkLT5jeGxkLnRhcmdldF90eXBlKTsNCj4gICAg
ICAgICAgfSB3aGlsZSAoSVNfRVJSKGN4bHIpICYmIFBUUl9FUlIoY3hscikgPT0gLUVCVVNZKTsN
Cj4gDQo+ICAgICAgICAgIGlmIChJU19FUlIoY3hscikpIHsNCj4gQEAgLTMyMDAsOSArMzIzNSw5
IEBAIHN0YXRpYyBpbnQgY3hsX3JlZ2lvbl9wcm9iZShzdHJ1Y3QgZGV2aWNlICpkZXYpDQo+ICAg
ICAgICAgICAgICAgICAgcmV0dXJuIHJjOw0KPiANCj4gICAgICAgICAgc3dpdGNoIChjeGxyLT5t
b2RlKSB7DQo+IC0gICAgICAgY2FzZSBDWExfREVDT0RFUl9QTUVNOg0KPiArICAgICAgIGNhc2Ug
Q1hMX1JFR0lPTl9QTUVNOg0KPiAgICAgICAgICAgICAgICAgIHJldHVybiBkZXZtX2N4bF9hZGRf
cG1lbV9yZWdpb24oY3hscik7DQo+IC0gICAgICAgY2FzZSBDWExfREVDT0RFUl9SQU06DQo+ICsg
ICAgICAgY2FzZSBDWExfUkVHSU9OX1JBTToNCj4gICAgICAgICAgICAgICAgICAvKg0KPiAgICAg
ICAgICAgICAgICAgICAqIFRoZSByZWdpb24gY2FuIG5vdCBiZSBtYW5nZWQgYnkgQ1hMIGlmIGFu
eSBwb3J0aW9uIG9mDQo+ICAgICAgICAgICAgICAgICAgICogaXQgaXMgYWxyZWFkeSBvbmxpbmUg
YXMgJ1N5c3RlbSBSQU0nDQo+IEBAIC0zMjIzLDggKzMyNTgsOCBAQCBzdGF0aWMgaW50IGN4bF9y
ZWdpb25fcHJvYmUoc3RydWN0IGRldmljZSAqZGV2KQ0KPiAgICAgICAgICAgICAgICAgIC8qIEhE
TS1IIHJvdXRlcyB0byBkZXZpY2UtZGF4ICovDQo+ICAgICAgICAgICAgICAgICAgcmV0dXJuIGRl
dm1fY3hsX2FkZF9kYXhfcmVnaW9uKGN4bHIpOw0KPiAgICAgICAgICBkZWZhdWx0Og0KPiAtICAg
ICAgICAgICAgICAgZGV2X2RiZygmY3hsci0+ZGV2LCAidW5zdXBwb3J0ZWQgcmVnaW9uIG1vZGU6
ICVkXG4iLA0KPiAtICAgICAgICAgICAgICAgICAgICAgICBjeGxyLT5tb2RlKTsNCj4gKyAgICAg
ICAgICAgICAgIGRldl9kYmcoJmN4bHItPmRldiwgInVuc3VwcG9ydGVkIHJlZ2lvbiBtb2RlOiAl
c1xuIiwNCj4gKyAgICAgICAgICAgICAgICAgICAgICAgY3hsX3JlZ2lvbl9tb2RlX25hbWUoY3hs
ci0+bW9kZSkpOw0KPiAgICAgICAgICAgICAgICAgIHJldHVybiAtRU5YSU87DQo+ICAgICAgICAg
IH0NCj4gICB9DQo+IGRpZmYgLS1naXQgYS9kcml2ZXJzL2N4bC9jeGwuaCBiL2RyaXZlcnMvY3hs
L2N4bC5oDQo+IGluZGV4IGNkNGE5ZmZkYWNjNy4uZWQyODJkY2Q1Y2Y1IDEwMDY0NA0KPiAtLS0g
YS9kcml2ZXJzL2N4bC9jeGwuaA0KPiArKysgYi9kcml2ZXJzL2N4bC9jeGwuaA0KPiBAQCAtMzc0
LDYgKzM3NCwyOCBAQCBzdGF0aWMgaW5saW5lIGNvbnN0IGNoYXIgKmN4bF9kZWNvZGVyX21vZGVf
bmFtZShlbnVtIGN4bF9kZWNvZGVyX21vZGUgbW9kZSkNCj4gICAgICAgICAgcmV0dXJuICJtaXhl
ZCI7DQo+ICAgfQ0KPiANCj4gK2VudW0gY3hsX3JlZ2lvbl9tb2RlIHsNCj4gKyAgICAgICBDWExf
UkVHSU9OX05PTkUsDQo+ICsgICAgICAgQ1hMX1JFR0lPTl9SQU0sDQo+ICsgICAgICAgQ1hMX1JF
R0lPTl9QTUVNLA0KPiArICAgICAgIENYTF9SRUdJT05fTUlYRUQsDQo+ICsgICAgICAgQ1hMX1JF
R0lPTl9ERUFELA0KPiArfTsNCj4gKw0KPiArc3RhdGljIGlubGluZSBjb25zdCBjaGFyICpjeGxf
cmVnaW9uX21vZGVfbmFtZShlbnVtIGN4bF9yZWdpb25fbW9kZSBtb2RlKQ0KPiArew0KPiArICAg
ICAgIHN0YXRpYyBjb25zdCBjaGFyICogY29uc3QgbmFtZXNbXSA9IHsNCj4gKyAgICAgICAgICAg
ICAgIFtDWExfUkVHSU9OX05PTkVdID0gIm5vbmUiLA0KPiArICAgICAgICAgICAgICAgW0NYTF9S
RUdJT05fUkFNXSA9ICJyYW0iLA0KPiArICAgICAgICAgICAgICAgW0NYTF9SRUdJT05fUE1FTV0g
PSAicG1lbSIsDQo+ICsgICAgICAgICAgICAgICBbQ1hMX1JFR0lPTl9NSVhFRF0gPSAibWl4ZWQi
LA0KPiArICAgICAgIH07DQo+ICsNCj4gKyAgICAgICBpZiAobW9kZSA+PSBDWExfUkVHSU9OX05P
TkUgJiYgbW9kZSA8PSBDWExfUkVHSU9OX01JWEVEKQ0KPiArICAgICAgICAgICAgICAgcmV0dXJu
IG5hbWVzW21vZGVdOw0KPiArICAgICAgIHJldHVybiAibWl4ZWQiOw0KPiArfQ0KPiArDQo+ICAg
LyoNCj4gICAgKiBUcmFjayB3aGV0aGVyIHRoaXMgZGVjb2RlciBpcyByZXNlcnZlZCBmb3IgcmVn
aW9uIGF1dG9kaXNjb3ZlcnksIG9yDQo+ICAgICogZnJlZSBmb3IgdXNlcnNwYWNlIHByb3Zpc2lv
bmluZy4NCj4gQEAgLTUwMiw3ICs1MjQsOCBAQCBzdHJ1Y3QgY3hsX3JlZ2lvbl9wYXJhbXMgew0K
PiAgICAqIHN0cnVjdCBjeGxfcmVnaW9uIC0gQ1hMIHJlZ2lvbg0KPiAgICAqIEBkZXY6IFRoaXMg
cmVnaW9uJ3MgZGV2aWNlDQo+ICAgICogQGlkOiBUaGlzIHJlZ2lvbidzIGlkLiBJZCBpcyBnbG9i
YWxseSB1bmlxdWUgYWNyb3NzIGFsbCByZWdpb25zDQo+IC0gKiBAbW9kZTogRW5kcG9pbnQgZGVj
b2RlciBhbGxvY2F0aW9uIC8gYWNjZXNzIG1vZGUNCj4gKyAqIEBtb2RlOiBSZWdpb24gbW9kZSB3
aGljaCBkZWZpbmVzIHdoaWNoIGVuZHBvaW50IGRlY29kZXIgbW9kZSB0aGUgcmVnaW9uIGlzDQo+
ICsgKiAgICAgICAgY29tcGF0aWJsZSB3aXRoDQo+ICAgICogQHR5cGU6IEVuZHBvaW50IGRlY29k
ZXIgdGFyZ2V0IHR5cGUNCj4gICAgKiBAY3hsX252YjogbnZkaW1tIGJyaWRnZSBmb3IgY29vcmRp
bmF0aW5nIEBjeGxyX3BtZW0gc2V0dXAgLyBzaHV0ZG93bg0KPiAgICAqIEBjeGxyX3BtZW06IChm
b3IgcG1lbSByZWdpb25zKSBjYWNoZWQgY29weSBvZiB0aGUgbnZkaW1tIGJyaWRnZQ0KPiBAQCAt
NTEyLDcgKzUzNSw3IEBAIHN0cnVjdCBjeGxfcmVnaW9uX3BhcmFtcyB7DQo+ICAgc3RydWN0IGN4
bF9yZWdpb24gew0KPiAgICAgICAgICBzdHJ1Y3QgZGV2aWNlIGRldjsNCj4gICAgICAgICAgaW50
IGlkOw0KPiAtICAgICAgIGVudW0gY3hsX2RlY29kZXJfbW9kZSBtb2RlOw0KPiArICAgICAgIGVu
dW0gY3hsX3JlZ2lvbl9tb2RlIG1vZGU7DQo+ICAgICAgICAgIGVudW0gY3hsX2RlY29kZXJfdHlw
ZSB0eXBlOw0KPiAgICAgICAgICBzdHJ1Y3QgY3hsX252ZGltbV9icmlkZ2UgKmN4bF9udmI7DQo+
ICAgICAgICAgIHN0cnVjdCBjeGxfcG1lbV9yZWdpb24gKmN4bHJfcG1lbTsNCj4gZGlmZiAtLWdp
dCBhL2RyaXZlcnMvY3hsL2N4bG1lbS5oIGIvZHJpdmVycy9jeGwvY3hsbWVtLmgNCj4gaW5kZXgg
NWYyZTY1MjA0YmY5Li44YzhmNDdiMzk3YWIgMTAwNjQ0DQo+IC0tLSBhL2RyaXZlcnMvY3hsL2N4
bG1lbS5oDQo+ICsrKyBiL2RyaXZlcnMvY3hsL2N4bG1lbS5oDQo+IEBAIC0zOTYsNiArMzk2LDcg
QEAgZW51bSBjeGxfZGV2dHlwZSB7DQo+ICAgICAgICAgIENYTF9ERVZUWVBFX0NMQVNTTUVNLA0K
PiAgIH07DQo+IA0KPiArI2RlZmluZSBDWExfTUFYX0RDX1JFR0lPTiA4DQo+ICAgLyoqDQo+ICAg
ICogc3RydWN0IGN4bF9kZXZfc3RhdGUgLSBUaGUgZHJpdmVyIGRldmljZSBzdGF0ZQ0KPiAgICAq
DQo+IEBAIC00MTIsNiArNDEzLDggQEAgZW51bSBjeGxfZGV2dHlwZSB7DQo+ICAgICogQGRwYV9y
ZXM6IE92ZXJhbGwgRFBBIHJlc291cmNlIHRyZWUgZm9yIHRoZSBkZXZpY2UNCj4gICAgKiBAcG1l
bV9yZXM6IEFjdGl2ZSBQZXJzaXN0ZW50IG1lbW9yeSBjYXBhY2l0eSBjb25maWd1cmF0aW9uDQo+
ICAgICogQHJhbV9yZXM6IEFjdGl2ZSBWb2xhdGlsZSBtZW1vcnkgY2FwYWNpdHkgY29uZmlndXJh
dGlvbg0KPiArICogQGRjX3JlczogQWN0aXZlIER5bmFtaWMgQ2FwYWNpdHkgbWVtb3J5IGNvbmZp
Z3VyYXRpb24gZm9yIGVhY2ggcG9zc2libGUNCj4gKyAqICAgICAgICAgIHJlZ2lvbg0KPiAgICAq
IEBjb21wb25lbnRfcmVnX3BoeXM6IHJlZ2lzdGVyIGJhc2Ugb2YgY29tcG9uZW50IHJlZ2lzdGVy
cw0KPiAgICAqIEBzZXJpYWw6IFBDSWUgRGV2aWNlIFNlcmlhbCBOdW1iZXINCj4gICAgKiBAdHlw
ZTogR2VuZXJpYyBNZW1vcnkgQ2xhc3MgZGV2aWNlIG9yIFZlbmRvciBTcGVjaWZpYyBNZW1vcnkg
ZGV2aWNlDQo+IEBAIC00MjYsMTEgKzQyOSwyMyBAQCBzdHJ1Y3QgY3hsX2Rldl9zdGF0ZSB7DQo+
ICAgICAgICAgIHN0cnVjdCByZXNvdXJjZSBkcGFfcmVzOw0KPiAgICAgICAgICBzdHJ1Y3QgcmVz
b3VyY2UgcG1lbV9yZXM7DQo+ICAgICAgICAgIHN0cnVjdCByZXNvdXJjZSByYW1fcmVzOw0KPiAr
ICAgICAgIHN0cnVjdCByZXNvdXJjZSBkY19yZXNbQ1hMX01BWF9EQ19SRUdJT05dOw0KPiAgICAg
ICAgICByZXNvdXJjZV9zaXplX3QgY29tcG9uZW50X3JlZ19waHlzOw0KPiAgICAgICAgICB1NjQg
c2VyaWFsOw0KPiAgICAgICAgICBlbnVtIGN4bF9kZXZ0eXBlIHR5cGU7DQo+ICAgfTsNCj4gDQo+
ICsjZGVmaW5lIENYTF9EQ19SRUdJT05fU1RSTEVOIDcNCj4gK3N0cnVjdCBjeGxfZGNfcmVnaW9u
X2luZm8gew0KPiArICAgICAgIHU2NCBiYXNlOw0KPiArICAgICAgIHU2NCBkZWNvZGVfbGVuOw0K
PiArICAgICAgIHU2NCBsZW47DQo+ICsgICAgICAgdTY0IGJsa19zaXplOw0KPiArICAgICAgIHUz
MiBkc21hZF9oYW5kbGU7DQo+ICsgICAgICAgdTggZmxhZ3M7DQo+ICsgICAgICAgdTggbmFtZVtD
WExfRENfUkVHSU9OX1NUUkxFTl07DQo+ICt9Ow0KPiArDQo+ICAgLyoqDQo+ICAgICogc3RydWN0
IGN4bF9tZW1kZXZfc3RhdGUgLSBHZW5lcmljIFR5cGUtMyBNZW1vcnkgRGV2aWNlIENsYXNzIGRy
aXZlciBkYXRhDQo+ICAgICoNCj4gQEAgLTQ0OSw2ICs0NjQsOCBAQCBzdHJ1Y3QgY3hsX2Rldl9z
dGF0ZSB7DQo+ICAgICogQGVuYWJsZWRfY21kczogSGFyZHdhcmUgY29tbWFuZHMgZm91bmQgZW5h
YmxlZCBpbiBDRUwuDQo+ICAgICogQGV4Y2x1c2l2ZV9jbWRzOiBDb21tYW5kcyB0aGF0IGFyZSBr
ZXJuZWwtaW50ZXJuYWwgb25seQ0KPiAgICAqIEB0b3RhbF9ieXRlczogc3VtIG9mIGFsbCBwb3Nz
aWJsZSBjYXBhY2l0aWVzDQo+ICsgKiBAc3RhdGljX2NhcDogU3VtIG9mIFJBTSBhbmQgUE1FTSBj
YXBhY2l0aWVzDQo+ICsgKiBAZHluYW1pY19jYXA6IENvbXBsZXRlIERQQSByYW5nZSBvY2N1cGll
ZCBieSBEQyByZWdpb25zDQo+ICAgICogQHZvbGF0aWxlX29ubHlfYnl0ZXM6IGhhcmQgdm9sYXRp
bGUgY2FwYWNpdHkNCj4gICAgKiBAcGVyc2lzdGVudF9vbmx5X2J5dGVzOiBoYXJkIHBlcnNpc3Rl
bnQgY2FwYWNpdHkNCj4gICAgKiBAcGFydGl0aW9uX2FsaWduX2J5dGVzOiBhbGlnbm1lbnQgc2l6
ZSBmb3IgcGFydGl0aW9uLWFibGUgY2FwYWNpdHkNCj4gQEAgLTQ1Niw2ICs0NzMsMTAgQEAgc3Ry
dWN0IGN4bF9kZXZfc3RhdGUgew0KPiAgICAqIEBhY3RpdmVfcGVyc2lzdGVudF9ieXRlczogc3Vt
IG9mIGhhcmQgKyBzb2Z0IHBlcnNpc3RlbnQNCj4gICAgKiBAbmV4dF92b2xhdGlsZV9ieXRlczog
dm9sYXRpbGUgY2FwYWNpdHkgY2hhbmdlIHBlbmRpbmcgZGV2aWNlIHJlc2V0DQo+ICAgICogQG5l
eHRfcGVyc2lzdGVudF9ieXRlczogcGVyc2lzdGVudCBjYXBhY2l0eSBjaGFuZ2UgcGVuZGluZyBk
ZXZpY2UgcmVzZXQNCj4gKyAqIEBucl9kY19yZWdpb246IG51bWJlciBvZiBEQyByZWdpb25zIGlt
cGxlbWVudGVkIGluIHRoZSBtZW1vcnkgZGV2aWNlDQo+ICsgKiBAZGNfcmVnaW9uOiBhcnJheSBj
b250YWluaW5nIGluZm8gYWJvdXQgdGhlIERDIHJlZ2lvbnMNCj4gKyAqIEBkY19ldmVudF9sb2df
c2l6ZTogVGhlIG51bWJlciBvZiBldmVudHMgdGhlIGRldmljZSBjYW4gc3RvcmUgaW4gdGhlDQo+
ICsgKiBEeW5hbWljIENhcGFjaXR5IEV2ZW50IExvZyBiZWZvcmUgaXQgb3ZlcmZsb3dzDQo+ICAg
ICogQGV2ZW50OiBldmVudCBsb2cgZHJpdmVyIHN0YXRlDQo+ICAgICogQHBvaXNvbjogcG9pc29u
IGRyaXZlciBzdGF0ZSBpbmZvDQo+ICAgICogQGZ3OiBmaXJtd2FyZSB1cGxvYWQgLyBhY3RpdmF0
aW9uIHN0YXRlDQo+IEBAIC00NzMsNyArNDk0LDEwIEBAIHN0cnVjdCBjeGxfbWVtZGV2X3N0YXRl
IHsNCj4gICAgICAgICAgREVDTEFSRV9CSVRNQVAoZGNkX2NtZHMsIENYTF9EQ0RfRU5BQkxFRF9N
QVgpOw0KPiAgICAgICAgICBERUNMQVJFX0JJVE1BUChlbmFibGVkX2NtZHMsIENYTF9NRU1fQ09N
TUFORF9JRF9NQVgpOw0KPiAgICAgICAgICBERUNMQVJFX0JJVE1BUChleGNsdXNpdmVfY21kcywg
Q1hMX01FTV9DT01NQU5EX0lEX01BWCk7DQo+ICsNCj4gICAgICAgICAgdTY0IHRvdGFsX2J5dGVz
Ow0KPiArICAgICAgIHU2NCBzdGF0aWNfY2FwOw0KPiArICAgICAgIHU2NCBkeW5hbWljX2NhcDsN
Cj4gICAgICAgICAgdTY0IHZvbGF0aWxlX29ubHlfYnl0ZXM7DQo+ICAgICAgICAgIHU2NCBwZXJz
aXN0ZW50X29ubHlfYnl0ZXM7DQo+ICAgICAgICAgIHU2NCBwYXJ0aXRpb25fYWxpZ25fYnl0ZXM7
DQo+IEBAIC00ODEsNiArNTA1LDExIEBAIHN0cnVjdCBjeGxfbWVtZGV2X3N0YXRlIHsNCj4gICAg
ICAgICAgdTY0IGFjdGl2ZV9wZXJzaXN0ZW50X2J5dGVzOw0KPiAgICAgICAgICB1NjQgbmV4dF92
b2xhdGlsZV9ieXRlczsNCj4gICAgICAgICAgdTY0IG5leHRfcGVyc2lzdGVudF9ieXRlczsNCj4g
Kw0KPiArICAgICAgIHU4IG5yX2RjX3JlZ2lvbjsNCj4gKyAgICAgICBzdHJ1Y3QgY3hsX2RjX3Jl
Z2lvbl9pbmZvIGRjX3JlZ2lvbltDWExfTUFYX0RDX1JFR0lPTl07DQo+ICsgICAgICAgc2l6ZV90
IGRjX2V2ZW50X2xvZ19zaXplOw0KPiArDQo+ICAgICAgICAgIHN0cnVjdCBjeGxfZXZlbnRfc3Rh
dGUgZXZlbnQ7DQo+ICAgICAgICAgIHN0cnVjdCBjeGxfcG9pc29uX3N0YXRlIHBvaXNvbjsNCj4g
ICAgICAgICAgc3RydWN0IGN4bF9zZWN1cml0eV9zdGF0ZSBzZWN1cml0eTsNCj4gQEAgLTU4Nyw2
ICs2MTYsNyBAQCBzdHJ1Y3QgY3hsX21ib3hfaWRlbnRpZnkgew0KPiAgICAgICAgICBfX2xlMTYg
aW5qZWN0X3BvaXNvbl9saW1pdDsNCj4gICAgICAgICAgdTggcG9pc29uX2NhcHM7DQo+ICAgICAg
ICAgIHU4IHFvc190ZWxlbWV0cnlfY2FwczsNCj4gKyAgICAgICBfX2xlMTYgZGNfZXZlbnRfbG9n
X3NpemU7DQo+ICAgfSBfX3BhY2tlZDsNCg0KSGksDQoNClRvIGhhbmRsZSBiYWNrd2FyZHMgY29t
cGF0aWJpbGl0eSB3aXRoIENYTCAyLjAgZGV2aWNlcywgDQpjeGxfZGV2X3N0YXRlX2lkZW50aWZ5
KCkgbmVlZHMgdG8gaGFuZGxlIGJvdGggdGhlIENYTCAyLjAgYW5kIDMuMCANCnZlcnNpb25zIG9m
IHN0cnVjdCBjeGxfbWJveF9pZGVudGlmeS4gVGhlIHNwZWMgc2F5cyB0aGF0IG5ld2VyIGNvZGUg
Y2FuIA0KdXNlIHRoZSBwYXlsb2FkIHNpemUgdG8gZGV0ZWN0IHRoZSBkaWZmZXJlbnQgdmVyc2lv
bnMsIHNvIHNvbWV0aGluZyBsaWtlIA0KdGhlIGZvbGxvd2luZzoNCg0KZGlmZiAtLWdpdCBhL2Ry
aXZlcnMvY3hsL2NvcmUvbWJveC5jIGIvZHJpdmVycy9jeGwvY29yZS9tYm94LmMNCmluZGV4IDk0
NjJjMzRhYTFkYy4uMGE2ZjAzODk5NmFhIDEwMDY0NA0KLS0tIGEvZHJpdmVycy9jeGwvY29yZS9t
Ym94LmMNCisrKyBiL2RyaXZlcnMvY3hsL2NvcmUvbWJveC5jDQpAQCAtMTM1Niw2ICsxMzU2LDcg
QEAgaW50IGN4bF9kZXZfc3RhdGVfaWRlbnRpZnkoc3RydWN0IGN4bF9tZW1kZXZfc3RhdGUgDQoq
bWRzKQ0KICAgICAgICAgICAgICAgICAub3Bjb2RlID0gQ1hMX01CT1hfT1BfSURFTlRJRlksDQog
ICAgICAgICAgICAgICAgIC5zaXplX291dCA9IHNpemVvZihpZCksDQogICAgICAgICAgICAgICAg
IC5wYXlsb2FkX291dCA9ICZpZCwNCisgICAgICAgICAgICAgICAubWluX291dCA9IENYTF9NQk9Y
X0lERU5USUZZX01JTl9MRU5HVEgsDQogICAgICAgICB9Ow0KICAgICAgICAgcmMgPSBjeGxfaW50
ZXJuYWxfc2VuZF9jbWQobWRzLCAmbWJveF9jbWQpOw0KICAgICAgICAgaWYgKHJjIDwgMCkNCkBA
IC0xMzc5LDcgKzEzODAsOCBAQCBpbnQgY3hsX2Rldl9zdGF0ZV9pZGVudGlmeShzdHJ1Y3QgY3hs
X21lbWRldl9zdGF0ZSANCiptZHMpDQogICAgICAgICAgICAgICAgIG1kcy0+cG9pc29uLm1heF9l
cnJvcnMgPSBtaW5fdCh1MzIsIHZhbCwgDQpDWExfUE9JU09OX0xJU1RfTUFYKTsNCiAgICAgICAg
IH0NCg0KLSAgICAgICBtZHMtPmRjX2V2ZW50X2xvZ19zaXplID0gbGUxNl90b19jcHUoaWQuZGNf
ZXZlbnRfbG9nX3NpemUpOw0KKyAgICAgICBpZiAobWJveF9jbWQuc2l6ZV9vdXQgPj0gQ1hMX01C
T1hfSURFTlRJRllfQ1hMM19MRU5HVEgpDQorICAgICAgICAgICAgICAgbWRzLT5kY19ldmVudF9s
b2dfc2l6ZSA9IGxlMTZfdG9fY3B1KGlkLmRjX2V2ZW50X2xvZ19zaXplKTsNCg0KICAgICAgICAg
cmV0dXJuIDA7DQogIH0NCmRpZmYgLS1naXQgYS9kcml2ZXJzL2N4bC9jeGxtZW0uaCBiL2RyaXZl
cnMvY3hsL2N4bG1lbS5oDQppbmRleCBhZTlkY2IyOTFjNzUuLjc1NmUzMGRiMTBkNiAxMDA2NDQN
Ci0tLSBhL2RyaXZlcnMvY3hsL2N4bG1lbS5oDQorKysgYi9kcml2ZXJzL2N4bC9jeGxtZW0uaA0K
QEAgLTYyOSw4ICs2MjksMTEgQEAgc3RydWN0IGN4bF9tYm94X2lkZW50aWZ5IHsNCiAgICAgICAg
IF9fbGUxNiBpbmplY3RfcG9pc29uX2xpbWl0Ow0KICAgICAgICAgdTggcG9pc29uX2NhcHM7DQog
ICAgICAgICB1OCBxb3NfdGVsZW1ldHJ5X2NhcHM7DQorICAgICAgIC8qIENYTCAzLjAgYWRkaXRp
b25zICovDQogICAgICAgICBfX2xlMTYgZGNfZXZlbnRfbG9nX3NpemU7DQogIH0gX19wYWNrZWQ7
DQorI2RlZmluZSBDWExfTUJPWF9JREVOVElGWV9NSU5fTEVOR1RIICAgIDB4NDMNCisjZGVmaW5l
IENYTF9NQk9YX0lERU5USUZZX0NYTDNfTEVOR1RIIHNpemVvZihzdHJ1Y3QgY3hsX21ib3hfaWRl
bnRpZnkpDQoNCiAgLyoNCiAgICogQ29tbW9uIEV2ZW50IFJlY29yZCBGb3JtYXQNCg0KLS0tDQoN
ClNvbWV0aGluZyBzaW1pbGFyIG5lZWRzIHRvIGJlIGhhbmRsZWQgZm9yIGN4bF9ldmVudF9nZXRf
aW50X3BvbGljeSB3aXRoIA0KdGhlIGFkZGl0aW9uIG9mIGR5bmNhcF9zZXR0aW5ncyB0byBjeGxf
ZXZlbnRfaW50ZXJydXB0X3BvbGljeSwgdGhhdCBGYW4gDQpOaSBtZW50aW9ucy4NCg0KVGhhbmtz
LA0KSm9yZ2VuDQoNCj4gICAvKg0KPiBAQCAtNzQxLDkgKzc3MSwzMSBAQCBzdHJ1Y3QgY3hsX21i
b3hfc2V0X3BhcnRpdGlvbl9pbmZvIHsNCj4gICAgICAgICAgX19sZTY0IHZvbGF0aWxlX2NhcGFj
aXR5Ow0KPiAgICAgICAgICB1OCBmbGFnczsNCj4gICB9IF9fcGFja2VkOw0KPiAtDQo+ICAgI2Rl
ZmluZSAgQ1hMX1NFVF9QQVJUSVRJT05fSU1NRURJQVRFX0ZMQUcgICAgICBCSVQoMCkNCj4gDQo+
ICtzdHJ1Y3QgY3hsX21ib3hfZ2V0X2RjX2NvbmZpZyB7DQo+ICsgICAgICAgdTggcmVnaW9uX2Nv
dW50Ow0KPiArICAgICAgIHU4IHN0YXJ0X3JlZ2lvbl9pbmRleDsNCj4gK30gX19wYWNrZWQ7DQo+
ICsNCj4gKy8qIFNlZSBDWEwgMy4wIFRhYmxlIDEyNSBnZXQgZHluYW1pYyBjYXBhY2l0eSBjb25m
aWcgT3V0cHV0IFBheWxvYWQgKi8NCj4gK3N0cnVjdCBjeGxfbWJveF9keW5hbWljX2NhcGFjaXR5
IHsNCj4gKyAgICAgICB1OCBhdmFpbF9yZWdpb25fY291bnQ7DQo+ICsgICAgICAgdTggcnN2ZFs3
XTsNCj4gKyAgICAgICBzdHJ1Y3QgY3hsX2RjX3JlZ2lvbl9jb25maWcgew0KPiArICAgICAgICAg
ICAgICAgX19sZTY0IHJlZ2lvbl9iYXNlOw0KPiArICAgICAgICAgICAgICAgX19sZTY0IHJlZ2lv
bl9kZWNvZGVfbGVuZ3RoOw0KPiArICAgICAgICAgICAgICAgX19sZTY0IHJlZ2lvbl9sZW5ndGg7
DQo+ICsgICAgICAgICAgICAgICBfX2xlNjQgcmVnaW9uX2Jsb2NrX3NpemU7DQo+ICsgICAgICAg
ICAgICAgICBfX2xlMzIgcmVnaW9uX2RzbWFkX2hhbmRsZTsNCj4gKyAgICAgICAgICAgICAgIHU4
IGZsYWdzOw0KPiArICAgICAgICAgICAgICAgdTggcnN2ZFszXTsNCj4gKyAgICAgICB9IF9fcGFj
a2VkIHJlZ2lvbltdOw0KPiArfSBfX3BhY2tlZDsNCj4gKyNkZWZpbmUgQ1hMX0RZTkFNSUNfQ0FQ
QUNJVFlfU0FOSVRJWkVfT05fUkVMRUFTRV9GTEFHIEJJVCgwKQ0KPiArI2RlZmluZSBDWExfUkVH
SU9OU19SRVRVUk5FRChzaXplX291dCkgXA0KPiArICAgICAgICgoc2l6ZV9vdXQgLSA4KSAvIHNp
emVvZihzdHJ1Y3QgY3hsX2RjX3JlZ2lvbl9jb25maWcpKQ0KPiArDQo+ICAgLyogU2V0IFRpbWVz
dGFtcCBDWEwgMy4wIFNwZWMgOC4yLjkuNC4yICovDQo+ICAgc3RydWN0IGN4bF9tYm94X3NldF90
aW1lc3RhbXBfaW4gew0KPiAgICAgICAgICBfX2xlNjQgdGltZXN0YW1wOw0KPiBAQCAtODY3LDYg
KzkxOSw3IEBAIGVudW0gew0KPiAgIGludCBjeGxfaW50ZXJuYWxfc2VuZF9jbWQoc3RydWN0IGN4
bF9tZW1kZXZfc3RhdGUgKm1kcywNCj4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RydWN0
IGN4bF9tYm94X2NtZCAqY21kKTsNCj4gICBpbnQgY3hsX2Rldl9zdGF0ZV9pZGVudGlmeShzdHJ1
Y3QgY3hsX21lbWRldl9zdGF0ZSAqbWRzKTsNCj4gK2ludCBjeGxfZGV2X2R5bmFtaWNfY2FwYWNp
dHlfaWRlbnRpZnkoc3RydWN0IGN4bF9tZW1kZXZfc3RhdGUgKm1kcyk7DQo+ICAgaW50IGN4bF9h
d2FpdF9tZWRpYV9yZWFkeShzdHJ1Y3QgY3hsX2Rldl9zdGF0ZSAqY3hsZHMpOw0KPiAgIGludCBj
eGxfZW51bWVyYXRlX2NtZHMoc3RydWN0IGN4bF9tZW1kZXZfc3RhdGUgKm1kcyk7DQo+ICAgaW50
IGN4bF9tZW1fY3JlYXRlX3JhbmdlX2luZm8oc3RydWN0IGN4bF9tZW1kZXZfc3RhdGUgKm1kcyk7
DQo+IGRpZmYgLS1naXQgYS9kcml2ZXJzL2N4bC9wY2kuYyBiL2RyaXZlcnMvY3hsL3BjaS5jDQo+
IGluZGV4IDUyNDJkYmYwMDQ0ZC4uYTliMTEwZmYxMTc2IDEwMDY0NA0KPiAtLS0gYS9kcml2ZXJz
L2N4bC9wY2kuYw0KPiArKysgYi9kcml2ZXJzL2N4bC9wY2kuYw0KPiBAQCAtODc5LDYgKzg3OSwx
MCBAQCBzdGF0aWMgaW50IGN4bF9wY2lfcHJvYmUoc3RydWN0IHBjaV9kZXYgKnBkZXYsIGNvbnN0
IHN0cnVjdCBwY2lfZGV2aWNlX2lkICppZCkNCj4gICAgICAgICAgaWYgKHJjKQ0KPiAgICAgICAg
ICAgICAgICAgIHJldHVybiByYzsNCj4gDQo+ICsgICAgICAgcmMgPSBjeGxfZGV2X2R5bmFtaWNf
Y2FwYWNpdHlfaWRlbnRpZnkobWRzKTsNCj4gKyAgICAgICBpZiAocmMpDQo+ICsgICAgICAgICAg
ICAgICByZXR1cm4gcmM7DQo+ICsNCj4gICAgICAgICAgcmMgPSBjeGxfbWVtX2NyZWF0ZV9yYW5n
ZV9pbmZvKG1kcyk7DQo+ICAgICAgICAgIGlmIChyYykNCj4gICAgICAgICAgICAgICAgICByZXR1
cm4gcmM7DQo+IA0KPiAtLQ0KPiAyLjQxLjANCj4gDQo=

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 92FC5EC8740
	for <linux-cxl@archiver.kernel.org>; Thu,  7 Sep 2023 16:13:36 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S236492AbjIGQNh (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Thu, 7 Sep 2023 12:13:37 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:40546 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S238141AbjIGQMa (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Thu, 7 Sep 2023 12:12:30 -0400
Received: from mgamail.intel.com (mgamail.intel.com [134.134.136.126])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 40981AD20;
        Thu,  7 Sep 2023 09:09:36 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1694102977; x=1725638977;
  h=date:from:to:cc:subject:message-id:references:
   mime-version:in-reply-to;
  bh=KiWWo5ZdTxhRmlpWM3C4+Ct7kECXOtwevYtY5xYN8cE=;
  b=e6XcuZlL9UViTu2QNuwoqsNp8p3WlbygM6LxaXPShQRnlOPHz9vSUW4p
   asTZY4QuNiBypi5G+Tu9uzc+a7bH8KIrQ//BdoEtgzItHz2jAq8ZT6HW3
   icbztfGVrUfmRx4v5fyqK6bUukNDi8pobofbm7NC6isMDLhJg2dW8YzO8
   D/pkwt1zKy1w1Ufj8GKGBNkCuAhf4VAHPR3hvaFLx/dY9eP08axInAQTo
   zk5DtZIXxhP1QPPNmpI5jTBTjTlL7XnD2CCXxmt5wixj4DwPC6hrZ83S1
   gFuEooC4590FOruRAMSQ6gchE/m3dAHeAzpNrmI2GowqEZVgCgxZW0LrU
   g==;
X-IronPort-AV: E=McAfee;i="6600,9927,10826"; a="362448233"
X-IronPort-AV: E=Sophos;i="6.02,235,1688454000"; 
   d="scan'208";a="362448233"
Received: from orsmga001.jf.intel.com ([10.7.209.18])
  by orsmga106.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 07 Sep 2023 08:46:06 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10826"; a="777113375"
X-IronPort-AV: E=Sophos;i="6.02,235,1688454000"; 
   d="scan'208";a="777113375"
Received: from aschofie-mobl2.amr.corp.intel.com (HELO aschofie-mobl2) ([10.251.29.163])
  by orsmga001-auth.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 07 Sep 2023 08:46:05 -0700
Date: Thu, 7 Sep 2023 08:46:04 -0700
From: Alison Schofield <alison.schofield@intel.com>
To: ira.weiny@intel.com
Cc: Dan Williams <dan.j.williams@intel.com>,
        Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        linux-cxl@vger.kernel.org, linux-kernel@vger.kernel.org
Subject: Re: [PATCH RFC v2 03/18] cxl/mem: Read Dynamic capacity
 configuration from the device
Message-ID: <ZPnwPDZrKYT7hp6X@aschofie-mobl2>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
 <20230604-dcd-type2-upstream-v2-3-f740c47e7916@intel.com>
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: <20230604-dcd-type2-upstream-v2-3-f740c47e7916@intel.com>
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

On Mon, Aug 28, 2023 at 10:20:54PM -0700, Ira Weiny wrote:
> From: Navneet Singh <navneet.singh@intel.com>
> 
> Devices can optionally support Dynamic Capacity (DC).  These devices are
> known as Dynamic Capacity Devices (DCD).

snip

> 
> +static enum cxl_region_mode
> +cxl_decoder_to_region_mode(enum cxl_decoder_mode mode)
> +{
> +	switch (mode) {
> +	case CXL_DECODER_NONE:
> +		return CXL_REGION_NONE;
> +	case CXL_DECODER_RAM:
> +		return CXL_REGION_RAM;
> +	case CXL_DECODER_PMEM:
> +		return CXL_REGION_PMEM;
> +	case CXL_DECODER_DEAD:
> +		return CXL_REGION_DEAD;
> +	case CXL_DECODER_MIXED:
> +	default:
> +		return CXL_REGION_MIXED;
> +	}
> +
> +	return CXL_REGION_MIXED;

Can the paths to return _MIXED be simplified here?


> +}
> +
snip

> diff --git a/drivers/cxl/cxl.h b/drivers/cxl/cxl.h
> index cd4a9ffdacc7..ed282dcd5cf5 100644
> --- a/drivers/cxl/cxl.h
> +++ b/drivers/cxl/cxl.h
> @@ -374,6 +374,28 @@ static inline const char *cxl_decoder_mode_name(enum cxl_decoder_mode mode)
>  	return "mixed";
>  }
>  
> +enum cxl_region_mode {
> +	CXL_REGION_NONE,
> +	CXL_REGION_RAM,
> +	CXL_REGION_PMEM,
> +	CXL_REGION_MIXED,
> +	CXL_REGION_DEAD,
> +};

I'm concerned about _DEAD.
At first I was going to say name these as CXL_REGION_MODE_*, but it's
pretty obvious that these are mode words...except for DEAD. Is that 
an actual mode or is it some type of status? I don't think I see it
used yet.

> +
> +static inline const char *cxl_region_mode_name(enum cxl_region_mode mode)
> +{
> +	static const char * const names[] = {
> +		[CXL_REGION_NONE] = "none",
> +		[CXL_REGION_RAM] = "ram",
> +		[CXL_REGION_PMEM] = "pmem",
> +		[CXL_REGION_MIXED] = "mixed",
> +	};
> +
> +	if (mode >= CXL_REGION_NONE && mode <= CXL_REGION_MIXED)
> +		return names[mode];
> +	return "mixed";
> +}

snip

> +
>  /**
>   * struct cxl_memdev_state - Generic Type-3 Memory Device Class driver data
>   *
> @@ -449,6 +464,8 @@ struct cxl_dev_state {
>   * @enabled_cmds: Hardware commands found enabled in CEL.
>   * @exclusive_cmds: Commands that are kernel-internal only
>   * @total_bytes: sum of all possible capacities
> + * @static_cap: Sum of RAM and PMEM capacities
> + * @dynamic_cap: Complete DPA range occupied by DC regions

Wondering about renaming RAM and PMEM caps as 'static'.
They are changeable via set partition commands.


>   * @volatile_only_bytes: hard volatile capacity
>   * @persistent_only_bytes: hard persistent capacity
>   * @partition_align_bytes: alignment size for partition-able capacity
> @@ -456,6 +473,10 @@ struct cxl_dev_state {
>   * @active_persistent_bytes: sum of hard + soft persistent
>   * @next_volatile_bytes: volatile capacity change pending device reset
>   * @next_persistent_bytes: persistent capacity change pending device reset
> + * @nr_dc_region: number of DC regions implemented in the memory device
> + * @dc_region: array containing info about the DC regions
> + * @dc_event_log_size: The number of events the device can store in the
> + * Dynamic Capacity Event Log before it overflows
>   * @event: event log driver state
>   * @poison: poison driver state info
>   * @fw: firmware upload / activation state
> @@ -473,7 +494,10 @@ struct cxl_memdev_state {
>  	DECLARE_BITMAP(dcd_cmds, CXL_DCD_ENABLED_MAX);
>  	DECLARE_BITMAP(enabled_cmds, CXL_MEM_COMMAND_ID_MAX);
>  	DECLARE_BITMAP(exclusive_cmds, CXL_MEM_COMMAND_ID_MAX);
> +
>  	u64 total_bytes;
> +	u64 static_cap;
> +	u64 dynamic_cap;
>  	u64 volatile_only_bytes;
>  	u64 persistent_only_bytes;
>  	u64 partition_align_bytes;
> @@ -481,6 +505,11 @@ struct cxl_memdev_state {
>  	u64 active_persistent_bytes;
>  	u64 next_volatile_bytes;
>  	u64 next_persistent_bytes;
> +
> +	u8 nr_dc_region;
> +	struct cxl_dc_region_info dc_region[CXL_MAX_DC_REGION];
> +	size_t dc_event_log_size;
> +
>  	struct cxl_event_state event;
>  	struct cxl_poison_state poison;
>  	struct cxl_security_state security;
> @@ -587,6 +616,7 @@ struct cxl_mbox_identify {
>  	__le16 inject_poison_limit;
>  	u8 poison_caps;
>  	u8 qos_telemetry_caps;
> +	__le16 dc_event_log_size;
>  } __packed;
>  

snip

>  /*

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id E7BC8EE14D0
	for <linux-cxl@archiver.kernel.org>; Wed,  6 Sep 2023 21:39:26 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S244823AbjIFVj2 (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Wed, 6 Sep 2023 17:39:28 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:43724 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S243608AbjIFVj1 (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Wed, 6 Sep 2023 17:39:27 -0400
Received: from mgamail.intel.com (mgamail.intel.com [134.134.136.126])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 0C93719A4;
        Wed,  6 Sep 2023 14:39:22 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1694036363; x=1725572363;
  h=date:from:to:cc:subject:message-id:references:
   in-reply-to:mime-version;
  bh=0/R4rfSYXaeHggrgb1CxSoO2Erpc+3+WksS/BZxzsms=;
  b=jSuhY0HNSR3m61omoglgBI4kgc91QnHXYoNJDAg7WVw0zAQ30YnWTawv
   v/N0KJxu5DhoWEgKMb7sx8nvdwMslmkfA/TJtbJXaRi5fAGeqbnDSD3ZR
   H4iqELr/Ab3rHazKCa99qVsytLAi27ezyLp6Y+G21/S2sKqleFLYTyZyb
   sZd/3uwv9iXHFxPEcW2MfGfHA8HpzLfr6PqP9dlgmpAT93kq6+LuuNW2I
   oazmhB5TVkm/F4XTuy6FXbKCmT9WsXAB2IwKMgbWC5Tx7/H14gvsvn/r+
   RUdtwvoK8peC7ZiwyVR2wtq1pH9OIPE2R5TTWcmgiT6Nh6yzCLPu9xHMj
   Q==;
X-IronPort-AV: E=McAfee;i="6600,9927,10825"; a="362223688"
X-IronPort-AV: E=Sophos;i="6.02,233,1688454000"; 
   d="scan'208";a="362223688"
Received: from fmsmga006.fm.intel.com ([10.253.24.20])
  by orsmga106.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 06 Sep 2023 14:39:20 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10825"; a="988469779"
X-IronPort-AV: E=Sophos;i="6.02,233,1688454000"; 
   d="scan'208";a="988469779"
Received: from fmsmsx601.amr.corp.intel.com ([10.18.126.81])
  by fmsmga006.fm.intel.com with ESMTP/TLS/AES256-GCM-SHA384; 06 Sep 2023 14:39:15 -0700
Received: from fmsmsx611.amr.corp.intel.com (10.18.126.91) by
 fmsmsx601.amr.corp.intel.com (10.18.126.81) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.32; Wed, 6 Sep 2023 14:39:15 -0700
Received: from fmsmsx611.amr.corp.intel.com (10.18.126.91) by
 fmsmsx611.amr.corp.intel.com (10.18.126.91) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27; Wed, 6 Sep 2023 14:39:14 -0700
Received: from fmsedg602.ED.cps.intel.com (10.1.192.136) by
 fmsmsx611.amr.corp.intel.com (10.18.126.91) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27 via Frontend Transport; Wed, 6 Sep 2023 14:39:14 -0700
Received: from NAM12-MW2-obe.outbound.protection.outlook.com (104.47.66.46) by
 edgegateway.intel.com (192.55.55.71) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.27; Wed, 6 Sep 2023 14:39:14 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=L/KydPIL41mI1shQgRn3/2nJ203q9QCBBB93DoyVnMmQaD7zlVkCxkhwURnokNuVLgr7ri8Te/5ZEcF06mgTjjldhv/RHMzDI5nOeONFyE+U+1EZuVIxaAAFPb6rm3RIFd76V84ZKQeQdSlVkYSUo6l9kPJjvBEaHPDxPsKpBnTX9EgWD1LThThIWjSUlyh8LILCn9nI91gGzRjwG8mZLv6L835sxuiXwvqxzR9tWde/tuREm7aCGKfjtJShYyhySLQAqxMtzK8wUmOXyzCyOgm9l8BV8aPnrpt/94oGoJa5hC5D5lbsKz8ecckOAVZmehe76pjnTE4f+OcSsAqCcw==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=QQYC8AhHQqpk7fJbTr4j2kxTLhWAqZ9nIegg9ZU3oG8=;
 b=EUv1/5Zc07Am1roKpRpsUHDBgU3JiUHsD3ctSlglD6Hsb3o3rIVg7DiB1262tGIGj7wHVZxpCtM7PWJ+/asxVoOx3v8KHP0ePhxTyfgf4T+jxG4vozJwGqQUyYGNLnFveSGr4f3LDsuVfVtX0/XELrEgXRAhqQcxXTJZHxdc9F9Q1B5IHj1/i8ybKqAhE6rkuJYDn86cKc4P7lIMJ2tUK6seH/4fHhDb4/swQZv5CtgE4SU8jt4u910db+8dFJSKbzv+sRZzVTHbIJhPd8ePap7hFsg+gwBLKR6qgFB1nLcmkJwwj9G+6dxGp4tADQhKveJpqvVASz+jWp7lvoUFBQ==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from SA1PR11MB6733.namprd11.prod.outlook.com (2603:10b6:806:25c::17)
 by CH3PR11MB7180.namprd11.prod.outlook.com (2603:10b6:610:148::5) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.6745.34; Wed, 6 Sep
 2023 21:39:12 +0000
Received: from SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938]) by SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938%6]) with mapi id 15.20.6745.034; Wed, 6 Sep 2023
 21:39:12 +0000
Date: Wed, 6 Sep 2023 14:39:09 -0700
From: Ira Weiny <ira.weiny@intel.com>
To: Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Ira Weiny <ira.weiny@intel.com>
CC: Dan Williams <dan.j.williams@intel.com>,
        Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
Subject: Re: [PATCH RFC v2 18/18] tools/testing/cxl: Add Dynamic Capacity
 events
Message-ID: <64f8f17d8dee3_1e8e78294a3@iweiny-mobl.notmuch>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
 <20230604-dcd-type2-upstream-v2-18-f740c47e7916@intel.com>
 <20230830132335.0000162e@Huawei.com>
Content-Type: text/plain; charset="us-ascii"
Content-Disposition: inline
In-Reply-To: <20230830132335.0000162e@Huawei.com>
X-ClientProxiedBy: BY5PR03CA0024.namprd03.prod.outlook.com
 (2603:10b6:a03:1e0::34) To SA1PR11MB6733.namprd11.prod.outlook.com
 (2603:10b6:806:25c::17)
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: SA1PR11MB6733:EE_|CH3PR11MB7180:EE_
X-MS-Office365-Filtering-Correlation-Id: 66dd0b19-ae75-4051-9d98-08dbaf21b60b
X-LD-Processed: 46c98d88-e344-4ed4-8496-4ed7712e255d,ExtAddr
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;
X-Microsoft-Antispam-Message-Info: VNcD1xUMOx2GYfrWo087d0oiR6A/O911qCHzYGMVZ5dLZZ141m9hDBuEpk+403PRWPifP1KEYONuH6Fnpo7cfuhoWdfJVrkyZgj8Q5pgBLDYfCd7dfZMqN0A5pN/gjAEmpDNUBEJcWQLYyXdPIV7pvSUYTwiqd06Vbvyoka3OxVmmwhJluogYjTjVpVsRJ8nDgOKM+w4aNM7AYmaOICa/hZlok/T67pOCRrD0V8HddART2Qp9lkC8W9xJDYom1XimTUwM6oHNR1pwvup0/80rdSCNtTHrYIVoGrvU4qlloqA3eNt+bXdxL9vBHKbtH9ImO/vqmf3zNWvD6F7qoVCM9ViS3oCzSTyRQ1dnfxaWl1BNa9QLGKMzIXSED/xHk5f+1kxo6Ae2IXCTxyjhbMYggdQaonBdYAEKX05G+cqgrNI160c0fa+EFL2Sb+3EZob11bGHgUR7111KSEylXy5QnwckZPHrt3Szldi3NqNmwOZkxwsT/TvWixltOmIkPmwYzfcypLBlXmmvyhFUHosXoQWfYV7qpADLOfygoDfGYOXmoOPZR03mQpfklayytIW
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:SA1PR11MB6733.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230031)(136003)(366004)(376002)(346002)(39860400002)(396003)(451199024)(1800799009)(186009)(41300700001)(5660300002)(44832011)(86362001)(6666004)(478600001)(2906002)(8676002)(4326008)(8936002)(316002)(66556008)(54906003)(110136005)(66476007)(66946007)(26005)(6486002)(6506007)(82960400001)(38100700002)(6512007)(9686003)(83380400001);DIR:OUT;SFP:1102;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?us-ascii?Q?+lKtYjbDJw1gEKea8IphM5eK2qphRIj1OoGkYenSuRfukoxuEqdQc2QdxZiE?=
 =?us-ascii?Q?elkTQ9QLIBZbIOuA0kOKG21Q2cS2lcm+OzK46v6rubyMazdxyg+sIk/RJFi3?=
 =?us-ascii?Q?BeRNGHJ9ARZBi1qPkjNl69+Mr+9WD/KxM+UXYvR61HaCMBfBeHeXSkHbxQri?=
 =?us-ascii?Q?Jv9CjR8r6dJQuNfvqcwZFKnK71BMBCSn/XMuH03Y0G6+7ZfLT3acHkdGEV5Y?=
 =?us-ascii?Q?Uy+2wrUk16vmsD9rMd26xqniJnY+UspHA91seOQgkINg01DMVuiorio4/TeF?=
 =?us-ascii?Q?eDPcFR0Afl5StXnyRA8OiqGIvLUdmeJ0kExI29P5LxgnymWB7noWHptuBFWW?=
 =?us-ascii?Q?eWMopUW/g2PjqG7OCj1KTw1tc9dZNOuhMae+pLgXO5FiMiADVvMGz9jGTIVE?=
 =?us-ascii?Q?a6PD9CoZyywktD7WCJPOjMyEBTMmLxB0hntvJuqrUCOQXi9FHsTAf6BBIZRY?=
 =?us-ascii?Q?O7vT/6+zkp2JKedHI3H2spaaN965S0ZLLhoqGO4aH+I0CGCl8uW++mI5hAbn?=
 =?us-ascii?Q?e0lawnpNlV/GLAvw7FYasfMy+JfeapwAIgI0T1BrkPS0mOGEomF1JJS8/nDI?=
 =?us-ascii?Q?eyMyN4BzxfTA/HLsEzMNV1ujQcULaVT0doCi9nmBI/klgkiun0deb8sqVAaa?=
 =?us-ascii?Q?CS/xbf2rjkFC3A7i1mofFrtAvJ8f8lezN3WApcJet8bzFL+in2+2vvCanTWf?=
 =?us-ascii?Q?UXodxoLVqab0oPrRqmjLzwzBUc0OT2JCRbltUQba0JLrwK5OU3azao8FDwi/?=
 =?us-ascii?Q?wGOD3L1jx6TRCmqsb1E8A+STkKETTbr5Pj1b2m/h/5BguKMLRG6lPZSZusqT?=
 =?us-ascii?Q?rOQn+DqgN2QtIiexI1rrjedxLb1ZqX5RT3hQVw6uUkko/i30RBBbfHKTAH1w?=
 =?us-ascii?Q?1EoZCjlAP9I42FoZW4vyOdZbxI8qGomi80N+sPli3bGgW42GlcOqmOhwq6sj?=
 =?us-ascii?Q?6CGIGoypcDaMSe1J3ziRzY2KjycXM+pixN5VJQY2dM39vB/tELv0o3+SYjNg?=
 =?us-ascii?Q?Z6RfcJ3vTw676tUIe9I84EGUT3yr12YXJREk20tgFLtIchQ6LwcqblEWiFUB?=
 =?us-ascii?Q?6eSBkry1udCu3A84ZgsQ8hRIApnD3C4Bq7aDAIP/CImJ4HOvEygFB5pYWvIl?=
 =?us-ascii?Q?ZeV+Mi9Tnf8GoET4rXm33kEq+fx+YEgkIxaoJ+EQ6/Vdoze9CtxDHpEh4ybS?=
 =?us-ascii?Q?b+GtOYuvSutlU2mSGoT868f//ihYzN0HF5lypkw9zof7ys8WsDNMwBEpPVzI?=
 =?us-ascii?Q?NINKpMN4r8OvOmprH0iI9SWcfOUxbZCfygQ9voT6Z0DzxNHWbhT81YH7+R5J?=
 =?us-ascii?Q?+HM0LF8ebDo3JGyWgqjcrwMaLCTnFd0xuH7XKlV9vhja2QlhLz4xN3p6LyVc?=
 =?us-ascii?Q?86k+pBieIyu0tgRmPVJSu7STPr+6AlvlIi4gXyxf4Qg3AVZHfJqHW+PzRRUG?=
 =?us-ascii?Q?3lopzHH9LqFhh8lFz7JWl38qSZw6lOrfvfA6uN6gS0mEJTk23sHB487oaKNB?=
 =?us-ascii?Q?lA3AIbYrf82ls6Y3tbFrL7CzOAJjWg6RFxFM162L2aG3iitE45u1TfvDeSXv?=
 =?us-ascii?Q?xzEBQ1x8gB8eSenYAbuwITUZLrsaJK2hmoBa6py6?=
X-MS-Exchange-CrossTenant-Network-Message-Id: 66dd0b19-ae75-4051-9d98-08dbaf21b60b
X-MS-Exchange-CrossTenant-AuthSource: SA1PR11MB6733.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 06 Sep 2023 21:39:12.7535
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: cegVM0MzFw/zf8SoogcifkM2XMtYQC7TD4/JAxbYJUSsdgBD7F2xc+BobUBjtPJlA3bgqZ9IPqZCM0toMdaIGw==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: CH3PR11MB7180
X-OriginatorOrg: intel.com
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

Jonathan Cameron wrote:
> On Mon, 28 Aug 2023 22:21:09 -0700
> Ira Weiny <ira.weiny@intel.com> wrote:
> 
> > OS software needs to be alerted when new extents arrive on a Dynamic
> > Capacity Device (DCD).  On test DCDs extents are added through sysfs.
> > 
> > Add events on DCD extent injection.  Directly call the event irq
> > callback to simulate irqs to process the test extents.
> > 
> > Signed-off-by: Ira Weiny <ira.weiny@intel.com>
> Trivial comments inline.
> 
> Reviewed-by: Jonathan.Cameron@huawei.com>
> 
> > ---
> >  tools/testing/cxl/test/mem.c | 57 ++++++++++++++++++++++++++++++++++++++++++++
> >  1 file changed, 57 insertions(+)
> > 
> > diff --git a/tools/testing/cxl/test/mem.c b/tools/testing/cxl/test/mem.c
> > index d6041a2145c5..20364fee9df9 100644
> > --- a/tools/testing/cxl/test/mem.c
> > +++ b/tools/testing/cxl/test/mem.c
> > @@ -2008,6 +2008,41 @@ static bool new_extent_valid(struct device *dev, size_t new_start,
> >  	return false;
> >  }
> >  
> > +struct dcd_event_dyn_cap dcd_event_rec_template = {
> > +	.hdr = {
> > +		.id = UUID_INIT(0xca95afa7, 0xf183, 0x4018,
> > +				0x8c, 0x2f, 0x95, 0x26, 0x8e, 0x10, 0x1a, 0x2a),
> > +		.length = sizeof(struct dcd_event_dyn_cap),
> > +	},
> > +};
> > +
> > +static int send_dc_event(struct mock_event_store *mes, enum dc_event type,
> > +			 u64 start, u64 length, const char *tag_str)
> 
> Arguably it's not sending the event, but rather adding it to the event log and
> flicking the irq. So maybe naming needs some thought?

I spent all my naming energy on what to call extents at each layer...  ;-)

Yea I'll rename to add_dc_event() or something like that.

> 
> > +{
> > +	struct device *dev = mes->mds->cxlds.dev;
> > +	struct dcd_event_dyn_cap *dcd_event_rec;
> > +
> > +	dcd_event_rec = devm_kzalloc(dev, sizeof(*dcd_event_rec), GFP_KERNEL);
> > +	if (!dcd_event_rec)
> > +		return -ENOMEM;
> > +
> > +	memcpy(dcd_event_rec, &dcd_event_rec_template, sizeof(*dcd_event_rec));
> 
> devm_kmemdup?

Yep would work well.

Thanks again for all the review,
Ira

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 3034EEE14D3
	for <linux-cxl@archiver.kernel.org>; Wed,  6 Sep 2023 21:18:36 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S244666AbjIFVSi (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Wed, 6 Sep 2023 17:18:38 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:56020 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S234572AbjIFVSh (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Wed, 6 Sep 2023 17:18:37 -0400
Received: from mgamail.intel.com (mgamail.intel.com [134.134.136.24])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 9BF249C;
        Wed,  6 Sep 2023 14:18:33 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1694035113; x=1725571113;
  h=date:from:to:cc:subject:message-id:references:
   in-reply-to:mime-version;
  bh=Hrh6MnTMRYH79ecIVpp5acj9okYIHWs+xrieAzVimug=;
  b=L8LG3Z3NciWMtoog6DTiMlkbSiyHe91oyjEkP2lR8KqDPQNC2u95kThy
   7JYgQHcg7qhjm2jvByK5vCHpq6AYKiqrzqgCCaFOljOi2w2nyGKNw6CCi
   ZQGwqwfRjvTk+esrDgygtkgZHrAvQWCbyaYgYBTQ64ipy9OA0vJeS0XME
   d7xUVOPVfcMUXqYrRclB/PZikQwX0Wyf4wqZ643Icb2GjsLP6/F55OsDE
   SD11C1Px2ALMmXMf4s48TwsflPKqwLwjyr8l/aStnpWWn7C9iPPtIXnT4
   +UmEtb1wW8FxbM07cKPiP46FopjAsqYxhCdDOlX5o5OBXLy/Ph3xOJ+pZ
   A==;
X-IronPort-AV: E=McAfee;i="6600,9927,10825"; a="379896849"
X-IronPort-AV: E=Sophos;i="6.02,233,1688454000"; 
   d="scan'208";a="379896849"
Received: from fmsmga001.fm.intel.com ([10.253.24.23])
  by orsmga102.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 06 Sep 2023 14:18:33 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10825"; a="884894107"
X-IronPort-AV: E=Sophos;i="6.02,233,1688454000"; 
   d="scan'208";a="884894107"
Received: from orsmsx602.amr.corp.intel.com ([10.22.229.15])
  by fmsmga001.fm.intel.com with ESMTP/TLS/AES256-GCM-SHA384; 06 Sep 2023 14:18:20 -0700
Received: from orsmsx611.amr.corp.intel.com (10.22.229.24) by
 ORSMSX602.amr.corp.intel.com (10.22.229.15) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.32; Wed, 6 Sep 2023 14:18:31 -0700
Received: from orsmsx610.amr.corp.intel.com (10.22.229.23) by
 ORSMSX611.amr.corp.intel.com (10.22.229.24) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27; Wed, 6 Sep 2023 14:18:30 -0700
Received: from ORSEDG602.ED.cps.intel.com (10.7.248.7) by
 orsmsx610.amr.corp.intel.com (10.22.229.23) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27 via Frontend Transport; Wed, 6 Sep 2023 14:18:30 -0700
Received: from NAM11-BN8-obe.outbound.protection.outlook.com (104.47.58.168)
 by edgegateway.intel.com (134.134.137.103) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.27; Wed, 6 Sep 2023 14:18:28 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=dVRfTjNJHH7objPMS52GJquTmD/m6vyG7zzwkhMSiMc/gC4vXDPhDdHer007BZRDiWozol5l8w9X/fdQRWjuwbTHhJVhWFfeAjVopkR8Szpiz6h2nnD9bXu+E7bxDNltfYpgSJd75I4aahSWfp2zymSkX68ScbYa0KWOeCNJqvrEHdhn3A5z7jK4dWqlHsJ6soazZ8lfEibpGHxivDJEOchSRICW3TVR/VbGhUIdygm1KjTF9QIWKJqKlXXX4DrtDum2tPCI1wBwj+3kw5EoaQzsMVdBzHmvBJWbYCdCe9h20NqQXKuJH76AiN7H0tBAwEOlf1Q9hnuwiyxYhlgYlg==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=YunKIhrMnfv0ziiItIYjibEXhd6Bj9PyLBIn4zKIjaQ=;
 b=Udr58noRLyX3jTNLsQNb1zEMZivaG3ycPXRWw69wtXQw+lAxg7mssb5rA2YprfmAWy5R173T2XQc3uJwuS4+4BKW/WNHxCBaUHueNow6CTLRhZthVViTlBKOymbAICJR8JlcFOBl7OltOCQ6umnbpvNsr9cKnps8Ux052oE+tKKdErS9THSSR4aE+5Jh5p/f7J/DePjteWtveO9Sp268BIklbpLws+JWvkttrA3MTb47HxBUUE0z1dWHnnGSCyy2RkEosR5JVZMojD10/p3czG2fyHBl+sK0fy+MtNPRbbhqnxs3dSGn1KlVGCWf2DIUIZuLadsDa41bQNbQKqMurA==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from SA1PR11MB6733.namprd11.prod.outlook.com (2603:10b6:806:25c::17)
 by SN7PR11MB6726.namprd11.prod.outlook.com (2603:10b6:806:266::13) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.6745.34; Wed, 6 Sep
 2023 21:18:26 +0000
Received: from SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938]) by SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938%6]) with mapi id 15.20.6745.034; Wed, 6 Sep 2023
 21:18:26 +0000
Date: Wed, 6 Sep 2023 14:18:23 -0700
From: Ira Weiny <ira.weiny@intel.com>
To: Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Ira Weiny <ira.weiny@intel.com>
CC: Dan Williams <dan.j.williams@intel.com>,
        Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
Subject: Re: [PATCH RFC v2 17/18] tools/testing/cxl: Add DC Regions to mock
 mem data
Message-ID: <64f8ec9f3241d_1e8e782941c@iweiny-mobl.notmuch>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
 <20230604-dcd-type2-upstream-v2-17-f740c47e7916@intel.com>
 <20230830132037.00005348@Huawei.com>
Content-Type: text/plain; charset="us-ascii"
Content-Disposition: inline
In-Reply-To: <20230830132037.00005348@Huawei.com>
X-ClientProxiedBy: SJ0PR03CA0245.namprd03.prod.outlook.com
 (2603:10b6:a03:3a0::10) To SA1PR11MB6733.namprd11.prod.outlook.com
 (2603:10b6:806:25c::17)
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: SA1PR11MB6733:EE_|SN7PR11MB6726:EE_
X-MS-Office365-Filtering-Correlation-Id: 2afc75b4-66da-4339-9f62-08dbaf1ecf45
X-LD-Processed: 46c98d88-e344-4ed4-8496-4ed7712e255d,ExtAddr
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;
X-Microsoft-Antispam-Message-Info: CeVh3FTF+CPlBtx/qjIQF/QpVQdWKBSNdeXA+RBZk9G9z+KLN9Y2a4Ta9Hx4mOqGyjNlmEPFkmYpyLADE3zXXOqghkU5VTLucVDWsHcVpntisJCOg2hrEn1RHIcBFzFaTRtxt19y7q/WuDYdeYa/QaXYdCMW0EEnQSjZK8gVxyHNctRpCyKTy8NhSyNMV1W1/3Jf2iuMsWldvftbMw64+ip3gvn7g2SFBKOTN0YIi5t6FtSFRGWAPRT0U2h7rl5X7fhmUz6AcWTyTWudlzerFLidgqEZOP9z20eYjrpuNs8uNMHJNtMUE4zsEwTSfeV5dAQUMkbFxF3UMF04MuSwP9CblBtBRh4tWhSx4h4QgLVxRgpGnhsE9YntmZ9qEoRs2O4nC3eGcYVfnpmV6B11ygYZ8JSgKqUi899/0OXXSYFlK1GnYvp7saJe8mJuNq9hlslJRi3s4ZuG3md7N1R1vohF1VTv62H+8ggjYZ++tlvfX3dQwy/AXHWAxOc5ZaG3WOJYavU0KE6l5AFgcmvzgWITGcmKZYqRS2LY8VGle4Tfoe2galoITCMA9S3YPJJR
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:SA1PR11MB6733.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230031)(366004)(396003)(346002)(39860400002)(136003)(376002)(1800799009)(186009)(451199024)(82960400001)(9686003)(6666004)(6486002)(6506007)(86362001)(38100700002)(26005)(2906002)(6512007)(83380400001)(478600001)(110136005)(4326008)(41300700001)(8936002)(8676002)(5660300002)(66476007)(316002)(54906003)(66556008)(44832011)(66946007);DIR:OUT;SFP:1102;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?us-ascii?Q?XxmrJ+9GhUslfB8ZjqZqr65YKZ/VClvsrHeDLH7TCaEf8B2LKoCSoeo3Y+7x?=
 =?us-ascii?Q?tGOpluOYdLS2rQPtJXWsmhko+Cm52QEm/vABjwoHmue1924jQfUFx+ILsPzd?=
 =?us-ascii?Q?86Nbnf9HKfl+rm71Ez8URixG5+mEkFtd8Sm6q9obDcktoCr9D1ACYER1ZXE2?=
 =?us-ascii?Q?ccUE4t2JUu4240+/zCR0alDQLPDQQm+f4qZYPg9+MZHGTHm/0OB9EIeOdqwM?=
 =?us-ascii?Q?LlalslWLQcgII+/IMSV2pA4qwzgYz33cDT2I6hThoZTjUNT5Msxm74XDYFlQ?=
 =?us-ascii?Q?X19E9lLvYDESuPKYb5XZxAjn3kPzJOcKlnq3k1SXmLNSBSRjC+6EhkzZv75y?=
 =?us-ascii?Q?QbS127yjHjyHOb5agCDxSW60VZf7wP0df48brcWusSvcS5IUhBvRhdIfO/c8?=
 =?us-ascii?Q?HkhPrJrPMPr6exk1meNGx3ot5qIBHGRHTqxtrpoOdMLA0/Jhmwrxj727gyT7?=
 =?us-ascii?Q?uCZVJDRGINjRedUmq4Ifnz49lDhIezpv9RqH3V1NjQ+4kDNSXQEIigQaRlQK?=
 =?us-ascii?Q?wBDZcQoeCivoEnsDdevhxZY6FVZdk1OI4IE+s5L/GspQurJVkUFNh1sXqVji?=
 =?us-ascii?Q?5fu6hQX/N/QErtXPZQHB9gIx+wFJidRVMssgJAG2orI0XrfPXsQbvy3qImP2?=
 =?us-ascii?Q?OEZayRQhVANKQwuNrlN/oiThR90W6/dEQh7HEajOC9DiMAlAcM1SCSOuM72e?=
 =?us-ascii?Q?7STUE+OH2fLnpLs39f3bSQGYyGju1iYhnG650iQk0Tn3p91YvQzLsNJ5I6//?=
 =?us-ascii?Q?9+mLUarsepPqiYHDW5Kv+d8xvzU+pKcjJIMgaoD3ybWSSptqk+RgCwGwSnPA?=
 =?us-ascii?Q?2X9PRjDlV+lo9Rq9gn5r6rPPdSWdCVG60CyXob3AhW/Iv+aOehxLiYP/FLdm?=
 =?us-ascii?Q?d6kgH6LXwczAzGzlO/Mexz/UvSK9ajHGvOxlBykpyOL6GNlxDPXJ/NycqFan?=
 =?us-ascii?Q?NQAZhghZvGicxvFOAWHx7osgWfbDq6YAJ6DOGj86QfonJ4i/gR88mfS7lgT8?=
 =?us-ascii?Q?j9lEOMt4w3V83aIFqCcr/OHRO+aDtPqiio+75XfmFUKdKOo0shPDb9+K5++l?=
 =?us-ascii?Q?Zm2Bx3nVo4lIs+iclkTVu/2qqpfz/VqYB40dZV92lFn2p6pUbwj7WwAKioo1?=
 =?us-ascii?Q?r2fuzQ9Cu/eY28ejskLuLAlx9pMYDysqYOqPk/JXSAnJ8yvO4Wu+gQ0eZcTt?=
 =?us-ascii?Q?h++FBdrK8mJ0q9pz4u/5exJ84uJq/wceG3laZ0qakVuYnfCoYQ4ilGFQ7gDl?=
 =?us-ascii?Q?ZyjNnX/vVtsKm35P46vn2dTeLK1ifbitNqcZ/P6tglbLHmBlWmg6N8gi3Jtt?=
 =?us-ascii?Q?hGVuj7wpt5F8IFcnXAcz27NAF30NWJSjejqv6f+VZl42SrUuoKp1sN3Q54+I?=
 =?us-ascii?Q?ghMNXU42Oiugf4UEEmWbxbKuwDMkr+Mm+iT1v3lnFD9BryvvhBPDFLeQy/4k?=
 =?us-ascii?Q?/rYY7wlY88DfpIa6Ns4lLOjUEEUBJX47vlrx5HflFEL8ciBi9OE531GfZL/8?=
 =?us-ascii?Q?yMAp9ffyxA/Cs38J+isKkpYigHox/FhcYPN1MAmQ6Viv4H3DUerNpAZZknog?=
 =?us-ascii?Q?crcwBbSzkbu77Kyfq72KRu6tkE/OpIm9m7Oh9hLb?=
X-MS-Exchange-CrossTenant-Network-Message-Id: 2afc75b4-66da-4339-9f62-08dbaf1ecf45
X-MS-Exchange-CrossTenant-AuthSource: SA1PR11MB6733.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 06 Sep 2023 21:18:26.6042
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: knDD6oUvyBRhK+TfA1jb40O4BCOlnnK7ZP0r2Rcs1HI9J9TIXVcPvMgpd+SZQzbXRjzUl5g138fauOODIW6iFw==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: SN7PR11MB6726
X-OriginatorOrg: intel.com
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

Jonathan Cameron wrote:
> On Mon, 28 Aug 2023 22:21:08 -0700
> Ira Weiny <ira.weiny@intel.com> wrote:
> 
> > To test DC regions the mock memory devices will need to store
> > information about the regions and manage fake extent data.
> > 
> > Define mock_dc_region information within the mock memory data.  Add
> > sysfs entries on the mock device to inject and delete extents.
> > 
> > The inject format is <start>:<length>:<tag>
> > The delete format is <start>
> > 
> > Add DC mailbox commands to the CEL and implement those commands.
> > 
> > Signed-off-by: Ira Weiny <ira.weiny@intel.com>
> 
> Looks fine to me.  Totally trivial comment inline.
> 
> FWIW
> Reviewed-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
> 
> 
> > +
> >  static int mock_gsl(struct cxl_mbox_cmd *cmd)
> >  {
> >  	if (cmd->size_out < sizeof(mock_gsl_payload))
> > @@ -1315,6 +1429,148 @@ static int mock_activate_fw(struct cxl_mockmem_data *mdata,
> >  	return -EINVAL;
> >  }
> >  
> 
> Bit inconsistent on whether there are one or two blank lines between functions.

I missed this one in my internal review.  There should be no
inconsistency...  always 1 unless I messed up!  :-D

Thanks,
Ira

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 208C3EE14D3
	for <linux-cxl@archiver.kernel.org>; Wed,  6 Sep 2023 21:15:55 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S232411AbjIFVP5 (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Wed, 6 Sep 2023 17:15:57 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:43570 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S231134AbjIFVP4 (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Wed, 6 Sep 2023 17:15:56 -0400
Received: from mgamail.intel.com (mgamail.intel.com [192.55.52.93])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id A96BAE6F;
        Wed,  6 Sep 2023 14:15:51 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1694034951; x=1725570951;
  h=date:from:to:cc:subject:message-id:references:
   in-reply-to:mime-version;
  bh=ODlvg/VJ1uWoKcul6iYtQFdCAZ94gZpvT2gIKHNY9oM=;
  b=nXRGkqpGcWkJf8kRe0UzAtE5NEVjwkG32PDWYi8nRYC8cBh862j3uQC8
   W2V+xOKb/6gGktHp10Yz54NhLRreTx8VrgnMY7QZMZx/yKEbxw41SLHSc
   MY3UTpl8UhxPpML6vEBUKWuxqEcxHvGVxP5IKRzV6355RxWKeqBKVMB9e
   KPd8M7/MxRzbaV16ukeXNAdmWbX6BWhiy4L3gVSnFWgF/xgQZZ+2nz/ZS
   vKV7IHW407QHV2BWlRIzAE3XULTCgmtpmU26oM0Xvc8FADjg3d27NeSnL
   iU5UPKMo327p/yT5QVLDWX2JkorS8LmOWDt1OY5qmsvGaocKl8qSkk/Zn
   A==;
X-IronPort-AV: E=McAfee;i="6600,9927,10825"; a="374579823"
X-IronPort-AV: E=Sophos;i="6.02,233,1688454000"; 
   d="scan'208";a="374579823"
Received: from orsmga002.jf.intel.com ([10.7.209.21])
  by fmsmga102.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 06 Sep 2023 14:15:39 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10825"; a="741726648"
X-IronPort-AV: E=Sophos;i="6.02,233,1688454000"; 
   d="scan'208";a="741726648"
Received: from fmsmsx602.amr.corp.intel.com ([10.18.126.82])
  by orsmga002.jf.intel.com with ESMTP/TLS/AES256-GCM-SHA384; 06 Sep 2023 14:15:37 -0700
Received: from fmsmsx612.amr.corp.intel.com (10.18.126.92) by
 fmsmsx602.amr.corp.intel.com (10.18.126.82) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.32; Wed, 6 Sep 2023 14:15:36 -0700
Received: from fmsmsx610.amr.corp.intel.com (10.18.126.90) by
 fmsmsx612.amr.corp.intel.com (10.18.126.92) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27; Wed, 6 Sep 2023 14:15:36 -0700
Received: from FMSEDG603.ED.cps.intel.com (10.1.192.133) by
 fmsmsx610.amr.corp.intel.com (10.18.126.90) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27 via Frontend Transport; Wed, 6 Sep 2023 14:15:36 -0700
Received: from NAM11-BN8-obe.outbound.protection.outlook.com (104.47.58.168)
 by edgegateway.intel.com (192.55.55.68) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.27; Wed, 6 Sep 2023 14:15:35 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=NkunV6DfpTH37W2qUpfFV0VB3T76yGD1DYPAc7AFEGZVm3MKmqrso/auQ5FPnQmP+G2zE3GGO5y8SE33/2JvihlF5Nl1bAGl/+ZH9zptv3KGgVZPCr7YbdEvetRTYlRiAWJru/k+ThqmlD9z7KWjlSk5QIAxd1qyGuG25lnwZyFTW+pPp8rqYpshc9kJ+JwQCFQz4mHY7zPHQPw7Y+blY5uDkInTkkBd4yCOyzVjokd6pA6QVIXUyWLS58JJtatmgqejUYjINldmnierSAlpz5GPE0Ff+5F6KdZ6RB10XTOvw3Fx3FxFftdoiTRAN2DJ2J/KqkAv2ypXJt3fqBHpLg==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=ry7d4F47p8bLdrpWVxtya/vQ67FM9C/QJi3hWx536q0=;
 b=X4UfcR/JTQLel63l4GSaXjyAKNl66RlNTwXM/7+566dRrUqrQwFpItZDiX8sMKyFsvuC3Zk6VZzXWQY+t8X6PAcXpZwd5NKXy5+dJyQndk3oCdLIfSoPU3mYArtywJ+h7l2Q2hoKmWgE70VEb+1KBdASHc7ZfRcIevZw3KhUBwZwqnIt1hD6WEXmRoD24GvEfWVI49GrmPA77soUspVsBZ86bdnMYPzNot2BrClU3koAB5FpGvCi5Nxbe4YBs0LgNb3CcsGHrPrl8jVzsG6Nl9KxcEc7urfYItOMPjooGYoRgJLHd08nVR8RepvgRl+vY2U9ifIDVS/tahAT+7WCMA==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from SA1PR11MB6733.namprd11.prod.outlook.com (2603:10b6:806:25c::17)
 by SN7PR11MB6726.namprd11.prod.outlook.com (2603:10b6:806:266::13) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.6745.34; Wed, 6 Sep
 2023 21:15:33 +0000
Received: from SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938]) by SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938%6]) with mapi id 15.20.6745.034; Wed, 6 Sep 2023
 21:15:33 +0000
Date: Wed, 6 Sep 2023 14:15:28 -0700
From: Ira Weiny <ira.weiny@intel.com>
To: Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Ira Weiny <ira.weiny@intel.com>
CC: Dan Williams <dan.j.williams@intel.com>,
        Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
Subject: Re: [PATCH RFC v2 16/18] tools/testing/cxl: Make event logs dynamic
Message-ID: <64f8ebf0d849a_1e8e782946d@iweiny-mobl.notmuch>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
 <20230604-dcd-type2-upstream-v2-16-f740c47e7916@intel.com>
 <20230830131147.000034bc@Huawei.com>
Content-Type: text/plain; charset="us-ascii"
Content-Disposition: inline
In-Reply-To: <20230830131147.000034bc@Huawei.com>
X-ClientProxiedBy: BY3PR03CA0030.namprd03.prod.outlook.com
 (2603:10b6:a03:39a::35) To SA1PR11MB6733.namprd11.prod.outlook.com
 (2603:10b6:806:25c::17)
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: SA1PR11MB6733:EE_|SN7PR11MB6726:EE_
X-MS-Office365-Filtering-Correlation-Id: 03247137-e2ec-4fb6-4d06-08dbaf1e680b
X-LD-Processed: 46c98d88-e344-4ed4-8496-4ed7712e255d,ExtAddr
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;
X-Microsoft-Antispam-Message-Info: Cl8TSKtAPtCQ/jBmo5JVmmaemER0hOwd1MDZIi+VUurfaKJW9QcAlwYTrlatefuEspZ5FmH+rJgHfJgyfLAQjMS2do+yiFQV4tLkrEFt/Jl/lnCJai/7Yi0IqcSS8bu/EjWafeC3E0t0cZ+CPEbGh3LthcyqpGf9ks1tNtegrXGjRDUpZLyDPRPxgvv8SdPVPlrINOKAeG3X3FLz1Q+onDETN9lTiyW1/7znhfvkjGDixUja4XI+dkSegNHN+2h7Xdy/cMzCydZrkglxGVVh++FvWowUfijPb6uFkwYNKDWXnLvJPrJ5NHy2ke0V8PVj+es+Azh8+zZDoldU685PJS5ThNxFd5SFrv+iI2K0Un8l8DBpqVQdntBr2+tbVxBIi/Bmp95UO6IxxsbjqniTXmUdh1z5X63BFTz7pw5aj8ekgxe6LJW0q4qACUJKZpTMle4tMmBucmfwspmwvwQGx0THbKsJ8tKzNzIjpHaQKdWLVNFF4MfTzh1MEf+yc9IVTSQGCcPlOhNb7HrceJmDScjHoJcIOib7hkBMlKP4angoNjp38DkX4p9Yuv4zD4Xj
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:SA1PR11MB6733.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230031)(376002)(136003)(346002)(366004)(39860400002)(396003)(451199024)(1800799009)(186009)(6506007)(6486002)(6666004)(9686003)(6512007)(478600001)(83380400001)(2906002)(26005)(316002)(54906003)(66946007)(44832011)(66556008)(66476007)(41300700001)(4326008)(110136005)(5660300002)(8936002)(8676002)(38100700002)(86362001)(82960400001);DIR:OUT;SFP:1102;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?us-ascii?Q?r4iM8rSffTUKeL64R1l/fohDhhoH0cJsIPe2pUyYW2XaIn4q5SznvsQjSOlg?=
 =?us-ascii?Q?uRma6ctyDIH9SVCWxRyumYs91KkyABhFyZf2DHWYeZHtaw1pJzqGBKYb/OS8?=
 =?us-ascii?Q?8RToNTcPAv6AegfExzeiRGy1FmNFX98DDiKzIrsDEEIEE3qtm9JBka6S0TXQ?=
 =?us-ascii?Q?Rd4nDHX8qr57VkkYFcKcKzwN5JraFagkgj+U2riZBYRW2T/EaObtZSl2oH3L?=
 =?us-ascii?Q?VDC0yHcWDowNWsyGbfcHBAg5M2Pbp1g9THdIEYiY/o0/CkhSw6oBrRgLdccW?=
 =?us-ascii?Q?mK64jSFIWmQZMBC+o/Kin7jbuRP3yY910zKxI7e8swteX3GBrpY6y6IePZ4Z?=
 =?us-ascii?Q?4pFraV6tvCIgDHIKWXPBAFc+cqSOTVISPOeGXGnIrjupY0oTzfnkX5jACruG?=
 =?us-ascii?Q?A20ogaCA4ddC+WWpE1o8lMEsLuL+PzDoEvZo41on05zwnXed4m90wSESSxSC?=
 =?us-ascii?Q?w4VTHDYyA/5APo7A1kervkk0NDm8gYKZCgg/pXw6bGVmeKr9TwsAFuGkmDyv?=
 =?us-ascii?Q?sZf6m32+PaTcI568oiOpa9EUcQlPOUiNDH1qSLCsvTRZvTxzQfGyb/d9/HRd?=
 =?us-ascii?Q?BSjkwfoGBCrkzEMcgr8Jwbqe1HaXTKJjDCPtugiswfjilEzA2OxskPbVftl9?=
 =?us-ascii?Q?gWBUZYREfPl7XB3RfW/hosx4b4q9bg0zx/SIfc3qO4QYnYzER4BKR8H6ip3G?=
 =?us-ascii?Q?m8LVk7c2hCDF2LksTSd0jwi2MiJjOQykvRKhrilhQ79mbJp7Vqd7YjTYSU7v?=
 =?us-ascii?Q?+OUxMZj1GzQwlMKxV/fodauoMEbA6tXxRNVm6H6Xxdro3W4vj8e61FB37mpN?=
 =?us-ascii?Q?UXsZrwhj0j7D14Qw3KII+tkfJRLjpfCmod43ipytajRmMz3EoNUwdh09b8UC?=
 =?us-ascii?Q?igJBn89wDMy2AUU1atuC73e6a/9aLLBPfDZ0h2DsptHrHtUdZE2o75ttDwQx?=
 =?us-ascii?Q?tkTwj9hdI8jGLZ5wlC3ALvhScbt0qT5jIw6YRroyqO1se54JvF42xF4fwR+O?=
 =?us-ascii?Q?TKDM2YBqlG8TnuVYzG/RFlHFXuXAoXRvVieEtwm4aFQj29QuwJZaaIysFWHT?=
 =?us-ascii?Q?RAxpHFCXeK2HuqAwr9ZvvPjyllS1BzXni4//GjwMPadBXxkb0qyANBorGfFs?=
 =?us-ascii?Q?0UGMUEPOndkIZtPsDDhJ0UP9FAEC9px/+xbzUFT5ApiWFVeMJsMT6K6TtGfO?=
 =?us-ascii?Q?HYo176TbZWCnIALqBTJr6gcS0mm+pSRYz1dkpPTArcAaZvUa+rh5kNm6GXW+?=
 =?us-ascii?Q?way7CgiaCRUb79ACGncq3V262gqawyeWvnHJPHv5QpKWqyGE6xLSyht3+jsf?=
 =?us-ascii?Q?Vaq9/I3K/8jQcwhDSulaBnojWXE3/mu5SjxI7Vu7AsgyEIevehZOlDR5PXs0?=
 =?us-ascii?Q?3Pn9CAvLK/Sy0vgW6ARHFp0hNbUkR8YXPaGbA/8ig3Ic6bx+f84kERl7m6M2?=
 =?us-ascii?Q?zTde056fK3pdQk/AEsKemQqDJtvt1FGogMPFSe8oBJNYddvU1HGXt+LRi+/+?=
 =?us-ascii?Q?0ahZQFTuPuIvyI5+uYHpZ8J3sXlUzAvHVGTcOfWODJdtZ8jT/1NineS9Zsdf?=
 =?us-ascii?Q?gf317J36t+/oh4dXS7JmnwvxTDJco72oylzy51Zn?=
X-MS-Exchange-CrossTenant-Network-Message-Id: 03247137-e2ec-4fb6-4d06-08dbaf1e680b
X-MS-Exchange-CrossTenant-AuthSource: SA1PR11MB6733.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 06 Sep 2023 21:15:33.4182
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: s8S/sYfz9OfTPlMafVGoywhvWm/hALaRWVliLj7alftle+ADJ8wsVIb+hEYEG1OicA8orv/p/B2uNKndiw+ydw==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: SN7PR11MB6726
X-OriginatorOrg: intel.com
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

Jonathan Cameron wrote:
> On Mon, 28 Aug 2023 22:21:07 -0700
> Ira Weiny <ira.weiny@intel.com> wrote:
> 
> > The test event logs were created as static arrays as an easy way to mock
> > events.  Dynamic Capacity Device (DCD) test support requires events be
> > created dynamically when extents are created/destroyed.
> > 
> > Modify the event log storage to be dynamically allocated.  Thus they can
> > accommodate the dynamic events required by DCD.  Reuse the static event
> > data to create the dynamic events in the new logs without inventing
> > complex event injection through the test sysfs.  Simplify the processing
> > of the logs by using the event log array index as the handle.  Add a
> > lock to manage concurrency to come with DCD extent testing.
> > 
> > Signed-off-by: Ira Weiny <ira.weiny@intel.com>
> Diff did a horrible job on readability of this patch.

Yea apologies.  I'm not sure if b4 can use --patience or not but I tried
patience by hand and it did not do any better.

> 
> Ah well. Comments superficial only.
> 
> Jonathan
> 
> > ---
> >  tools/testing/cxl/test/mem.c | 276 ++++++++++++++++++++++++++-----------------
> >  1 file changed, 170 insertions(+), 106 deletions(-)
> > 
> > diff --git a/tools/testing/cxl/test/mem.c b/tools/testing/cxl/test/mem.c
> > index 51be202fabd0..6a036c8d215d 100644
> > --- a/tools/testing/cxl/test/mem.c
> > +++ b/tools/testing/cxl/test/mem.c
> > @@ -118,18 +118,27 @@ static struct {
> >  
> >  #define PASS_TRY_LIMIT 3
> >  
> > -#define CXL_TEST_EVENT_CNT_MAX 15
> > +#define CXL_TEST_EVENT_CNT_MAX 17
> >  
> >  /* Set a number of events to return at a time for simulation.  */
> >  #define CXL_TEST_EVENT_CNT 3
> >  
> > +/*
> > + * @next_handle: next handle (index) to be stored to
> > + * @cur_handle: current handle (index) to be returned to the user on get_event
> > + * @nr_events: total events in this log
> > + * @nr_overflow: number of events added past the log size
> > + * @lock: protect these state variables
> > + * @events: array of pending events to be returned.
> > + */
> >  struct mock_event_log {
> > -	u16 clear_idx;
> > -	u16 cur_idx;
> > +	u16 next_handle;
> > +	u16 cur_handle;
> >  	u16 nr_events;
> >  	u16 nr_overflow;
> > -	u16 overflow_reset;
> > -	struct cxl_event_record_raw *events[CXL_TEST_EVENT_CNT_MAX];
> > +	rwlock_t lock;
> > +	/* 1 extra slot to accommodate that handles can't be 0 */
> > +	struct cxl_event_record_raw *events[CXL_TEST_EVENT_CNT_MAX+1];
> 
> Spaces around +

Done.

> 
> >  };
> >  
> 
> ...
> 
> 
> >  
> > -static void cxl_mock_add_event_logs(struct mock_event_store *mes)
> > +/* Create a dynamically allocated event out of a statically defined event. */
> > +static void add_event_from_static(struct mock_event_store *mes,
> > +				  enum cxl_event_log_type log_type,
> > +				  struct cxl_event_record_raw *raw)
> > +{
> > +	struct device *dev = mes->mds->cxlds.dev;
> > +	struct cxl_event_record_raw *rec;
> > +
> > +	rec = devm_kzalloc(dev, sizeof(*rec), GFP_KERNEL);
> > +	if (!rec) {
> > +		dev_err(dev, "Failed to alloc event for log\n");
> > +		return;
> > +	}
> > +
> > +	memcpy(rec, raw, sizeof(*rec));
> 
> devm_kmemdup()?

Yea!  Thanks!

Ira

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id A9C99EB8FAF
	for <linux-cxl@archiver.kernel.org>; Wed,  6 Sep 2023 04:37:06 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S230259AbjIFEhI (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Wed, 6 Sep 2023 00:37:08 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:34152 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S229482AbjIFEhH (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Wed, 6 Sep 2023 00:37:07 -0400
Received: from mgamail.intel.com (mgamail.intel.com [192.55.52.93])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id B30B3199;
        Tue,  5 Sep 2023 21:37:03 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1693975023; x=1725511023;
  h=date:from:to:cc:subject:message-id:references:
   in-reply-to:mime-version;
  bh=DhdzAmatsrIjaCVe/PJ422kNQY+KJ5M+RIK7/Di8fNo=;
  b=gOZAYgdq6ARH5ogibHaYJdZ4gLIeXkwPLppW5yxFep7tow7mBj3bQ44S
   uTrb644lAiz2d2EhT5xkH6jOeQO54iXn6qsJ5etZmgGw0FcZ+B0h1O44M
   WOtKG1rjJf9+RakBnBKRKe73LuRWN38eMWk0vpRCJoi+27D3biMOVVX8r
   YYHdQX/JbLIvCeiwmdsuYoSy5ir1YlYE/al7SiPnuD0qHU1CIMjhFIhpq
   9GKKuqtXz7PGFhhlExdVorj6LDN+SQkS0AF69YX1PcHf+nEBu77N3OY/y
   yD9gKw7sZJ1T8WDuN6OjlJZS1w0qyJ3iY51I5MDynGDjfGDrU4zOJUASF
   g==;
X-IronPort-AV: E=McAfee;i="6600,9927,10824"; a="374360119"
X-IronPort-AV: E=Sophos;i="6.02,231,1688454000"; 
   d="scan'208";a="374360119"
Received: from orsmga003.jf.intel.com ([10.7.209.27])
  by fmsmga102.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 05 Sep 2023 21:37:03 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10824"; a="691168977"
X-IronPort-AV: E=Sophos;i="6.02,231,1688454000"; 
   d="scan'208";a="691168977"
Received: from orsmsx601.amr.corp.intel.com ([10.22.229.14])
  by orsmga003.jf.intel.com with ESMTP/TLS/AES256-GCM-SHA384; 05 Sep 2023 21:37:02 -0700
Received: from orsmsx612.amr.corp.intel.com (10.22.229.25) by
 ORSMSX601.amr.corp.intel.com (10.22.229.14) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27; Tue, 5 Sep 2023 21:37:02 -0700
Received: from orsmsx610.amr.corp.intel.com (10.22.229.23) by
 ORSMSX612.amr.corp.intel.com (10.22.229.25) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27; Tue, 5 Sep 2023 21:37:02 -0700
Received: from orsedg603.ED.cps.intel.com (10.7.248.4) by
 orsmsx610.amr.corp.intel.com (10.22.229.23) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27 via Frontend Transport; Tue, 5 Sep 2023 21:37:02 -0700
Received: from NAM12-DM6-obe.outbound.protection.outlook.com (104.47.59.169)
 by edgegateway.intel.com (134.134.137.100) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.27; Tue, 5 Sep 2023 21:36:58 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=V7pP8f8B5MKTyyVshTQVxe6cmLJtpZvvT+9h172Rfca8wT8eR5LFw6A3JPegnSDkugZq1LXs9Nh/4ok4GmOuwZqGGlEM4KZbkmwNkvVHvbc8FXltQPtQxbzr5o+TSOwsPZAYWvD1J6UOWPp4p60Y3DXe7gQwQyXEJhg+OZwUdgWTTXESTsHped4IYPVyuiOsj6Ux6VBZTxl6AuMf5jWmsfaAPdMATDWR34PjRXJFIaKKylFDklGRkbjTM0WUawGVFcD77yr5fpmb4L+M90D6OSFGgebjefzuzAlA/uDxnxz8j2GHIzVoEPzqs7M+B9lcPA25t0lnfAfA3QL84xP5xg==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=EVrr7GyqqBo2J5nJ2SCcGoh8bMr1nKMSwHJkfDz1GPk=;
 b=Bji+a5iKDw5GGN31h0/IrWkdsAD4kzuZYy39UYAuCMWubOtqpfb/iMJ5YGlTWvnZXGy7EaDa/oshSu2OdBZZZDPxgpytMZ91tKf8nIATPdenxpcDsurgs8IgtMXJdsTYo3WDD2qCJDIxOKS0SUlxT6S/ThKHAMhQO/AOXPC5rqj9nGSoD6SuErKpyTM/XAhF9Q2ytj39iUf66YdsxAKz89nTMCXyKo0qWLbrNu7hgiizZ3OowK/F1dogW1dZsebLOg4dsAyLnUjZPM2RmHh7s8wcd5OOrCMkcvRieGEcXUt/EdZS0KK17+TKDw+0KYVHVuoac9co4zwY0e2PfT1qMw==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from SA1PR11MB6733.namprd11.prod.outlook.com (2603:10b6:806:25c::17)
 by DS7PR11MB5965.namprd11.prod.outlook.com (2603:10b6:8:70::16) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.6745.34; Wed, 6 Sep
 2023 04:36:52 +0000
Received: from SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938]) by SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938%6]) with mapi id 15.20.6745.030; Wed, 6 Sep 2023
 04:36:52 +0000
Date: Tue, 5 Sep 2023 21:36:48 -0700
From: Ira Weiny <ira.weiny@intel.com>
To: Dave Jiang <dave.jiang@intel.com>, Ira Weiny <ira.weiny@intel.com>,
        "Dan Williams" <dan.j.williams@intel.com>
CC: Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Alison Schofield <alison.schofield@intel.com>,
        "Vishal Verma" <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
Subject: Re: [PATCH RFC v2 08/18] cxl/region: Add Dynamic Capacity CXL region
 support
Message-ID: <64f801e098dd2_234994294d0@iweiny-mobl.notmuch>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
 <20230604-dcd-type2-upstream-v2-8-f740c47e7916@intel.com>
 <bb4716e5-5ebf-e818-3c37-7ff2f0cdde23@intel.com>
Content-Type: text/plain; charset="us-ascii"
Content-Disposition: inline
In-Reply-To: <bb4716e5-5ebf-e818-3c37-7ff2f0cdde23@intel.com>
X-ClientProxiedBy: SJ0PR03CA0225.namprd03.prod.outlook.com
 (2603:10b6:a03:39f::20) To SA1PR11MB6733.namprd11.prod.outlook.com
 (2603:10b6:806:25c::17)
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: SA1PR11MB6733:EE_|DS7PR11MB5965:EE_
X-MS-Office365-Filtering-Correlation-Id: a2300ae0-9db9-442c-4295-08dbae92e44c
X-LD-Processed: 46c98d88-e344-4ed4-8496-4ed7712e255d,ExtAddr
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;
X-Microsoft-Antispam-Message-Info: XHEtGrfhbv+tdr6nnAhkmfBHkMS65Vhy+mL7m5AkQ8LdTDEv68/oUaRc1VEu2NP6SFDGxORB9VnXcrAgGMyHCji10K48pU/BRlBhrKznpH2kKg3G5uaZ2c5JGtE0gLEE+nho6IQFW7Nf2ejLRIpcENqS67FICCI21cLnXVxHgLvcKoV+cmRkG4fcThI3YmlsRsJVIxeWQGVfzgo0K4kM2M+HovOXnNmdghKMvnH8T7CwW00aSPjS+YzLTgmUYw3i3NkgSAFtfQZl/zgaLHp0u+Y/MyNJnOoYBqvwBBsIeyLxZGsueTPjxm5gOE1xNI3fGfLn+s7ZuLlMBW8eUB56iV8DmCpq9I4AP+cDpRPXkhz7ZCWopdAeUdwulq4rorLrDVbj5YwISITxWrTyF/Euqy6ENCKt6bRF20moLHjIlaGKMVPvaEzalD43CYRxjWPhKkphqyuARzRgpHDHZ6DLEddi4NGslE5l2XCw+dhVJMmdhhA7SPaQe0upWEXZs4J5od+YByLdm0ZWLq078KOcvuj6Gic8t+j3DYL7/EPPO4qBZOYcU+FVdQkdha2a+mj8
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:SA1PR11MB6733.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230031)(39860400002)(376002)(346002)(396003)(136003)(366004)(1800799009)(186009)(451199024)(8936002)(8676002)(4326008)(83380400001)(478600001)(66946007)(66556008)(66476007)(6636002)(54906003)(110136005)(26005)(6486002)(6506007)(6666004)(53546011)(6512007)(9686003)(41300700001)(2906002)(316002)(38100700002)(82960400001)(5660300002)(44832011)(86362001);DIR:OUT;SFP:1102;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?us-ascii?Q?SDGs2qui0dKjYxQ+E+SwjxBX1yYJ5SaGnYKUfPDhSEz/1sCN/8z9sTMiJ/kX?=
 =?us-ascii?Q?+4FEBH5eVwhSaLHNEWCmfiNOvlJpf6MKjLU4vDjaCtgk8vf6nMfgu28LkADp?=
 =?us-ascii?Q?OryTwPKPEdlXYsd/CdN6DZxoLgXjiTqudrvQzjZEI83RtK8MWAuTAe1GzqfB?=
 =?us-ascii?Q?FEnvKJh8RdWmgEk2Q806yJOj7r8T/qwu8e5X/pQIsMu4sPiSHc/ohAXejkkr?=
 =?us-ascii?Q?oX0dssBaS4virBD04n9O7fAX0TOGb3QhUxg8Wl/O9oUE31nefb7eoQaRnkXM?=
 =?us-ascii?Q?0milAuRnwKZhySWS72qphRRGVQwpWzPq9BpSVrmFtMy/cUxKpRQZkA4o/dSR?=
 =?us-ascii?Q?J79Sdm4oalapAYeJSUWSRSyQe2MEP+kDZ2sepCZx4uofqvdByKxzbS+U03fq?=
 =?us-ascii?Q?xeouPIDDqfUZN++90FpguqqcnRaiDkQA7pRE+CfouTzpt0VCtbracILGYDP8?=
 =?us-ascii?Q?IYjBxz5Euun5zUjmvrXy8oytPpcKKyBsIPhDVVrUhkPLx63WujEMnqsB6La0?=
 =?us-ascii?Q?gGxWbiXQKm8GWZNNokVhkTRtK1jNMCi9Kx5PsMskXhdwA4OyHB/Ki5KV0WXK?=
 =?us-ascii?Q?YfK8XwiTwl0pBh/r3YFXSQXetINIJqKAe6FOG+NBqarYx3kXHZeCbBpueyKK?=
 =?us-ascii?Q?JqzaJxcI1KBpDe0tYKcBkSI5j1u7msVJBfaVQ6cg/8gFEawQhEWlmNKS+vQZ?=
 =?us-ascii?Q?G271ybrMAHBzxYPVGTj0z768uwZdT8dQupwtgubxmY6ywcvdnfOoDL0+vsjk?=
 =?us-ascii?Q?J8FxfFLbQGJlxHKa8taaQHOT+L5gU4IPdMLl9VyiWdUInPcG1E+1+uQ5hFWk?=
 =?us-ascii?Q?1LmVudKjGsvXmu79tHMDQ6F7+/51zcsHQBLsSK+w/++TJ8V6tv0dmaxGnGrZ?=
 =?us-ascii?Q?jAV/22C6jaXl+CtJPT3sEIXiFpublTdjQTc0z2ayQd4e476DssLII138D3Rb?=
 =?us-ascii?Q?sH5XuVpsBH3OGaErbIyBhkMXbkwFBRr3RPF+D6soJF2Yq5b+I5veKampQnMD?=
 =?us-ascii?Q?qWAVJkVfXFUWOS6m4cPGG9fjRx8Kb0cXJxqnUcGPvEuzj7+bh4e7EO9fehVA?=
 =?us-ascii?Q?N3YkdtOSvpwT9BpYsP0PAp/KIJTPX1afxW9SdHAzFUJwPdvZb5U69DekLLPj?=
 =?us-ascii?Q?HGm0OG+tACENDvhfF7Txmgn9h2Czry+QcAKk6MXSceoc8pO9fdPVpgBhss02?=
 =?us-ascii?Q?POPxYavd+yqD8ZgRO6ZyPP9ILpr6O22vfvpo8heNvLy/s9Lb/7udn1YgIPpB?=
 =?us-ascii?Q?fAhKuh2DVrjtsJqhcHQFXPInUh95XI+SeAs/Fm9OknY185T5nqANPxp9RIbv?=
 =?us-ascii?Q?n3h4V1UVDN9JsGDFlXYOWaxrtJyZU3OgLENNdb04QqSFY3m8RZRBRFpaENK0?=
 =?us-ascii?Q?KjLZifqqd4OQBrH+MyKEKXXtq/GtdT9erkLHOPvNQvE7j5LkGl2m53LT+OMR?=
 =?us-ascii?Q?6s6PfTDZ+rFagxbYAlYyv6aVICku23c701EuDUBlnzHKmLsthmQ0MVUpf5rT?=
 =?us-ascii?Q?7u07+eFTbsADH4v94J+O8YXBhbsiQfJBxVsgAR9MXKoDUdUixcvHByILlFqA?=
 =?us-ascii?Q?M7Lpfn1uiZq7AKMa3kmxrg5AAjeCBH3tvGsD5zWl?=
X-MS-Exchange-CrossTenant-Network-Message-Id: a2300ae0-9db9-442c-4295-08dbae92e44c
X-MS-Exchange-CrossTenant-AuthSource: SA1PR11MB6733.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 06 Sep 2023 04:36:52.3381
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: 6F+eX1JefZrchO+TZQ4+ASFKDq9G+2WylanTReUY8n0A9eOL8mwzIDkC12qAIw7LF90W3BsmZWEyR8/wRGDM5w==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: DS7PR11MB5965
X-OriginatorOrg: intel.com
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

Dave Jiang wrote:
> 
> 
> On 8/28/23 22:20, Ira Weiny wrote:
> > CXL devices optionally support dynamic capacity.  CXL Regions must be
> > configured correctly to access this capacity.  Similar to ram and pmem
> > partitions, DC Regions represent different partitions of the DPA space.
> > 
> > Interleaving is deferred due to the complexity of managing extents on
> > multiple devices at the same time.  However, there is nothing which
> > directly prevents interleave support at this time.  The check allows
> > for early rejection.
> > 
> > To maintain backwards compatibility with older software, CXL regions
> > need a default DAX device to hold the reference for the region until it
> > is deleted.
> > 
> > Add create_dc_region sysfs entry to create DC regions.  Share the logic
> > of devm_cxl_add_dax_region() and region_is_system_ram().  Special case
> > DC capable CXL regions to create a 0 sized seed DAX device until others
> > can be created on dynamic space later.
> > 
> > Flag dax_regions to indicate 0 capacity available until dax_region
> > extents are supported by the region.
> > 
> > Co-developed-by: Navneet Singh <navneet.singh@intel.com>
> > Signed-off-by: Navneet Singh <navneet.singh@intel.com>
> > Signed-off-by: Ira Weiny <ira.weiny@intel.com>
> 
> You probably should update kernel version to v6.7. Otherwise

Done.

> Reviewed-by: Dave Jiang <dave.jiang@intel.com>
> 

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 5A3B3EB8FAD
	for <linux-cxl@archiver.kernel.org>; Wed,  6 Sep 2023 04:35:18 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S235306AbjIFEfU (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Wed, 6 Sep 2023 00:35:20 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:46874 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S229482AbjIFEfP (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Wed, 6 Sep 2023 00:35:15 -0400
Received: from mgamail.intel.com (mgamail.intel.com [192.55.52.93])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id DC76E18D;
        Tue,  5 Sep 2023 21:35:11 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1693974911; x=1725510911;
  h=date:from:to:cc:subject:message-id:references:
   in-reply-to:mime-version;
  bh=mXdvslv0ebxG4zr79bn+LRRaB7d8RRrL/rSaPfFGYcM=;
  b=A5JyQ1lFZxuWmBUthobT47GAjnmMw2n48OxEI5CHmYD5MqYi7D/Ktc+h
   ZSLVc7/U1abhCaNdbJcL000O3wjHbW0KC89GpnZou+pHqp8WElcQOsaC3
   PmySpwYCHjtDujRoyVyzU0OUPxtPDaoFXpMK1yDMS/wpB51eQef5lum5a
   decffeOMstAoQpAUonS2tfr7cJAKJwNLP8p+UHqjB7jMPxT4juNsc7qva
   awLjCWPt4blFQVIcw8y695tL/CXwy3DXDFPch2qi7EflVLOwx4B5ZImYg
   IXA5D7g27HKzF3wUNn0uZqgrMQrH2I0K6AQTtaDKeg20UB6uxT7EIXlx4
   g==;
X-IronPort-AV: E=McAfee;i="6600,9927,10824"; a="374359911"
X-IronPort-AV: E=Sophos;i="6.02,231,1688454000"; 
   d="scan'208";a="374359911"
Received: from fmsmga004.fm.intel.com ([10.253.24.48])
  by fmsmga102.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 05 Sep 2023 21:35:11 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10824"; a="811508822"
X-IronPort-AV: E=Sophos;i="6.02,231,1688454000"; 
   d="scan'208";a="811508822"
Received: from fmsmsx601.amr.corp.intel.com ([10.18.126.81])
  by fmsmga004.fm.intel.com with ESMTP/TLS/AES256-GCM-SHA384; 05 Sep 2023 21:35:11 -0700
Received: from fmsmsx610.amr.corp.intel.com (10.18.126.90) by
 fmsmsx601.amr.corp.intel.com (10.18.126.81) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.32; Tue, 5 Sep 2023 21:35:10 -0700
Received: from fmsmsx610.amr.corp.intel.com (10.18.126.90) by
 fmsmsx610.amr.corp.intel.com (10.18.126.90) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27; Tue, 5 Sep 2023 21:35:10 -0700
Received: from fmsedg602.ED.cps.intel.com (10.1.192.136) by
 fmsmsx610.amr.corp.intel.com (10.18.126.90) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27 via Frontend Transport; Tue, 5 Sep 2023 21:35:10 -0700
Received: from NAM11-CO1-obe.outbound.protection.outlook.com (104.47.56.177)
 by edgegateway.intel.com (192.55.55.71) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.27; Tue, 5 Sep 2023 21:35:09 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=a3eKz+OPKhE+3s6CIvFjH5/sDgkRjkB1DifgYBuOy6vvugiYrHnYfARQWK3INJHPuK896bOQeaTd1oQXTJkJZwvtW1acXk8XbiolShYLzcqEOst6smrimfK1N5CDAH0bad8rD67tjO69XnNemgu3cdIC8eUPxYgFAj0eqGZ30kVQa64bEL+d05+E8l8AEumE4KcXwi8bDpaDLXjDqpl9ypj+i2vhFLoau95q2dtVtAH+PALmWbUS4Qfv5oFUxq1I0AXIu2kKs8XaCfTOmzkYyyqHrNIJxNiufSUMb8aBiL2UEe5ZzR3aoskoPfWsqfLbgnmJmzdjDKf5yV5s3X4qjQ==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=1cwqdMRqq1pNzdZsWeGMvECg9gImUgtizjex/6IIonY=;
 b=DM5OK6AmhDpG4yHf9VC39MsO35QH+LsTGZn47+Bssc/je1sjQyhlaqNKbCtTbOKywTvRq49v1dDuPFM20TwIoT4qsUPzGAsm/4AEXVsc3k4FwaCwrrAAtOatq1K5TChu0CnM6+dwhMZAND8rEmp5su6efMjjAjy6D7rrbh2NwWasbh8pIcTEo6rt2XCHnEduy35C3V4Wph7UX6DWin9RkHBss9oKBIXYuvQZ3+hLLWNcMSvC6GAiLCl1KQ20rGPupF8exDaJfRb+eT/Auvdmu6GNHeKm52iMY/o2NuqQWoFSTJ6HLdV+kXbsio1SlesfSCeHb74lIFXESUbUCDGPPQ==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from SA1PR11MB6733.namprd11.prod.outlook.com (2603:10b6:806:25c::17)
 by DS7PR11MB5965.namprd11.prod.outlook.com (2603:10b6:8:70::16) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.6745.34; Wed, 6 Sep
 2023 04:35:07 +0000
Received: from SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938]) by SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938%6]) with mapi id 15.20.6745.030; Wed, 6 Sep 2023
 04:35:07 +0000
Date: Tue, 5 Sep 2023 21:35:03 -0700
From: Ira Weiny <ira.weiny@intel.com>
To: Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Ira Weiny <ira.weiny@intel.com>
CC: Dan Williams <dan.j.williams@intel.com>,
        Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
Subject: Re: [PATCH RFC v2 14/18] dax/region: Support DAX device creation on
 dynamic DAX regions
Message-ID: <64f80177c2c21_1e8e7829487@iweiny-mobl.notmuch>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
 <20230604-dcd-type2-upstream-v2-14-f740c47e7916@intel.com>
 <20230830125025.00000fea@Huawei.com>
Content-Type: text/plain; charset="us-ascii"
Content-Disposition: inline
In-Reply-To: <20230830125025.00000fea@Huawei.com>
X-ClientProxiedBy: BYAPR08CA0007.namprd08.prod.outlook.com
 (2603:10b6:a03:100::20) To SA1PR11MB6733.namprd11.prod.outlook.com
 (2603:10b6:806:25c::17)
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: SA1PR11MB6733:EE_|DS7PR11MB5965:EE_
X-MS-Office365-Filtering-Correlation-Id: 2783d416-4d94-439f-b363-08dbae92a5a8
X-LD-Processed: 46c98d88-e344-4ed4-8496-4ed7712e255d,ExtAddr
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;
X-Microsoft-Antispam-Message-Info: k+fhubqm4gQ3Zgo/rtcXteerq2FD9kVV1rFzQuQYt/SEorsaAsSJD7dV/DkTPmky7UNgikTVw1bEYzVtjoqfcG/Sfca1aE9zJm9hx/w2VRNCGo5U1MNqdVBoWIEyzmvD+zNkhT0e2EGqkJbcfXEPKmPwKQi0SD9TSQ1AuHqHRLShvK7Su7s3L4SVF8NCCdpHR3uIeHYDo92B+RjPuf4i615BI7HTFDekCqK0u2QvLgDxmTNXD666YGH6TLVEPOZi2j7yVGvagPP16SWg0+k65VgM/mQNnLgiUMFqoxLU0rcM/2C5uMRqNBYzUBs8iJAyCeDEeAdK1FzcJL8fvuF3ON/DbMQ1V6zXyufLGc7LzzXf1gTfo37+DsC5YgXC2uEeudzoRJrq9majs6dlZV+oww3rqVlZ46SnR2hSoQdHHU89t8CEkmxSki77nixosN9DZ/vxoO28gN91Z1KfWJHBWP9lznEDy3tlkaL7uMX+nk5al/wRpuiIbyp0bEg4d5JVOl9ionhT6mNKKfyklvkdNHeovUJONqD0SLIWjZQ41TVs6k8bQmiR7Btj7JvyqX18
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:SA1PR11MB6733.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230031)(39860400002)(376002)(346002)(396003)(136003)(366004)(1800799009)(186009)(451199024)(8936002)(8676002)(4326008)(83380400001)(478600001)(66946007)(66556008)(66476007)(54906003)(110136005)(26005)(6486002)(6506007)(6666004)(6512007)(9686003)(41300700001)(2906002)(316002)(38100700002)(82960400001)(5660300002)(44832011)(86362001);DIR:OUT;SFP:1102;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?us-ascii?Q?LAki+MDVD+SnKxPCd0rim/P/BnFbTnDotzYZxUmFpXbscZ0+x7XXe6RxCqiO?=
 =?us-ascii?Q?oto8+wtLhEc3O1j65WcuwXj++2cSgWXaT++KSjOAFUeuBqhXv1LPKfT5hNj0?=
 =?us-ascii?Q?8dfxFVWLDzjYbE4mwL72GJ9qmdp5S09XXSqfR9M4kregiGL7XUnjCfyusKmi?=
 =?us-ascii?Q?l0zrcZWQyU/wQyqk+U4FL0n+SbEby4TZVuK6C4FOrtbxyNtbQ+VPF59yhOm+?=
 =?us-ascii?Q?hLtFBaj6hDzH/p7wP5f8xJuyzl/+pszL1d1D40Xe+dCD+uuVlIRJHhASghaJ?=
 =?us-ascii?Q?7lLH7nLEhrIVHG3w92s30uJyHI//QrliNbrLJypOQ+nZ88gQsyRYsRceuOxH?=
 =?us-ascii?Q?xEVYmsIofNhbLRdZGn7UWab3ecmYbA1Nxz9f/+l3pS+yJ0E3Qf0yZX8a8Woh?=
 =?us-ascii?Q?+KmEXsI47h5xv5vKEGbqN4i1+cG3MwrpG+fKFgFZMLO2TRd8O6hyqtIDNgiS?=
 =?us-ascii?Q?AQrRnuoaDgAeHdW6gtJIhO/QZJe1K27QRlHR4M6jUwbqw99u0fcWrYg65nW7?=
 =?us-ascii?Q?DJbImrztbvkV7twEjuFApu2RccotUMUzUjlYppub2nln6TEf1rtwq/8gOpZX?=
 =?us-ascii?Q?LhdSHoZZ4f/1cLLFMJrf6Cmu9SJZl3kS7CEcnxmYtLzGDALVIyaukfjpETk5?=
 =?us-ascii?Q?m16F/WYISTLCuvddk7GPb1HKsjHrb225Ve1O5KoAAEYCn/kRbqNrJZXerpch?=
 =?us-ascii?Q?efMdD1s88L6Fl1/klvDt3ZDOUgnZbIJ5x8yoSmCkXC7FQ2lhy+3Xr1r4TZqi?=
 =?us-ascii?Q?BQvc5wKNsmHwCY6vUwK2Cz40rZnAB2WyJlAPlsc7/THl/Z3k7aoxRp+o/ZXA?=
 =?us-ascii?Q?/fkvRy7hnt/LDQ+6A7WyXu+YU8TnGkKF5aeEtVh+lrgjzir8Y1tQ9GY0KO1C?=
 =?us-ascii?Q?ejp/OZF5TP9r56OZT1JQiLOlmQzFdiMVY/pGatwmF4GgXgszuRegML6d3++j?=
 =?us-ascii?Q?L2q6Wwb3oCZj/vEe03uv8umfOBVGMOjef0w9/PMyC/+Ui8W6weFPYYq9vTXu?=
 =?us-ascii?Q?YIulRmry9Y9xYLTk7c1TbpQ+393Iqu1EOy7/oHJ2+Em9hp5ht6UaN5qu1faC?=
 =?us-ascii?Q?757X4lHS/BaR3Uc0rtXcFTM0mXulIN4R1ojrCwtWKMac30jvMRhp+ZUAMfaf?=
 =?us-ascii?Q?FqBNYd95btgBBP4mBciInj3VysbZzH0qfyoPL8anbR57NZn61Gt3k8vaUfH7?=
 =?us-ascii?Q?p6vZMqfnKgki+TBjAz5pcutz6k8t8nyyII5aM8Hgj5/cfTJBCkjOjojUXPre?=
 =?us-ascii?Q?KOOBCQyr+ahyCSBAOU9IDzrE+zNjwPx2kIpZdzN9jOU4DNfBZL9Bkeyxy/rY?=
 =?us-ascii?Q?aiAkpDbb96HKe9I97aKLAKU+wyjKcy2UW0ykU2tVVivGu8GhhM+DpiOAipq2?=
 =?us-ascii?Q?7U6BKChM7JKu1xsUk/Y1tu1AK0AQ8mi+KoBv1GOFVNBC/sTjOtqFthzSxZvT?=
 =?us-ascii?Q?cF1YX0bWwS3AXyMR6UjPnAU/mDqymddCS0lCKbq0P/rkjGAMZj5LGFQOGPo9?=
 =?us-ascii?Q?kr0Tmw9e2ajTp/QUSEMQyhehC0AjIZb2xT1kF37eK6oLuf+WQyH4ZEKbHVy6?=
 =?us-ascii?Q?wZFPt9mHj4BWk9tBuMINzc3TPWBQLodcL2uQUu5w?=
X-MS-Exchange-CrossTenant-Network-Message-Id: 2783d416-4d94-439f-b363-08dbae92a5a8
X-MS-Exchange-CrossTenant-AuthSource: SA1PR11MB6733.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 06 Sep 2023 04:35:07.6272
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: EiMOnQY8ImQImxSzC38opzEM5h0axZttqh8B1SU4BfT9eCG9idsgm7GWyTkl4LIT4BIKbWrM/0MDKseoNJTEpQ==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: DS7PR11MB5965
X-OriginatorOrg: intel.com
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

Jonathan Cameron wrote:
> On Mon, 28 Aug 2023 22:21:05 -0700
> Ira Weiny <ira.weiny@intel.com> wrote:
> 
> > Dynamic Capacity (DC) DAX regions have a list of extents which define
> > the memory of the region which is available.
> > 
> > Now that DAX region extents are fully realized support DAX device
> > creation on dynamic regions by adjusting the allocation algorithms
> > to account for the extents.  Remember also references must be held on
> > the extents until the DAX devices are done with the memory.
> > 
> > Redefine the region available size to include only extent space.  Reuse
> > the size allocation algorithm by defining sub-resources for each extent
> > and limiting range allocation to those extents which have space.  Do not
> > support direct mapping of DAX devices on dynamic devices.
> > 
> > Enhance DAX device range objects to hold references on the extents until
> > the DAX device is destroyed.
> > 
> > NOTE: At this time all extents within a region are created equally.
> > However, labels are associated with extents which can be used with
> > future DAX device labels to group which extents are used.
> 
> This sound like a bad place to start to me as we are enabling something
> that is probably 'wrong' in the long term as opposed to just not enabling it
> until we have appropriate support.

I disagree.  I don't think the kernel should be trying to process tags at
the lower level.

> I'd argue better to just reject any extents with different labels for now.

Again I disagree.  This is less restrictive.  The idea is that labels can
be changed such that user space can ultimately decided which extents
should be used for which devices.  I have some work on that already.
(Basically it becomes quite easy to assign a label to a dax device and
have the extent search use only dax extents which match that label.)

> 
> As this is an RFC meh ;)

Sure!  ;-)

> 
> Whilst this looks fine to me, I'm rather out of my depth wrt to the DAX
> side of things so take that with a pinch of salt.

NP

> 
> Jonathan
> 
> 
> > 
> > Signed-off-by: Ira Weiny <ira.weiny@intel.com>
> > ---
> >  drivers/dax/bus.c         | 157 +++++++++++++++++++++++++++++++++++++++-------
> >  drivers/dax/cxl.c         |  44 +++++++++++++
> >  drivers/dax/dax-private.h |   5 ++
> >  3 files changed, 182 insertions(+), 24 deletions(-)
> > 
> > diff --git a/drivers/dax/bus.c b/drivers/dax/bus.c
> > index ea7ae82b4687..a9ea6a706702 100644
> > --- a/drivers/dax/bus.c
> > +++ b/drivers/dax/bus.c
> 
> ...
> 
> 
> > @@ -1183,7 +1290,7 @@ static ssize_t mapping_store(struct device *dev, struct device_attribute *attr,
> >  	to_alloc = range_len(&r);
> >  	if (alloc_is_aligned(dev_dax, to_alloc))
> >  		rc = alloc_dev_dax_range(&dax_region->res, dev_dax, r.start,
> > -					 to_alloc);
> > +					 to_alloc, NULL);
> >  	device_unlock(dev);
> >  	device_unlock(dax_region->dev);
> >  
> > @@ -1400,8 +1507,10 @@ struct dev_dax *devm_create_dev_dax(struct dev_dax_data *data)
> >  	device_initialize(dev);
> >  	dev_set_name(dev, "dax%d.%d", dax_region->id, dev_dax->id);
> >  
> > +	dev_WARN_ONCE(parent, is_dynamic(dax_region) && data->size,
> > +		      "Dynamic DAX devices are created initially with 0 size");
> 
> dev_info() maybe more appropriate?

Unless I'm mistaken this can happen from userspace but only if something
in the code changes later.  Because the dax layer is trying to support
non-dynamic regions (which dynamic may be a bad name), I was worried that
the creation with a size might slip through...

> Is this common enough that we need the
> _ONCE?

once is because it could end up spamming a log later if something got
coded up wrong.

> 
> 
> >  	rc = alloc_dev_dax_range(&dax_region->res, dev_dax, dax_region->res.start,
> > -				 data->size);
> > +				 data->size, NULL);
> >  	if (rc)
> >  		goto err_range;
> >  
> > diff --git a/drivers/dax/cxl.c b/drivers/dax/cxl.c
> > index 44cbd28668f1..6394a3531e25 100644
> > --- a/drivers/dax/cxl.c
> > +++ b/drivers/dax/cxl.c
> ...
> 
> 
> >  static int cxl_dax_region_create_extent(struct dax_region *dax_region,
> >  					struct cxl_dr_extent *cxl_dr_ext)
> >  {
> > @@ -45,11 +80,20 @@ static int cxl_dax_region_create_extent(struct dax_region *dax_region,
> >  	/* device manages the dr_extent on success */
> >  	kref_init(&dr_extent->ref);
> >  
> > +	rc = dax_region_add_resource(dax_region, dr_extent,
> > +				     cxl_dr_ext->hpa_offset,
> > +				     cxl_dr_ext->hpa_length);
> > +	if (rc) {
> > +		kfree(dr_extent);
> 
> goto for these and single unwinding block?

Yea.  Done.

> 
> > +		return rc;
> > +	}
> > +
> >  	rc = dax_region_ext_create_dev(dax_region, dr_extent,
> >  				       cxl_dr_ext->hpa_offset,
> >  				       cxl_dr_ext->hpa_length,
> >  				       cxl_dr_ext->label);
> >  	if (rc) {
> > +		dax_region_rm_resource(dr_extent);
> >  		kfree(dr_extent);
> as above.

Done.

> 
> >  		return rc;
> >  	}
> > diff --git a/drivers/dax/dax-private.h b/drivers/dax/dax-private.h
> > index 250babd6e470..ad73b53aa802 100644
> > --- a/drivers/dax/dax-private.h
> > +++ b/drivers/dax/dax-private.h
> > @@ -44,12 +44,16 @@ struct dax_region {
> >  /*
> >   * struct dax_region_extent - extent data defined by the low level region
> >   * driver.
> > + * @region: cache of dax_region
> > + * @res: cache of resource tree for this extent
> >   * @private_data: lower level region driver data
> 
> Not sure 'lower level' is well defined here. Is "region driver data"
> not enough?

For me it was not.  I'll have to sleep on it.  Technically there is no
dax_region 'driver' but only a dax_region device.

> 
> >   * @ref: track number of dax devices which are using this extent
> >   * @get: get reference to low level data
> >   * @put: put reference to low level data
> >   */
> >  struct dax_region_extent {
> > +	struct dax_region *region;
> > +	struct resource *res;
> >  	void *private_data;
> >  	struct kref ref;
> >  	void (*get)(struct dax_region_extent *dr_extent);
> > @@ -131,6 +135,7 @@ struct dev_dax {
> >  		unsigned long pgoff;
> >  		struct range range;
> >  		struct dax_mapping *mapping;
> > +		struct dax_region_extent *dr_extent;
> 
> Huh. Seems that ranges is in the kernel doc but not the
> bits that make that up.  Maybe good to add the docs
> whilst here?

oh.  sure.  took me a couple of reads of this sentence.

I'm going to think on this too.

Ira

> 
> >  	} *ranges;
> >  };
> >  
> > 
> 



From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 998EBEB8FAF
	for <linux-cxl@archiver.kernel.org>; Wed,  6 Sep 2023 04:12:48 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S230201AbjIFEMu (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Wed, 6 Sep 2023 00:12:50 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:36744 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S229554AbjIFEMt (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Wed, 6 Sep 2023 00:12:49 -0400
Received: from mgamail.intel.com (mgamail.intel.com [192.55.52.151])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id CBD921B3;
        Tue,  5 Sep 2023 21:12:45 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1693973565; x=1725509565;
  h=date:from:to:cc:subject:message-id:references:
   in-reply-to:mime-version;
  bh=ttcaR02VbTbi7xk9rfwPd2bxEaqzYEThyKCJOZQj2/U=;
  b=bXJBvYd7iD0hR+uQOH/QZ49q2YQql3bCC/LE/myHupcf+p1efYzgBMB/
   VrOOD99RYcb/kQvyWiAJyRsxk47kOJz1H3ueR1AZWSJ26jwFBO8rlpDUc
   4yxeeakYHzfdNXCVdGS0Q2ZmnvM/D1PtN7ZunXq2PwrP1ws2hFa+ELDA0
   mZQttE/jkCQJ1cTs7ow3ko96bheW03gHMtgNGQThLNcBavPM8N+FtRFKs
   UoFLwBjqYOmhkOYHrdMM14NMezcoHeVlwxC4D4NNtdcpw69soGDY4ZymA
   NE0Hoh4ZMuM0LsyhecsmFOet+cRDrqSxJqlbXzd5ribZ1lwqyCJy9EjxL
   A==;
X-IronPort-AV: E=McAfee;i="6600,9927,10824"; a="357275637"
X-IronPort-AV: E=Sophos;i="6.02,231,1688454000"; 
   d="scan'208";a="357275637"
Received: from fmsmga001.fm.intel.com ([10.253.24.23])
  by fmsmga107.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 05 Sep 2023 21:12:45 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10824"; a="884542203"
X-IronPort-AV: E=Sophos;i="6.02,231,1688454000"; 
   d="scan'208";a="884542203"
Received: from orsmsx602.amr.corp.intel.com ([10.22.229.15])
  by fmsmga001.fm.intel.com with ESMTP/TLS/AES256-GCM-SHA384; 05 Sep 2023 21:12:35 -0700
Received: from orsmsx611.amr.corp.intel.com (10.22.229.24) by
 ORSMSX602.amr.corp.intel.com (10.22.229.15) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27; Tue, 5 Sep 2023 21:12:44 -0700
Received: from orsmsx611.amr.corp.intel.com (10.22.229.24) by
 ORSMSX611.amr.corp.intel.com (10.22.229.24) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27; Tue, 5 Sep 2023 21:12:44 -0700
Received: from ORSEDG602.ED.cps.intel.com (10.7.248.7) by
 orsmsx611.amr.corp.intel.com (10.22.229.24) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27 via Frontend Transport; Tue, 5 Sep 2023 21:12:44 -0700
Received: from NAM04-DM6-obe.outbound.protection.outlook.com (104.47.73.44) by
 edgegateway.intel.com (134.134.137.103) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.27; Tue, 5 Sep 2023 21:12:43 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=JvdCb/EvWrcPFUyHSbPy8lnttq+o28l0QbKcOeFsBTqv3kGorWg81kNAffO2127KIJ7t1tYfGAoWwCru8YwlsVm5crfFoBjNSjH4GGS1FMazpxFZSrp6Le5+7is+XcAWD+UoUzzdhrkB0RpqSR5ba1ED24UqPCmfAUrAajeEiDVCXaZVDPn0eiSIuXcBVIloonQKiuiuqXtHvpy/pye/qe2KqQpua68FJrFIpAYN159XvxrzyvqC7Bdz9nR9U3sObFfJx/o6dB0gZCnVPqznB4mx+3saflGi/zmefox44+nv2asBqAKB8lt6X73b6e8u5QamwQ+j5JR+Uxvw1evUpg==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=qKumtsLS5SGQx7avUspj0UWXIUmdzi1b7CAqAW0NbiE=;
 b=SmAKwKhwbQhYvPqrE8jgPJKs2NdQGEFyACfXTPIbzzMA/NI3zLBPuDKJPFySmDRdbzNM7skKSJjQ2rXgzbPaijnURaS+Kn2Ubc1u7ZK94ty4qwvmWzlK9V6RKLQDoffyj0uqexvG42p0gT4UThjE1zoU89ssGx/Yw7SWoX+luzP1xla5PPb4pkZXpu870EULov1/uhLm2NXnPYSyPMtDo2NMeKZ18JD7lhq4Zuydx6HKHNveEj4qqYca3NelmpoRX9Ua85rehlOcYyh4PTW8hYhMfANtVIyyIiCH25G4Cx7PDL6DMR/VvhNKn5ylYx5mK2sJ9s9rr1QAfZetugCBiw==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from SA1PR11MB6733.namprd11.prod.outlook.com (2603:10b6:806:25c::17)
 by PH7PR11MB7049.namprd11.prod.outlook.com (2603:10b6:510:20c::22) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.6745.32; Wed, 6 Sep
 2023 04:12:42 +0000
Received: from SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938]) by SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938%6]) with mapi id 15.20.6745.030; Wed, 6 Sep 2023
 04:12:42 +0000
Date: Tue, 5 Sep 2023 21:12:38 -0700
From: Ira Weiny <ira.weiny@intel.com>
To: Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Ira Weiny <ira.weiny@intel.com>
CC: Dan Williams <dan.j.williams@intel.com>,
        Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
Subject: Re: [PATCH RFC v2 13/18] dax/bus: Factor out dev dax resize logic
Message-ID: <64f7fc36a911a_1e8e78294b9@iweiny-mobl.notmuch>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
 <20230604-dcd-type2-upstream-v2-13-f740c47e7916@intel.com>
 <20230830122741.00007628@Huawei.com>
Content-Type: text/plain; charset="us-ascii"
Content-Disposition: inline
In-Reply-To: <20230830122741.00007628@Huawei.com>
X-ClientProxiedBy: SJ0PR03CA0158.namprd03.prod.outlook.com
 (2603:10b6:a03:338::13) To SA1PR11MB6733.namprd11.prod.outlook.com
 (2603:10b6:806:25c::17)
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: SA1PR11MB6733:EE_|PH7PR11MB7049:EE_
X-MS-Office365-Filtering-Correlation-Id: a5fb5a4b-0116-4192-1ceb-08dbae8f83e3
X-LD-Processed: 46c98d88-e344-4ed4-8496-4ed7712e255d,ExtAddr
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;
X-Microsoft-Antispam-Message-Info: OB0d88kGbzHKzp/mwL0LULVcV/V2LLZ2Gazo0bgYtoV2hvVF1JVONLSlH8hz/YtsiFmqu93b8HKKHoSPhB2Vv2Tc0kGL2/H8tR32G152SHMEZw/PV3MZ57dxpakAFb6dcmDIEaIv7nfrMDHLpK0z7Sr3p9GDUANV0grQEo3ZqLajsti/BlLStNRIE+BdpxmNtSTCLt+gYSOsxhxbkMbMHESvbKydYzZXz1ytsyZ8L0AfawXG9F7UVWHI5RD7wg8QDOAzPLOX1vduYElKkRxISLct/Jz+yfFvRzyhzKQl5EjuAbNdEfa9sTlIXkcMY7+jjJiGDwoL7IWnob7NXAo2hsuUnzp07DJjqUDQHN9efhZh/YGm3tn+piADarToIcFez7N3h1OlgOgz+OrDUyoHsAyTVoCpnKgioGa309zztkk2DxVNOWDG0Xey7VTmlsmI0tUHtEdFmgzANAreWbba1Xvifq2xGaPgptGNBETjUG494dxvB2nHQq8Jz/KCI4cqXfHXJXfD2g7JfxgbDLGYvshr/MRtQ3ZDBVT4xOdW6enrcJVKp9NTjeeDfdZeWkDV
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:SA1PR11MB6733.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230031)(396003)(376002)(366004)(346002)(136003)(39860400002)(1800799009)(186009)(451199024)(26005)(6506007)(6486002)(6512007)(9686003)(66899024)(38100700002)(86362001)(82960400001)(83380400001)(8936002)(44832011)(41300700001)(66556008)(316002)(4326008)(110136005)(66476007)(54906003)(5660300002)(66946007)(8676002)(2906002)(6666004)(478600001);DIR:OUT;SFP:1102;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?us-ascii?Q?kH7J/6i/ZMzoesh+mbogkyVpCR3p+C5NGH2PHxWgyJnsxZwSqwna1L6SIvJB?=
 =?us-ascii?Q?b5/bJ6a26Ziord8S/EFfc2Yw8JjlqC/Yb0fXulRn3/dva6jGpvABbChqXehQ?=
 =?us-ascii?Q?FTCBvj3U5anSzXOCGqFKmFslDLkbY9PuLcicqRVV3WVbnDKBjMSWfnmDaldQ?=
 =?us-ascii?Q?RalU4TNKMY4T4pyu2nM6Tv/cqFQQQ1Nr5xsdEhPVxrkssMkLHzpYSLvNuX0c?=
 =?us-ascii?Q?zusUirg/q6CtMJ7oa7Z8UrkO8zCDpxcpjNODB7DZWsrBzcTru/0/sQEBVmf0?=
 =?us-ascii?Q?4Sk6ysJHfZ7N1XRFSTOp3otpA/QutCFrXcyQTtyevuKQ+wS+CwHScH6iG8iG?=
 =?us-ascii?Q?Hqjpcxw1VJUu8Bw7wSTwlz+Rdh9/86hkrFrOuREZHOsVjmsyXBzLg34nR59V?=
 =?us-ascii?Q?qh592eEr9FuHxQ5v2btNMM7/wFEnSChGatpKNlw0rowcMebW1rQB594AzVd9?=
 =?us-ascii?Q?J6knaW8J0m7i+znE2NtHLhpABFm+Kgx4+aYkZHMZQniG52cI3/M9B4lz+kaX?=
 =?us-ascii?Q?0v0sOSKCQHSGJRFL9ZYR7+gwUfyT0Q3HqdLHqLQ0Mx9TSn1FJKW3HTJY1Cx8?=
 =?us-ascii?Q?nVYnMUEgJAovYwa7bUUMgMFKXqv26o6HlFlApPZ2aBTjvXUi1o2qMZ5YFCSA?=
 =?us-ascii?Q?+MYAHpq/tBTUasdZ+DntoDKccjabgVpkffp4JPvpTUpkxrp3z0n/KbgY0eYy?=
 =?us-ascii?Q?o9eetrd230JErQbtDDfJpBjKrfQsTxpsHVzQnuNFjZMB435h3NyOPHtFFt2R?=
 =?us-ascii?Q?8RcHPwAN+DghZKtDpTiSEv82ZkIkY5ZzVhs1G3hD60EbAhES+XnwW5ZIZokJ?=
 =?us-ascii?Q?pl65psjALC3/Iej4Z88QWkEn1SUUKVftJ4jte5HOT3OCjNkT751lEm6ZZDHg?=
 =?us-ascii?Q?d4+0xIop2giqTecwzFl66jIiaPnt5o+AjTQetgr3d0IMGQRH1ciWlcDewcIh?=
 =?us-ascii?Q?1szV2HbZDG+oimiA1Vy+3FQIjVLnB85ctrrVzC41B4zGTX63vOwkyxRELRAY?=
 =?us-ascii?Q?0VzBmokmCaOgc3hh6aYhqudlKHqEpKVoLvugMqrmFV8FyVIB6N6LWYPZ6GaI?=
 =?us-ascii?Q?YbmUbvhtC92RC3VnhGtxuiJlFS2G/5vlD+BgAupYiU5mnL0LHXOSnYG14VMj?=
 =?us-ascii?Q?VMS0q5YRI+1JY7MPe4K2J9qp+pcSMEfV6Ib+7lYcvI1BuUgQPRKi1KauZ/yY?=
 =?us-ascii?Q?R2dDR1QtQTIkSC5TQM0Y48W+2DBeoQEFZ+Wl/M7uxC8vYDXIsfbhD2SKqAlP?=
 =?us-ascii?Q?WtPdR8WytsGMrowP7x2FTADC9R7deHDJWzgq41BXhJjWWAARBamxxIjdnUmS?=
 =?us-ascii?Q?buCu8G/jB5tp3wTeE4WvK0HwLlutkLaeDZ9SP7QoF4muWJc7J+eSH8haRCnD?=
 =?us-ascii?Q?WfMoss0WYG51OzYIUas4HwByKsy+nOoTtMG19W5feAOjglv3/R/n+FAxUvV+?=
 =?us-ascii?Q?5WCbzQakinImg9pcvUBlZyc5Ma2YZdvIpKNeeuF0+aS0ZmU2dCxXNtafReO8?=
 =?us-ascii?Q?4ox/5YY1QFXoN3i16VDMv8HQnNc1JdzTLS2DNZsG9owf3jo809dd916EFM7Z?=
 =?us-ascii?Q?TlrgmSGpihraRh0xaLq8CjLDEsFHGKVFDooEqfuZ?=
X-MS-Exchange-CrossTenant-Network-Message-Id: a5fb5a4b-0116-4192-1ceb-08dbae8f83e3
X-MS-Exchange-CrossTenant-AuthSource: SA1PR11MB6733.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 06 Sep 2023 04:12:42.1131
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: QIPE9qnQC+Oz7vfoE8yhLw9dXSHCiWbgUl1ESl6SDYB4XRQ+nLOWEwAHe7zFIs5ozv3h2tAlLgRGW5Rs1zMIjg==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: PH7PR11MB7049
X-OriginatorOrg: intel.com
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

Jonathan Cameron wrote:
> On Mon, 28 Aug 2023 22:21:04 -0700
> Ira Weiny <ira.weiny@intel.com> wrote:
> 
> > Dynamic Capacity regions must limit dev dax resources to those areas
> > which have extents backing real memory.  Four alternatives were
> > considered to manage the intersection of region space and extents:
> > 
> > 1) Create a single region resource child on region creation which
> >    reserves the entire region.  Then as extents are added punch holes in
> >    this reservation.  This requires new resource manipulation to punch
> >    the holes and still requires an additional iteration over the extent
> >    areas which may already have existing dev dax resources used.
> > 
> > 2) Maintain an ordered xarray of extents which can be queried while
> >    processing the resize logic.  The issue is that existing region->res
> >    children may artificially limit the allocation size sent to
> >    alloc_dev_dax_range().  IE the resource children can't be directly
> >    used in the resize logic to find where space in the region is.
> > 
> > 3) Maintain a separate resource tree with extents.  This option is the
> >    same as 2) but with a different data structure.  Most ideally we have
> >    some unified representation of the resource tree.
> > 
> > 4) Create region resource children for each extent.  Manage the dax dev
> >    resize logic in the same way as before but use a region child
> >    (extent) resource as the parents to find space within each extent.
> > 
> > Option 4 can leverage the existing resize algorithm to find space within
> > the extents.
> > 
> > In preparation for this change, factor out the dev_dax_resize logic.
> > For static regions use dax_region->res as the parent to find space for
> > the dax ranges.  Future patches will use the same algorithm with
> > individual extent resources as the parent.
> > 
> > Signed-off-by: Ira Weiny <ira.weiny@intel.com>
> Hi Ira,
> 
> Some trivial comments on comments, but in general this indeed seems to be doing what you
> say and factoring out the static allocation part.
> 
> Reviewed-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

Thanks!

> 
> 
> > ---
> >  drivers/dax/bus.c | 128 +++++++++++++++++++++++++++++++++---------------------
> >  1 file changed, 79 insertions(+), 49 deletions(-)
> > 
> > diff --git a/drivers/dax/bus.c b/drivers/dax/bus.c
> > index b76e49813a39..ea7ae82b4687 100644
> > --- a/drivers/dax/bus.c
> > +++ b/drivers/dax/bus.c
> > @@ -817,11 +817,10 @@ static int devm_register_dax_mapping(struct dev_dax *dev_dax, int range_id)
> >  	return 0;
> >  }
> >  
> 
> > -static ssize_t dev_dax_resize(struct dax_region *dax_region,
> > -		struct dev_dax *dev_dax, resource_size_t size)
> > +/*
> 
> /**
> 
> Suitable builds will then check this doc matches the function etc
> even if this is never included into any of the docs build.

Done.

> 
> > + * dev_dax_resize_static - Expand the device into the unused portion of the
> > + * region. This may involve adjusting the end of an existing resource, or
> > + * allocating a new resource.
> > + *
> > + * @parent: parent resource to allocate this range in.
> > + * @dev_dax: DAX device we are creating this range for
> 
> Trivial: Doesn't seem to be consistent on . or not

That is because my brain has a real consistency issue on this...  ;-)

'.' removed.

Thanks again,
Ira

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 860F0EB8FA5
	for <linux-cxl@archiver.kernel.org>; Wed,  6 Sep 2023 04:09:36 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S232384AbjIFEJi (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Wed, 6 Sep 2023 00:09:38 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:45068 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S229554AbjIFEJg (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Wed, 6 Sep 2023 00:09:36 -0400
Received: from mgamail.intel.com (mgamail.intel.com [134.134.136.126])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 6B3101B3;
        Tue,  5 Sep 2023 21:09:33 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1693973373; x=1725509373;
  h=date:from:to:cc:subject:message-id:references:
   in-reply-to:mime-version;
  bh=lI3+11216xNrB37tkRrnEFrn2zPXSIwi6UTWOkuv6Is=;
  b=dTS/CmTPnKkrZWW99k0zYgTTuJc2dODMfB68DXkyrtd25PoBAHfor67d
   ZPl4bbY+Xn0GJj1sIKXl3J4DSsf7nZWaH8AVmrZsaEujz828W7FQMjtOo
   ma0+lGJvDluFpbceKQGryRzMb72HlIPpqUPH5EzfWUbOVgqq065UMjQ5I
   kn4osdVtacFVXeGM6KL5aoXCacEZWuLM79+m7bvtPuz9gQCp6M5pk8yoZ
   DiSzGNMMkbJYIHKHCvcwNFpMgXmIcDmobgBRLskUhwcSjPJhNu4zDZ4ou
   gDP9AXMGhD90qGQAbqjSbqS5vY/pE4kgoOpp410VUs0M80UJpDBBwo6jk
   w==;
X-IronPort-AV: E=McAfee;i="6600,9927,10824"; a="361995251"
X-IronPort-AV: E=Sophos;i="6.02,231,1688454000"; 
   d="scan'208";a="361995251"
Received: from fmsmga001.fm.intel.com ([10.253.24.23])
  by orsmga106.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 05 Sep 2023 21:08:01 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10824"; a="884541269"
X-IronPort-AV: E=Sophos;i="6.02,231,1688454000"; 
   d="scan'208";a="884541269"
Received: from fmsmsx602.amr.corp.intel.com ([10.18.126.82])
  by fmsmga001.fm.intel.com with ESMTP/TLS/AES256-GCM-SHA384; 05 Sep 2023 21:07:49 -0700
Received: from fmsmsx603.amr.corp.intel.com (10.18.126.83) by
 fmsmsx602.amr.corp.intel.com (10.18.126.82) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27; Tue, 5 Sep 2023 21:07:58 -0700
Received: from fmsedg601.ED.cps.intel.com (10.1.192.135) by
 fmsmsx603.amr.corp.intel.com (10.18.126.83) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27 via Frontend Transport; Tue, 5 Sep 2023 21:07:58 -0700
Received: from NAM11-CO1-obe.outbound.protection.outlook.com (104.47.56.170)
 by edgegateway.intel.com (192.55.55.70) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.27; Tue, 5 Sep 2023 21:07:58 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=RzqvgTjIkyqJluo6ieqYee1ENvX+k+j10j37tGQNagFeihHxbISamG9EW6JXgnt6v6v0QLdsY9WqCf62m5p4k9oPnFezpoYuPQRtCx6yVHxN9ezq9elnh9TD2q0MLY0go0NajnWvf7pwroIA/Ttvud6aZiXpTvP5h+DK6BqK9oHie0xprMPVv+SVZ9qcM/wWw5GTjpXTqZuouXw2tzp3Y7a/jzqrB2SEOzG6PWsvVu7/pUytEBH2hswnMIZSSTI8/uNF9qWB2PPbqYg5+2ScN/RPWSTc11s6+Sq5tW/ae6FV+9Ep0MqA9pcEeY5LI7yIfY4OyowzYxfltDygN6IJaw==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=lWwftGQRA9NK45pY3vVfH9OteqttS5/eUit5G1/Fm+Y=;
 b=gVJ2c7zDurNq9/XvurZCKsA/Sq0c89e9n95Q93OxEOOEFWi0MBVLceoJGfGWja7IV20aSG1bRXOOCVeohA/q+/rTOi9bqCIQW12cO11ry4l1o03RcV+PCcpJ89XFC9ztcjbP8YK/CvOMU6fj5LoNSjlX0hlQNh6Dcr3Yz91eN8n7sIBlhzU+Ucqeu2IZgPDxJY9r3obhKGnjY7m2AFLEd1OmkVj0+PLUiRDfq3A+43/6if8DHK+Fyx6BjP21EMoVEVsuwQxhmYVeb+nLm3rg9LW6G8+lkJTnQldZHl+nBMZP4h3YMpv+D0707/AdzwQ9xQNf3AiusKPbAF8Jx44tHg==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from SA1PR11MB6733.namprd11.prod.outlook.com (2603:10b6:806:25c::17)
 by PH7PR11MB7049.namprd11.prod.outlook.com (2603:10b6:510:20c::22) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.6745.32; Wed, 6 Sep
 2023 04:07:51 +0000
Received: from SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938]) by SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938%6]) with mapi id 15.20.6745.030; Wed, 6 Sep 2023
 04:07:51 +0000
Date: Tue, 5 Sep 2023 21:07:48 -0700
From: Ira Weiny <ira.weiny@intel.com>
To: Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        <ira.weiny@intel.com>
CC: Dan Williams <dan.j.williams@intel.com>,
        Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
Subject: Re: [PATCH RFC v2 15/18] cxl/mem: Trace Dynamic capacity Event Record
Message-ID: <64f7fb141d719_1e8e7829412@iweiny-mobl.notmuch>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
 <20230604-dcd-type2-upstream-v2-15-f740c47e7916@intel.com>
 <20230829174635.00004371@Huawei.com>
Content-Type: text/plain; charset="us-ascii"
Content-Disposition: inline
In-Reply-To: <20230829174635.00004371@Huawei.com>
X-ClientProxiedBy: BYAPR05CA0045.namprd05.prod.outlook.com
 (2603:10b6:a03:74::22) To SA1PR11MB6733.namprd11.prod.outlook.com
 (2603:10b6:806:25c::17)
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: SA1PR11MB6733:EE_|PH7PR11MB7049:EE_
X-MS-Office365-Filtering-Correlation-Id: a91c8551-4249-4200-da30-08dbae8ed6e0
X-LD-Processed: 46c98d88-e344-4ed4-8496-4ed7712e255d,ExtAddr
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;
X-Microsoft-Antispam-Message-Info: A8xn+aM16Y2aYdEYQ27N5XE0+ApvFvy8s4LVA8V8yIj4jpAwW3LGe+3IrAiNwAN9h01JiWDRtqtMIYMOJpEkrYvOOxWNg7b5zwajxjCHdMgP/xivJecRmltMV3uq0HxEd3xvG0J49Y34gfLHnjRKJjRfJBPLxdabRCsRPxEdG822G8EAftReA0dtgfscZB6jK4oru3j/6tFyd2v1T2a7Y58CUcZuyHqX0JR5fm/Riw8MgOEtkEl29OO6GmDm+tqdxsFMaPhSBu62jz+HAOapYBNDZicYRttRY9sGjq+lavt0nG2xwccogMX0JrbqjaWBgXNNaATD9xhPkaz1lfFa3e7mX1RqvOwP65n55zFLhUgsAbgBxb53Xkd+66uLXxpcai2WQruIhr7D9idMrsDO90q1A0g1sL/nv2BLv2PyxqbGUTQmuXRDYx4IsMpg8P+pGhxImPG4u8mG17qNpu3+MAwAw7F+TxGdMIuSMQ6+OGLC+mP3naV+Eq2jY5zsWS61ZxjQZLtVqf6o91fzsf1WIHNYU7K+wafu328k/whlH2xdzZnp/9+Qokkyt2rAtnoZ
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:SA1PR11MB6733.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230031)(396003)(376002)(366004)(346002)(136003)(39860400002)(1800799009)(186009)(451199024)(26005)(6506007)(6486002)(6512007)(9686003)(38100700002)(86362001)(82960400001)(83380400001)(8936002)(44832011)(4744005)(41300700001)(66556008)(316002)(4326008)(66476007)(54906003)(5660300002)(66946007)(8676002)(2906002)(6666004)(478600001);DIR:OUT;SFP:1102;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?us-ascii?Q?z53xVZKi3BXSxZ9k7gn6Ijw97eKUFpkrV2/pKPPlONO7SpOJn9YYLQxjzymg?=
 =?us-ascii?Q?qwJYKlWF7XYGmLrtD4R38kpZl0aopHt4BS9XfVQl1stxUC8l8yLkEK6XUUv3?=
 =?us-ascii?Q?ilZHwy+HfaIoIEhHcC3mjyKwBsnuXnx9J/VXN0jNAH5CCW8eZ1Y0o5pEKBma?=
 =?us-ascii?Q?1mnqqQzxeYYDcJqpMfzQh/tUWrlYHmRHsDzHrYCfj43B0MTwaSg7MtdfoAHm?=
 =?us-ascii?Q?wCNnL5I+pDsGjlW2m0phd90RgZczc//fop328vdSa1c6sJFSLUljrwHr1xo5?=
 =?us-ascii?Q?gBeHp4pYMHnKirLl3cyVBxTjt7+vW3ALN9tTCPFiNa3A+jTThqW7Z4THPQ/0?=
 =?us-ascii?Q?iztQlmv3UorDDlEwKVuIFSO2s79KLxMwbOK90Sj2+5xZwQS0rcJDslAA9S0L?=
 =?us-ascii?Q?AWg9qxngY8/UaNxR0f4Xyd8sy7pcnEqkBnO1hoBErU4kxC8b/jllOEVwhMhe?=
 =?us-ascii?Q?v/y9/o46M6A5YQlZ5hkAlyckM4l59hWVVzuHx20vTyjhCMP9Z/gG66mwpuqG?=
 =?us-ascii?Q?seUfr9LD46KryeOMTNwFH3+0B1GaHpihoMbKvrwvA+m8m+wr1x0YFQ9SOqgF?=
 =?us-ascii?Q?h3ChKG3DKuEbh+suEpcgAeixRaO9lIfJnaUMdZyua27ToLx4W5+oH8fPbuhO?=
 =?us-ascii?Q?M7o8Z6YzAfoaO4U9l+BER0GtMRIFa7aqfEgPyNey7Juez7WJnX7xsYn6a7Gc?=
 =?us-ascii?Q?+MrAJqr0H2qb8wsb3R0cLoIebRID/NcFmrDPY7omcop4Fd+fc/qrZsidFXv8?=
 =?us-ascii?Q?x3GMCmmZVrjIeDkSxJI8SHGg6Z2MWFQp0PC7MOFArobLP2ucVbwP2yzRqxPC?=
 =?us-ascii?Q?AyLR9C+JyDmjVVa6JHu4LisyFnFCl/SR4uaFP/cjuWFV+LYrrs0HKhRIRhJ6?=
 =?us-ascii?Q?jHlisNutoc3s1EZryqYgp0ha+NZMrjSc/xgD/9zCf+wYn2TLWI9k83ZxNKu3?=
 =?us-ascii?Q?lpXBn7maks2Q8jvgkxt6zn89+MATsIbnVPEWQvi9FY9U1mxVE17oluabROb8?=
 =?us-ascii?Q?+c3xkInTvclX+ajinyzwEkBA8SfXAvKGQ1B24YIaYxJjz465KNKadgXC1z+z?=
 =?us-ascii?Q?K0JIc8FQy+Fg4aXN2swPnF5izugqPmd1MNYKs/YzOIM8MaNH9PjK1ljnGyxc?=
 =?us-ascii?Q?OhBm0MvtbvbIzeunOTLGhz9St2FelaSSL/zD5aWMVbQ07SKlEdPctd6rftI6?=
 =?us-ascii?Q?IT+4vB/ziUtOj2guiV2OtjKadaxBAG+nDwYVSDQksEAxrkSSSBNtHoffbKdM?=
 =?us-ascii?Q?JsThf03aUqiJxqZrCmjCdJfgWEADdZWA6TvPVO9CUDVXAwV+jxhNdudczGH5?=
 =?us-ascii?Q?eWWTEGU4guci6GAr8snWrwaQUZ34HylzihF5LoELEWNXPpFrX/7VxZjNS6IX?=
 =?us-ascii?Q?umvcnrMZB9wWx3pVQ91gM60YKYuGuY1au2cSPZHwXJeG0S3NFp2Ok8/3LUen?=
 =?us-ascii?Q?owjFD26n6eC78HbLTOf2qQfS3LrjKW/6OlhQ1f9+dwqWXnxqgLYaqhLGor0N?=
 =?us-ascii?Q?+6k9Sg3aB2whoNYumsL1Lg8FxCJHDoRIQM2M1TMKGNXEjQ3NB9BWMDkpM1Qa?=
 =?us-ascii?Q?Fhx2mWWlC4/kR5rFuomV56wVtNoDTU2c+eAQu5Z9?=
X-MS-Exchange-CrossTenant-Network-Message-Id: a91c8551-4249-4200-da30-08dbae8ed6e0
X-MS-Exchange-CrossTenant-AuthSource: SA1PR11MB6733.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 06 Sep 2023 04:07:51.8399
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: /SDUySUmxHKG3a1/s/xmkRoN2XQXnSNm3IdxAlDjJ7v3ix3rm1vVs8J0LIbPkMgJQAZ3vy06u0DMh1R8eyhZKA==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: PH7PR11MB7049
X-OriginatorOrg: intel.com
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

Jonathan Cameron wrote:
> On Mon, 28 Aug 2023 22:21:06 -0700
> ira.weiny@intel.com wrote:
> 
> > From: Navneet Singh <navneet.singh@intel.com>
> > 
> > CXL rev 3.0 section 8.2.9.2.1.5 defines the Dynamic Capacity Event Record
> > Determine if the event read is a Dynamic capacity event record and
> > if so trace the record for the debug purpose.
> > 
> > Add DC trace points to the trace log.
> 
> Probably should say why these might be useful...
> 

Its kind of hidden.

	"... for the debug purpose."

I suppose this could be used to react to new extents coming online to
create new dax devices in the future.  But that should really be done
through udev when dax extent devices surface not these events.

I'll clarify the commit message.

Thanks,
Ira

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 8278DEB8FA5
	for <linux-cxl@archiver.kernel.org>; Wed,  6 Sep 2023 04:00:56 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S229585AbjIFEA6 (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Wed, 6 Sep 2023 00:00:58 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:42792 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S229554AbjIFEA5 (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Wed, 6 Sep 2023 00:00:57 -0400
Received: from mgamail.intel.com (mgamail.intel.com [192.55.52.120])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 4F800CEE;
        Tue,  5 Sep 2023 21:00:52 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1693972852; x=1725508852;
  h=date:from:to:cc:subject:message-id:references:
   in-reply-to:mime-version;
  bh=aWNqt15lPzq65Ivi2Mo0sr1ynZBbiYzLn+tZznriogk=;
  b=Aez2765WXjFZ95Qej6axHM0PbRqZkdpeipAqSmg6j/BL3BiQ1Dsn6FzO
   F5zlkm2dZ3dkhvoVe4NSMsGAnxr5Zb7okqAKU3yQgQxG3hyXvx/9k+LqX
   HDzZ5ZYl/Txx/hfDUWwQEsO8fQithMDuMw6Tn5vHVaeuMIXEp2nHGTldc
   CJblUze0IqXpqMZ4qxIghXvf0y69tXBgPPie63r+Y+GrK4W083tEb4+Hg
   MjONHoDuIiwRv3k9p4rFEU+rFxI5h994xfv9ovTXIu+popjDGvTvjjbsl
   BgkAe3ij6fvs7b/ctvj/8pCFovHlSppHRiHxvMqwHnW+TvHDgteKSkcjQ
   Q==;
X-IronPort-AV: E=McAfee;i="6600,9927,10824"; a="375867204"
X-IronPort-AV: E=Sophos;i="6.02,231,1688454000"; 
   d="scan'208";a="375867204"
Received: from fmsmga008.fm.intel.com ([10.253.24.58])
  by fmsmga104.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 05 Sep 2023 21:00:51 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10824"; a="806864895"
X-IronPort-AV: E=Sophos;i="6.02,231,1688454000"; 
   d="scan'208";a="806864895"
Received: from fmsmsx602.amr.corp.intel.com ([10.18.126.82])
  by fmsmga008.fm.intel.com with ESMTP/TLS/AES256-GCM-SHA384; 05 Sep 2023 21:00:50 -0700
Received: from fmsmsx610.amr.corp.intel.com (10.18.126.90) by
 fmsmsx602.amr.corp.intel.com (10.18.126.82) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27; Tue, 5 Sep 2023 21:00:50 -0700
Received: from fmsmsx610.amr.corp.intel.com (10.18.126.90) by
 fmsmsx610.amr.corp.intel.com (10.18.126.90) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27; Tue, 5 Sep 2023 21:00:49 -0700
Received: from fmsedg601.ED.cps.intel.com (10.1.192.135) by
 fmsmsx610.amr.corp.intel.com (10.18.126.90) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27 via Frontend Transport; Tue, 5 Sep 2023 21:00:49 -0700
Received: from NAM12-MW2-obe.outbound.protection.outlook.com (104.47.66.45) by
 edgegateway.intel.com (192.55.55.70) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.27; Tue, 5 Sep 2023 21:00:49 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=LfG9qMnXXXe22kOPOVn3u5QAXcWg1/Ewc64x7TyPD/mR6exOgTSUxDc2ITYMaSmAfjoP7V0v2YDU2/pfYyGsrxsgz63tZETSa10fX4aiea+clp36YHddTy6VsCsaD7FhvbBHN2zCdNtNUZI5xfxeTMJ+LKH2R6mUuDgRx8MM0d8YSZQddINkCQF9Sb6wkrvDULSIKzMsHA9OS1EihPCClEfIE6yZjZzTN5ozM5e31kyvPYPu6Zp5Nrx1nr3HsFv2meozvGSfRzNKM4YjZ5O1JYizzArpNvJGNEHmmJlc49gU6RjLMvUHEjlr4MyPqFHnmyNbBf0A22iziBGZHaliZQ==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=L1E32rQ5Hjgdh0CYAlLuiT5nyVzf5xbGeOXR3w5k4kA=;
 b=Mpvcyvy5yWqu9jZ14rMnGRsWfTFYx5++hxQlX5db5R+ypRI5abMEkqOdZGW42J5KcsnR8w/NO0QRQa01tjrcn9Oies2CUVjlXnxcLkXtKcZDcQIIHvxBTaXovOqkdCSI9VAp9rEAySoMRxQUy930FZ4OZQkcpuBjzGRORDWBig0F3UsLhWfpoA+FTZ2Wq37xRB/VMn4ATw7AqRqWAEjmAWH7bS3kjH2sTWjZeqVZflB3YvvsmUJNrAjTU2NcRut2ThGg5HfeQdk4G2eanhTYrOWkKHJ/INoh1f81wVJt1vEx3Y4mCDqanc1kuKDS3UNc4cWwdh+eRIsfp3iDEiFwIw==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from SA1PR11MB6733.namprd11.prod.outlook.com (2603:10b6:806:25c::17)
 by SA1PR11MB5803.namprd11.prod.outlook.com (2603:10b6:806:23e::8) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.6745.33; Wed, 6 Sep
 2023 04:00:48 +0000
Received: from SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938]) by SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938%6]) with mapi id 15.20.6745.030; Wed, 6 Sep 2023
 04:00:48 +0000
Date: Tue, 5 Sep 2023 21:00:44 -0700
From: Ira Weiny <ira.weiny@intel.com>
To: Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Ira Weiny <ira.weiny@intel.com>
CC: Dan Williams <dan.j.williams@intel.com>,
        Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
Subject: Re: [PATCH RFC v2 12/18] cxl/region: Notify regions of DC changes
Message-ID: <64f7f96c1850f_1e8e78294a9@iweiny-mobl.notmuch>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
 <20230604-dcd-type2-upstream-v2-12-f740c47e7916@intel.com>
 <20230829174053.000008a1@Huawei.com>
Content-Type: text/plain; charset="us-ascii"
Content-Disposition: inline
In-Reply-To: <20230829174053.000008a1@Huawei.com>
X-ClientProxiedBy: SJ0PR13CA0078.namprd13.prod.outlook.com
 (2603:10b6:a03:2c4::23) To SA1PR11MB6733.namprd11.prod.outlook.com
 (2603:10b6:806:25c::17)
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: SA1PR11MB6733:EE_|SA1PR11MB5803:EE_
X-MS-Office365-Filtering-Correlation-Id: 933d2bce-08bd-4685-fb55-08dbae8dd9da
X-LD-Processed: 46c98d88-e344-4ed4-8496-4ed7712e255d,ExtAddr
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;
X-Microsoft-Antispam-Message-Info: 5JrXypKJfTqEsyODV3o12blzc77fgEQDdTG71N+QLoJSI9pW0k9IxoO/Ma7aWxuRjS8mWLvAIGBZUVS7tJJDhsELME0GzyYPeigew0ljyD5yp9yXAX6nwAbExOtpPZR4c1sUzmpNqLNK8gwV2H8aaBrdjmcFIbSPb+TuBy9RQ7ohrRaL/87lFurJ3OCfIKcFF0lbkB7bTLfa8XKtZtP6gHLe/pUxUL41yxhEI7c9ulPAeFaTxjaZJBK7s8c3bhpEqCzpYJepnuYtEzidct9Vt5EaE8v2FPizyg0YaXzvjE77W/fePx12uNy5jcWra9t15aWFzz1hvSyn3o7rcSXJVCb7MS2P9rf4oJEdFDwlLAibXjXTK4r4+f6E0lxIChLqfgJsEmQY+4VfR7banqnUGLAVUz9Z07Zb4jYkAULFutweR/bn+jYTPCDR38Uy7CKMsOfaBxTRYEnOqDFJ2p1nVrX5iCITmiQgE0oAoLbpKmb+ANLBwY8NB4gcax1qeJe5RD75W6uXiWniDjAGoY0b+QFVCETwK3KUGAuFIdI2V53av33Axxtba5XibyMCfZw5
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:SA1PR11MB6733.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230031)(346002)(366004)(39860400002)(376002)(396003)(136003)(186009)(451199024)(1800799009)(2906002)(82960400001)(38100700002)(86362001)(9686003)(41300700001)(6512007)(6506007)(6486002)(54906003)(66476007)(110136005)(66946007)(8936002)(4326008)(8676002)(66556008)(316002)(478600001)(6666004)(44832011)(26005)(5660300002)(83380400001);DIR:OUT;SFP:1102;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?us-ascii?Q?4GHtuUBvSKF7R4ROSH4/nGQUnMWhqQQ9vYosN2qz8lILgR4kM7OYxfrHPNT9?=
 =?us-ascii?Q?YIoobxN1Z38sIwQ2rhLRmAYfzKtxBXGScWS6l01wn8S9zqsqmwtHKhdN++mk?=
 =?us-ascii?Q?NL2tTgUWtkCmz3LkxyJMUdd9jCT2osx6F7rW9xta3llhTW+NYh2gljhrhbw0?=
 =?us-ascii?Q?n3fxjCT67zoJIykIvoIpR9pKW5hTRH73yeCo3tGWsr956gKg4IyNr9uPTvze?=
 =?us-ascii?Q?dQtsf/KF27zK8sEam44gjwwOJR5ech7i42ih4/FiLqUdtTQMODEPFN4nonlr?=
 =?us-ascii?Q?9zubY7AkEs229gIGgkxL/SFjibt9xMW4FjDMoGY73w/AOUJTReQ5/9Uxt/hp?=
 =?us-ascii?Q?kd3LBgIagehmdc3X1yweiQmquoToQAzp6k53LSGL+DAQtuhX4QDK1K0T9Ca8?=
 =?us-ascii?Q?hS8pi14AEyyIqhgJGx0iwY+anPIBS+rSdZVz14sgzWlS0TNuMZ2PwJZUU86t?=
 =?us-ascii?Q?NdeHIr5Lpebmb7Wa9Uty+9U1pG0uiMktDZB3EN0vsksqv6Xm4xapce1rMpWW?=
 =?us-ascii?Q?XnmTadzAsKjsJMZ7R1UNX82/HztDqPzI8BiouCgRSLlDbzNdgbLifU/A3rek?=
 =?us-ascii?Q?OsR3Tm5/96eIny032klYyXsHC4oG5Mxg6h4kapO69vKMx45C3ge2yPPPMgjE?=
 =?us-ascii?Q?Zt1TZRHjA5tYi6yc0ls2gIxy85zHgcSsO2EXBHYTFoTByUwag8W/OhOksUAV?=
 =?us-ascii?Q?YZdaT06ojRx/KU5mXlInzPWkW4nmFCKvrscM8UuDf3fUwyAtBto0hJmvLAbf?=
 =?us-ascii?Q?YsFHkQZGKvJ+hXUWJJ2G2AaiDaSM3e3FpSMPmvZyuB2vugPar8JLcDZS8mH9?=
 =?us-ascii?Q?IMe9zdtd7XtOhjMOGMuLaZo14MFdE1W4biZfQmutlVAGoL8ex+Kbc9LwXfg3?=
 =?us-ascii?Q?V1Fgfq+efZ19LTt43XaLSvDUNCLU0WJN8W67p2C/igI3308bRrhAWt6Su5do?=
 =?us-ascii?Q?t+zO7dyq6ARRYDrmEhdRq+yxw1Q4wgW+vSKZ35198Uzso0qNLz86EwJxdJ56?=
 =?us-ascii?Q?B6ukVuYdAL3W+UgNI0bXuEWXncg7hX6CY3L9OPoptoFv80GoKTR7HIIHKnls?=
 =?us-ascii?Q?0VM+W8HyYZWMMk4dAIXIxSMBFeiu15dseJBo80qi5u7TCGyNCeCYuMGI4Jd8?=
 =?us-ascii?Q?2aw6gd+RxGatTBB0MOQLCgEigHXcaPpazsAOCHKvdrhEeUtpdUBbGujJtppW?=
 =?us-ascii?Q?U5sBUPmSjGxSBZB6T28/2lzB7oicyUQKHHwVUA1JR3bHU9bY089gyCtyzqQY?=
 =?us-ascii?Q?nZJioziMoZ3UP8l1wnbRez7jn63jP9kpvKZSkLwUmcvwEnwlFraxaLtdZfwl?=
 =?us-ascii?Q?7D2bq7TNhTC/nCtnp1zF+6YHT5g9t5q6RlaHYr/zV6ePi+hE9vKr090lWBzN?=
 =?us-ascii?Q?pwhwaWzj2ksOGzj/PUfcpn9dHPLdq4sBv+OtQSQpE5kXTEdONXhQ3jfoiZLR?=
 =?us-ascii?Q?zPycv0Xs5t9/pfC0lOidK5E/0j1H9JDrMhduN9r3CsNBw9qy+M8z1rAFDxS+?=
 =?us-ascii?Q?7ijDtGaS9Nc24eDOdadrW5Bi2ZS122xIk7kcJBSzwxF5OLLlXHzzXEc21qXO?=
 =?us-ascii?Q?fper1TxbUD01B+I34Q+DcFx/2dHxA4uvKKwDro/F?=
X-MS-Exchange-CrossTenant-Network-Message-Id: 933d2bce-08bd-4685-fb55-08dbae8dd9da
X-MS-Exchange-CrossTenant-AuthSource: SA1PR11MB6733.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 06 Sep 2023 04:00:47.6711
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: m3fg08JmS1BG3oFqgCMNSeVT0h2tDbunTTh3IRF059wm3u2DfOjUIrVsqLq2nlyAeOZXB6bGNWVt1GG0E5oDig==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: SA1PR11MB5803
X-OriginatorOrg: intel.com
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

Jonathan Cameron wrote:
> On Mon, 28 Aug 2023 22:21:03 -0700
> Ira Weiny <ira.weiny@intel.com> wrote:
> 
> > In order for a user to use dynamic capacity effectively they need to
> > know when dynamic capacity is available.  Thus when Dynamic Capacity
> > (DC) extents are added or removed by a DC device the regions affected
> > need to be notified.  Ultimately the DAX region uses the memory
> > associated with DC extents.  However, remember that CXL DAX regions
> > maintain any interleave details between devices.
> > 
> > When a DCD event occurs, iterate all CXL endpoint decoders and notify
> > regions which contain the endpoints affected by the event.  In turn
> > notify the DAX regions of the changes to the DAX region extents.
> > 
> > For now interleave is handled by creating simple 1:1 mappings between
> > the CXL DAX region and DAX region layers.  Future implementations will
> > need to resolve when to actually surface a DAX region extent and pass
> > the notification along.
> > 
> > Remember that adding capacity is safe because there is no chance of the
> > memory being in use.  Also remember at this point releasing capacity is
> > straight forward because DAX devices do not yet have references to the
> > extents.  Future patches will handle that complication.
> > 
> > Signed-off-by: Ira Weiny <ira.weiny@intel.com>
> > 
> 
> A few trivial comments on this.  Lot here so I'll take a closer look
> at some point after doing a light pass over the rest of the series.
> 

I agree this is a lot.  I thought about splitting the notification into 2
layers.  Notify from device to CXL region then a separate patch from CXL
region to DAX region.  In the end I channeled Dan and kept it all together
because without interleaving there is not much for the CXL region to do
but pass the notification up.  So that patch would have been kind of
awkward.

> 
> 
> 
> > diff --git a/drivers/cxl/mem.c b/drivers/cxl/mem.c
> > index 80cffa40e91a..d3c4c9c87392 100644
> > --- a/drivers/cxl/mem.c
> > +++ b/drivers/cxl/mem.c
> > @@ -104,6 +104,55 @@ static int cxl_debugfs_poison_clear(void *data, u64 dpa)
> >  DEFINE_DEBUGFS_ATTRIBUTE(cxl_poison_clear_fops, NULL,
> >  			 cxl_debugfs_poison_clear, "%llx\n");
> >  
> > +static int match_ep_decoder_by_range(struct device *dev, void *data)
> > +{
> > +	struct cxl_dc_extent_data *extent = data;
> > +	struct cxl_endpoint_decoder *cxled;
> > +
> > +	if (!is_endpoint_decoder(dev))
> > +		return 0;
> 
> blank line

Done.

> 
> > +	cxled = to_cxl_endpoint_decoder(dev);
> > +	return cxl_dc_extent_in_ed(cxled, extent);
> > +}
> > +
> > +static struct cxl_endpoint_decoder *cxl_find_ed(struct cxl_memdev_state *mds,
> > +						struct cxl_dc_extent_data *extent)
> > +{
> > +	struct cxl_memdev *cxlmd = mds->cxlds.cxlmd;
> > +	struct cxl_port *endpoint = cxlmd->endpoint;
> > +	struct device *dev;
> > +
> > +	dev = device_find_child(&endpoint->dev, extent,
> > +				match_ep_decoder_by_range);
> > +	if (!dev) {
> > +		dev_dbg(mds->cxlds.dev, "Extent DPA:%llx LEN:%llx not mapped\n",
> > +			extent->dpa_start, extent->length);
> > +		return NULL;
> > +	}
> > +
> > +	return to_cxl_endpoint_decoder(dev);
> > +}
> > +
> > +static int cxl_mem_notify(struct device *dev, struct cxl_drv_nd *nd)
> > +{
> > +	struct cxl_memdev *cxlmd = to_cxl_memdev(dev);
> > +	struct cxl_memdev_state *mds = to_cxl_memdev_state(cxlmd->cxlds);
> > +	struct cxl_endpoint_decoder *cxled;
> > +	struct cxl_dc_extent_data *extent;
> > +	int rc = 0;
> > +
> > +	extent = nd->extent;
> > +	dev_dbg(dev, "notify DC action %d DPA:%llx LEN:%llx\n",
> > +		nd->event, extent->dpa_start, extent->length);
> > +
> > +	cxled = cxl_find_ed(mds, extent);
> > +	if (!cxled)
> > +		return 0;
> Blank line.

Done.

> 
> > +	rc = cxl_ed_notify_extent(cxled, nd);
> > +	put_device(&cxled->cxld.dev);
> > +	return rc;
> > +}
> > +
> >  static int cxl_mem_probe(struct device *dev)
> >  {
> >  	struct cxl_memdev *cxlmd = to_cxl_memdev(dev);
> > @@ -247,6 +296,7 @@ __ATTRIBUTE_GROUPS(cxl_mem);
> >  static struct cxl_driver cxl_mem_driver = {
> >  	.name = "cxl_mem",
> >  	.probe = cxl_mem_probe,
> > +	.notify = cxl_mem_notify,
> >  	.id = CXL_DEVICE_MEMORY_EXPANDER,
> >  	.drv = {
> >  		.dev_groups = cxl_mem_groups,
> > diff --git a/drivers/dax/cxl.c b/drivers/dax/cxl.c
> > index 057b00b1d914..44cbd28668f1 100644
> > --- a/drivers/dax/cxl.c
> > +++ b/drivers/dax/cxl.c
> > @@ -59,6 +59,29 @@ static int cxl_dax_region_create_extent(struct dax_region *dax_region,
> >  	return 0;
> >  }
> >  
> > +static int cxl_dax_region_add_extent(struct cxl_dax_region *cxlr_dax,
> > +				     struct cxl_dr_extent *cxl_dr_ext)
> > +{
> 
> Why not have this helper in the earlier patch that introduced the code
> this is factoring out?  Will reduce churn in the set whilst not much hurting
> readability of that patch.

Because this logic appeared in only 1 place in that patch.  Here we are
using this same logic 2x so it got factored out.

I see where you are coming from because this is a straight up copy of the
code.  I'll go ahead and do that.

> 
> > +	/*
> > +	 * get not zero is important because this is racing with the
> > +	 * region driver which is racing with the memory device which
> > +	 * could be removing the extent at the same time.
> > +	 */
> > +	if (cxl_dr_extent_get_not_zero(cxl_dr_ext)) {
> > +		struct dax_region *dax_region;
> > +		int rc;
> > +
> > +		dax_region = dev_get_drvdata(&cxlr_dax->dev);
> > +		dev_dbg(&cxlr_dax->dev, "Creating HPA:%llx LEN:%llx\n",
> > +			cxl_dr_ext->hpa_offset, cxl_dr_ext->hpa_length);
> > +		rc = cxl_dax_region_create_extent(dax_region, cxl_dr_ext);
> > +		cxl_dr_extent_put(cxl_dr_ext);
> > +		if (rc)
> > +			return rc;
> > +	}
> > +	return 0;
> Perhaps flip logic
> 	if (!cxl_dr_extent_get_not_zero())
> 		return 0;
> 
> etc to reduce the code indent.

That is ok.  But in this case I do kind of like the indent.  I'll change
it to your way because I think it is slightly better.

Done in the previous patch.


> > +}
> > +
> >  static int cxl_dax_region_create_extents(struct cxl_dax_region *cxlr_dax)
> >  {
> >  	struct cxl_dr_extent *cxl_dr_ext;
> > @@ -66,27 +89,68 @@ static int cxl_dax_region_create_extents(struct cxl_dax_region *cxlr_dax)
> >  
> >  	dev_dbg(&cxlr_dax->dev, "Adding extents\n");
> >  	xa_for_each(&cxlr_dax->extents, index, cxl_dr_ext) {
> > -		/*
> > -		 * get not zero is important because this is racing with the
> > -		 * region driver which is racing with the memory device which
> > -		 * could be removing the extent at the same time.
> > -		 */
> > -		if (cxl_dr_extent_get_not_zero(cxl_dr_ext)) {
> > -			struct dax_region *dax_region;
> > -			int rc;
> > -
> > -			dax_region = dev_get_drvdata(&cxlr_dax->dev);
> > -			dev_dbg(&cxlr_dax->dev, "Found OFF:%llx LEN:%llx\n",
> > -				cxl_dr_ext->hpa_offset, cxl_dr_ext->hpa_length);
> > -			rc = cxl_dax_region_create_extent(dax_region, cxl_dr_ext);
> > -			cxl_dr_extent_put(cxl_dr_ext);
> > -			if (rc)
> > -				return rc;
> > -		}
> > +		int rc;
> > +
> > +		rc = cxl_dax_region_add_extent(cxlr_dax, cxl_dr_ext);
> > +		if (rc)
> > +			return rc;
> >  	}
> >  	return 0;
> >  }
> >  
> > +static int match_cxl_dr_extent(struct device *dev, void *data)
> > +{
> > +	struct dax_reg_ext_dev *dr_reg_ext_dev;
> > +	struct dax_region_extent *dr_extent;
> > +
> > +	if (!is_dr_ext_dev(dev))
> > +		return 0;
> > +
> > +	dr_reg_ext_dev = to_dr_ext_dev(dev);
> > +	dr_extent = dr_reg_ext_dev->dr_extent;
> > +	return data == dr_extent->private_data;
> > +}
> > +
> > +static int cxl_dax_region_rm_extent(struct cxl_dax_region *cxlr_dax,
> > +				    struct cxl_dr_extent *cxl_dr_ext)
> > +{
> > +	struct dax_reg_ext_dev *dr_reg_ext_dev;
> > +	struct dax_region *dax_region;
> > +	struct device *dev;
> > +
> > +	dev = device_find_child(&cxlr_dax->dev, cxl_dr_ext,
> > +				match_cxl_dr_extent);
> > +	if (!dev)
> > +		return -EINVAL;
> 
> blank line.

Done.

> 
> > +	dr_reg_ext_dev = to_dr_ext_dev(dev);
> > +	put_device(dev);
> > +	dax_region = dev_get_drvdata(&cxlr_dax->dev);
> > +	dax_region_ext_del_dev(dax_region, dr_reg_ext_dev);
> blank line

Done.

> 
> > +	return 0;
> > +}
> > +
> > +static int cxl_dax_region_notify(struct device *dev,
> > +				 struct cxl_drv_nd *nd)
> > +{
> > +	struct cxl_dax_region *cxlr_dax = to_cxl_dax_region(dev);
> > +	struct cxl_dr_extent *cxl_dr_ext = nd->cxl_dr_ext;
> > +	int rc = 0;
> > +
> > +	switch (nd->event) {
> > +	case DCD_ADD_CAPACITY:
> > +		rc = cxl_dax_region_add_extent(cxlr_dax, cxl_dr_ext);
> > +		break;
> 
> Early returns in here will perhaps make this more readable and definitely
> make it more compact.

Yep. done.

Thanks again for the review!
Ira

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 9B13CEB8FAD
	for <linux-cxl@archiver.kernel.org>; Wed,  6 Sep 2023 03:37:20 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S231299AbjIFDhW (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 5 Sep 2023 23:37:22 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:46406 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S229783AbjIFDhV (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 5 Sep 2023 23:37:21 -0400
Received: from mgamail.intel.com (mgamail.intel.com [134.134.136.20])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 4B73A128;
        Tue,  5 Sep 2023 20:37:15 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1693971435; x=1725507435;
  h=date:from:to:cc:subject:message-id:references:
   in-reply-to:mime-version;
  bh=BEhDvMys6aNAZ6aKLz07QUSQiYDm/jAne4aaaqGD91Y=;
  b=nH4/zuXbrgO9AqmdRc+vXvKeJDO+rGFG5ffO+lTwb/WnSma2aLIi8Mgj
   cImUIggJyi8bWRjFegYgnbkYOSgTmvYEwkoo96WUKPTY7RQBm4MqiP7GY
   1RrxsH1uagTrL+Vgzz8UGp5rInnGuj+Pp1RtZTrgDj1vnJiWLiUn54glc
   9d07ynyVEEou4+RpGD8DVLs+Wlz/b2Tr653eAY/QNSpw66qvu4y76QaQc
   kjiWGkWvzh7Rt5mux/+7H7cF4sJrKq5DBjRXy/zkoYavvYzzjhAW7f/OJ
   VU2cH3M45supmJrX+y08T5kryZ9A97l3tXav8+ocycVAT63aa9guyUFSx
   w==;
X-IronPort-AV: E=McAfee;i="6600,9927,10824"; a="367179210"
X-IronPort-AV: E=Sophos;i="6.02,231,1688454000"; 
   d="scan'208";a="367179210"
Received: from orsmga001.jf.intel.com ([10.7.209.18])
  by orsmga101.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 05 Sep 2023 20:37:14 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10824"; a="776430874"
X-IronPort-AV: E=Sophos;i="6.02,231,1688454000"; 
   d="scan'208";a="776430874"
Received: from orsmsx603.amr.corp.intel.com ([10.22.229.16])
  by orsmga001.jf.intel.com with ESMTP/TLS/AES256-GCM-SHA384; 05 Sep 2023 20:36:55 -0700
Received: from orsmsx610.amr.corp.intel.com (10.22.229.23) by
 ORSMSX603.amr.corp.intel.com (10.22.229.16) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27; Tue, 5 Sep 2023 20:36:55 -0700
Received: from orsmsx610.amr.corp.intel.com (10.22.229.23) by
 ORSMSX610.amr.corp.intel.com (10.22.229.23) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27; Tue, 5 Sep 2023 20:36:54 -0700
Received: from ORSEDG602.ED.cps.intel.com (10.7.248.7) by
 orsmsx610.amr.corp.intel.com (10.22.229.23) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27 via Frontend Transport; Tue, 5 Sep 2023 20:36:54 -0700
Received: from NAM11-BN8-obe.outbound.protection.outlook.com (104.47.58.168)
 by edgegateway.intel.com (134.134.137.103) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.27; Tue, 5 Sep 2023 20:36:54 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=QpOFCAIZJfypNgDAVCQLv85cxKfMQAZYAYXDhvaiaB6At0ng16iIarzFvI3VXSIcPMtV2GDNDzPtFJXpd7t0+t6LzD9Ixz+sA5mWRb+OjiwdohrdZLCgPcWfmfykI0KDrEx7Q3GXS0aCAEvkbkxQGeUMU/3DB7uni/ONkPqoU83nkYNwfTfYUi0tmdNIYFIfvqK1cxNfwPHmmSmwZrRnI6qZFB/shXSCxKFQFGzRZAxmPL/9gkWuEj+2xTT++ek+A5JsQopOPHd24b0OCGZDmvCvMVYQOA0LlUXPRuZA9ad33vNa/ThAkajz9f9GTX3OKp3GmSOrz3W/g23OyEfqlw==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=cpFirkmfqh/oZD25egw8vXlVk3DSYmyze2gSrqf/RzY=;
 b=eUU0tgypDdCXYkHC2t4XfcfiO159wog5D+Skgrox+Y8ikmhArciqIErQRa6aanF+IgEezrAtoOCdMC7ng62jOt+Uq6CAuIiCUd25JLpQfs/HULmZgJuUZBZB+weD9Nb7Y+p3fyPNrTH8/EI9DoVRAZXAmimBPaNvJV5WBFawjgwAmZb3jJRu1EQNG/kmyZ4QKt65lSrCftDf1PZFUIp+eULMeC+KC1uVTMIzNnoiNdWvcradk80qBUo1uInKyRvVqrokFigMXJGNZMrkPKCbZ8pE/F+ZXFc+hpPG5KF0b9UlzIIJDiNkk64oku9hBuVJt4+Mr7LdWRm/s/7C6QcigA==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from SA1PR11MB6733.namprd11.prod.outlook.com (2603:10b6:806:25c::17)
 by PH0PR11MB5048.namprd11.prod.outlook.com (2603:10b6:510:3d::14) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.6745.33; Wed, 6 Sep
 2023 03:36:52 +0000
Received: from SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938]) by SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938%6]) with mapi id 15.20.6745.030; Wed, 6 Sep 2023
 03:36:52 +0000
Date: Tue, 5 Sep 2023 20:36:47 -0700
From: Ira Weiny <ira.weiny@intel.com>
To: Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Ira Weiny <ira.weiny@intel.com>
CC: Dan Williams <dan.j.williams@intel.com>,
        Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
Subject: Re: [PATCH RFC v2 11/18] cxl/region: Expose DC extents on region
 driver load
Message-ID: <64f7f3cf14b0e_1e8e78294e8@iweiny-mobl.notmuch>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
 <20230604-dcd-type2-upstream-v2-11-f740c47e7916@intel.com>
 <20230829172048.000006fb@Huawei.com>
Content-Type: text/plain; charset="us-ascii"
Content-Disposition: inline
In-Reply-To: <20230829172048.000006fb@Huawei.com>
X-ClientProxiedBy: BY5PR03CA0002.namprd03.prod.outlook.com
 (2603:10b6:a03:1e0::12) To SA1PR11MB6733.namprd11.prod.outlook.com
 (2603:10b6:806:25c::17)
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: SA1PR11MB6733:EE_|PH0PR11MB5048:EE_
X-MS-Office365-Filtering-Correlation-Id: 796a443e-9e0d-431f-6dea-08dbae8a825d
X-LD-Processed: 46c98d88-e344-4ed4-8496-4ed7712e255d,ExtAddr
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;
X-Microsoft-Antispam-Message-Info: 0AEAvFqdndqTkde9K566F2Ep0/WTfV/Tem2/aKz1mHi2T/Owl25cvDHN4uB7Xy/yXnNW/k7fZTtgqJ0SbHUGVESDeqaifnp0XBviNDDg9/cvkbg6kyCg8crjuPfE5mTW+KV1A80ZxGg74Dp48VaXEkvcUtq8sdzGg2TEpDMz5QZh6uXlZLxBIULdWcWfmVYrhtMv39VUxnmY5vQ9lNyPthwzrIbto+fofr3c/YQcpn4H1uKtbIlX3cGBsbF0JRVI89dEe7gCUZSxQPUzQOf9pYxCBNwMQ19or2fsOAvyAijNoLeoAt/vSvNVm/vktwxJj1yujxytUwP+l+1yuzpXZDSibgowT6J+f7DSDx1vO9dPj2usmrOhBkrEMyMeoG8YI4lT+VDxdXHRxM0/vk2VzGsyXYukao52viIy1AvjaRI8EyM+m7Zy93IGscQHTIS66dMMdMkxMt16QEpQWqQHAyHw708VLqCm6/Hmki5FOC5RFg4ohagdRVc14HNyAc8GX/h78ODB3C2MBvr/CBn44bb0oGS8F216QphR4P5IXYS7KpvoHBKJtUAk3IHHoveP
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:SA1PR11MB6733.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230031)(396003)(346002)(366004)(376002)(39860400002)(136003)(186009)(1800799009)(451199024)(41300700001)(5660300002)(26005)(2906002)(86362001)(38100700002)(82960400001)(44832011)(8936002)(4326008)(8676002)(6666004)(6512007)(9686003)(6486002)(6506007)(478600001)(110136005)(316002)(66946007)(54906003)(66476007)(66556008);DIR:OUT;SFP:1102;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?us-ascii?Q?qDP+TbB6XlyKvvfmV29Vo82At7aRgL76Cst991zIpz8YFl8AiWKh0tOynJXl?=
 =?us-ascii?Q?pvzdm53l1jpkoGNfPTo8XfGBblsWa3vMV84mGCLV8mCl1M48cPSlEKPcQH2t?=
 =?us-ascii?Q?H7+9uxEWqNIlShDbMcXAEQIovM7ttOm3/dTSJRVBeiKbsqPWpEkOuZhy4X2R?=
 =?us-ascii?Q?BjmFamtN1namATl4cORP7YNtmVD/oTTOx30jAue6XunOHufm01Nqw/SRdffV?=
 =?us-ascii?Q?8xjK/zvDJ/9HGyYV3sHKFIYTttc48ItFGYy0VhCwqkyOps0MbHYB1c7hEu1c?=
 =?us-ascii?Q?fCEVlCRViO4JqUbmtT2HJvynMvqRvKw+F4qrT4dpsGHcKiRN4fynmlLQggOk?=
 =?us-ascii?Q?+46MDRd4NncMJu3lVQTxQ2CiDVP+FxA3pnzzISFVkJgnLiZM+yZnUhaaaaAC?=
 =?us-ascii?Q?z95W+nKlLEl0Uz7WFTF3FbaVa2kYSpms+poJqMrGdA3N+i8zB5G0JzeIMOso?=
 =?us-ascii?Q?8KIijSedvSTIcZu4QCzjKEfMzDKpQ+z+UzzrvRA5vcsTaweyVTuumX71//3K?=
 =?us-ascii?Q?1fHRCcOQ69MxZ7UAtZ1nT7Kf3oFhZ/vxN6oSJHLqnYhN95L3amn5lAX7hxOd?=
 =?us-ascii?Q?aiRX2AnY993Wuy0Ftt21ey5biID0G5ytcZB31kXVEHd9sHgk50CAOvbj759E?=
 =?us-ascii?Q?kfCpgrkR632+N5UJQrPD9WROmXBF4spNZ+OX3LMdgnDBhY3fWTaxK1LlQkLi?=
 =?us-ascii?Q?JKYFw3OGSCHXOUq3SfrYZKnhvoOZdGAgcIA/+VsHa1Y/fJ/pSyvrfqOAINLo?=
 =?us-ascii?Q?h4UNmX5dMgOyoWQSo/gqSN8uYnUGjqoKFY4T6u7OQPyN4VtsguVAjB1D/owo?=
 =?us-ascii?Q?/LHyYDhyYut2pjaS4oVDiKMKOGROHrZ7PCtL6cA1EIgmGoLUxWsDXtUvAVL1?=
 =?us-ascii?Q?pS5cZYaB0tUh8OyKYgO7+9+gO7OTYaUg3VAGgeiewAW5FO3nGS8kB6jhL0Wx?=
 =?us-ascii?Q?2jhTkGrmyFpaVo18URsVwQAP07iMtxUYXq/ALAWzkkEOwCkYgRvITcUwhQP6?=
 =?us-ascii?Q?FQYVaJxgjn9S0fnYRNtzZ4ryPAurRt+D3PAhTcrWtnJ3vNJqxCg0jk742pYG?=
 =?us-ascii?Q?m5Gz6ll1t0DDxR6fREMA6zbide1ss5ENtExV623hcq68Ni0Uuhk/tRYcr0Fv?=
 =?us-ascii?Q?NunqPbC74QV7t77GCXRinv4XXybfm+pl7cR/CsNjS3K+B+0dUGPiKE9UpKpF?=
 =?us-ascii?Q?GjKtGnMTWLthnG+igZvlWVqLUFBz3HsPatnLc0cxGeboqlK1TuNknXkR5ep5?=
 =?us-ascii?Q?hRiDXCTdelKLov4dvhi1sj3tA0jUhTUt/4eP7tDveNnuLtJ3wNLMIi+7Umxl?=
 =?us-ascii?Q?l130aF3ofZTFuDzrmk/YeNVBsvU0BXMOLTVfjXt+3abtdsX1VAiIUZZb6nae?=
 =?us-ascii?Q?jKdNj0iS1W2u564iUBzZnjVxK6yAtxkom+ig1h/hW7pnH4AFR2cvWIaesI7N?=
 =?us-ascii?Q?nOcQ/mwmigH0b1hVOLeJ89eTXWH4cgth0YOT4ct31J0G5LWzK+uoDrnE6l0y?=
 =?us-ascii?Q?eBhGk1xOX9tIN4ZV2rHWhmMUVCMY6ktM2awG3a4Xe4pcTiOKZBCPbPFhcgZb?=
 =?us-ascii?Q?5dh6ne7kRNtcRnUC75JN5x0MP4PSiBlRJQZQLSYr?=
X-MS-Exchange-CrossTenant-Network-Message-Id: 796a443e-9e0d-431f-6dea-08dbae8a825d
X-MS-Exchange-CrossTenant-AuthSource: SA1PR11MB6733.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 06 Sep 2023 03:36:52.1582
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: IOJ19PE9VKVVFaW73dc1oxSZpJa3iNeiGn00peSobETEHMVFiTJH+yehvdLFUDEhjEbAD6lrXMsNByULcL48Qg==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: PH0PR11MB5048
X-OriginatorOrg: intel.com
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

Jonathan Cameron wrote:
> On Mon, 28 Aug 2023 22:21:02 -0700
> Ira Weiny <ira.weiny@intel.com> wrote:
> 
> > Ultimately user space must associate Dynamic Capacity (DC) extents with
> > DAX devices.  Remember also that DCD extents may have been accepted
> > previous to regions being created and must have references held until
> > all higher level regions and DAX devices are done with the memory.
> > 
> > On CXL region driver load scan existing device extents and create CXL
> > DAX region extents as needed.
> > 
> > Create abstractions for the extents to be used in DAX region.  This
> > includes a generic interface to take proper references on the lower
> > level CXL region extents.
> > 
> > Also maintain separate objects for the DAX region extent device vs the
> > DAX region extent.  The DAX region extent device has a shorter life span
> > which corresponds to the removal of an extent while a DAX device is
> > still using it.  In this case an extent continues to exist whilst the
> > ability to create new DAX devices on that extent is prevented.
> > 
> > NOTE: Without interleaving; the device, CXL region, and DAX region
> > extents have a 1:1:1 relationship.  Future support for interleaving will
> > maintain a 1:N relationship between CXL region extents and the hardware
> > extents.
> > 
> > While the ability to create DAX devices on an extent exists; expose the
> > necessary details of DAX region extents by creating a device with the
> > following sysfs entries.
> > 
> > /sys/bus/cxl/devices/dax_regionX/extentY
> > /sys/bus/cxl/devices/dax_regionX/extentY/length
> > /sys/bus/cxl/devices/dax_regionX/extentY/label
> > 
> > Label is a rough analogy to the DC extent tag.  As such the DC extent
> > tag is used to initially populate the label.  However, the label is made
> > writeable so that it can be adjusted in the future when forming a DAX
> > device.
> > 
> > Signed-off-by: Navneet Singh <navneet.singh@intel.com>
> > Co-developed-by: Navneet Singh <navneet.singh@intel.com>
> > Signed-off-by: Ira Weiny <ira.weiny@intel.com>
> > 
> 
> Trivial stuff inline.
> 
> 
> 
> > diff --git a/drivers/dax/dax-private.h b/drivers/dax/dax-private.h
> > index 27cf2daaaa79..4dab52496c3f 100644
> > --- a/drivers/dax/dax-private.h
> > +++ b/drivers/dax/dax-private.h
> > @@ -5,6 +5,7 @@
> >  #ifndef __DAX_PRIVATE_H__
> >  #define __DAX_PRIVATE_H__
> >  
> > +#include <linux/pgtable.h>
> >  #include <linux/device.h>
> >  #include <linux/cdev.h>
> >  #include <linux/idr.h>
> > @@ -40,6 +41,58 @@ struct dax_region {
> >  	struct device *youngest;
> >  };
> >  
> > +/*
> /**
> 
> as it's valid kernel doc so no disadvantage really.

Sure. Done.

> 
> > + * struct dax_region_extent - extent data defined by the low level region
> > + * driver.
> > + * @private_data: lower level region driver data
> > + * @ref: track number of dax devices which are using this extent
> > + * @get: get reference to low level data
> > + * @put: put reference to low level data
> 
> I'd like to understand when these are optional - perhaps comment on that?

They are not optional in this implementation.  I got a bit carried away in
extrapolating the dax_region away from the lower levels in thinking that
some other implementation may not need these.

I will still keep the helpers below though.

> 
> > + */
> > +struct dax_region_extent {
> > +	void *private_data;
> > +	struct kref ref;
> > +	void (*get)(struct dax_region_extent *dr_extent);
> > +	void (*put)(struct dax_region_extent *dr_extent);
> > +};
> > +
> > +static inline void dr_extent_get(struct dax_region_extent *dr_extent)
> > +{
> > +	if (dr_extent->get)
> > +		dr_extent->get(dr_extent);
> > +}
> > +
> > +static inline void dr_extent_put(struct dax_region_extent *dr_extent)
> > +{
> > +	if (dr_extent->put)
> > +		dr_extent->put(dr_extent);
> > +}
> > +
> > +#define DAX_EXTENT_LABEL_LEN 64
> 
> blank line here.

Sure.  Done

Ira

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id F27B6CCF9E9
	for <linux-cxl@archiver.kernel.org>; Tue,  5 Sep 2023 23:49:39 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S235230AbjIEXtl (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 5 Sep 2023 19:49:41 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:53530 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S229999AbjIEXtj (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 5 Sep 2023 19:49:39 -0400
Received: from mgamail.intel.com (mgamail.intel.com [192.55.52.93])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 6D1971BE;
        Tue,  5 Sep 2023 16:49:35 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1693957775; x=1725493775;
  h=date:from:to:cc:subject:message-id:references:
   in-reply-to:mime-version;
  bh=NP5G6QvC2pGeBXcNJgadWRBzt0MIOFwOlugbqf1icZQ=;
  b=dhmabb7FS0lWSX2X5yibYG8/V8NF7BVIZ7BNXH4OGAdysVLH4GgCpNvi
   7XLFtmm6a6M1Tn2mFUciN4toS4QWHfi5GahWEDfIISgfXGdPz5uatrl+z
   96vnJqQTZXIqKubh2yFB5XDf627LeQhilqQwxEyG7i4/jG1cKvEWwdWuH
   iTt0QsdvxabBFjmMqexyX4+GnicfxxvQs+ed338cbIrFOaVCdiSpQEfCS
   BzDTpQ3ObHu/qOywZ4S757vzW0stwG/J0yLA0BEpxlXEoxzT+P8zbCK3C
   XMj1J2z4WYSmsukkDx3Zme9pFhqKy8ebHgUKN6zwK1OG4VcDRwb2KIlgK
   Q==;
X-IronPort-AV: E=McAfee;i="6600,9927,10824"; a="374321738"
X-IronPort-AV: E=Sophos;i="6.02,230,1688454000"; 
   d="scan'208";a="374321738"
Received: from fmsmga008.fm.intel.com ([10.253.24.58])
  by fmsmga102.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 05 Sep 2023 16:49:35 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10824"; a="806801362"
X-IronPort-AV: E=Sophos;i="6.02,230,1688454000"; 
   d="scan'208";a="806801362"
Received: from orsmsx601.amr.corp.intel.com ([10.22.229.14])
  by fmsmga008.fm.intel.com with ESMTP/TLS/AES256-GCM-SHA384; 05 Sep 2023 16:49:34 -0700
Received: from orsmsx611.amr.corp.intel.com (10.22.229.24) by
 ORSMSX601.amr.corp.intel.com (10.22.229.14) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27; Tue, 5 Sep 2023 16:49:34 -0700
Received: from orsmsx610.amr.corp.intel.com (10.22.229.23) by
 ORSMSX611.amr.corp.intel.com (10.22.229.24) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27; Tue, 5 Sep 2023 16:49:33 -0700
Received: from orsedg603.ED.cps.intel.com (10.7.248.4) by
 orsmsx610.amr.corp.intel.com (10.22.229.23) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27 via Frontend Transport; Tue, 5 Sep 2023 16:49:33 -0700
Received: from NAM11-DM6-obe.outbound.protection.outlook.com (104.47.57.172)
 by edgegateway.intel.com (134.134.137.100) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.27; Tue, 5 Sep 2023 16:49:33 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=jK2dp3LPNVIFbPcQiEl7phcvAvOnzJcKh+ufBAOiUM/JvDO2rMwlQC5O/4BMHcIEpmSXa1lGoxX/vAdSJoY6H85oGWukOxi2CsjX0P0btj2kQOvHzpGn7GkzfVD7nXY7WB5/B/Ncjan5U56o3hSTHDT9m1HEookalWZQFLqUBI7pTaq9rhrAfFXWwvhv6KNqxr/0L3mM6J3pjsciJugkjIErGjf0MvxD7udV3KZdl9eOfu2mr3gnEs3tHtASgGAVXEVUDjtv75iuZIQ+BF11tL8+0uTTsgJkMcWDL/PqsiwwdrtwbtIkFLLwh/vGDypPrhQr/1/ZpON4rJkH3nsWiQ==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=bpWJg4CccjlexYRJPh8z4RG27Q+nnfX7hZDIYgw17tY=;
 b=iEkLQBN9TGksvJJ5fxVZR5TsXJtuRZxkhbnYzIxfyt0obLgGxLp/6OuALPadQSo9E2gMWThSZ6ZUvNVwvJoEA7P40RzvNxY3V6eR62WQHFbxIgoi/SqCzYNXy7ZXPjfJpSplzRVPLSMpKfkcn/0ZnjFLrlO91SZ+37WKiTekJzwTh8e0Kg/dMW2TIxUvf/uRSTI4zj9VB8FS+Lt2Y9D4XAFGGyqKNDOO9CjelFqC7OPSzO7h80UyBgDFPvvLFGTDbhEtynQ5GrV3YZMGJ4+CT2KZNwUEtg4wzof9ehHlLkonKHB1li34jfrRIz1REWn3MuJCVKuCyhJM9xNK1rjnNw==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from SA1PR11MB6733.namprd11.prod.outlook.com (2603:10b6:806:25c::17)
 by SN7PR11MB8281.namprd11.prod.outlook.com (2603:10b6:806:26b::20) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.6745.33; Tue, 5 Sep
 2023 23:49:30 +0000
Received: from SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938]) by SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938%6]) with mapi id 15.20.6745.030; Tue, 5 Sep 2023
 23:49:30 +0000
Date: Tue, 5 Sep 2023 16:49:25 -0700
From: Ira Weiny <ira.weiny@intel.com>
To: Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Ira Weiny <ira.weiny@intel.com>
CC: Dan Williams <dan.j.williams@intel.com>,
        Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
Subject: Re: [PATCH RFC v2 10/18] cxl/mem: Handle DCD add and release
 capacity events.
Message-ID: <64f7be8553587_1e8e782946e@iweiny-mobl.notmuch>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
 <20230604-dcd-type2-upstream-v2-10-f740c47e7916@intel.com>
 <20230829165930.0000208c@Huawei.com>
Content-Type: text/plain; charset="us-ascii"
Content-Disposition: inline
In-Reply-To: <20230829165930.0000208c@Huawei.com>
X-ClientProxiedBy: BYAPR05CA0045.namprd05.prod.outlook.com
 (2603:10b6:a03:74::22) To SA1PR11MB6733.namprd11.prod.outlook.com
 (2603:10b6:806:25c::17)
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: SA1PR11MB6733:EE_|SN7PR11MB8281:EE_
X-MS-Office365-Filtering-Correlation-Id: 3dc2e0c0-668b-465a-e8e2-08dbae6abf79
X-LD-Processed: 46c98d88-e344-4ed4-8496-4ed7712e255d,ExtAddr
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;
X-Microsoft-Antispam-Message-Info: Rn0ie0sVqFp4Vqom3hvGJH0uCPshnfHozfcmDaXs1Sfe6eg7pIgKA3XeeOryRzjIE1fahH/7stWSPsVfDfrScARAf6cHxmc0cz+4urnQSSakb+f/6TKb2z0SZ/JvqzxKvYgTh7hPpTr1XjuQy3NHIfLAIAMNfc6IXi71GUxFlF7WJJPfAWbNxffj8pb1GeWDR/phXPoh0VObFAUGqRGd9HuOt7kS3j1jTUjA65V2RgsXMLJAummvtJE3evjeDLskNtZxo1qULNEtcA/xUmpSvN9EJGUzFPG9iUXLVG/PgqzpEPlh4O6UJzHNvdkxq+PcafBx71+FmCoKgibqawWYypFj8NLY5cgINTlB9hz4Drk+WkRO0/ZeTTWyw11RN7kiBQ9DTnBakUpgfnsxOLU07Z5yYh35fhrR3ioiSVw63M2lP4FlYurHYOffpDLD6yTcmnS7gyhzOXf4EpWx0/8Azyzr9CWb+FWElToQllxo22Upu1zjRO7BmoSMaksnDtJ9l+E8KLieLcPuOkuYQ81s7jKvca/m0QpYFY7CzaZhWZtbA4ymkeXTbdgJEjjdzAaK
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:SA1PR11MB6733.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230031)(366004)(39860400002)(136003)(376002)(396003)(346002)(1800799009)(186009)(451199024)(83380400001)(26005)(2906002)(8936002)(8676002)(478600001)(82960400001)(4326008)(5660300002)(44832011)(41300700001)(6666004)(316002)(86362001)(110136005)(54906003)(66476007)(66556008)(66946007)(6512007)(9686003)(6506007)(38100700002)(6486002);DIR:OUT;SFP:1102;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?us-ascii?Q?hSwNgVHcgaNOFPPPhfQHVcCD9Kf47AhGo2UTfyG91gDV+CYqRrnWGjcmJc3Z?=
 =?us-ascii?Q?H3mMSnO9vw+ig7CefuxLjedvS98Jhdp9EXMcCDwRTiZfC7BvVmF/0SYpMTxX?=
 =?us-ascii?Q?j6nKHVQcIBxwEUbcGrD5yjAyktZxY0Uu6GxfMoGOOBhI7fOfWq6RGY/6+xpK?=
 =?us-ascii?Q?LBAD4XkgvJUhmDMQ9OofcMMcJm/RfuE80bdgxxtRSFhb73iu6TdAiYEHfsUo?=
 =?us-ascii?Q?Nh7wwKvySgEv64S3pf0LYR2VzzbbxE+oQPA97S+KieqtwuBSYWwRjjkr5U56?=
 =?us-ascii?Q?xzD+fdqzERdtgpNz/4yMGvaC63NPuLrviS49pXlbhv1nXi3isB33NKtU/ZE+?=
 =?us-ascii?Q?GTlgvJzfNfbdXDG0RJoTad2lwtuYQVknfO/YBuEh01b6mmRxG74WhBRW+vy+?=
 =?us-ascii?Q?cTmfl9tCLIkU9BJlp0k46yOA0EfuUG9MQiutrvksdqxeOw/i96uM2yN46BKb?=
 =?us-ascii?Q?KgesxkR1MOcmmer4gd5gbXgrgcjisJYVErk2hMQ1IbPyg5wNt1GZbbPgeAcI?=
 =?us-ascii?Q?BGNkmPULcPX8ayWT+TnvB9GqGYGAGKxwCoHfnAYC2Bkfh7kU4bTbpSy9mWDz?=
 =?us-ascii?Q?usU6mS8Ur5piQOofjwklk/Lk1wFCn1LrNndSonLSMhLcXQamT0wLT8OJS5kc?=
 =?us-ascii?Q?BdA5U730JkSo1T7bsLBy5DHHMdd+v59+j0+mT2uKV3x2R8H+OxSNtL+luAoH?=
 =?us-ascii?Q?BDXl5XCnYhCzccC+fPGsVqJaCRgcYMeTti+x2YuE8HR0W0sc5CFNTPIiPzNY?=
 =?us-ascii?Q?rXgya6ALoQmc8yb6gCEN/LEZwPO62T3HNaSI8lJrgcMLszY4SfxDsW1hIBSz?=
 =?us-ascii?Q?o41/9aCWAzujLepbgYiu09zYy98H7v2RviyPxvcIu9ClPCGcWFfX0XxVgb2d?=
 =?us-ascii?Q?V+lO+4JNPnOqYwryXS4ad+pGy9hVahBoQsOJ5iag+IXODv8z/DExbXDa84cd?=
 =?us-ascii?Q?5mYxH6gT971LUx5eMM1TklV/dkMrgfd3J13IhZe0vuAlTN974PjyaWVWJlFk?=
 =?us-ascii?Q?bssdZHjoNh9CWobXmc2Rz6CQmM/s/L6/jddxxi6Vatjjj3ona8BH6ggKhEpD?=
 =?us-ascii?Q?l/9fA+21Cv0p/kACt+FTSgK0yFQq7FRIoLNzM81eXBKiqT22o7HhYY5OFazp?=
 =?us-ascii?Q?pNAIOza70WjnwQPHVUe2MYQoRu0Cl6bdAeEL5VMSu2uPpuW2YpaTjuqF8uWJ?=
 =?us-ascii?Q?i5Y6kQm9pmxHk+RVqUyYfnNBS9pkuox6FNFSwLEzoSMavv3C3qL2PfHQzfsw?=
 =?us-ascii?Q?IzG7KpPxgQyfMQAgUnzwWOzr5HjJVZOrKtwd5ooUnki3wIdBVUxlU607AWbz?=
 =?us-ascii?Q?+q8EgyX+fWg1ORJdMEBcdBGI8kaBHmgiq/XJNP3/fJ74LY99+reTG1op8n6p?=
 =?us-ascii?Q?J1M1WJUM4DlIcBdUntSLRq/x3gb67ZI38krhfhSbw5xSgsf/frtP9aTOmKwL?=
 =?us-ascii?Q?WHfs31aYd3BJIVxagaX4sr6kykDUqFODrNgTjtEow5FLrEMSdy05WqTuCXx8?=
 =?us-ascii?Q?deiicosLr7cQzgsLogMMFOdHF5morQCJFL/f6zBQHnFKAhlRm1HCtXEup3lf?=
 =?us-ascii?Q?9UhAgxQpTltooUoBVLMs7oLW7opAyc0yP+oAh4hu?=
X-MS-Exchange-CrossTenant-Network-Message-Id: 3dc2e0c0-668b-465a-e8e2-08dbae6abf79
X-MS-Exchange-CrossTenant-AuthSource: SA1PR11MB6733.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 05 Sep 2023 23:49:30.7395
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: PQc0QHWd9HZPH95jby7ZhsMkogqoq7Dq1IxnJSBhvN8IyMpIlVU1WWLRCJQ9+nk2lnix5aguSCH94Nglg4u0cw==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: SN7PR11MB8281
X-OriginatorOrg: intel.com
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

Jonathan Cameron wrote:
> On Mon, 28 Aug 2023 22:21:01 -0700
> Ira Weiny <ira.weiny@intel.com> wrote:
> 
> > A Dynamic Capacity Device (DCD) utilizes events to signal the host about
> > the changes to the allocation of Dynamic Capacity (DC) extents. The
> > device communicates the state of DC extents through an extent list that
> > describes the starting DPA, length, and meta data of the blocks the host
> > can access.
> > 
> > Process the dynamic capacity add and release events.  The addition or
> > removal of extents can occur at any time.  Adding asynchronous memory is
> > straight forward.  Also remember the host is under no obligation to
> > respond to a release event until it is done with the memory.  Introduce
> > extent kref's to handle the delay of extent release.
> > 
> > In the case of a force removal, access to the memory will fail and may
> > cause a crash.  However, the extent tracking object is preserved for the
> > region to safely tear down as long as the memory is not accessed.
> > 
> > Signed-off-by: Navneet Singh <navneet.singh@intel.com>
> > Co-developed-by: Ira Weiny <ira.weiny@intel.com>
> > Signed-off-by: Ira Weiny <ira.weiny@intel.com>
> Minor stuff inline.
> 
> 
> > +static int cxl_prepare_ext_list(struct cxl_mbox_dc_response **res,
> > +				int *n, struct range *extent)
> > +{
> > +	struct cxl_mbox_dc_response *dc_res;
> > +	unsigned int size;
> > +
> > +	if (!extent)
> > +		size = struct_size(dc_res, extent_list, 0);
> 
> This is confusing as if you did have *n > 0 I'd kind of expect
> this to just not extend the list rather than shortening it.
> Now I guess that never happens, but locally it looks odd.
> 
> Maybe just handle that case in a separate function as it doesn't
> share much code with the case where there is an extent and I would
> assume we always know at the caller which one we want.

Yea I forget why I left this alone.  I did not care for it during internal
review and I think I got so busy with the other code that this just got
left behind.

Frankly this is a candidate for the __free() magic as well.  But in a
helper function which handles sending the response...

This needs some refactoring for sure...  :-/

> 
> 
> > +	else
> > +		size = struct_size(dc_res, extent_list, *n + 1);
> 
> Might be clearer with a local variable for the number of extents.
> 
> extents_count = *n;
> 
> if (extent)
> 	extents_count++;
> 
> size = struct_size(dc_res, extent_list, extents_count);
> 
> Though I'm not sure that really helps.  Maybe this will just need
> to be a little confusing :)

Actually no.  IIRC the original idea was to have a running response data
structure realloc'ed as events were processed from the log and then to
send out a final large response...  But in my refactoring I did not do
that.  The refactoring processes each event (extent) before going on to
the next event.  I suppose this may be an issue later if large numbers
of extents are added to the logs rapidly and the processing is not fast
enough and the logs overflow.

But I don't think the complexity is warranted at this time.  Especially
because under that condition the size of the response needs to be
contained within mds->payload_size.  So there is quite a bit more
complexity there that I don't think was accounted for initially.

I think cxl_send_dc_cap_response() should handle this allocation (using
__free() magic) and then do the send all in 1 function.

I'll refactor and see how it goes.

> 
> > +
> > +	dc_res = krealloc(*res, size, GFP_KERNEL);
> > +	if (!dc_res)
> > +		return -ENOMEM;
> > +
> > +	if (extent) {
> > +		dc_res->extent_list[*n].dpa_start = cpu_to_le64(extent->start);
> > +		memset(dc_res->extent_list[*n].reserved, 0, 8);
> > +		dc_res->extent_list[*n].length = cpu_to_le64(range_len(extent));
> > +		(*n)++;
> > +	}
> > +
> > +	*res = dc_res;
> > +	return 0;
> > +}
> 
> > +
> > +/* Returns 0 if the event was handled successfully. */
> > +static int cxl_handle_dcd_event_records(struct cxl_memdev_state *mds,
> > +					struct cxl_event_record_raw *rec)
> > +{
> > +	struct dcd_event_dyn_cap *record = (struct dcd_event_dyn_cap *)rec;
> > +	uuid_t *id = &rec->hdr.id;
> > +	int rc;
> > +
> > +	if (!uuid_equal(id, &dc_event_uuid))
> > +		return -EINVAL;
> > +
> > +	switch (record->data.event_type) {
> > +	case DCD_ADD_CAPACITY:
> > +		rc = cxl_handle_dcd_add_event(mds, &record->data.extent);
> > +		break;
> 
> I guess it might not be consistent with local style...
> 		return cxl_handle_dcd_add_event()  etc

Sure.  That is cleaner.  Done.

Ira

> 
> > +	case DCD_RELEASE_CAPACITY:
> > +        case DCD_FORCED_CAPACITY_RELEASE:
> > +		rc = cxl_handle_dcd_release_event(mds, &record->data.extent);
> > +		break;
> > +	default:
> > +		return -EINVAL;
> > +	}
> > +
> > +	return rc;
> > +}
> > +
> 
> 



From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 890BECA100D
	for <linux-cxl@archiver.kernel.org>; Tue,  5 Sep 2023 21:43:57 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S244489AbjIEVn6 (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 5 Sep 2023 17:43:58 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:46872 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S244176AbjIEVnz (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 5 Sep 2023 17:43:55 -0400
Received: from mgamail.intel.com (mgamail.intel.com [192.55.52.115])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 4F416CEA;
        Tue,  5 Sep 2023 14:43:05 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1693950185; x=1725486185;
  h=date:from:to:cc:subject:message-id:references:
   in-reply-to:mime-version;
  bh=KoYZbbY5D8/eTzliWOMmIAXkXXl+PXE3mcrXCjQyE/0=;
  b=H64nKdxzkWhX/OSThWz4kbjPQ0gfwCkqBpWQ6q77HdYNSksjl89aBd8Z
   tsEPIe3S4/JgpG4xdlrrk5m8z5rOlOX8oDuafAs7hVwPO3qqvnZz5ekHh
   tBoTNnyK4HtQjB/bBPjk760x+bIX9X/WJkmcm/YYI/r5YrD7vSd3F93Ik
   PhX5gJeBaj4Sgw2s+LeWEbYiRreuGsMpqFX/5AgT2v79kJZsY3wDnCHc0
   vwFjlHrZZ8OS7qbuy2vRJuIsajK+GkJypfzB+EG4ZDaFlkBoqpHCF0QAT
   8uN+cM8jYfgFk/qhaD0iZ53XO1iEc22pRrMd3CD1QSLbAo/MTHf9wkSa0
   Q==;
X-IronPort-AV: E=McAfee;i="6600,9927,10824"; a="376827966"
X-IronPort-AV: E=Sophos;i="6.02,230,1688454000"; 
   d="scan'208";a="376827966"
Received: from orsmga008.jf.intel.com ([10.7.209.65])
  by fmsmga103.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 05 Sep 2023 14:41:24 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10824"; a="770489430"
X-IronPort-AV: E=Sophos;i="6.02,230,1688454000"; 
   d="scan'208";a="770489430"
Received: from orsmsx603.amr.corp.intel.com ([10.22.229.16])
  by orsmga008.jf.intel.com with ESMTP/TLS/AES256-GCM-SHA384; 05 Sep 2023 14:41:24 -0700
Received: from orsmsx610.amr.corp.intel.com (10.22.229.23) by
 ORSMSX603.amr.corp.intel.com (10.22.229.16) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27; Tue, 5 Sep 2023 14:41:23 -0700
Received: from orsedg603.ED.cps.intel.com (10.7.248.4) by
 orsmsx610.amr.corp.intel.com (10.22.229.23) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27 via Frontend Transport; Tue, 5 Sep 2023 14:41:17 -0700
Received: from NAM11-DM6-obe.outbound.protection.outlook.com (104.47.57.176)
 by edgegateway.intel.com (134.134.137.100) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.27; Tue, 5 Sep 2023 14:41:17 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=Wz5clSfiQNu6g4OXr4gSppOnD+l6Mj1O+JvQ4QD32Ifm+v0AjpCXH3vXUSG4ome9moBNy85sLBAXyQRYRIn0jfSX88g178x4vmKZc1MMJsdjUD3Zy1enPmIokNCktp+mEBlkUVOanhoX2ylfzh31zqLXgvc3i36txH1l4VSNXy/6GNqzAz1EWR2WikqgHx411mds4O9urSm4+bkgJt2/7ccCvsD8EkNWantjY40Y4vJjRl7odevkk0FgMMha1H6KxEPUK7PPP/cOaRIjTIfCyr2wVBFH4rzyMH/lo3gZwNKg0x2gE6RjDQQmFrjOTgljsknHDCWKaYOtFIkXsgnhJA==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=hX+h0qQ0QgcUXitSrOWz330Nl1GJkS5jrNolJXveXJg=;
 b=k8CkUHIGnTWZetaaA6QuQZ4iV+8H0QP859t1r+SSUnvG/Y6ZxwZJWwYxcVTAZNAHkMycKRqGObsxHZnZ0P6LPjohBfM2wp2DqgsorImD63EYpCef3EFYuYgTccwIGS811m7jKXIZ4I66QaUo4vJO0A4O5ZOB8oq2QzTKmY+k8bcMYSTlC5Z6D83wQdRtzd8Q4gjlxHg8uCw10QemOi/N5so0K2IV7V+nRZLqB+xdmZP1aZxyB0MGnrlbAuVJ9MsyIUCwstgoPZd2/Uzwz6y23Z4o7Isbgrhum2Mf+TgGCBJK63a1s024qvcd/RllKyUh7c6gufILTDmMjOT+fzU26Q==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from SA1PR11MB6733.namprd11.prod.outlook.com (2603:10b6:806:25c::17)
 by DM4PR11MB8226.namprd11.prod.outlook.com (2603:10b6:8:182::12) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.6745.33; Tue, 5 Sep
 2023 21:41:15 +0000
Received: from SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938]) by SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938%6]) with mapi id 15.20.6745.030; Tue, 5 Sep 2023
 21:41:15 +0000
Date: Tue, 5 Sep 2023 14:41:12 -0700
From: Ira Weiny <ira.weiny@intel.com>
To: Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Ira Weiny <ira.weiny@intel.com>
CC: Dan Williams <dan.j.williams@intel.com>,
        Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
Subject: Re: [PATCH RFC v2 09/18] cxl/mem: Read extents on memory device
 discovery
Message-ID: <64f7a078298ec_1e8e7829471@iweiny-mobl.notmuch>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
 <20230604-dcd-type2-upstream-v2-9-f740c47e7916@intel.com>
 <20230829162600.00004ac2@Huawei.com>
Content-Type: text/plain; charset="us-ascii"
Content-Disposition: inline
In-Reply-To: <20230829162600.00004ac2@Huawei.com>
X-ClientProxiedBy: BYAPR07CA0100.namprd07.prod.outlook.com
 (2603:10b6:a03:12b::41) To SA1PR11MB6733.namprd11.prod.outlook.com
 (2603:10b6:806:25c::17)
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: SA1PR11MB6733:EE_|DM4PR11MB8226:EE_
X-MS-Office365-Filtering-Correlation-Id: 1811146e-8d6b-4f71-2fa4-08dbae58d49f
X-LD-Processed: 46c98d88-e344-4ed4-8496-4ed7712e255d,ExtAddr
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;
X-Microsoft-Antispam-Message-Info: XKLq8sYuLVysrp6i1IRG1ikbyJqU8Yr9VuzGg/yQcfSG/+xMu1WiObH7E3uGo9QS+oLzSqN9kwSazXytTFmzrorEyfTxvcMB9/LUPXDI0RvrpBWaXX458wFZBYBU4XHwld1FBfSM/UXMmzsWCjmXVtcAdb//CuvYTSRBJyGH1IHQB9ox0UJfq16zVNy9bSq/U6PPxpl1m6+1koRpZP5ncdCLme1b8RHw1hIvuCv/qS38bl6lGi2MOjQtMEvbYwauvcSj2pP2q0gMbMXv2gyP5RuTF3hBPvEeFj6ElDKe2QO+3Igx533ttCLVheTk2NTjyjPqIwrn5YD83t56trmj0B6CMiYb194lf4Q2LVilHL5fmPqv8U112fLC0+yKmtynoKTK244q4S0XJSPQ4o7PAkuzgJLnbgcmmqdDcrd+Tc2kYz+TKuRxCP4jIptdHB94qw5UBaxitsI6C8sOf3qB8wtXZPin1jaU+w6gV4DWUx0Un+nyFKfsa5pdt1E6MjAFLXA/ocD/PP8UCsjikfO43tgwOGR/dv+jHQqDTVNfyb628Ew7rcVbpqsgHUKJIo58
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:SA1PR11MB6733.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230031)(136003)(396003)(346002)(366004)(376002)(39860400002)(451199024)(1800799009)(186009)(6486002)(6512007)(9686003)(6666004)(6506007)(82960400001)(38100700002)(86362001)(2906002)(26005)(110136005)(478600001)(66946007)(5660300002)(8936002)(44832011)(4326008)(8676002)(66476007)(316002)(41300700001)(54906003)(66556008);DIR:OUT;SFP:1102;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?us-ascii?Q?4aX+hMQpOHcIEDJF7TLBKO/FYKkxCaKJyMKJd+KFmiqBYjTFYI54vR5wFeFs?=
 =?us-ascii?Q?dbt0E4VpbnnJ+V0tq5WhHjRnmOxZqHoqpB8kYnBn5OrdEncn6Ln17RNaHXug?=
 =?us-ascii?Q?8bLx+EjK5KUTv4/6OIeUchGsYKnUE6aYWI34si7TZ9m6rl7Ae+081kV0kT8N?=
 =?us-ascii?Q?b9wDu2RYqe0rXP7P0yszznXCgqdEIsAorvwg4ZcptCtU3ZrfTibwYfywwkh8?=
 =?us-ascii?Q?UKPgybFIKXBDW6S9D/nzZcz77OX7wCVz2pxOMvMzZDqUlLLR89q4bTzkw7uu?=
 =?us-ascii?Q?GFvG2nCzFHsuvsq+OsBjlIBmajE7oMdvehhOJJc/teuEsp+zuFc4BWiqFr9B?=
 =?us-ascii?Q?skqpIGftHzAX3xrZtYjq9YMOHj/r1DYObiFdjJpB9L8SMtBKWit7Vw9LyX1e?=
 =?us-ascii?Q?a4xGnuOh4PpIyWSThuUC9ehTjpWj8mEU9YY2fwgfHNGPr4iJ+77o7gk4iZif?=
 =?us-ascii?Q?WHjFBniCqkBgAVErY2wdt2a8pH0y2/vMLg45b3on8hKm67H8ygAV32gwiFuC?=
 =?us-ascii?Q?oPTJRyrr+MMHxzguCCexmHX1AmT2NG01iEJrJpQKJBuGF10S3uYHpK5PlBoN?=
 =?us-ascii?Q?S4XbffKG5+teU2dXM5jVAgwd2IZ+VMZLrqbqJq5S9+rMzDjSZxfAbeQt5xlV?=
 =?us-ascii?Q?nbjwT1FjKaWeB6cj/6oGOmvT2OGp+ETa2BNn2ywaU0vsbCymZdmGWCcZe48M?=
 =?us-ascii?Q?X/NjuysG1hSddGfBtn4aECmwZHReEH+MXbisWjdERy9NxtQ5l/h7xhXZJQi5?=
 =?us-ascii?Q?nFNEywF1aZmi3izAVzt07/30/5PTq5BKyRdI/2Q7BTeqFeHTdgrbU6TtT8sP?=
 =?us-ascii?Q?sTOUFc3uCinuX17H8Tpo4Te8ixb8On+n3Ud1/Bkr7cQkrw/4/OdNYy4hNUNZ?=
 =?us-ascii?Q?kHbJ61yO+W7/Z9btK3Wdgvchm82lb0ULwU4TZRMOcrtwc5LxwdlO3WCwISp5?=
 =?us-ascii?Q?Ldtre6DvXX7qadFDJxNPGPJBTrEuK/fAw0Iv1nbLgp9OaaJRPUPKKHuXqbCU?=
 =?us-ascii?Q?HXn0ZlItrPhb0uxi5qbgYZ3fapLoH+tilWNQszZJl3apR393vSqHUtG9I0Mk?=
 =?us-ascii?Q?r5DilEH75Q4UrVUWpknpPZ7cMxiswPtkqLTg7iT9s0iMREQl+VDNstNjD4d7?=
 =?us-ascii?Q?M3PvZGUX4oCwZ2zpxfXEu1O7l1tERCsf/pb2Tqn3zqT/ZvlVYnaizMH/zviB?=
 =?us-ascii?Q?036I2KqFieP9XZVHNNPODa07UukUftRxZ6ZZawLmh9WgT7s1eJ5ML156Uk81?=
 =?us-ascii?Q?wVxJH/xoa8Rw6gMJH+E0EVQKuWfUHXwnL9ZzMlrih8aZwpqK3O0qGeOWLfAL?=
 =?us-ascii?Q?YtyEob4eOHUxxyZj/IT965T0GNpjCaieTIbKg+yidO4vDf5AAHvwXsAEpH6z?=
 =?us-ascii?Q?1kpxsnzLNKXjZ3/qY5bczrU0nm8CDWg7fJ2AlAflF8DKkHxXWS5wU4S8ILHe?=
 =?us-ascii?Q?Cg6lH2+YUWE5mvksf5GEKTZwf1FsMoK84EU0t8tr0UKxIRTQVSL78ibXwXRc?=
 =?us-ascii?Q?yMpGIpOoVPEwXAAuLO3nn2JsNSQM7jX8uJVZcdX6L8mzF4Jk4vNO5ZVRs6wl?=
 =?us-ascii?Q?CbMeu37ipRUZod4/s/8GtrVOcdLFL2o562S71z6s?=
X-MS-Exchange-CrossTenant-Network-Message-Id: 1811146e-8d6b-4f71-2fa4-08dbae58d49f
X-MS-Exchange-CrossTenant-AuthSource: SA1PR11MB6733.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 05 Sep 2023 21:41:15.2997
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: VhXszqwxXJitM6B/FmCGCvgcVF0LE5KKsXhu7DO/roYvhu7lYKTYv/pjJr2w06iooIN8E/BDQmF2EBFipuMCcA==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: DM4PR11MB8226
X-OriginatorOrg: intel.com
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

Jonathan Cameron wrote:
> On Mon, 28 Aug 2023 22:21:00 -0700
> Ira Weiny <ira.weiny@intel.com> wrote:
> 
> > When a Dynamic Capacity Device (DCD) is realized some extents may
> > already be available within the DC Regions.  This can happen if the host
> > has accepted extents and been rebooted or any other time the host driver
> > software has become out of sync with the device hardware.
> > 
> > Read the available extents during probe and store them for later
> > use.
> > 
> > Signed-off-by: Navneet Singh <navneet.singh@intel.com>
> > Co-developed-by: Navneet Singh <navneet.singh@intel.com>
> > Signed-off-by: Ira Weiny <ira.weiny@intel.com>
> > 
> A few minor comments inline.
> 
> Thanks,
> 
> Jonathan
> 

[snip]

> 
> > +static int cxl_dev_get_dc_extent_cnt(struct cxl_memdev_state *mds,
> > +				     unsigned int *extent_gen_num)
> > +{
> > +	struct cxl_mbox_get_dc_extent get_dc_extent;
> > +	struct cxl_mbox_dc_extents dc_extents;
> > +	struct device *dev = mds->cxlds.dev;
> > +	struct cxl_mbox_cmd mbox_cmd;
> > +	unsigned int count;
> > +	int rc;
> > +
> > +	/* Check GET_DC_EXTENT_LIST is supported by device */
> > +	if (!test_bit(CXL_DCD_ENABLED_GET_EXTENT_LIST, mds->dcd_cmds)) {
> > +		dev_dbg(dev, "unsupported cmd : get dyn cap extent list\n");
> > +		return 0;
> > +	}
> > +
> > +	get_dc_extent = (struct cxl_mbox_get_dc_extent) {
> > +		.extent_cnt = cpu_to_le32(0),
> > +		.start_extent_index = cpu_to_le32(0),
> > +	};
> > +
> > +	mbox_cmd = (struct cxl_mbox_cmd) {
> > +		.opcode = CXL_MBOX_OP_GET_DC_EXTENT_LIST,
> > +		.payload_in = &get_dc_extent,
> > +		.size_in = sizeof(get_dc_extent),
> > +		.size_out = mds->payload_size,
> 
> If all you are after is the count, then size_out can be a lot smaller than that
> I think as we know it can't return any extents.

Done.

> 
> > +		.payload_out = &dc_extents,
> > +		.min_out = 1,
> > +	};
> > +
> > +	rc = cxl_internal_send_cmd(mds, &mbox_cmd);
> > +	if (rc < 0)
> > +		return rc;
> > +
> > +	count = le32_to_cpu(dc_extents.total_extent_cnt);
> > +	*extent_gen_num = le32_to_cpu(dc_extents.extent_list_num);
> > +
> > +	return count;
> > +}
> > +
> > +static int cxl_dev_get_dc_extents(struct cxl_memdev_state *mds,
> > +				  unsigned int start_gen_num,
> > +				  unsigned int exp_cnt)
> > +{
> > +	struct cxl_mbox_dc_extents *dc_extents;
> > +	unsigned int start_index, total_read;
> > +	struct device *dev = mds->cxlds.dev;
> > +	struct cxl_mbox_cmd mbox_cmd;
> > +	int retry = 3;
> 
> Why 3?

Removed.

> 
> > +	int rc;
> > +
> > +	/* Check GET_DC_EXTENT_LIST is supported by device */
> > +	if (!test_bit(CXL_DCD_ENABLED_GET_EXTENT_LIST, mds->dcd_cmds)) {
> > +		dev_dbg(dev, "unsupported cmd : get dyn cap extent list\n");
> > +		return 0;
> > +	}
> > +
> > +	dc_extents = kvmalloc(mds->payload_size, GFP_KERNEL);
> 
> Maybe __free magic would simplify this enough to be useful.

Yes.  I'd not wrapped my head around the __free magic until you mentioned in
in the other patch.  It is pretty easy to use.  But I'm worried because it
seems 'too easy'...  ;-)

I'll convert this one too.  So far the other one seems good.  So dare I
say "I know what I'm doing now"...  :-D

> 
> > +	if (!dc_extents)
> > +		return -ENOMEM;
> > +
> > +reset:
> > +	total_read = 0;
> > +	start_index = 0;
> > +	do {
> > +		unsigned int nr_ext, total_extent_cnt, gen_num;
> > +		struct cxl_mbox_get_dc_extent get_dc_extent;
> > +
> > +		get_dc_extent = (struct cxl_mbox_get_dc_extent) {
> > +			.extent_cnt = exp_cnt - start_index,
> > +			.start_extent_index = start_index,
> > +		};
> > +		
> > +		mbox_cmd = (struct cxl_mbox_cmd) {
> > +			.opcode = CXL_MBOX_OP_GET_DC_EXTENT_LIST,
> > +			.payload_in = &get_dc_extent,
> > +			.size_in = sizeof(get_dc_extent),
> > +			.size_out = mds->payload_size,
> > +			.payload_out = dc_extents,
> > +			.min_out = 1,
> > +		};
> > +		
> > +		rc = cxl_internal_send_cmd(mds, &mbox_cmd);
> > +		if (rc < 0)
> > +			goto out;
> > +		
> > +		nr_ext = le32_to_cpu(dc_extents->ret_extent_cnt);
> > +		total_read += nr_ext;
> > +		total_extent_cnt = le32_to_cpu(dc_extents->total_extent_cnt);
> > +		gen_num = le32_to_cpu(dc_extents->extent_list_num);
> > +
> > +		dev_dbg(dev, "Get extent list count:%d generation Num:%d\n",
> > +			total_extent_cnt, gen_num);
> > +
> > +		if (gen_num != start_gen_num || exp_cnt != total_extent_cnt) {
> > +			dev_err(dev, "Extent list changed while reading; %u != %u : %u != %u\n",
> > +				gen_num, start_gen_num, exp_cnt, total_extent_cnt);
> > +			if (retry--)
> > +				goto reset;
> > +			return -EIO;

And this was a bug too :-(  ...  Fixed with the __free() magic.

Thanks for the review,
Ira

> > +		}
> > +		
> > +		for (int i = 0; i < nr_ext ; i++) {
> > +			dev_dbg(dev, "Storing extent %d/%d\n",
> > +				start_index + i, exp_cnt);
> > +			rc = cxl_store_dc_extent(mds, &dc_extents->extent[i]);
> > +			if (rc)
> > +				goto out;
> > +		}
> > +
> > +		start_index += nr_ext;
> > +	} while (exp_cnt > total_read);
> > +
> > +out:
> > +	kvfree(dc_extents);
> > +	return rc;
> > +}
> 
> 



From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id BD5D3CA100C
	for <linux-cxl@archiver.kernel.org>; Tue,  5 Sep 2023 21:10:44 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S242168AbjIEVKq (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 5 Sep 2023 17:10:46 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:44624 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S244143AbjIEVKc (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 5 Sep 2023 17:10:32 -0400
Received: from mout.gmx.net (mout.gmx.net [212.227.17.20])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 8F21C1A2;
        Tue,  5 Sep 2023 14:10:20 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=gmx.us;
 s=s31663417; t=1693948196; x=1694552996; i=fan.ni@gmx.us;
 bh=Rxg1bMuDR/Fqk/qNCZkvHDUMlglXCGuhkqfIPFzT4UU=;
 h=X-UI-Sender-Class:Date:From:To:Cc:Subject:References:In-Reply-To;
 b=rkSa+R0+G5Ruybj8uxHKGwOFjJdivgZUKLemobTU+Wjd8HUJrR9LNWAGQkflcyju3FPLace
 cXENxHDrr08sx5WJiTGfh31EiyswMaX+Mr9x6kIxwJZ8IdWziumZSZdpaSX9G8NxGv5S/S3d2
 Q/qHvZ7gjk43imUahsCLby/ZbgieRJbkX7qJCQGvJ39AzlSbzFoo4yzVc+lnoPf3acGYYV5yY
 ePtZWC40kKufci+8iTCIMT8F0Z7VVWews6nDtKMVFm2Z5F9qyEPTsifePHu1dwY4iuLV+mHfz
 zKJ4WuEod7o07KNHgmA93SEo0/xgaP7Hv4sjEvTM4RhNlMNfnJ7Q==
X-UI-Sender-Class: 724b4f7f-cbec-4199-ad4e-598c01a50d3a
Received: from debian ([50.205.20.42]) by mail.gmx.net (mrgmx104
 [212.227.17.174]) with ESMTPSA (Nemesis) id 1N4hzj-1pc5Fj0KAh-011kXc; Tue, 05
 Sep 2023 23:09:56 +0200
Date: Tue, 5 Sep 2023 14:09:48 -0700
From: Fan Ni <fan.ni@gmx.us>
To: Ira Weiny <ira.weiny@intel.com>
Cc: Dan Williams <dan.j.williams@intel.com>,
        Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        linux-cxl@vger.kernel.org, linux-kernel@vger.kernel.org
Subject: Re: [PATCH RFC v2 08/18] cxl/region: Add Dynamic Capacity CXL region
 support
Message-ID: <ZPeZHIPef2otzVNU@debian>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
 <20230604-dcd-type2-upstream-v2-8-f740c47e7916@intel.com>
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: <20230604-dcd-type2-upstream-v2-8-f740c47e7916@intel.com>
X-Provags-ID: V03:K1:m40EFgx6zakYxZbW6pPX5UgDd/jX5DbaJjPsQBz10t2JUmWMbXB
 LNMiig8gFdHOws43UgFdNvY85cSuoowl+iAIP9OL75y0KzWyIxxY8U6OOeiQLRIiq7QhhYO
 JPLMOkbJYC54EqHcR9weR4o7ad+FVWknJTzUpItIfqMOwP3QoJLtlKzRwKzrurEbywt1p/V
 D6AxOq5PTGXOvQv1LvWYg==
UI-OutboundReport: notjunk:1;M01:P0:duuZmDkwjYY=;xA048yNUMBdNNtcPuW7tqu0mGSx
 337C0p56b1P5SROw8HqhP+5ZDHlRRs15gaEWNfcAmtOhcab27y44bBdu1lZu+o0Kp2ggeohtD
 XjcUymaNl01y5wTasnqAYuWx/4qWQtNZPrkK4zAB5DF2iu7wkV9Pi/Y72i22mi5vII50a+1DW
 qJa9ZaCWtW5R8WdNbry2KLF6cMc3Q//AXsn63DLfZZyCJdh4bgL4kGx/KJiHu46cnrECuqjGb
 3EFoom1crTDw4ZNGVwGl9XXfkfE7UFreCcVW8bmiCgvbd1H03rCk+RgMBywIiEQYuangX6LiR
 SNKDGjN6V8/mfgR4iL50PP1YgEFlRIfGRTugJ/x+UxideGJjQhSa1IPxmxtzH2afNToaA4BKD
 AopMFXudXb+b05OCvFv1N5NtKWdw8JiFTUnWfTEHsDohaMd7Mn6hfMeWh+hDKCq4zqGXmqykN
 Of+vM+EPvwyCffA2cgz0aV4WUKYiajCXBxucenPEZyuGUSX8KV/JWGg9zqn4ihMim5j2eqBu3
 3nyUXVjEQuUjMaUkrCrDG23NblJp1hkhxD14cXzsu5eB9LuUaPG2KkAxJHRu2BpxSYQgh62wZ
 GLbT+ozzpSCxK4JAF46b0KeQe+/W6jPgStZ0DxBYenfviJtyJY6mMmn0eLluDVD+gjx8gowOd
 GCSK5tfVaNJr/wXL2Hx1MPkYtYiDWmXZyN6gWAjxtW2ZiM7zHdLpnA9lAM3PrYGXfp7c6gyi+
 zPI0aLVth40WDHvVM8W9eTHp+xOd9dQr39w9UlcZVW2BThGmmfzbfeL8vcPx9BP28rVIQymcC
 pUmbsvCmSiMhjvo2FxPCMm5t2ww5lr4XIp4z0tJgQqjiFmKLHNsBUMcHhLcIJrPNS4q5jDFyz
 +gSP+QecwVO3YpmfkY8TD/5llMqBMT9qygbCjwDOigm+vqM9RgQeY2Fplu0LmNXj3owpqokc8
 9l6iSvmVHApdBqg0G30cVpW4ixo=
Content-Transfer-Encoding: quoted-printable
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

On Mon, Aug 28, 2023 at 10:20:59PM -0700, Ira Weiny wrote:
> CXL devices optionally support dynamic capacity.  CXL Regions must be
> configured correctly to access this capacity.  Similar to ram and pmem
> partitions, DC Regions represent different partitions of the DPA space.
>
> Interleaving is deferred due to the complexity of managing extents on
> multiple devices at the same time.  However, there is nothing which
> directly prevents interleave support at this time.  The check allows
> for early rejection.
>
> To maintain backwards compatibility with older software, CXL regions
> need a default DAX device to hold the reference for the region until it
> is deleted.
>
> Add create_dc_region sysfs entry to create DC regions.  Share the logic
> of devm_cxl_add_dax_region() and region_is_system_ram().  Special case
> DC capable CXL regions to create a 0 sized seed DAX device until others
> can be created on dynamic space later.
>
> Flag dax_regions to indicate 0 capacity available until dax_region
> extents are supported by the region.
>
> Co-developed-by: Navneet Singh <navneet.singh@intel.com>
> Signed-off-by: Navneet Singh <navneet.singh@intel.com>
> Signed-off-by: Ira Weiny <ira.weiny@intel.com>
>

Reviewed-by: Fan Ni <fan.ni@samsung.com>

> ---
> changes for v2:
> [iweiny: flag empty dax regions]
> [iweiny: Split out anything not directly related to creating a DC CXL
> 	 region]
> [iweiny: Separate out dev dax stuff]
> [iweiny/navneet: create 0 sized DAX device by default]
> [iweiny: use new DC region mode]
> ---
>  Documentation/ABI/testing/sysfs-bus-cxl | 20 +++++-----
>  drivers/cxl/core/core.h                 |  1 +
>  drivers/cxl/core/port.c                 |  1 +
>  drivers/cxl/core/region.c               | 71 ++++++++++++++++++++++++++=
++-----
>  drivers/dax/bus.c                       |  8 ++++
>  drivers/dax/bus.h                       |  1 +
>  drivers/dax/cxl.c                       | 15 ++++++-
>  7 files changed, 96 insertions(+), 21 deletions(-)
>
> diff --git a/Documentation/ABI/testing/sysfs-bus-cxl b/Documentation/ABI=
/testing/sysfs-bus-cxl
> index aa65dc5b4e13..a0562938ecac 100644
> --- a/Documentation/ABI/testing/sysfs-bus-cxl
> +++ b/Documentation/ABI/testing/sysfs-bus-cxl
> @@ -351,20 +351,20 @@ Description:
>  		interleave_granularity).
>
>
> -What:		/sys/bus/cxl/devices/decoderX.Y/create_{pmem,ram}_region
> +What:		/sys/bus/cxl/devices/decoderX.Y/create_{pmem,ram,dc}_region
>  Date:		May, 2022, January, 2023
> -KernelVersion:	v6.0 (pmem), v6.3 (ram)
> +KernelVersion:	v6.0 (pmem), v6.3 (ram), v6.6 (dc)
>  Contact:	linux-cxl@vger.kernel.org
>  Description:
>  		(RW) Write a string in the form 'regionZ' to start the process
> -		of defining a new persistent, or volatile memory region
> -		(interleave-set) within the decode range bounded by root decoder
> -		'decoderX.Y'. The value written must match the current value
> -		returned from reading this attribute. An atomic compare exchange
> -		operation is done on write to assign the requested id to a
> -		region and allocate the region-id for the next creation attempt.
> -		EBUSY is returned if the region name written does not match the
> -		current cached value.
> +		of defining a new persistent, volatile, or Dynamic Capacity
> +		(DC) memory region (interleave-set) within the decode range
> +		bounded by root decoder 'decoderX.Y'. The value written must
> +		match the current value returned from reading this attribute.
> +		An atomic compare exchange operation is done on write to assign
> +		the requested id to a region and allocate the region-id for the
> +		next creation attempt.  EBUSY is returned if the region name
> +		written does not match the current cached value.
>
>
>  What:		/sys/bus/cxl/devices/decoderX.Y/delete_region
> diff --git a/drivers/cxl/core/core.h b/drivers/cxl/core/core.h
> index 45e7e044cf4a..cf3cf01cb95d 100644
> --- a/drivers/cxl/core/core.h
> +++ b/drivers/cxl/core/core.h
> @@ -13,6 +13,7 @@ extern struct attribute_group cxl_base_attribute_group=
;
>  #ifdef CONFIG_CXL_REGION
>  extern struct device_attribute dev_attr_create_pmem_region;
>  extern struct device_attribute dev_attr_create_ram_region;
> +extern struct device_attribute dev_attr_create_dc_region;
>  extern struct device_attribute dev_attr_delete_region;
>  extern struct device_attribute dev_attr_region;
>  extern const struct device_type cxl_pmem_region_type;
> diff --git a/drivers/cxl/core/port.c b/drivers/cxl/core/port.c
> index a5db710a63bc..608901bb7d91 100644
> --- a/drivers/cxl/core/port.c
> +++ b/drivers/cxl/core/port.c
> @@ -314,6 +314,7 @@ static struct attribute *cxl_decoder_root_attrs[] =
=3D {
>  	&dev_attr_target_list.attr,
>  	SET_CXL_REGION_ATTR(create_pmem_region)
>  	SET_CXL_REGION_ATTR(create_ram_region)
> +	SET_CXL_REGION_ATTR(create_dc_region)
>  	SET_CXL_REGION_ATTR(delete_region)
>  	NULL,
>  };
> diff --git a/drivers/cxl/core/region.c b/drivers/cxl/core/region.c
> index 69af1354bc5b..fc8dee469244 100644
> --- a/drivers/cxl/core/region.c
> +++ b/drivers/cxl/core/region.c
> @@ -2271,6 +2271,7 @@ static struct cxl_region *devm_cxl_add_region(stru=
ct cxl_root_decoder *cxlrd,
>  	switch (mode) {
>  	case CXL_REGION_RAM:
>  	case CXL_REGION_PMEM:
> +	case CXL_REGION_DC:
>  		break;
>  	default:
>  		dev_err(&cxlrd->cxlsd.cxld.dev, "unsupported mode %s\n",
> @@ -2383,6 +2384,33 @@ static ssize_t create_ram_region_store(struct dev=
ice *dev,
>  }
>  DEVICE_ATTR_RW(create_ram_region);
>
> +static ssize_t create_dc_region_show(struct device *dev,
> +				     struct device_attribute *attr, char *buf)
> +{
> +	return __create_region_show(to_cxl_root_decoder(dev), buf);
> +}
> +
> +static ssize_t create_dc_region_store(struct device *dev,
> +				      struct device_attribute *attr,
> +				      const char *buf, size_t len)
> +{
> +	struct cxl_root_decoder *cxlrd =3D to_cxl_root_decoder(dev);
> +	struct cxl_region *cxlr;
> +	int rc, id;
> +
> +	rc =3D sscanf(buf, "region%d\n", &id);
> +	if (rc !=3D 1)
> +		return -EINVAL;
> +
> +	cxlr =3D __create_region(cxlrd, id, CXL_REGION_DC,
> +			       CXL_DECODER_HOSTONLYMEM);
> +	if (IS_ERR(cxlr))
> +		return PTR_ERR(cxlr);
> +
> +	return len;
> +}
> +DEVICE_ATTR_RW(create_dc_region);
> +
>  static ssize_t region_show(struct device *dev, struct device_attribute =
*attr,
>  			   char *buf)
>  {
> @@ -2834,7 +2862,7 @@ static void cxlr_dax_unregister(void *_cxlr_dax)
>  	device_unregister(&cxlr_dax->dev);
>  }
>
> -static int devm_cxl_add_dax_region(struct cxl_region *cxlr)
> +static int __devm_cxl_add_dax_region(struct cxl_region *cxlr)
>  {
>  	struct cxl_dax_region *cxlr_dax;
>  	struct device *dev;
> @@ -2863,6 +2891,21 @@ static int devm_cxl_add_dax_region(struct cxl_reg=
ion *cxlr)
>  	return rc;
>  }
>
> +static int devm_cxl_add_dax_region(struct cxl_region *cxlr)
> +{
> +	return __devm_cxl_add_dax_region(cxlr);
> +}
> +
> +static int devm_cxl_add_dc_dax_region(struct cxl_region *cxlr)
> +{
> +	if (cxlr->params.interleave_ways !=3D 1) {
> +		dev_err(&cxlr->dev, "Interleaving DC not supported\n");
> +		return -EINVAL;
> +	}
> +
> +	return __devm_cxl_add_dax_region(cxlr);
> +}
> +
>  static int match_decoder_by_range(struct device *dev, void *data)
>  {
>  	struct range *r1, *r2 =3D data;
> @@ -3203,6 +3246,19 @@ static int is_system_ram(struct resource *res, vo=
id *arg)
>  	return 1;
>  }
>
> +/*
> + * The region can not be manged by CXL if any portion of
> + * it is already online as 'System RAM'
> + */
> +static bool region_is_system_ram(struct cxl_region *cxlr,
> +				 struct cxl_region_params *p)
> +{
> +	return (walk_iomem_res_desc(IORES_DESC_NONE,
> +				    IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY,
> +				    p->res->start, p->res->end, cxlr,
> +				    is_system_ram) > 0);
> +}
> +
>  static int cxl_region_probe(struct device *dev)
>  {
>  	struct cxl_region *cxlr =3D to_cxl_region(dev);
> @@ -3242,14 +3298,7 @@ static int cxl_region_probe(struct device *dev)
>  	case CXL_REGION_PMEM:
>  		return devm_cxl_add_pmem_region(cxlr);
>  	case CXL_REGION_RAM:
> -		/*
> -		 * The region can not be manged by CXL if any portion of
> -		 * it is already online as 'System RAM'
> -		 */
> -		if (walk_iomem_res_desc(IORES_DESC_NONE,
> -					IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY,
> -					p->res->start, p->res->end, cxlr,
> -					is_system_ram) > 0)
> +		if (region_is_system_ram(cxlr, p))
>  			return 0;
>
>  		/*
> @@ -3261,6 +3310,10 @@ static int cxl_region_probe(struct device *dev)
>
>  		/* HDM-H routes to device-dax */
>  		return devm_cxl_add_dax_region(cxlr);
> +	case CXL_REGION_DC:
> +		if (region_is_system_ram(cxlr, p))
> +			return 0;
> +		return devm_cxl_add_dc_dax_region(cxlr);
>  	default:
>  		dev_dbg(&cxlr->dev, "unsupported region mode: %s\n",
>  			cxl_region_mode_name(cxlr->mode));
> diff --git a/drivers/dax/bus.c b/drivers/dax/bus.c
> index 0ee96e6fc426..b76e49813a39 100644
> --- a/drivers/dax/bus.c
> +++ b/drivers/dax/bus.c
> @@ -169,6 +169,11 @@ static bool is_static(struct dax_region *dax_region=
)
>  	return (dax_region->res.flags & IORESOURCE_DAX_STATIC) !=3D 0;
>  }
>
> +static bool is_dynamic(struct dax_region *dax_region)
> +{
> +	return (dax_region->res.flags & IORESOURCE_DAX_DYNAMIC_CAP) !=3D 0;
> +}
> +
>  bool static_dev_dax(struct dev_dax *dev_dax)
>  {
>  	return is_static(dev_dax->region);
> @@ -285,6 +290,9 @@ static unsigned long long dax_region_avail_size(stru=
ct dax_region *dax_region)
>
>  	device_lock_assert(dax_region->dev);
>
> +	if (is_dynamic(dax_region))
> +		return 0;
> +
>  	for_each_dax_region_resource(dax_region, res)
>  		size -=3D resource_size(res);
>  	return size;
> diff --git a/drivers/dax/bus.h b/drivers/dax/bus.h
> index 1ccd23360124..74d8fe4a5532 100644
> --- a/drivers/dax/bus.h
> +++ b/drivers/dax/bus.h
> @@ -13,6 +13,7 @@ struct dax_region;
>  /* dax bus specific ioresource flags */
>  #define IORESOURCE_DAX_STATIC BIT(0)
>  #define IORESOURCE_DAX_KMEM BIT(1)
> +#define IORESOURCE_DAX_DYNAMIC_CAP BIT(2)
>
>  struct dax_region *alloc_dax_region(struct device *parent, int region_i=
d,
>  		struct range *range, int target_node, unsigned int align,
> diff --git a/drivers/dax/cxl.c b/drivers/dax/cxl.c
> index 8bc9d04034d6..147c8c69782b 100644
> --- a/drivers/dax/cxl.c
> +++ b/drivers/dax/cxl.c
> @@ -13,19 +13,30 @@ static int cxl_dax_region_probe(struct device *dev)
>  	struct cxl_region *cxlr =3D cxlr_dax->cxlr;
>  	struct dax_region *dax_region;
>  	struct dev_dax_data data;
> +	resource_size_t dev_size;
> +	unsigned long flags;
>
>  	if (nid =3D=3D NUMA_NO_NODE)
>  		nid =3D memory_add_physaddr_to_nid(cxlr_dax->hpa_range.start);
>
> +	dev_size =3D range_len(&cxlr_dax->hpa_range);
> +
> +	flags =3D IORESOURCE_DAX_KMEM;
> +	if (cxlr->mode =3D=3D CXL_REGION_DC) {
> +		/* Add empty seed dax device */
> +		dev_size =3D 0;
> +		flags |=3D IORESOURCE_DAX_DYNAMIC_CAP;
> +	}
> +
>  	dax_region =3D alloc_dax_region(dev, cxlr->id, &cxlr_dax->hpa_range, n=
id,
> -				      PMD_SIZE, IORESOURCE_DAX_KMEM);
> +				      PMD_SIZE, flags);
>  	if (!dax_region)
>  		return -ENOMEM;
>
>  	data =3D (struct dev_dax_data) {
>  		.dax_region =3D dax_region,
>  		.id =3D -1,
> -		.size =3D range_len(&cxlr_dax->hpa_range),
> +		.size =3D dev_size,
>  	};
>
>  	return PTR_ERR_OR_ZERO(devm_create_dev_dax(&data));
>
> --
> 2.41.0
>

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 1F03DCA1008
	for <linux-cxl@archiver.kernel.org>; Tue,  5 Sep 2023 20:46:01 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S238977AbjIEUqC (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 5 Sep 2023 16:46:02 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:35564 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S231834AbjIEUqC (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 5 Sep 2023 16:46:02 -0400
Received: from mgamail.intel.com (mgamail.intel.com [134.134.136.126])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 5B09EE45;
        Tue,  5 Sep 2023 13:45:51 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1693946751; x=1725482751;
  h=date:from:to:cc:subject:message-id:references:
   in-reply-to:mime-version;
  bh=5awU6mhbJaxOmgz/MzcBlM7sQM7YG5Ob1P5noLzYaQg=;
  b=lxO60ngKu6hWsloii9TDpJAjlWh7HV3Sz3Mjj9V+X4/2k3NscqMNhYMe
   7ycGJq7LL6b1DU3EemTmxDFJPGKFz7ko7EjhkfRfZV04rbrVpRmjNNj3e
   4qUJT9VPLQAPBZm8DRF86vGJhbT7lP0blhc02AN3v5mVuKg5SbZFCX8eH
   hJbCJTyeQwSo0brarQhTuJPjEDZexrWsVJHj143ZgMVvrtvdaNPEwOIze
   5DsK0s45St3UVxVcCOyP98nqTp8Uy9e8E++jZTPHIhZwLxA0XL/KFKY/a
   18PG/tzT/3lMhxpMdgreiiM10gA56JMoH8vQOS65XFUd9QCCZzPIrdKmz
   g==;
X-IronPort-AV: E=McAfee;i="6600,9927,10824"; a="361928175"
X-IronPort-AV: E=Sophos;i="6.02,230,1688454000"; 
   d="scan'208";a="361928175"
Received: from orsmga004.jf.intel.com ([10.7.209.38])
  by orsmga106.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 05 Sep 2023 13:45:50 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10824"; a="864887332"
X-IronPort-AV: E=Sophos;i="6.02,230,1688454000"; 
   d="scan'208";a="864887332"
Received: from fmsmsx602.amr.corp.intel.com ([10.18.126.82])
  by orsmga004.jf.intel.com with ESMTP/TLS/AES256-GCM-SHA384; 05 Sep 2023 13:45:50 -0700
Received: from fmsmsx610.amr.corp.intel.com (10.18.126.90) by
 fmsmsx602.amr.corp.intel.com (10.18.126.82) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27; Tue, 5 Sep 2023 13:45:49 -0700
Received: from fmsedg601.ED.cps.intel.com (10.1.192.135) by
 fmsmsx610.amr.corp.intel.com (10.18.126.90) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27 via Frontend Transport; Tue, 5 Sep 2023 13:45:49 -0700
Received: from NAM11-CO1-obe.outbound.protection.outlook.com (104.47.56.171)
 by edgegateway.intel.com (192.55.55.70) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.27; Tue, 5 Sep 2023 13:45:48 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=T//vjZInvaDaGvdmkwCwywoisYnaEoIRR1EQ3v9ZV3tqvllpG3gVO2SaRn0656pZG8i+DLRIwt9ho1D6UsgeAlCQthAySJZGcKIf2MX/Tf17LA4r3s5sY3mXEoNUdp9uuCDB1Ju53hEYpq3YmEDM1WFmkXtDmd9R8zp4tRao7Qxpm2wWffHdWKSTe3c2n9BdqRxuif90XR3DnCx7GCiwsW9bcQBSep6daUJSxm7laN85gHOv63mf19pzDddo6Ci1WkRR21G0v/STXh3wTYjEZgqXt36d4lsbjVAG5VagqNwfY3WcDW7HPNfw7HMt8zaa4/U1NZca9CmD69aTaYPcEQ==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=jCXCosk3R3IDKZT89+9ZZRAK5EPGrOm7K6abuMVaoQI=;
 b=O7MCTjoAyHPqBGwTQBk6TaT3Q+6fw7Pm0a86gep8AQ+mpVc+GPovBTa+lvrAGJwIOwRXVW4pNg8eRFVGp0nJNtvpvgPUzCRCoFy8tnZBhw/nTF1WJMgxSgCXZN+GKji92I/4/yRJ9StNnjB+s03pi0IkqwZeSW0S8ym4FJSFxlrPXBf9dSuB7GFwH6P3JZBjVcpESbjKN2gz8dQX8gVEOiflQPLEZ5Gs6S1H5AGSgScOjC8vCkyE0nsjJ1F8O7ygQ8NYihLWrU7gDifi+Cvg1HESKkYXxhnl2njdqRgrke8VidPd5+aYM1rRv8dLlAd82hlxOe6eJ4QFKZX+k5wm2Q==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from SA1PR11MB6733.namprd11.prod.outlook.com (2603:10b6:806:25c::17)
 by CYXPR11MB8709.namprd11.prod.outlook.com (2603:10b6:930:dd::21) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.6745.33; Tue, 5 Sep
 2023 20:45:45 +0000
Received: from SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938]) by SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938%6]) with mapi id 15.20.6745.030; Tue, 5 Sep 2023
 20:45:45 +0000
Date: Tue, 5 Sep 2023 13:45:40 -0700
From: Ira Weiny <ira.weiny@intel.com>
To: Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        <ira.weiny@intel.com>
CC: Dan Williams <dan.j.williams@intel.com>,
        Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
Subject: Re: [PATCH RFC v2 07/18] cxl/mem: Expose device dynamic capacity
 configuration
Message-ID: <64f79374c8860_1e8e7829466@iweiny-mobl.notmuch>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
 <20230604-dcd-type2-upstream-v2-7-f740c47e7916@intel.com>
 <20230829161449.00000c7a@Huawei.com>
Content-Type: text/plain; charset="us-ascii"
Content-Disposition: inline
In-Reply-To: <20230829161449.00000c7a@Huawei.com>
X-ClientProxiedBy: BY3PR10CA0029.namprd10.prod.outlook.com
 (2603:10b6:a03:255::34) To SA1PR11MB6733.namprd11.prod.outlook.com
 (2603:10b6:806:25c::17)
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: SA1PR11MB6733:EE_|CYXPR11MB8709:EE_
X-MS-Office365-Filtering-Correlation-Id: 226e4c90-24d0-4f8e-235d-08dbae5113f0
X-LD-Processed: 46c98d88-e344-4ed4-8496-4ed7712e255d,ExtAddr
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;
X-Microsoft-Antispam-Message-Info: XrezJ5Rya80Dj2bL7J8gqWA4DtwQc0gQgIb2/Q5nHdlWH0o4mnILqoL7GmkoFBxnzZ9TzbP4uVjdsb+ia90YYOvGmzIioOKRsr4OJ2LdDN8qzWnZ5Ynx+Nn3fet5fEr95WkKJU1mQija5CI1KavcU8nHE9PCwDdkyqxD3V7A6puJGqZFMWUfPUxJba9N2dBbLnxassslo4SzQ3g/687BU4O/Fn4YnL4Y4wHRi1+QCFYaFbyV2/OJ82mFl1pmdYZxymNmyjujNomd8prwoZm3GZKrg4Uo4fS6L6l2gy+ud6d99/eVda6cz7P0sIM/48u/MNFk1i24nSF5cFa4128HMdKfFji2Gm7ZXxMMCNTb5kQKOEd4Friw5EJjRXQzTmNFcKoiOQesdjCq07RAlp9Ln0hPaEiGreMyIyML3eaeasI4llCozIEBNaYK8NYYSf2ka53oBlOe0sVXg7+mJ0O1TOUFotsZe04NIKkVwaWUk8lePwNW0TeoOBf2SvB5AAqcma65oG5UciYMASvcrNiCc2QLCXiepJ3lzkU3f8/rg2YTRWejsVUfvWDJ1L7X63LI
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:SA1PR11MB6733.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230031)(39860400002)(346002)(396003)(366004)(376002)(136003)(451199024)(186009)(1800799009)(26005)(38100700002)(86362001)(66556008)(66946007)(6486002)(9686003)(6506007)(6512007)(82960400001)(478600001)(6666004)(66476007)(2906002)(4326008)(8676002)(44832011)(8936002)(316002)(41300700001)(54906003)(5660300002);DIR:OUT;SFP:1102;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?us-ascii?Q?tW9LJ1iU2yjqkmoZRUc/fN27rkiXsX/DOAhA6I2swKscaDQQT3SvkLxITuSw?=
 =?us-ascii?Q?KvgC6we1VUithutaIes2FBM9zcpsKc5QgWQKDw/2UpJSZUgZc7ZZHrcphish?=
 =?us-ascii?Q?l+o1GysNszCM9bChSJOAJoWILaVC3gmSGlpAHX6WfNhqJ6+zHLR4TFecDctX?=
 =?us-ascii?Q?3DA0dZgqnUYRaR39fC4BEyYR8WNPIfz6GcoUNf8+FbeX+UmS1W8VEK642kE3?=
 =?us-ascii?Q?tIRy139O7p9cbktlsEyZWvvXz041CCybkZ302LFCrqo9F2drMEUznqY8VgyR?=
 =?us-ascii?Q?TeuESbfgJqmqVPaqFxEvwgZW0PX6fUYCypJQ9SlBwfptvmyxaTfQkDqDOF6l?=
 =?us-ascii?Q?SjNi0CcjKeMfh3nFnpgsLp1tw97DmZGIpME/z5J/iSotyo8MiGE/lORGYBxV?=
 =?us-ascii?Q?Csf9fxnroUobr7LqVo5fWEHOGghHwcScjKESyKoQlWin9pv2BQeQrrCkPNKy?=
 =?us-ascii?Q?UQ56aij9faDe8PgnrJThyW+J6hH8KLQQg2fqHHuAAdkXpoAa1+hAYoE0LY/+?=
 =?us-ascii?Q?oy5GkNGFbfiglZWY0MBxpFXyNn4Qiqs6EAadwfOzd2B+c7zkgo55z+C/MLRW?=
 =?us-ascii?Q?CHf+A5ZHqWnCyZ5BBsG0B2VvKcv0yW/GJcVJusYILvd5O67lE0ZMbonVhkHp?=
 =?us-ascii?Q?4WTgBr2jGbymL/9QXJd+QIA15CX4+GWOrOpUDLvUQHUL7aRRD4Q0B3wcr+8W?=
 =?us-ascii?Q?17gDPIBeelZV5XuXAWmB9ixq7wTHC2vERdonKhffKnRCFS0yRQ4rVAgzf8uv?=
 =?us-ascii?Q?sQ530dkhbjibcbTIvkzFXj733E+GS1T474nf+qL/pJds8oB7/4bIFiaDo9HK?=
 =?us-ascii?Q?aIEgrOOyyy0XpF5CsZzpIczkn+RJ27Ih2OCJLN29V/cAA/I5uPvghv9EZ5wI?=
 =?us-ascii?Q?sXnFftHNfDlz27qmn50R+T3eDEECyD1X0Qug3mTTRP/DyohBlolymN+RGwRa?=
 =?us-ascii?Q?CQXRnyvC0DyH3nu9jHa/nKD3ytXth90cbbwgiSU4aj10zQuDsyacSBHUdmOX?=
 =?us-ascii?Q?BdLD1VWLAu51T4+bMY6jbgmmhjxNki1x1t9d9+DVy24HbMSfYL0rgf7NW+Yx?=
 =?us-ascii?Q?/KOXgDO4Bollylt5lMM9zfD66eplvbDJXnglNidwjFCO9xAIrfd79iKPgU/R?=
 =?us-ascii?Q?AYjJykhLImilLQxrdcg6PUaLJn/ZmLKNKkLD+ygpnTUpqGaJkYGqD7EBOUA5?=
 =?us-ascii?Q?jyPw3N6E+TEeBalIc9TwC3L5QzOsVvsc2VIgUD8oGsAgxvp3lnJ2SaN7Jgl4?=
 =?us-ascii?Q?swxPkKKCNy+a5uLe9hKI6/Vs7K5nxBignxVKWHZuQyV2+o3YT6hqPcljLUC7?=
 =?us-ascii?Q?KRmqsDV5075i9Sk3IbJBzjy79pyxoS2YGZvDjDilg3kBKxnPPa+UAFCZQdmH?=
 =?us-ascii?Q?L4c8Rfx6DLG1w4dX14wvA6iBdl3206WKqYyjtJmYMNpHiqggPFqG+7c4+KIK?=
 =?us-ascii?Q?rPMN2/WlAYZOdrAl2ykvvCuRzwiNVO0ib2QBbd7mPXO8LHJna6QBuCLQSaIs?=
 =?us-ascii?Q?/scJSbR9tLSMbVr7eRxksz90kN5BF6RF+AcQdXekZPwMDhtG+HfXYo4rLlxe?=
 =?us-ascii?Q?FjDmg147vSzMgaUiFmbp+KyRWhMGdHuIUz0gYNr7?=
X-MS-Exchange-CrossTenant-Network-Message-Id: 226e4c90-24d0-4f8e-235d-08dbae5113f0
X-MS-Exchange-CrossTenant-AuthSource: SA1PR11MB6733.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 05 Sep 2023 20:45:45.5615
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: tC4+WEoLo2gpfRyYhPxzNLwXVamt7x7uRp2VcsJ4g7uOAUbzIuoTrKLQbqdEScVkIjR+B86QmxL0RIKuU0ueFA==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: CYXPR11MB8709
X-OriginatorOrg: intel.com
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

Jonathan Cameron wrote:
> On Mon, 28 Aug 2023 22:20:58 -0700
> ira.weiny@intel.com wrote:
> 
> > From: Navneet Singh <navneet.singh@intel.com>
> > 
> > To properly configure CXL regions on Dynamic Capacity Devices (DCD),
> > user space will need to know the details of the DC Regions available on
> > a device.
> > 
> > Expose driver dynamic capacity configuration through sysfs
> > attributes.
> > 
> > Co-developed-by: Navneet Singh <navneet.singh@intel.com>
> > Signed-off-by: Navneet Singh <navneet.singh@intel.com>
> > Signed-off-by: Ira Weiny <ira.weiny@intel.com>
> > 
> One trivial comment inline.  I wondered a bit if it would
> be better to not present dc at all on devices that don't support
> dynamic capacity, but for now there isn't an elegant way to do that
> (some discussions and patches are flying around however so maybe this
>  will be resolved before this series merges giving us that elegant
>  option).

For now I will keep this yes.  But if there is a better way then sure.

> 
> With commented code tidied up
> Reviewed-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
> 

Thanks.

> > diff --git a/drivers/cxl/core/memdev.c b/drivers/cxl/core/memdev.c
> > index 492486707fd0..397262e0ebd2 100644
> > --- a/drivers/cxl/core/memdev.c
> > +++ b/drivers/cxl/core/memdev.c
> > @@ -101,6 +101,20 @@ static ssize_t pmem_size_show(struct device *dev, struct device_attribute *attr,
> >  static struct device_attribute dev_attr_pmem_size =
> >  	__ATTR(size, 0444, pmem_size_show, NULL);
> >  
> > +static ssize_t region_count_show(struct device *dev, struct device_attribute *attr,
> > +				 char *buf)
> > +{
> > +	struct cxl_memdev *cxlmd = to_cxl_memdev(dev);
> > +	struct cxl_memdev_state *mds = to_cxl_memdev_state(cxlmd->cxlds);
> > +	int len = 0;
> > +
> > +	len = sysfs_emit(buf, "%d\n", mds->nr_dc_region);
> > +	return len;
> 
> return sysfs_emit(buf, "...);
> 	

Done thanks!
Ira

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id CFD68CA1001
	for <linux-cxl@archiver.kernel.org>; Tue,  5 Sep 2023 19:56:46 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S229872AbjIET4s (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 5 Sep 2023 15:56:48 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:40200 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S234122AbjIET4q (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 5 Sep 2023 15:56:46 -0400
Received: from mout.gmx.net (mout.gmx.net [212.227.17.22])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 7E191AB;
        Tue,  5 Sep 2023 12:56:42 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=gmx.us;
 s=s31663417; t=1693943801; x=1694548601; i=fan.ni@gmx.us;
 bh=fH5fl2iT7bJK58HYQS61E8lV0EElinXPEGRDeSG774o=;
 h=X-UI-Sender-Class:Date:From:To:Cc:Subject:References:In-Reply-To;
 b=sIbOg/13QgrWZTAnXi+N/5zBxKEmvxiMSSTzrJ2p5jw97RUc1M4V2EMk0RckDttucTbxDXD
 UWuCQ8bpb1ObvHtk+yePEB6ZdoQ130dOCURiqYOe1Rp0UvcPSKKW05buNFPfWrkNcNd2q+sxD
 n8scVq4ytZPy3PVqVRj5fxERVYUbLC/XxAMjyCDsUyw1pMiybRo5//NwHo5s/sil7ybkQV0iL
 NArbTJ02b1kFnD7ODROBMFZc9z2wDt7+Mm0rEtu2JI0rj9zywibRPoKvGFV9Wj+V33CnrxOt9
 AKDxG6op/sYvr2XZRfsG53lXQN/EiyU7bXl3pYxvouLuN8bpy8NA==
X-UI-Sender-Class: 724b4f7f-cbec-4199-ad4e-598c01a50d3a
Received: from debian ([50.205.20.42]) by mail.gmx.net (mrgmx104
 [212.227.17.174]) with ESMTPSA (Nemesis) id 1MORAU-1qI4sX1A10-00Pxua; Tue, 05
 Sep 2023 19:55:23 +0200
Date: Tue, 5 Sep 2023 10:55:12 -0700
From: Fan Ni <fan.ni@gmx.us>
To: Jonathan Cameron <Jonathan.Cameron@huawei.com>
Cc: ira.weiny@intel.com, Dan Williams <dan.j.williams@intel.com>,
        Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        linux-cxl@vger.kernel.org, linux-kernel@vger.kernel.org
Subject: Re: [PATCH RFC v2 07/18] cxl/mem: Expose device dynamic capacity
 configuration
Message-ID: <ZPdrgN9mt8oIxil0@debian>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
 <20230604-dcd-type2-upstream-v2-7-f740c47e7916@intel.com>
 <20230829161449.00000c7a@Huawei.com>
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: <20230829161449.00000c7a@Huawei.com>
X-Provags-ID: V03:K1:7FPfXhisLSI5kaGGZv7QSee2tVduCM+GGxg07v26LnQxmJb/e2Y
 FbZ8OozFEEM/40NKV6fLI4a0kSuNBMG2KRFpV0QCAvoUha4X23E0SGNyxQIp1nHuLTTRsGN
 Xbselzcygt4H8Lt0lP94xfuCecNICDqX8Ozo9sB2RSPL1ORa/wVptzyNvMAyJqFpqQ2kfg+
 /DGjsm5aILKhJGgxS1baw==
UI-OutboundReport: notjunk:1;M01:P0:0w8GjRTky48=;3F3nJFdQAnPV2FCoraDBQRYPbdV
 7rV9e5EKoIgOHv+HKfvO8zPNGqFgSK6wAoVAlT8O3UrrhwUysgQzKDGXerQVMSk4gxI86inKa
 Zi3sDFMwevK0FN3dcwdkKu6zEBcrQoS/NIMyPqSnvf66cgEW8RNzPWpkRMalwr79pSTnWrB2C
 jfPbGofYzTHinYisduwUoyZUE5pgJc01E5unlidWOwdXWGRzkDhVxGl5nZfYLPofculBCYcRy
 Ji/siB7unuefEdiyg3D/aeQRPjc1AU3z4csPDubGBjIGU+MrQydr+QOKYgxx5vYgkbeLXV64o
 hnHjuRno0daFZvEmP1b2pIlcFZRMBpELtbBxs4k1itSCovvewhiORZrF9DsJsa7L4s+fYCAAN
 YfMmc5QY4MdGZXjidFf4ldGH9gWc0CxBs8kyeS06NPR4n7sMD+s0oNs0pgvyFKjZ+3gYyC3lb
 fmqNWD01kwgeiLmiYTzN/QhdFczpwmpmuhdh7RXV18GGqssTE+G6BMrlC+JizwST3ZgkQpbep
 fJA2SO91FLS8uOqTC79UrsgFXhUbodgOHriWMrkWSwY09uBEZtIUAUkjQ3XDAGP/84ihE7SHK
 les8bAY8b4WAHzCG8fadBSsC+VVhebpstN2H+CcjzfD2Ww5j7ZcyKS0h+XF85a/FjgHcrBkNy
 UTBGCKwx+qMX6cCwaXvIcqowSSxSdg327GivaLDAFoc0496s5IH+s63pZ6jd6cG+JoIl3uTA/
 2z2CUEs87uflfU7SfsxoVhMNGFQ3AdAQXNsIYwmGreojaOnZWxesBEdXGc5ym+pfX3clQusbx
 4WO9basreyl/vRFLxxBRy+J7EJrPQvqNnfm0YIOt0zI6qZUfPo8186i2L7PI3KO3/UeY1Y7KO
 YFDjvWl8dh7FDh5LHqi9QltjmQVgUI6Pfv1/fa4RrTe/MZUbTJAq95k9kP4pd32k5Ijm1oOFG
 jz64tAXnRH2bGBItDH2SbY7knQ8=
Content-Transfer-Encoding: quoted-printable
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

On Tue, Aug 29, 2023 at 04:14:49PM +0100, Jonathan Cameron wrote:
> On Mon, 28 Aug 2023 22:20:58 -0700
> ira.weiny@intel.com wrote:
>
> > From: Navneet Singh <navneet.singh@intel.com>
> >
> > To properly configure CXL regions on Dynamic Capacity Devices (DCD),
> > user space will need to know the details of the DC Regions available o=
n
> > a device.
> >
> > Expose driver dynamic capacity configuration through sysfs
> > attributes.
> >
> > Co-developed-by: Navneet Singh <navneet.singh@intel.com>
> > Signed-off-by: Navneet Singh <navneet.singh@intel.com>
> > Signed-off-by: Ira Weiny <ira.weiny@intel.com>
> >
> One trivial comment inline.  I wondered a bit if it would
> be better to not present dc at all on devices that don't support
> dynamic capacity, but for now there isn't an elegant way to do that
> (some discussions and patches are flying around however so maybe this
>  will be resolved before this series merges giving us that elegant
>  option).
>
> With commented code tidied up
> Reviewed-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
>

Agreed. It makes more sense to not show dc at all.
Other than that, looks good to me.

Reviewed-by: Fan Ni <fan.ni@samsung.com>

>
> > ---
> > Changes for v2:
> > [iweiny: Rebased on latest master/type2 work]
> > [iweiny: add documentation for sysfs entries]
> > [iweiny: s/dc_regions_count/region_count/]
> > [iweiny: s/dcY_size/regionY_size/]
> > [alison: change size format to %#llx]
> > [iweiny: change count format to %d]
> > [iweiny: Formatting updates]
> > [iweiny: Fix crash when device is not a mem device: found with cxl-tes=
t]
> > ---
> >  Documentation/ABI/testing/sysfs-bus-cxl | 17 ++++++++
> >  drivers/cxl/core/memdev.c               | 77 ++++++++++++++++++++++++=
+++++++++
> >  2 files changed, 94 insertions(+)
> >
> > diff --git a/Documentation/ABI/testing/sysfs-bus-cxl b/Documentation/A=
BI/testing/sysfs-bus-cxl
> > index 2268ffcdb604..aa65dc5b4e13 100644
> > --- a/Documentation/ABI/testing/sysfs-bus-cxl
> > +++ b/Documentation/ABI/testing/sysfs-bus-cxl
> > @@ -37,6 +37,23 @@ Description:
> >  		identically named field in the Identify Memory Device Output
> >  		Payload in the CXL-2.0 specification.
> >
> > +What:		/sys/bus/cxl/devices/memX/dc/region_count
> > +Date:		July, 2023
> > +KernelVersion:	v6.6
> > +Contact:	linux-cxl@vger.kernel.org
> > +Description:
> > +		(RO) Number of Dynamic Capacity (DC) regions supported on the
> > +		device.  May be 0 if the device does not support Dynamic
> > +		Capacity.
> > +
> > +What:		/sys/bus/cxl/devices/memX/dc/regionY_size
> > +Date:		July, 2023
> > +KernelVersion:	v6.6
> > +Contact:	linux-cxl@vger.kernel.org
> > +Description:
> > +		(RO) Size of the Dynamic Capacity (DC) region Y.  Only
> > +		available on devices which support DC and only for those
> > +		region indexes supported by the device.
> >
> >  What:		/sys/bus/cxl/devices/memX/serial
> >  Date:		January, 2022
> > diff --git a/drivers/cxl/core/memdev.c b/drivers/cxl/core/memdev.c
> > index 492486707fd0..397262e0ebd2 100644
> > --- a/drivers/cxl/core/memdev.c
> > +++ b/drivers/cxl/core/memdev.c
> > @@ -101,6 +101,20 @@ static ssize_t pmem_size_show(struct device *dev,=
 struct device_attribute *attr,
> >  static struct device_attribute dev_attr_pmem_size =3D
> >  	__ATTR(size, 0444, pmem_size_show, NULL);
> >
> > +static ssize_t region_count_show(struct device *dev, struct device_at=
tribute *attr,
> > +				 char *buf)
> > +{
> > +	struct cxl_memdev *cxlmd =3D to_cxl_memdev(dev);
> > +	struct cxl_memdev_state *mds =3D to_cxl_memdev_state(cxlmd->cxlds);
> > +	int len =3D 0;
> > +
> > +	len =3D sysfs_emit(buf, "%d\n", mds->nr_dc_region);
> > +	return len;
>
> return sysfs_emit(buf, "...);
>
> > +}
> > +
> > +struct device_attribute dev_attr_region_count =3D
> > +	__ATTR(region_count, 0444, region_count_show, NULL);
> > +
> >  static ssize_t serial_show(struct device *dev, struct device_attribut=
e *attr,
> >  			   char *buf)
> >  {
> > @@ -454,6 +468,62 @@ static struct attribute *cxl_memdev_security_attr=
ibutes[] =3D {
> >  	NULL,
> >  };
> >
> > +static ssize_t show_size_regionN(struct cxl_memdev *cxlmd, char *buf,=
 int pos)
> > +{
> > +	struct cxl_memdev_state *mds =3D to_cxl_memdev_state(cxlmd->cxlds);
> > +
> > +	return sysfs_emit(buf, "%#llx\n", mds->dc_region[pos].decode_len);
> > +}
> > +
> > +#define REGION_SIZE_ATTR_RO(n)						\
> > +static ssize_t region##n##_size_show(struct device *dev,		\
> > +				     struct device_attribute *attr,	\
> > +				     char *buf)				\
> > +{									\
> > +	return show_size_regionN(to_cxl_memdev(dev), buf, (n));		\
> > +}									\
> > +static DEVICE_ATTR_RO(region##n##_size)
> > +REGION_SIZE_ATTR_RO(0);
> > +REGION_SIZE_ATTR_RO(1);
> > +REGION_SIZE_ATTR_RO(2);
> > +REGION_SIZE_ATTR_RO(3);
> > +REGION_SIZE_ATTR_RO(4);
> > +REGION_SIZE_ATTR_RO(5);
> > +REGION_SIZE_ATTR_RO(6);
> > +REGION_SIZE_ATTR_RO(7);
> > +
> > +static struct attribute *cxl_memdev_dc_attributes[] =3D {
> > +	&dev_attr_region0_size.attr,
> > +	&dev_attr_region1_size.attr,
> > +	&dev_attr_region2_size.attr,
> > +	&dev_attr_region3_size.attr,
> > +	&dev_attr_region4_size.attr,
> > +	&dev_attr_region5_size.attr,
> > +	&dev_attr_region6_size.attr,
> > +	&dev_attr_region7_size.attr,
> > +	&dev_attr_region_count.attr,
> > +	NULL,
> > +};
> > +
> > +static umode_t cxl_dc_visible(struct kobject *kobj, struct attribute =
*a, int n)
> > +{
> > +	struct device *dev =3D kobj_to_dev(kobj);
> > +	struct cxl_memdev *cxlmd =3D to_cxl_memdev(dev);
> > +	struct cxl_memdev_state *mds =3D to_cxl_memdev_state(cxlmd->cxlds);
> > +
> > +	/* Not a memory device */
> > +	if (!mds)
> > +		return 0;
> > +
> > +	if (a =3D=3D &dev_attr_region_count.attr)
> > +		return a->mode;
> > +
> > +	if (n < mds->nr_dc_region)
> > +		return a->mode;
> > +
> > +	return 0;
> > +}
> > +
> >  static umode_t cxl_memdev_visible(struct kobject *kobj, struct attrib=
ute *a,
> >  				  int n)
> >  {
> > @@ -482,11 +552,18 @@ static struct attribute_group cxl_memdev_securit=
y_attribute_group =3D {
> >  	.attrs =3D cxl_memdev_security_attributes,
> >  };
> >
> > +static struct attribute_group cxl_memdev_dc_attribute_group =3D {
> > +	.name =3D "dc",
> > +	.attrs =3D cxl_memdev_dc_attributes,
> > +	.is_visible =3D cxl_dc_visible,
> > +};
> > +
> >  static const struct attribute_group *cxl_memdev_attribute_groups[] =
=3D {
> >  	&cxl_memdev_attribute_group,
> >  	&cxl_memdev_ram_attribute_group,
> >  	&cxl_memdev_pmem_attribute_group,
> >  	&cxl_memdev_security_attribute_group,
> > +	&cxl_memdev_dc_attribute_group,
> >  	NULL,
> >  };
> >
> >
>

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id EFC5FCA0FFD
	for <linux-cxl@archiver.kernel.org>; Tue,  5 Sep 2023 16:24:02 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S245309AbjIEQYB (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 5 Sep 2023 12:24:01 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:39204 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1347822AbjIEEc7 (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 5 Sep 2023 00:32:59 -0400
Received: from mgamail.intel.com (mgamail.intel.com [192.55.52.120])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 5A95DCC7;
        Mon,  4 Sep 2023 21:32:55 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1693888375; x=1725424375;
  h=date:from:to:cc:subject:message-id:references:
   in-reply-to:mime-version;
  bh=GeXO9oUqDoCCJAUPxQTKFDJmOVKSEeNtmE0R/2xwhSo=;
  b=PIk2rJCJEn2/S5gkfrPEp7WZVuiBiMAqwu5Pw4zZ7wyjmAx5d7LuPaIa
   XYq99h9nKeSMo+7QdOtNRhn6QN+RZURGvs/AnW9i4kUCDEakUexHmkcAY
   2eareNn2QQQdNngCjJqv0IYACTX47uEwHNXVjyQd/PYgK6bTjNAtuOtmj
   paDHXn4tT1PyH40LOF0VcYLeUwBg2jehR/viIaBzU34pv6zlka4Ug/ohp
   vqHvCUSNEztOLsg9SrIYXfR1dRw1j2cfQkv4vOO7TAvtUSjj/gfGNqqAm
   AVtewbG3cyE8BKdkoKeptEkdp3FE2FAepQxZOHyt08Csva6k9D6WUpAee
   g==;
X-IronPort-AV: E=McAfee;i="6600,9927,10823"; a="375590367"
X-IronPort-AV: E=Sophos;i="6.02,228,1688454000"; 
   d="scan'208";a="375590367"
Received: from orsmga002.jf.intel.com ([10.7.209.21])
  by fmsmga104.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 04 Sep 2023 21:32:54 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10823"; a="740977841"
X-IronPort-AV: E=Sophos;i="6.02,228,1688454000"; 
   d="scan'208";a="740977841"
Received: from orsmsx601.amr.corp.intel.com ([10.22.229.14])
  by orsmga002.jf.intel.com with ESMTP/TLS/AES256-GCM-SHA384; 04 Sep 2023 21:32:54 -0700
Received: from orsmsx610.amr.corp.intel.com (10.22.229.23) by
 ORSMSX601.amr.corp.intel.com (10.22.229.14) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27; Mon, 4 Sep 2023 21:32:53 -0700
Received: from orsmsx612.amr.corp.intel.com (10.22.229.25) by
 ORSMSX610.amr.corp.intel.com (10.22.229.23) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27; Mon, 4 Sep 2023 21:32:53 -0700
Received: from ORSEDG602.ED.cps.intel.com (10.7.248.7) by
 orsmsx612.amr.corp.intel.com (10.22.229.25) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27 via Frontend Transport; Mon, 4 Sep 2023 21:32:53 -0700
Received: from NAM11-DM6-obe.outbound.protection.outlook.com (104.47.57.176)
 by edgegateway.intel.com (134.134.137.103) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.27; Mon, 4 Sep 2023 21:32:53 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=W3ffjQo2mH9piglIEeZ5Cb0vUTIm6cGiwETuXpl3Azj4PdA/nmtsOzYG/loZ0dXxCW5RzqCQswKo6XEml9ty2+UZrDiDctbSjBaW/hFpwOvktAn+NX7hsekzh4lx0RKaj3dGFQxhFfp0sVEKOYUgB7qf5R5pQ09bJv/CpxyUkMwetbDWC7iK6J7M2PTTpoBahiNPqHhjiOVHtbdtf2NlnIMrw5njYt7O6MRvdB5/PGD4iYbUHehU7KEMn/tbUnbMPq/kQA8fTYB5FYzp2t3e0OWqyVbkrD6aJjohVxVfe7HDLFnkJKk2/fmej0ZvBFh70uFa1W0HfBdQRBI4912vlg==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=Y9yvn5TJ+H6OEM6BbXniIe4hKvfx9og6I2U7pT3XYSQ=;
 b=dA/HcDVL5P2QGA1kRWVEgPDcMtUZweyF3CT9sgZ6SEhS7lCi9Q/e12yTKwe5LPDzFxwRbD3rJ/i7lEiVMOv/nD2t7dQTC4fCK/TgIItBPM9B6dw2JhC47fqSx0h/gFAXXMtQVZEqA5gKTl5Z+LXcv9mqgB9hsHmgSb0bj0TUPRtPZVE4nF09i6recCpNh3MceYp6WZOyLf2fUgKy0LDVEDooV+r9PnUGcuObVQCi289jX5PSL2GuqXIauDZquyGqhBNq3AIgEHOUzwfvajjXcXxL28vHkvA+ROcI74g/h/6oYPC338/U6tzgtUHJzj+cYR0Qb2Rnba8hqjg8/JxC3w==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from SA1PR11MB6733.namprd11.prod.outlook.com (2603:10b6:806:25c::17)
 by SA0PR11MB4542.namprd11.prod.outlook.com (2603:10b6:806:9f::20) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.6745.33; Tue, 5 Sep
 2023 04:32:51 +0000
Received: from SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938]) by SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938%6]) with mapi id 15.20.6745.030; Tue, 5 Sep 2023
 04:32:51 +0000
Date: Mon, 4 Sep 2023 21:32:46 -0700
From: Ira Weiny <ira.weiny@intel.com>
To: Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Ira Weiny <ira.weiny@intel.com>
CC: Dan Williams <dan.j.williams@intel.com>,
        Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
Subject: Re: [PATCH RFC v2 06/18] cxl/port: Add Dynamic Capacity size support
 to endpoint decoders
Message-ID: <64f6af6e9316f_1e8e78294d4@iweiny-mobl.notmuch>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
 <20230604-dcd-type2-upstream-v2-6-f740c47e7916@intel.com>
 <20230829160919.00007f69@Huawei.com>
Content-Type: text/plain; charset="us-ascii"
Content-Disposition: inline
In-Reply-To: <20230829160919.00007f69@Huawei.com>
X-ClientProxiedBy: SJ0PR03CA0229.namprd03.prod.outlook.com
 (2603:10b6:a03:39f::24) To SA1PR11MB6733.namprd11.prod.outlook.com
 (2603:10b6:806:25c::17)
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: SA1PR11MB6733:EE_|SA0PR11MB4542:EE_
X-MS-Office365-Filtering-Correlation-Id: 5f851165-9f95-47a0-b8ab-08dbadc92a15
X-LD-Processed: 46c98d88-e344-4ed4-8496-4ed7712e255d,ExtAddr
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;
X-Microsoft-Antispam-Message-Info: 4LBgBtldhf0aWHff5Lazwz40d8bxt3FJYmNXLSe8O+sZd9lD902ijzRhhDTWdOknUlKcC8pLPcekpymDSE455Qy2ZSlVQp1efm2cIj/8wY3uyRi5Eoqk6WvcxIoOuifDo1QMkpgPbFNd9EB8hpmJAWq75sEfSZQfLhJUKAhPyOn3OhEmQA082fnPpf+o9P8vaObDJ1OioAPMTc6C/aEoEiygpFuC+Dw2RPIL3r2R+0Q4OnjadWYs/Mh8MvshUrZe7QyeoQdNJfOrQMaqfqlQmrziPmEFGO3C02dj7oHOIfK97+IBTQsIwdeb/cTzWbeaB9s9UeSUPqtEf5dzlybUwwmZMmuAN5v9MXpfTHLsKZtpC78gTPFSza1aa7/WZCOOugHAFQQYXtyBFsShn8oiRgSW+98i7nxhp/lC67gUVXgtaf6Pn3vW8pbsAyQXYEK3mc2XTwzLEG9PplsD/BaeKSs/78s5B8VNYsdJwuUSZyNgm1SvQEMSk/qOATX2jrA+W3PCujXSy0B4+i8kQAi6k1S8dr/dA9YPziLMsStkZh1psUa2PRwTXIQA6D15Ul0T
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:SA1PR11MB6733.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230031)(366004)(136003)(346002)(376002)(396003)(39860400002)(1800799009)(186009)(451199024)(2906002)(82960400001)(38100700002)(86362001)(6506007)(6512007)(41300700001)(9686003)(6486002)(54906003)(316002)(66476007)(110136005)(66556008)(66946007)(4326008)(8676002)(8936002)(478600001)(6666004)(83380400001)(44832011)(5660300002)(26005);DIR:OUT;SFP:1102;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?us-ascii?Q?K7vi8RZQfC22Ik7AOCdsuVl0g3j83j59dWjsZl7qiOS/0WbVSoTAmiEqwuPM?=
 =?us-ascii?Q?+9N6iLux4T2bCv6Tm2pEkfHFlO0bP5jQviB4T/98Wxr2WL7s+I8cK6bsZF5N?=
 =?us-ascii?Q?qR3BRKh1hV7VgIUBFmSeemk7O2OF57pUuZcuJyzG2jYLbzEEm6AVQS/qoJ1f?=
 =?us-ascii?Q?8y6lQeIboR+0One7dZXXw5tDuH3A+OhyMQN/8G+upmqk5i/lLtQ2Sl1eHpoU?=
 =?us-ascii?Q?Kl99pWGtPHIxPXUze7rjw3iVsM5/JDGNLAHrWyzYTg6e8gOqfqq7kZN7Upil?=
 =?us-ascii?Q?qcXI9NbvyAsEHXSci5v52v1pU6gml40GiddlD/RP/x3rUw9L5j6MWt9A9k5t?=
 =?us-ascii?Q?E4UAvtTFguiPEz5pMeSDf9/NkkRPC3BLGMb82+11jyD59ztgsrF+cJeVCJpE?=
 =?us-ascii?Q?R3LL85xy2ReZf/1u3i+8ajS4b1dr7NEqaftdZ9bFa0bRTm4/+4ZdfOHzSN5T?=
 =?us-ascii?Q?6PoqnTY51KduG9MpUdZ77WIZg3w+DH3Rh2aCcMs18m6zvVSPX9AWjCOyBe2I?=
 =?us-ascii?Q?ONCCCF5d5Kj45QlA6eqcimAPbRnPMdDjEY2U2lWMD/J7ewFMg9LIyI3ttEXE?=
 =?us-ascii?Q?P2ofATLH2xsvCtu1XO7zQkumbyD+izgLqLk3vUrCFu1ssAxpokv7Yp1jgnad?=
 =?us-ascii?Q?3ULUXplMC4h+UI5+QA9Ooi8htu5QCf6omujtOm/TgC3WY1pfYgjUtjw8MJb2?=
 =?us-ascii?Q?3NP/j84d7vMvnKI7TRxZOqFAlL/vQdx2qAWkODONz3e4FV7Gtwm5LUVSUIn6?=
 =?us-ascii?Q?hC/vz3mdx4AyDhXhkhVVToLs0BInOlNatrlBCCTEaTmcevCZx9ZnnatQ1P3j?=
 =?us-ascii?Q?EaG7oht4X8xkDTdHLA0WyoK3UdCDFKF+fJrp7OoYfIwhVFY5YylR/PNDmMrA?=
 =?us-ascii?Q?JeFUrMHeRtxEPn3rJ4KPJLTIlKjRXUjVXVdqsuwRzoZ5uiFFhTNb91bpssAL?=
 =?us-ascii?Q?u5QummnqlheTRBJNUCYs1wI/p9GrmceWjvSBMtmgoSJM4d2+vbM2p5HyxCYp?=
 =?us-ascii?Q?xytWJA4Voykt7InAVyIwqCOj8qj3mWwmCi+UnHVdZU5IeSbg6/d9AHhVK4cc?=
 =?us-ascii?Q?//ZjExXeQQ8Wt9j2mTai7yLkd3itbABXMTsGls/Xdje48kiwit23ThuPEhKQ?=
 =?us-ascii?Q?AQbrzTRGtJelEN9rknWmKEOVXlM63SEgsFka+82b755OkIc2eyOAXu/S2mXf?=
 =?us-ascii?Q?q9DTUydC2V+lBBLaTHCTUR+dypBVYrgWjgwz3q+JLKjiLFI+JIxzdmyJXXAy?=
 =?us-ascii?Q?2krwTzN4iwwEQvdcemBdKSMqKIPvriQGsyouU6MrGlBZVX5wgugyx8SVjzX4?=
 =?us-ascii?Q?mp/bCyXucubB4UMcSDuSs1UrDp8Rd3KqnuRvPvJtUnPRZdOnpg5KRJmxHEew?=
 =?us-ascii?Q?8KwUXTgMMT4qdMqkc2E83sp5iI3Vf1nXMG+dqX+Wdc4Y27EUg2GXNzVAwAVe?=
 =?us-ascii?Q?0r4kIvf/f32YHNH9B2GeyV+MQwR0GzwUqshz6pIeVAIzrJmeCOCAiZM5sknJ?=
 =?us-ascii?Q?Y+VmlAahsEJw1lNVKoxJzs60B0pICOmhTzMtLQvfWS68Ie77lFr4gK21wedR?=
 =?us-ascii?Q?w8BpOALmpElDAzHDE2HgPqlxOxNaigX811tu9Xe0?=
X-MS-Exchange-CrossTenant-Network-Message-Id: 5f851165-9f95-47a0-b8ab-08dbadc92a15
X-MS-Exchange-CrossTenant-AuthSource: SA1PR11MB6733.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 05 Sep 2023 04:32:51.1662
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: NbKq1WjciXKKeOBjW/UHpGv23uhlImf77Fs42EtVag18GD42zLfmrwHTkIZgcVvzE+dWjxSrl09UlK+9m9sg5Q==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: SA0PR11MB4542
X-OriginatorOrg: intel.com
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

Jonathan Cameron wrote:
> On Mon, 28 Aug 2023 22:20:57 -0700
> Ira Weiny <ira.weiny@intel.com> wrote:
> 

[snip]

> > 
> > Co-developed-by: Navneet Singh <navneet.singh@intel.com>
> > Signed-off-by: Navneet Singh <navneet.singh@intel.com>
> > Signed-off-by: Ira Weiny <ira.weiny@intel.com>
> 
> Various minor things noticed inline.

Thanks!

[snip]

> 
> > +
> > +static int cxl_reserve_dpa_skip(struct cxl_endpoint_decoder *cxled,
> > +				resource_size_t base, resource_size_t skipped)
> > +{
> > +	struct cxl_memdev *cxlmd = cxled_to_memdev(cxled);
> > +	struct cxl_port *port = cxled_to_port(cxled);
> > +	struct cxl_dev_state *cxlds = cxlmd->cxlds;
> > +	resource_size_t skip_base = base - skipped;
> > +	resource_size_t size, skip_len = 0;
> > +	struct device *dev = &port->dev;
> > +	int rc, index;
> > +
> > +	size = resource_size(&cxlds->ram_res);
> > +	if (size && skip_base <= cxlds->ram_res.end) {
> 
> This size only used in this if statement I'd just put it inline.

And in the pmem case...

>  
> > +		skip_len = cxlds->ram_res.end - skip_base + 1;
> > +		rc = cxl_request_skip(cxled, skip_base, skip_len);
> > +		if (rc)
> > +			return rc;
> > +		skip_base += skip_len;
> > +	}
> > +
> > +	if (skip_base == base) {
> > +		dev_dbg(dev, "skip done!\n");
> 
> Not sure that dbg is much help as other places below where skip also done...

Ok.

> 
> > +		return 0;
> > +	}
> > +
> > +	size = resource_size(&cxlds->pmem_res);
> > +	if (size && skip_base <= cxlds->pmem_res.end) {
> 
> size only used in this if statement. I'd just put
> the resource_size() bit inline.

Ah ok.  I think the line length was the issue here.

I'm ok taking the variable out.

> 
> > +		skip_len = cxlds->pmem_res.end - skip_base + 1;
> > +		rc = cxl_request_skip(cxled, skip_base, skip_len);
> > +		if (rc)
> > +			return rc;
> > +		skip_base += skip_len;
> > +	}
> > +
> > +	index = dc_mode_to_region_index(cxled->mode);
> > +	for (int i = 0; i <= index; i++) {
> > +		struct resource *dcr = &cxlds->dc_res[i];
> > +
> > +		if (skip_base < dcr->start) {
> > +			skip_len = dcr->start - skip_base;
> > +			rc = cxl_request_skip(cxled, skip_base, skip_len);
> > +			if (rc)
> > +				return rc;
> > +			skip_base += skip_len;
> > +		}
> > +
> > +		if (skip_base == base) {
> > +			dev_dbg(dev, "skip done!\n");
> 
> As above - perhaps some more info?

Sure.

> 
> > +			break;
> > +		}
> > +
> > +		if (resource_size(dcr) && skip_base <= dcr->end) {
> > +			if (skip_base > base)
> > +				dev_err(dev, "Skip error\n");
> 
> Not return ?  If there is a reason to carry on, I'd like a comment to say what it is.

Looks like a bug I missed.  thanks!

> 
> > +
> > +			skip_len = dcr->end - skip_base + 1;
> > +			rc = cxl_request_skip(cxled, skip_base, skip_len);
> > +			if (rc)
> > +				return rc;
> > +			skip_base += skip_len;
> > +		}
> > +	}
> > +
> > +	return 0;
> > +}
> > +
> 
> 
> > @@ -492,11 +607,13 @@ static resource_size_t cxl_dpa_freespace(struct cxl_endpoint_decoder *cxled,
> >  					 resource_size_t *start_out,
> >  					 resource_size_t *skip_out)
> >  {
> > +	resource_size_t free_ram_start, free_pmem_start, free_dc_start;
> >  	struct cxl_memdev *cxlmd = cxled_to_memdev(cxled);
> > -	resource_size_t free_ram_start, free_pmem_start;
> >  	struct cxl_dev_state *cxlds = cxlmd->cxlds;
> > +	struct device *dev = &cxled->cxld.dev;
> 
> There is one existing (I think) call to dev_dbg(cxled_dev(cxled) ...
> in this function.  So both should use that here, and should convert that one
> case to using dev.

I think the type 2 stuff is lower priority than this series.  The main reason I
had this series based on that work was due to the split of the memdev state
from the device state.  Because that patch has landed I've rebased this
series on master in hopes of it landing in 6.7 without the type 2
dependency.

As such this code got moved to __cxl_dpa_reserve().

> 
> >  	resource_size_t start, avail, skip;
> >  	struct resource *p, *last;
> > +	int index;
> >  
> >  	lockdep_assert_held(&cxl_dpa_rwsem);
> >  
> > @@ -514,6 +631,20 @@ static resource_size_t cxl_dpa_freespace(struct cxl_endpoint_decoder *cxled,
> >  	else
> >  		free_pmem_start = cxlds->pmem_res.start;
> >  
> > +	/*
> > +	 * Limit each decoder to a single DC region to map memory with
> > +	 * different DSMAS entry.
> > +	 */
> > +	index = dc_mode_to_region_index(cxled->mode);
> > +	if (index >= 0) {
> > +		if (cxlds->dc_res[index].child) {
> > +			dev_err(dev, "Cannot allocate DPA from DC Region: %d\n",
> > +				index);
> > +			return -EINVAL;
> > +		}
> > +		free_dc_start = cxlds->dc_res[index].start;
> > +	}
> > +
> >  	if (cxled->mode == CXL_DECODER_RAM) {
> >  		start = free_ram_start;
> >  		avail = cxlds->ram_res.end - start + 1;
> > @@ -535,6 +666,29 @@ static resource_size_t cxl_dpa_freespace(struct cxl_endpoint_decoder *cxled,
> >  		else
> >  			skip_end = start - 1;
> >  		skip = skip_end - skip_start + 1;
> > +	} else if (cxl_decoder_mode_is_dc(cxled->mode)) {
> > +		resource_size_t skip_start, skip_end;
> > +
> > +		start = free_dc_start;
> > +		avail = cxlds->dc_res[index].end - start + 1;
> > +		if ((resource_size(&cxlds->pmem_res) == 0) || !cxlds->pmem_res.child)
> 
> Previous patch used !resource_size()
> I prefer compare with 0 like you have here, but which ever is chosen, things should
> be consistent.
> 
> ...
> 

Yea good point.  I audited the series for this and made the change.

Ira

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 983A5C71153
	for <linux-cxl@archiver.kernel.org>; Tue,  5 Sep 2023 00:14:35 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S237503AbjIEAOh (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Mon, 4 Sep 2023 20:14:37 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:33516 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S232553AbjIEAOg (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Mon, 4 Sep 2023 20:14:36 -0400
Received: from mgamail.intel.com (mgamail.intel.com [134.134.136.31])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 38903E6;
        Mon,  4 Sep 2023 17:14:33 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1693872873; x=1725408873;
  h=date:from:to:cc:subject:message-id:references:
   in-reply-to:mime-version;
  bh=jXTml8ROylRcpxrDeh4M3sSBh0Z2uZU+fib1foNMrZI=;
  b=JiKnljQaa1iOZNIj2ltzZ48Bjvx7ILRH0jlCyXmRAWVLdJ3dO8Ts+Dak
   4wF+UjOT3fzHCSodCfUp7CyD21UdZpVv0MCori9EG0+tjlvIWzHN+6zQd
   I3dKoiX2eWqydhdClPeQYLSA4YVnnqU730EDFOMYCnrDk1QlxFwv+qjGF
   2Z3Rim7ukjYLR9rgGiTFrR/ccug63mPNyAhvHMfn+71IDrSD9ze1aiOBy
   4irrSNxeUq7GamU4Flii/D7tHNGjhWnNROY1DDnzQb7JfQzb9z/AdjX4v
   MhZVEuiegXzTtn1+bx9t+wV1NmNmlBD779kefsLNwKjcEanb9d7Z4F0r7
   w==;
X-IronPort-AV: E=McAfee;i="6600,9927,10823"; a="440643559"
X-IronPort-AV: E=Sophos;i="6.02,227,1688454000"; 
   d="scan'208";a="440643559"
Received: from fmsmga008.fm.intel.com ([10.253.24.58])
  by orsmga104.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 04 Sep 2023 17:14:32 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10823"; a="806391108"
X-IronPort-AV: E=Sophos;i="6.02,227,1688454000"; 
   d="scan'208";a="806391108"
Received: from fmsmsx601.amr.corp.intel.com ([10.18.126.81])
  by fmsmga008.fm.intel.com with ESMTP/TLS/AES256-GCM-SHA384; 04 Sep 2023 17:14:32 -0700
Received: from fmsmsx610.amr.corp.intel.com (10.18.126.90) by
 fmsmsx601.amr.corp.intel.com (10.18.126.81) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27; Mon, 4 Sep 2023 17:14:31 -0700
Received: from FMSEDG603.ED.cps.intel.com (10.1.192.133) by
 fmsmsx610.amr.corp.intel.com (10.18.126.90) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27 via Frontend Transport; Mon, 4 Sep 2023 17:14:31 -0700
Received: from NAM11-DM6-obe.outbound.protection.outlook.com (104.47.57.171)
 by edgegateway.intel.com (192.55.55.68) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.27; Mon, 4 Sep 2023 17:14:31 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=Sh0uHGa+5UcMfWHlonWc1ADcRBDH0WKwDYmwSoNrN23Nrjrs4krkf1c2PtwdZGjG5wTdl5VVelI4sA601CnKlXMphxpjK6rb8Bfpo87s9YvRWUV5iC/778xweny8TFq+63rpd6y+2yZ99xmYANoRLnrz//zare3FTfszavkSEgFPZKdohDR9SIucxT2a8kzDvWjZolgqHLg7m5gwtoVYjVj2jepy4hfNPp47izBK2NriaZu03CwDDDGyTh26DWhAP2syXAsYgVwKaRq2n5+F3s53mY/JObwExWeMs44k34bOaF47lw0nf+5mvGQftIRk4Ei5csRyxjlKeWhUw3Ex7w==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=wdqquMmJBgBEhEF2NWtWvZ1hE0FdPMdfjJj3E1oijVU=;
 b=QeRnd+7EMDVgeMMmu3Jz4D/6PqJpyauqLq75ta+ElBi4Q0iMHoTK97sC9SbfDi1PtQmSi5MuNvZy4UwNaxs18vSoOo/wmCRkQYILKcaRMGwOhOMLpzUdgqFAgGr2C/iCgMLA0HSEo56rzLT7Mu8HkeVLeyGY3kfDYQUK+Oe9K4h4p+ajGx3rFyvhlqkn4nbmWuEwuVKSHQjT4N6Oa4TzWfkDVHJH+rLutKXT1xjgniRM9cLwcM2iTezBVpcOyX5CUe9ScIBHStAUXLaPydeJv4Up+X0iSGmaEENm3jrzJwbh+HJXBluOYrECGxendWHjqku5T0/yZ3PWC1H+b1njig==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from SA1PR11MB6733.namprd11.prod.outlook.com (2603:10b6:806:25c::17)
 by SJ1PR11MB6250.namprd11.prod.outlook.com (2603:10b6:a03:459::17) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.6745.33; Tue, 5 Sep
 2023 00:14:29 +0000
Received: from SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938]) by SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938%6]) with mapi id 15.20.6745.030; Tue, 5 Sep 2023
 00:14:29 +0000
Date: Mon, 4 Sep 2023 17:14:25 -0700
From: Ira Weiny <ira.weiny@intel.com>
To: Dave Jiang <dave.jiang@intel.com>, <ira.weiny@intel.com>,
        Dan Williams <dan.j.williams@intel.com>
CC: Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Alison Schofield <alison.schofield@intel.com>,
        "Vishal Verma" <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
Subject: Re: [PATCH RFC v2 03/18] cxl/mem: Read Dynamic capacity
 configuration from the device
Message-ID: <64f672e1d4da7_1e8e78294c7@iweiny-mobl.notmuch>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
 <20230604-dcd-type2-upstream-v2-3-f740c47e7916@intel.com>
 <db3bd5d0-640a-b121-f3e7-cfb73dc6c9ff@intel.com>
Content-Type: text/plain; charset="us-ascii"
Content-Disposition: inline
In-Reply-To: <db3bd5d0-640a-b121-f3e7-cfb73dc6c9ff@intel.com>
X-ClientProxiedBy: BYAPR21CA0011.namprd21.prod.outlook.com
 (2603:10b6:a03:114::21) To SA1PR11MB6733.namprd11.prod.outlook.com
 (2603:10b6:806:25c::17)
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: SA1PR11MB6733:EE_|SJ1PR11MB6250:EE_
X-MS-Office365-Filtering-Correlation-Id: 1b79f2df-398e-40fd-9625-08dbada5123c
X-LD-Processed: 46c98d88-e344-4ed4-8496-4ed7712e255d,ExtAddr
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;
X-Microsoft-Antispam-Message-Info: momsah3LATqOzkejOc7qv/vqZvilw9EgXpnTiqmidipAkRc5jcMI2Gs+7GTnltOefTle/EJU3i/dxYOTCDpWYrLsiwxBepg0+QoIj6jlV4q4jf2CIDiF0ESleKnfHAVusIY1qXq6QhUEx4Q1G4Af26SOfXXKpe5q7ibKuOvykGeydbP9h2nL9MtbZYI5osfyRwCC4UxP4AxFtg9oIrt8lhQlq7YpXuXtSawLjJsn48MowM8rhgrJ6NXLai3BQAGkS16xollI/vaDlN9KyBhDQQ2tDTB/J6tVF6+8YKucdrEnYcKhaVxjRtSEGhemroqi7s5GVg0Fv0nDLG58B13dVLeG5GfjBFLTHJvCwkX2S+qNIZjj4voZ2KHNY4ZeOF76z87w9Txeaa9af7hMs+MtBzJl0muyLLpOrQF+3tLJHYjvyLC/vm1F5gJUlpcc5MbZ/GL/RU7Wb2CZoZHAIBiJwcywnNSYhnkEssNJShnYBtzV7iBE6Y2qEF767f47UZhLpGfPLTpnW/6gHFDqCPdF4v7tUD5Sc7tgCQag5mCKKcf5DjNIwuTF4kxFngJS06X5
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:SA1PR11MB6733.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230031)(136003)(366004)(39860400002)(346002)(396003)(376002)(1800799009)(451199024)(186009)(2906002)(83380400001)(4744005)(53546011)(6506007)(6486002)(54906003)(6636002)(316002)(66556008)(110136005)(66476007)(66946007)(478600001)(6666004)(5660300002)(26005)(44832011)(41300700001)(6512007)(9686003)(8676002)(4326008)(8936002)(82960400001)(38100700002)(86362001);DIR:OUT;SFP:1102;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?us-ascii?Q?PrVVHHYDNzYmgpRrz7T+13B1A5uA1o+dG7AZ8mxQk+Imm9WmL2E9zOWlc9bc?=
 =?us-ascii?Q?cw/v5BBYBinxux3VCIpfYqAb+HWIyyv7laLNsCV18glcqaLcynP5RA6IO5YO?=
 =?us-ascii?Q?mId0iJ+CwSLS10qwSF5HTENT8Zz53OOFNaP3IwmePjt2Ic54hsBKspsMsure?=
 =?us-ascii?Q?XxlRQUSi/aePGRrmEQoxD/Ma7lQTPKB49H1W4nWTs7cpITMvJ4eLVIdveLzd?=
 =?us-ascii?Q?OCNRY6l98p97vDwEb8Q3OmsCW4w4cWWlZ0fd9IC1ml3zmRMGf18d4DELZ8ej?=
 =?us-ascii?Q?EYi5rhYiApgMkSj6JPRgtvsvtBaPm7gmEKwZuO6E1yynQaMaMJth6xP/5+Qf?=
 =?us-ascii?Q?9oJBm6Y/0zfcycs2tual9R1Q39vas3YTOynG9XWfo23RWIe+ao6hDp/B/mIw?=
 =?us-ascii?Q?1J78hdwm1ciFzODpGrLMs8Dywy4fk2DYwSPDLjxlWwxdTYEp+L2tAKTCE+9U?=
 =?us-ascii?Q?AOY1zW65B72dK1PuxMCrR9TAXumnkJWIW4aEsDdhKihjFJFBGkP8apb3avUr?=
 =?us-ascii?Q?0+M1tAZIiukKo32PIWZEiER0Z4KBWakfayVpXbf74Hb/rBGBs9OUo9Y11gyE?=
 =?us-ascii?Q?fDyQ6O69KmcY0sS/VOB2C1r7uC41BRVmQudXQCp12xyLNPQRj4oo0YCBJxgp?=
 =?us-ascii?Q?swxyCfjW/hsMykzlj31hMHRWyhdeYM3oCN4ilN2m6E6LY50mpA44vPTh7Fgz?=
 =?us-ascii?Q?KYZpLvinrT0MrSPA1JqU0ou+tq1i+dXNfiOAKmhCKGgQ0R5RerJ9uyyu0CeK?=
 =?us-ascii?Q?TcQZ5aNAJe79LcsCrqzLNiBZYyIF42HYaYjxVXNFKP9FegRxJ20EmGwN+/zE?=
 =?us-ascii?Q?wNg+abeLl2wmlAcfY5MP1k/sz71LlyEudgxM/Xo4m96BFzNv4D/CseBLWhwk?=
 =?us-ascii?Q?sn4rFoRfj6ZLsfLdk+iPVhVoGHkOP+xMwItFy1EPfv5adNxuYWZSYy0k5Vxu?=
 =?us-ascii?Q?/rqoAplDj0iHogICWwVVyB2e+xiNd3yJeAFHa/DPHfGLLlpfggYSs2PhrQDG?=
 =?us-ascii?Q?AA6K0VaIvZ/WF/MCMYdxRkwP0ksA9wmNeopEHpi2F+6NeHUJrX23Q2Nsqrz/?=
 =?us-ascii?Q?isTXsNxXLepReaNL/jDAT8DcUPrpO3oqGc9Ei+l+NDRtyEDk4QXnYL82CW76?=
 =?us-ascii?Q?KMDZQ+DbeABKA5D7c5tg9Xqi+MBpwkc59Seatoe8RKVkExUGrCczqAvahXeh?=
 =?us-ascii?Q?wSHOIIe0YXlbq3aYBlP/ra3CmdyRMRSglHP9lBSExmTOH7udMoIZt2k6gjtt?=
 =?us-ascii?Q?8wdSnh5+izZhytDoFPhYTLj6EVv2Umxon1ADIhjwmO+F9kasboEVyoZ4pt+8?=
 =?us-ascii?Q?yVgnWWqtlFzdu3Yy+Wq13geebA/7J2VNu8VMjqnqo1FNXIRcA8sTxQyXAe5b?=
 =?us-ascii?Q?RC53rluUnz2WDc9abXzHFluPa8TOIE5VNuIIAeK+wCBKkUuswe+68F/Fghkx?=
 =?us-ascii?Q?BtzrpukVk3oWe5q7xqx/pI9DccsF9CENZ0faZfJ7c4n/v42ciVM8yuFNTjk6?=
 =?us-ascii?Q?pdVvYN3dFyxIcNniO+fgSneS/i6GKKW087SwS12QBT3OPukkFdjkeu/cTnjW?=
 =?us-ascii?Q?o7lvFiMZ7vhtm2Sm/6Z3gC0YKyBc7sePbUSGtMhY?=
X-MS-Exchange-CrossTenant-Network-Message-Id: 1b79f2df-398e-40fd-9625-08dbada5123c
X-MS-Exchange-CrossTenant-AuthSource: SA1PR11MB6733.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 05 Sep 2023 00:14:29.2372
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: vGvSdOpnRll0AwkSiO9QUq+HWOJzrn4aGcmhFqaBhG45Lj1MyTqi9H9hLEMKFOzf3zB4zlOJzKLFYei+zrkzVg==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: SJ1PR11MB6250
X-OriginatorOrg: intel.com
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

Dave Jiang wrote:
> 
> 
> On 8/28/23 22:20, ira.weiny@intel.com wrote:
> > From: Navneet Singh <navneet.singh@intel.com>
> > 
> > Devices can optionally support Dynamic Capacity (DC).  These devices are
> > known as Dynamic Capacity Devices (DCD).
> > 
> > Implement the DC (opcode 48XXh) mailbox commands as specified in CXL 3.0
> > section 8.2.9.8.9.  Read the DC configuration and store the DC region
> > information in the device state.
> > 
> > Co-developed-by: Navneet Singh <navneet.singh@intel.com>
> > Signed-off-by: Navneet Singh <navneet.singh@intel.com>
> > Signed-off-by: Ira Weiny <ira.weiny@intel.com>
> 
> Uncapitalize Dynamic in subject

Fair enough.

> 
> Also, maybe split out the REGION vs DECODER as a prep patch.

Done per Jonathan.

Thanks for the review.
Ira

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id D80BDC71153
	for <linux-cxl@archiver.kernel.org>; Tue,  5 Sep 2023 00:06:17 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S230416AbjIEAGT (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Mon, 4 Sep 2023 20:06:19 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:49350 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S229810AbjIEAGS (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Mon, 4 Sep 2023 20:06:18 -0400
Received: from mgamail.intel.com (mgamail.intel.com [192.55.52.88])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id AEB7A1B4;
        Mon,  4 Sep 2023 17:06:14 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1693872374; x=1725408374;
  h=date:from:to:cc:subject:message-id:references:
   in-reply-to:mime-version;
  bh=85yZgsLoQSgSzC3B+h9DrHitoPwVtb9Sa+bGVnaTL04=;
  b=KRHeFXv0rFq1uN4R93cvG0ESJlrOOaKLWcA3PqyoMNtk6xm2SGz1sn2O
   lJREL2a4dcMQkP3LT57lsfp3ZnclQlTDuSHVly9Ih+JToQRSsEo2XvAj8
   eiWYPZypmXJ9rpHOQuvKAZy+vBCtwVmqCi+2vHNA1gSDgFZymQj4vSlIo
   82JJIH7VheBQgNN30ELXOHRYYddnmNBJkDrAd6WYWqZ0666SUzhVm57wA
   SE+fo8o8/EoFnlZ9zFlzMCSIQ84kBE70sRrBMJF4z7+x1ylcUgfrt4VXn
   P9pibzt0Nr/ByM2JxUwIvf9RIPQOYouIurLbsa5UXFpPWav/4stfntTRQ
   w==;
X-IronPort-AV: E=McAfee;i="6600,9927,10823"; a="407658276"
X-IronPort-AV: E=Sophos;i="6.02,227,1688454000"; 
   d="scan'208";a="407658276"
Received: from fmsmga008.fm.intel.com ([10.253.24.58])
  by fmsmga101.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 04 Sep 2023 17:06:14 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10823"; a="806389309"
X-IronPort-AV: E=Sophos;i="6.02,227,1688454000"; 
   d="scan'208";a="806389309"
Received: from fmsmsx602.amr.corp.intel.com ([10.18.126.82])
  by fmsmga008.fm.intel.com with ESMTP/TLS/AES256-GCM-SHA384; 04 Sep 2023 17:06:11 -0700
Received: from fmsmsx610.amr.corp.intel.com (10.18.126.90) by
 fmsmsx602.amr.corp.intel.com (10.18.126.82) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27; Mon, 4 Sep 2023 17:06:08 -0700
Received: from fmsedg602.ED.cps.intel.com (10.1.192.136) by
 fmsmsx610.amr.corp.intel.com (10.18.126.90) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27 via Frontend Transport; Mon, 4 Sep 2023 17:06:08 -0700
Received: from NAM12-MW2-obe.outbound.protection.outlook.com (104.47.66.40) by
 edgegateway.intel.com (192.55.55.71) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.27; Mon, 4 Sep 2023 17:06:07 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=QnmDeLAVXAml4xcYdOPAPrBw+bXlevI3xea6E+1c9LK17ywAfF+SvPEdYgfm+KusfhfZvXOrMeDue0iG37K2Mns1xWftHhjdRWQtEEs/lA0wL+K+pdNJ96xJaTzeGblmvJj6nA4hm18iCT/zkUPFroplmOhVlXlewTeFMWZFkTIo183rid5kQbhbYvffGQalSbuIZ2uBPiDslPiN2Oa3CSwEif53WT0NBlJ97x4n2VHCBJEC/GMMcVX6Tn9igx+seiw75kTHJkH7QVFEZjY7xMGz7HSFatbX8jHoRwOhjdlF62xa/N5Y4I+8Rsr6fS8CjZ/38Th+JywnJoaCtMd1Bg==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=LiYk/xvGxs5WaaXiUI9u2arIhd+eq6u15Z9SoWqa5F8=;
 b=ZWmK/A02AEA8/OJRJAfeasT5cF5VzRD3tzD3eWj74M9nuw4MSST50h8xM8q4/aGRLLxfXCd3Cr3EHvIeTqrQy0pxVXaZmYZKbh5um/yOsBcp4LklzoS4LXRcWIL6nIZHLtotabAE5nAahVmiOVnwdbrdhcuwsd0dBNUzYNGZpfNPzN60M3nbNfMBQwHJwbYeu8MbnwoXQPdCBUz36yTGAl5iWJ76fWPu0jx3QSRMRZv0evzXMx8eh8C4SIBqwH3HwuLKVslBxf7D98VmPK1Xq6lY/gIFNQbNjJmsE/p2R47Oa8IChIFDS88tztHcQOR9+fMwGD12xvJeApol681FsQ==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from SA1PR11MB6733.namprd11.prod.outlook.com (2603:10b6:806:25c::17)
 by PH0PR11MB5029.namprd11.prod.outlook.com (2603:10b6:510:30::15) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.6745.32; Tue, 5 Sep
 2023 00:06:05 +0000
Received: from SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938]) by SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938%6]) with mapi id 15.20.6745.030; Tue, 5 Sep 2023
 00:06:05 +0000
Date: Mon, 4 Sep 2023 17:05:59 -0700
From: Ira Weiny <ira.weiny@intel.com>
To: Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Ira Weiny <ira.weiny@intel.com>
CC: Dan Williams <dan.j.williams@intel.com>,
        Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
Subject: Re: [PATCH RFC v2 05/18] cxl/port: Add Dynamic Capacity mode support
 to endpoint decoders
Message-ID: <64f670e7d52e2_1e8e7829411@iweiny-mobl.notmuch>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
 <20230604-dcd-type2-upstream-v2-5-f740c47e7916@intel.com>
 <20230829154945.00002870@Huawei.com>
Content-Type: text/plain; charset="us-ascii"
Content-Disposition: inline
In-Reply-To: <20230829154945.00002870@Huawei.com>
X-ClientProxiedBy: SJ0PR03CA0009.namprd03.prod.outlook.com
 (2603:10b6:a03:33a::14) To SA1PR11MB6733.namprd11.prod.outlook.com
 (2603:10b6:806:25c::17)
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: SA1PR11MB6733:EE_|PH0PR11MB5029:EE_
X-MS-Office365-Filtering-Correlation-Id: 7895447c-89ec-48f8-2d46-08dbada3e5b7
X-LD-Processed: 46c98d88-e344-4ed4-8496-4ed7712e255d,ExtAddr
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;
X-Microsoft-Antispam-Message-Info: PQ8ijpsdCB2OAXAmLHD/FykUhSCtKdkmY7k5IsBSXcTnXn0s4A5e4tulaJRW8mEQFZCM2MrhJblKPnxQO2QI3+07obgDa0QlmBPdk4IleOteTNlCk2bIO9T3tnncU6DAM6kgYCOZcJFHF2nACxbNY9HpoiTiVctVfnWtEpKzI03T/753d8B5X+Uc3wwTH0UODqYRrqH3CZJ8GRNjLxVsd7qClKkALb7m1j1GovuMgNrjo5Si396cC7znaT5ygeQQTAifnq0uiq+bXIc0EZ66CtpXQptELt70wYeRUhzwMZNPKcHnj79irGUQPXGBOf+7gFS4Hw0TqvcPZ6E/OkZZ60QC9Kh2RsMOI6L5wT+kRLQVbh67/LrHKpyBGXWTUvJJ1cfZIuLIjVuOWsr68tKKR7lyJonB2tSoroosT9TGr+BSrxODoNAuq5EUymKT8de8m1zOygU7X7X/alBTkeQca1yk+re/nk14aSxGjyPIXUwkRSezHJVmh/JiqPdIWcEj4Dfu8HsM0jI4fqG6Cm6n8nvFjcNL0Pe7Go9fENkQQ5frZzlftWSS5QZVBHN8oDyN
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:SA1PR11MB6733.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230031)(366004)(396003)(39860400002)(136003)(346002)(376002)(186009)(1800799009)(451199024)(41300700001)(66899024)(6666004)(6486002)(6506007)(478600001)(82960400001)(83380400001)(26005)(9686003)(6512007)(38100700002)(86362001)(66946007)(110136005)(2906002)(66476007)(316002)(54906003)(66556008)(5660300002)(8936002)(44832011)(4326008)(8676002);DIR:OUT;SFP:1102;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?us-ascii?Q?kVOnb3QxVSPLN6bwWDzS2UCgUQlo6sKVd2rGPFlrnsz9duaJ7LBL8mLnGwPp?=
 =?us-ascii?Q?ki43XT7CrxBF86aPDW0mner0Vu9DUSbKhoj8+YpOGp3CTg/3FgR8TjovLPe4?=
 =?us-ascii?Q?zF2xfSslShkOXxAnRVDKn8kwzd2XE0anaO7kxLTgNuHvbzFIgLEpRT3KjZni?=
 =?us-ascii?Q?FMAcpYBMU6a4V8cQaOtTnBbkM5wthc97b35B4+SB+2GcZVC8u3yUiqy69YNm?=
 =?us-ascii?Q?MzpWpK69a27K/P9Myy21Xe/5zzBg24Fi7mW33CLpVFL+f1iEHqaEaEfcRphZ?=
 =?us-ascii?Q?oHRPFUdF1e/ezZOQjCJnw485oMNNbcJ181h2+VRKPk6+OnwcKyotz6+LTG9J?=
 =?us-ascii?Q?k4exX3JMh54UtJB+/sP2KdmWj7urbOYacFhK6pr+kdZ4LqjlZuZ+bu8bzSlx?=
 =?us-ascii?Q?5WEdKoODotnxd4+FFpY0Der6UHqKTp6f0+/rQ2fAeiFhH0hqGN0I4dmF056a?=
 =?us-ascii?Q?ProkSfcEq2IK3WW9bXksb3iXLY7xVt1ebSBT6LR65/xaDceu9dOHC0GvSnab?=
 =?us-ascii?Q?T7a16X1b0cN1v+8VhGoLfKd8aWKvznyYRawAonvEwrKS5qiPhSIUk4MRH6VW?=
 =?us-ascii?Q?P+pDLyc4ctgSgdklulkkvla4vCR7h13SFpQgWbrU94bqK/+yjfNa7YnVRZ17?=
 =?us-ascii?Q?J0/YqJaNObC4Z/RgvZSe7RuQXcFsc+Hok/rCu/j9xPU63XIJ28bJv+6+V8SN?=
 =?us-ascii?Q?lHFxA6DDuHXgW2x5f8OzjXWVo/EgKoIj+Jxn4NvYIHJa+WUwhS3UgI/nQE9q?=
 =?us-ascii?Q?z71RZEklNeCSbhQU+wa/h9VqAus+sKLoXHVZ+R9d66BHeMKv9Ti9KhRqDGDx?=
 =?us-ascii?Q?OTjQo9EhKR1d+NZotOUOkIFt5hN9OoAvkohxl9kmJOkQzcfNLcUTeMqY0iTm?=
 =?us-ascii?Q?HgYvNEmh+BqKSadKqZhD3vM1A9Ttx2OekbLjNtzn79j/z/K7pQ+JozgAwqW4?=
 =?us-ascii?Q?CywVK9kTu8hN+eP6+S/6x0SxP/7Ab1kWJCDdcs+S5FZp/rjpw+TJWHFsWVYP?=
 =?us-ascii?Q?6daMxBVKQRDAFSPn4dd39W1+LfbWjvJQCk1jg45sk3TK8fKIVATqyB08037K?=
 =?us-ascii?Q?yKJreFU7wvw55liJ7GM8m+tA1YFJQZIb7nI0FshKQ983XkaW+kJCorqJIKd3?=
 =?us-ascii?Q?V7bKJVCmM9VLnu7vQNEqMh9mrjav1xu778U9Ji0CmMSZVEmLFlIieD43b2OH?=
 =?us-ascii?Q?xUEXthTQxva/+/bj6kIjUc4Feb7GHbjRkq4NfFSzhTe5klt6fHtTgk3X887w?=
 =?us-ascii?Q?boF7rmkIcdX1PnLKEr8eTGAMFVyC2nECf9jyadZL3/pNk4mglfZm4BooXg34?=
 =?us-ascii?Q?IWYYeNYufASV86EXdLnGTAMh6Q+psAkt5xH+qez9gfVmQPjlujLIaUq+W612?=
 =?us-ascii?Q?EzI3dZtujyGiR6KoJsnSlxcWqxqR8mmY9YwMD0SoYCHLAoawxVbr7pjuF7yT?=
 =?us-ascii?Q?j6LshpNv75mBAHsqEItfXycczHixNnT6JRcjC1ha6EBfx8+X+Ue/b+QGQuS4?=
 =?us-ascii?Q?s/w8KF6lL+GVJrMkIaIktOQPI42Dqx1QfLkRoWK9WiSN84VVuCRG40RrCgma?=
 =?us-ascii?Q?0xFt9vc4YVxCLyl+qALuoAswbEn4mZwZD3t0yj8U?=
X-MS-Exchange-CrossTenant-Network-Message-Id: 7895447c-89ec-48f8-2d46-08dbada3e5b7
X-MS-Exchange-CrossTenant-AuthSource: SA1PR11MB6733.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 05 Sep 2023 00:06:05.0844
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: k4z+JP2ZsVNnzOv/nsnXAs2TcZ6I1XcA28r6FtPsW4ncEOtZLdE3pcI5Xt3kP0DDDsERjl3AT7ShMGsRcU/isg==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: PH0PR11MB5029
X-OriginatorOrg: intel.com
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

Jonathan Cameron wrote:
> On Mon, 28 Aug 2023 22:20:56 -0700
> Ira Weiny <ira.weiny@intel.com> wrote:
> 
> > Endpoint decoders used to map Dynamic Capacity must be configured to
> > point to the correct Dynamic Capacity (DC) Region.  The decoder mode
> > currently represents the partition the decoder points to such as ram or
> > pmem.
> > 
> > Expand the mode to include DC Regions.
> > 
> > Co-developed-by: Navneet Singh <navneet.singh@intel.com>
> > Signed-off-by: Navneet Singh <navneet.singh@intel.com>
> > Signed-off-by: Ira Weiny <ira.weiny@intel.com>
> 
> I'm reading this in a linear fashion for now (and ideally that should
> always make sense) so I don't currently see the reason for the loops
> in here. If they are needed for a future patch, add something to the
> description to indicate that.
> 
> > 
> > ---
> > Changes for v2:
> > [iweiny: split from region creation patch]
> > ---
> >  Documentation/ABI/testing/sysfs-bus-cxl | 19 ++++++++++---------
> >  drivers/cxl/core/hdm.c                  | 24 ++++++++++++++++++++++++
> >  drivers/cxl/core/port.c                 | 16 ++++++++++++++++
> >  3 files changed, 50 insertions(+), 9 deletions(-)
> > 
> > diff --git a/Documentation/ABI/testing/sysfs-bus-cxl b/Documentation/ABI/testing/sysfs-bus-cxl
> > index 6350dd82b9a9..2268ffcdb604 100644
> > --- a/Documentation/ABI/testing/sysfs-bus-cxl
> > +++ b/Documentation/ABI/testing/sysfs-bus-cxl
> > @@ -257,22 +257,23 @@ Description:
> >  
> >  What:		/sys/bus/cxl/devices/decoderX.Y/mode
> >  Date:		May, 2022
> > -KernelVersion:	v6.0
> > +KernelVersion:	v6.0, v6.6 (dcY)
> >  Contact:	linux-cxl@vger.kernel.org
> >  Description:
> >  		(RW) When a CXL decoder is of devtype "cxl_decoder_endpoint" it
> >  		translates from a host physical address range, to a device local
> >  		address range. Device-local address ranges are further split
> > -		into a 'ram' (volatile memory) range and 'pmem' (persistent
> > -		memory) range. The 'mode' attribute emits one of 'ram', 'pmem',
> > -		'mixed', or 'none'. The 'mixed' indication is for error cases
> > -		when a decoder straddles the volatile/persistent partition
> > -		boundary, and 'none' indicates the decoder is not actively
> > -		decoding, or no DPA allocation policy has been set.
> > +		into a 'ram' (volatile memory) range, 'pmem' (persistent
> > +		memory) range, or Dynamic Capacity (DC) range. The 'mode'
> > +		attribute emits one of 'ram', 'pmem', 'dcY', 'mixed', or
> > +		'none'. The 'mixed' indication is for error cases when a
> > +		decoder straddles the volatile/persistent partition boundary,
> > +		and 'none' indicates the decoder is not actively decoding, or
> > +		no DPA allocation policy has been set.
> >  
> >  		'mode' can be written, when the decoder is in the 'disabled'
> > -		state, with either 'ram' or 'pmem' to set the boundaries for the
> > -		next allocation.
> > +		state, with 'ram', 'pmem', or 'dcY' to set the boundaries for
> > +		the next allocation.
> >  
> >  
> >  What:		/sys/bus/cxl/devices/decoderX.Y/dpa_resource
> > diff --git a/drivers/cxl/core/hdm.c b/drivers/cxl/core/hdm.c
> > index a254f79dd4e8..3f4af1f5fac8 100644
> > --- a/drivers/cxl/core/hdm.c
> > +++ b/drivers/cxl/core/hdm.c
> > @@ -267,6 +267,19 @@ static void devm_cxl_dpa_release(struct cxl_endpoint_decoder *cxled)
> >  	__cxl_dpa_release(cxled);
> >  }
> >  
> > +static int dc_mode_to_region_index(enum cxl_decoder_mode mode)
> > +{
> > +	int index = 0;
> > +
> > +	for (int i = CXL_DECODER_DC0; i <= CXL_DECODER_DC7; i++) {
> As you are relying on them being in order and adjacent for the loop, why is
> 
> 	if (mode < CXL_DECODER_DC0 || mode > CXL_DECODER_DC7)
> 		return -EINVAL;
> 
> 	return mode - CXL_DECODER_DC0;
> 
> Not sufficient?

That would work yes.  There is no future need for a loop.  It was just
implemented this way early on and I did not really think about it too
much.

Done.

> 
> > +		if (mode == i)
> > +			return index;
> > +		index++;
> > +	}
> > +
> > +	return -EINVAL;
> > +}
> > +
> >  static int __cxl_dpa_reserve(struct cxl_endpoint_decoder *cxled,
> >  			     resource_size_t base, resource_size_t len,
> >  			     resource_size_t skipped)
> > @@ -429,6 +442,7 @@ int cxl_dpa_set_mode(struct cxl_endpoint_decoder *cxled,
> >  	switch (mode) {
> >  	case CXL_DECODER_RAM:
> >  	case CXL_DECODER_PMEM:
> > +	case CXL_DECODER_DC0 ... CXL_DECODER_DC7:
> >  		break;
> >  	default:
> >  		dev_dbg(dev, "unsupported mode: %d\n", mode);
> > @@ -456,6 +470,16 @@ int cxl_dpa_set_mode(struct cxl_endpoint_decoder *cxled,
> >  		goto out;
> >  	}
> >  
> > +	for (int i = CXL_DECODER_DC0; i <= CXL_DECODER_DC7; i++) {
> > +		int index = dc_mode_to_region_index(i);
> > +
> > +		if (mode == i && !resource_size(&cxlds->dc_res[index])) {
> 
> Not obvious why we have the loop in this patch - perhaps it makes sense later.

I think it was just walking through the DC regions like the previous code
was walking through the PMEM/RAM 'regions'.

> If this is to enable later changes, then good to say that in the patch description.

... nope...

> otherwise, something like.
> 
> 	int index;
> 	
> 	rc = dc_mode_to_region_index(i);
> 	if (rc < 0)
> 		goto out;
> 
> 	index = rc;
> 	if (!resource_size(&cxlds->dc_res[index]) {
> 	....
> 		

Yea...  but that won't exactly work.  Something like this:

diff --git a/drivers/cxl/core/hdm.c b/drivers/cxl/core/hdm.c
index cf5d656c271b..f250d1566682 100644
--- a/drivers/cxl/core/hdm.c
+++ b/drivers/cxl/core/hdm.c
@@ -463,10 +463,12 @@ int cxl_dpa_set_mode(struct cxl_endpoint_decoder *cxled,
                goto out;
        }

-       for (int i = CXL_DECODER_DC0; i <= CXL_DECODER_DC7; i++) {
-               int index = dc_mode_to_region_index(i);
+       if (cxl_decoder_mode_is_dc(mode)) {
+               rc = dc_mode_to_region_index(mode);
+               if (rc < 0)
+                       goto out;

-               if (mode == i && !resource_size(&cxlds->dc_res[index])) {
+               if (!resource_size(&cxlds->dc_res[rc])) {
                        dev_dbg(dev, "no available dynamic capacity\n");
                        rc = -ENXIO;
                        goto out;

But looking at the function I think there could be a clean up patch before
this.  I don't see the need to check the mode twice.

...  Yes I think that looks cleaner.

Thanks for the review!
Ira

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 826C1C71153
	for <linux-cxl@archiver.kernel.org>; Sun,  3 Sep 2023 23:36:33 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1349740AbjICXgf (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Sun, 3 Sep 2023 19:36:35 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:46892 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S229653AbjICXge (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Sun, 3 Sep 2023 19:36:34 -0400
Received: from mgamail.intel.com (mgamail.intel.com [134.134.136.65])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 79216C0;
        Sun,  3 Sep 2023 16:36:30 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1693784190; x=1725320190;
  h=date:from:to:cc:subject:message-id:references:
   in-reply-to:mime-version;
  bh=m4Q8b7uY5d/CHZ0G4A3ZU1b0n4MNJfNsydggkirzrDA=;
  b=QGGfhZqkvjeEkXb/O7jtfTTXIJOL9mDEuXskf0fV6+jwjVDpnmVcllx8
   kZ/6gA1u8APAki1FiH94SOOdD4j9c666pQl5+LDOF+z3AzujkRbs7g5fw
   RgrJc4QeqPX44Fvw6DrCtkqBP8AALq5CH2RuVeefdHeKC3zdKYYAyhmu4
   bW79UocEARSZ7xcTpsT4903KSTHqPJkb2IRITQ9OMKTIWDxADLfb36Zx2
   iq8h0iZsp8EZqWhKSWWnDCByuolnNVhrnuObHrYjH4ELRz1KhRbllpKaN
   JGNPAu23a0CQ1AU6udWbEq3juRkpiH5QubP8AlTfqTChUQl77CdZMlYFB
   w==;
X-IronPort-AV: E=McAfee;i="6600,9927,10822"; a="380279412"
X-IronPort-AV: E=Sophos;i="6.02,225,1688454000"; 
   d="scan'208";a="380279412"
Received: from orsmga004.jf.intel.com ([10.7.209.38])
  by orsmga103.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 03 Sep 2023 16:36:29 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10822"; a="864149932"
X-IronPort-AV: E=Sophos;i="6.02,225,1688454000"; 
   d="scan'208";a="864149932"
Received: from orsmsx603.amr.corp.intel.com ([10.22.229.16])
  by orsmga004.jf.intel.com with ESMTP/TLS/AES256-GCM-SHA384; 03 Sep 2023 16:36:29 -0700
Received: from orsmsx610.amr.corp.intel.com (10.22.229.23) by
 ORSMSX603.amr.corp.intel.com (10.22.229.16) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27; Sun, 3 Sep 2023 16:36:29 -0700
Received: from orsmsx610.amr.corp.intel.com (10.22.229.23) by
 ORSMSX610.amr.corp.intel.com (10.22.229.23) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27; Sun, 3 Sep 2023 16:36:28 -0700
Received: from ORSEDG602.ED.cps.intel.com (10.7.248.7) by
 orsmsx610.amr.corp.intel.com (10.22.229.23) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27 via Frontend Transport; Sun, 3 Sep 2023 16:36:28 -0700
Received: from NAM12-DM6-obe.outbound.protection.outlook.com (104.47.59.176)
 by edgegateway.intel.com (134.134.137.103) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.27; Sun, 3 Sep 2023 16:36:28 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=j1vsD6+Q2+e3sg495fXakEDA/w7c2d3HBVEM9TzJSHblHcr4E8RbldTuMI6EAoZDv/JqKMhLtStLy+wDmxoVFCfXMKlK8Gz98eKzzmdsrmNdhjS7rhkBD0QcEPAGprqVAH3/vy42NCn9uNURr/LlwkiCzaP679QQy1X2DWPkroCsWoNVdBrU23qdhNncYidd3oZtD7S2lJBba2HbPZizMNSu+7f97nPH3rWrEixDUsYxLlG6VoP9N75LTc5GaQ4pnbd2bIH9rwP17ujTOM+6k42WZeM79eoscBHiGPAPhaenvjB0cDN4l2n3sj54UyGuTqyhETxbZvSSHvUOyCzVow==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=G0sF2bh3pCaJqCv8QjRA6ICMMeZQy5/5wlCkjcbOURU=;
 b=AE8AXhuOq+v5NBfcys7B6D24onVZBvugiPFovJr2BVSpBag8N2D0Jgx592yJaikLL/zRQot95E50Rf7Eh0Y+zuhTYGtTs0dPNhv9MmFlD3iUVnLrAGwe1lNQjUG81JKM+Iu/B0JNbD+8vVgF3WnzEOgJH3CPDVZjP5IjxMA36Ksl33yJ1Ysa3akuSEDICbsQBzENIIzrRCVnEAGKYlBJJow5vAL2g2aOyezzO8x3PP6BaGAi95hQ2Dp62KcPoISFwQZHNf7z1+eAyFVTK9ecmlUPr3z082VBhjx7WTCJYpFUZ5chGs+ad1n4POIaHld6cWG6mx5vywxnRz4rKDZOag==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from SA1PR11MB6733.namprd11.prod.outlook.com (2603:10b6:806:25c::17)
 by SA1PR11MB7109.namprd11.prod.outlook.com (2603:10b6:806:2ba::17) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.6745.30; Sun, 3 Sep
 2023 23:36:21 +0000
Received: from SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938]) by SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938%6]) with mapi id 15.20.6745.030; Sun, 3 Sep 2023
 23:36:21 +0000
Date: Sun, 3 Sep 2023 16:36:17 -0700
From: Ira Weiny <ira.weiny@intel.com>
To: Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        <ira.weiny@intel.com>
CC: Dan Williams <dan.j.williams@intel.com>,
        Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
Subject: Re: [PATCH RFC v2 03/18] cxl/mem: Read Dynamic capacity
 configuration from the device
Message-ID: <64f51871e49f6_1e8e78294a6@iweiny-mobl.notmuch>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
 <20230604-dcd-type2-upstream-v2-3-f740c47e7916@intel.com>
 <20230829153714.00000a4c@Huawei.com>
Content-Type: text/plain; charset="us-ascii"
Content-Disposition: inline
In-Reply-To: <20230829153714.00000a4c@Huawei.com>
X-ClientProxiedBy: SJ0PR05CA0175.namprd05.prod.outlook.com
 (2603:10b6:a03:339::30) To SA1PR11MB6733.namprd11.prod.outlook.com
 (2603:10b6:806:25c::17)
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: SA1PR11MB6733:EE_|SA1PR11MB7109:EE_
X-MS-Office365-Filtering-Correlation-Id: 08db49c0-2b4d-442a-b1e2-08dbacd69412
X-LD-Processed: 46c98d88-e344-4ed4-8496-4ed7712e255d,ExtAddr
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;
X-Microsoft-Antispam-Message-Info: rICmZEvMIIlbKojzX2Uv+/fIsgKuAwSBjogknv7QgMvrtbN7wGC4U+MWtk5zxfq4N6wLlpwwgAp/Ccp8Vdy0yVO5UAWAAyPI3OevkisNxPfZHYVZ+N8lRm8PA89FACgGMmP6yNHZFU70eBRJ4Sa9FyT5S7iFeTMMbgz/+gcMuY0PHc7OWZKEuM4vpInGC4gegY3i6VPVfq7tZ2gOWQJ3Mz1bSQtXUp6ea8Y2C9VDK2oC7ARIq5afnYVZD3TwZ+2cIA3ikKrrYq2LQ35OhaKWexsD7IqWEg43d86YFM3y+Vx05q1UA7/TfBioGKSTQ6nUelKmFCZbcLXmMSFN+/3hd5DAPKmkJwBq9DN9PNUyvWl3oqrZDbMjL3MxWEYcdOCujlo0E0qSZfNcpRKZu4YpWo/yD2SNcSx3GhudT5TYasba9hzetaxk19p3JDEPXMnAHHjnKdOLhW0rRCpnTN7bqvhWpk1mtp9CwDlXeixBffeAkXkC+hSCRm+Xsyj0LJrVEmGIwWKQE0dWABgoU05vXlQuXAYEo6TvGOS3D84FBbuMBB2pH/t4mXdAMmjYvWN9y8aJ+EIjArPfHjg3nE/1vh+FwmylRtfdZY6VCp2WZn5caK1DBXsYvaYWluob7yy9
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:SA1PR11MB6733.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230031)(136003)(376002)(39860400002)(396003)(346002)(366004)(1800799009)(451199024)(186009)(8936002)(8676002)(5660300002)(316002)(66476007)(54906003)(2906002)(66556008)(30864003)(66946007)(4326008)(44832011)(41300700001)(6506007)(6486002)(26005)(9686003)(6512007)(38100700002)(82960400001)(6666004)(478600001)(83380400001)(86362001)(461764006);DIR:OUT;SFP:1102;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?us-ascii?Q?AMy4mIHuczlj3JhZZaCOWlLafsf+wrt31Vp4No2HBLcQYAkwlt1CCXMbLdny?=
 =?us-ascii?Q?cbS6GYJeJumwGbacSzBMdFiJV4nrmdo6OLv8rg02xKr3K/U8f5uBv6TQ9P3y?=
 =?us-ascii?Q?wAOsqHIJpA4uT1PKb/HUkIpdfQ11Sh7qlVjY92fFXPvisubBicL7bwOdAS/e?=
 =?us-ascii?Q?LtbJ2/WuAv8BWDA1weGo+htSP8BH2dkBDDi+FzhFVMTPetjz4s9VHrffgrzE?=
 =?us-ascii?Q?dLq/LJlyrzEk+yilJmlEDZut8cvEu135g2EpUfzhRAHO4q/BLSLrX0oGDflP?=
 =?us-ascii?Q?ICqSgJ5RPnhBGXGP9F2DuDQPZvMvf5vipTw0CFEieuGbt4MjSeM/qoNhn9JA?=
 =?us-ascii?Q?Ew5ekN7nuDvEjE4/ktob9VaJhk8nAdmeoSNmST1E0/bCbc8p4G6iO2eFeElM?=
 =?us-ascii?Q?02MhMZM+3iTqeOVM7s551kLgOC6fINLcQxYkT/xsrVUZe1L3wbpwgLQ+PCvg?=
 =?us-ascii?Q?kh0D/m806EdRMwVTAzyF/uY7PiN72YPvW4yiR9y7wASWoq00Aow6r93orPuV?=
 =?us-ascii?Q?QpSJTMfq2BbVjAZuq8TmmPaBjNz3bwUe+YUtgBZdDi7cxoPzOj5DKha7n0dJ?=
 =?us-ascii?Q?DhBcxFdqshCcqx4N9iU1ZF8OUtqOxKUuzMQ0JCa0/uBKa+lIeS9WT28MUayH?=
 =?us-ascii?Q?QnO73zcZ3vkGI+7byi6O++SgCRZMNEocLgmFNHOBPJRctRdUUh6CHs+h/EaO?=
 =?us-ascii?Q?B5gJCq5V6g3YH6FdP8tvEviPNfQ5PXUW2kmx5ZJtS14TMIFid/5D0YTHBQr3?=
 =?us-ascii?Q?qAbJdMiPj1BDcnfAjn+XBWg5Ff7z3WY+uDUwYapqgFEOIAht33OFqf6pModw?=
 =?us-ascii?Q?MrvriMgAUHa5xbgFCit0gFuYU5WGB2xn0gLMh5uGZSblGJMvCV0npHdGIfQP?=
 =?us-ascii?Q?MqfonDdPJ93CzGmjvXqg/xKYByhvC4qIsOf56XAramR/hUAnGLNwRRvzJYIk?=
 =?us-ascii?Q?oowFQc0tSNJdLVgpXsAMeNcBCMeWypnaZyUPJt1r1pkVCCNDYx4XNP2Pg620?=
 =?us-ascii?Q?fW9DkvT040+dF2l3eB1udtXw1th9V5Hui1yyNpnxNPhMOrTvUdFBVayM6Opm?=
 =?us-ascii?Q?3ic4sfMGYY2QSVphnByWUqoAaeh3FoXtYPknvufnGuqOTAryg+NDUX7G/FoO?=
 =?us-ascii?Q?KHrQvslQoOAoZnWpbULA56gbRX3wTGT0pku6uz7ncIdGf3gMuXpBpivX+U3e?=
 =?us-ascii?Q?Bkyjyj1j5vagTlAIsKeTzVSO1JLqtFLShC4LaGSy6St4yJx4sxc6q5pOk4UB?=
 =?us-ascii?Q?Hij0InLLheL7fue0HGlwrXKSLCIc4YCeJ5/IXCMl9UhRH4kPuIkHOzBuZHck?=
 =?us-ascii?Q?RKY5OYlI2BemuP/4f3ziIccdYocVtlRqJNybmIWxgIBuO6QcbpXADr7c2+4c?=
 =?us-ascii?Q?aQpxy4TyLOi2tMQBYySo32rEe6W3q9kLpXE/UrvezjG+OFXcqu8Ure8+fkyN?=
 =?us-ascii?Q?LlhEfwHF5BXl8UU/MEDMJ5501lJ9N5l/jSih6p89vy9xPLrxphPtz/IAbsWb?=
 =?us-ascii?Q?HQh+IM0pbGRb1a4fML+6nAzx1uv+Dc3lNU+/wOpqV9dUw9Pn24dK0JG5U+ge?=
 =?us-ascii?Q?Z+5uSPZ9SaE2BZnKUenSBx5vkudCFDK6rxCrhU/j?=
X-MS-Exchange-CrossTenant-Network-Message-Id: 08db49c0-2b4d-442a-b1e2-08dbacd69412
X-MS-Exchange-CrossTenant-AuthSource: SA1PR11MB6733.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 03 Sep 2023 23:36:21.2518
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: Tby/FSw82xQwwadEQLT/rZBjCnbpVDMkwu9YUrsMiH7EswD/9dCvbGO7o2gh/oVtiBePhOV10t1IJffzJA1M4A==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: SA1PR11MB7109
X-OriginatorOrg: intel.com
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

Jonathan Cameron wrote:
> On Mon, 28 Aug 2023 22:20:54 -0700
> ira.weiny@intel.com wrote:
> 
> > From: Navneet Singh <navneet.singh@intel.com>
> > 
> > Devices can optionally support Dynamic Capacity (DC).  These devices are
> > known as Dynamic Capacity Devices (DCD).
> > 
> > Implement the DC (opcode 48XXh) mailbox commands as specified in CXL 3.0
> > section 8.2.9.8.9.  Read the DC configuration and store the DC region
> > information in the device state.
> > 
> > Co-developed-by: Navneet Singh <navneet.singh@intel.com>
> > Signed-off-by: Navneet Singh <navneet.singh@intel.com>
> > Signed-off-by: Ira Weiny <ira.weiny@intel.com>
> > 
> Hi.
> 
> A few minor things inline.  Otherwise, I wonder if it's worth separating
> the mode of the region from that of the endpoint decoder in a precusor patch.
> That's a large part of this one and not really related to the mbox command stuff.

I've taken some time looking through my backup branches because I thought
this was a separate patch.  I'm feeling like this was a rebase error where
some of the next patch got merged here accidentally.  I agree it seems a
good idea to have it separate but I can't confirm at this point if it was
originally.

Split done.

[snip]

> > +
> > +	rc = dc_resp->avail_region_count - start_region;
> > +
> > +	/*
> > +	 * The number of regions in the payload may have been truncated due to
> > +	 * payload_size limits; if so adjust the count in this query.
> 
> Not adjusting the query.  "if so adjust the returned count to match."

Yep done!

> 
> > +	 */
> > +	if (mbox_cmd.size_out < sizeof(*dc_resp))
> > +		rc = CXL_REGIONS_RETURNED(mbox_cmd.size_out);
> > +
> > +	dev_dbg(dev, "Read %d/%d DC regions\n", rc, dc_resp->avail_region_count);
> > +
> > +	return rc;
> > +}
> > +
> > +/**
> > + * cxl_dev_dynamic_capacity_identify() - Reads the dynamic capacity
> > + *					 information from the device.
> > + * @mds: The memory device state
> > + *
> > + * This will dispatch the get_dynamic_capacity command to the device
> > + * and on success populate structures to be exported to sysfs.
> 
> I'd skip the 'exported to sysfs' as I'd guess this will have other uses
> (maybe) in the longer term.
> 
> and on success populate state structures for later use.

Yea that was poorly worded.  Changed to:

	Read Dynamic Capacity information from the device and populate the
	state structures for later use.

> 
> > + *
> > + * Return: 0 if identify was executed successfully, -ERRNO on error.
> > + */
> > +int cxl_dev_dynamic_capacity_identify(struct cxl_memdev_state *mds)
> > +{
> > +	struct cxl_mbox_dynamic_capacity *dc_resp;
> > +	struct device *dev = mds->cxlds.dev;
> > +	size_t dc_resp_size = mds->payload_size;
> > +	u8 start_region;
> > +	int i, rc = 0;
> > +
> > +	for (i = 0; i < CXL_MAX_DC_REGION; i++)
> > +		snprintf(mds->dc_region[i].name, CXL_DC_REGION_STRLEN, "<nil>");
> > +
> > +	/* Check GET_DC_CONFIG is supported by device */
> > +	if (!test_bit(CXL_DCD_ENABLED_GET_CONFIG, mds->dcd_cmds)) {
> > +		dev_dbg(dev, "unsupported cmd: get_dynamic_capacity_config\n");
> > +		return 0;
> > +	}
> > +
> > +	dc_resp = kvmalloc(dc_resp_size, GFP_KERNEL);                         
> > +	if (!dc_resp)                                                                
> > +		return -ENOMEM;                                                 
> > +
> > +	start_region = 0;
> > +	do {
> > +		int j;
> > +
> > +		rc = cxl_get_dc_id(mds, start_region, dc_resp, dc_resp_size);
> 
> I'd spell out identify.
> Initially I thought this was getting an index.

Actually this is getting the DC configuration.  So I'm changing it to.

cxl_get_dc_config()

> 
> 
> > +		if (rc < 0)
> > +			goto free_resp;
> > +
> > +		mds->nr_dc_region += rc;
> > +
> > +		if (mds->nr_dc_region < 1 || mds->nr_dc_region > CXL_MAX_DC_REGION) {
> > +			dev_err(dev, "Invalid num of dynamic capacity regions %d\n",
> > +				mds->nr_dc_region);
> > +			rc = -EINVAL;
> > +			goto free_resp;
> > +		}
> > +
> > +		for (i = start_region, j = 0; i < mds->nr_dc_region; i++, j++) {
> > +			rc = cxl_dc_save_region_info(mds, i, &dc_resp->region[j]);
> > +			if (rc)
> > +				goto free_resp;
> > +		}
> > +
> > +		start_region = mds->nr_dc_region;
> > +
> > +	} while (mds->nr_dc_region < dc_resp->avail_region_count);
> > +
> > +	mds->dynamic_cap =
> > +		mds->dc_region[mds->nr_dc_region - 1].base +
> > +		mds->dc_region[mds->nr_dc_region - 1].decode_len -
> > +		mds->dc_region[0].base;
> > +	dev_dbg(dev, "Total dynamic capacity: %#llx\n", mds->dynamic_cap);
> > +
> > +free_resp:
> > +	kfree(dc_resp);
> 
> Maybe a first use for __free in cxl?
> 
> See include/linux/cleanup.h
> Would enable returns rather than goto and label.
> 

Good idea.  Done.

> 
> 
> > +	if (rc)
> > +		dev_err(dev, "Failed to get DC info: %d\n", rc);
> 
> I'd prefer to see more specific debug in the few paths that don't already
> print it above.

With the use of __free it kind of went the same way.

Done.

> 
> > +	return rc;
> > +}
> > +EXPORT_SYMBOL_NS_GPL(cxl_dev_dynamic_capacity_identify, CXL);
> > +
> >  static int add_dpa_res(struct device *dev, struct resource *parent,
> >  		       struct resource *res, resource_size_t start,
> >  		       resource_size_t size, const char *type)
> > @@ -1208,8 +1369,12 @@ int cxl_mem_create_range_info(struct cxl_memdev_state *mds)
> >  {
> >  	struct cxl_dev_state *cxlds = &mds->cxlds;
> >  	struct device *dev = cxlds->dev;
> > +	size_t untenanted_mem;
> >  	int rc;
> >  
> > +	untenanted_mem = mds->dc_region[0].base - mds->static_cap;
> > +	mds->total_bytes = mds->static_cap + untenanted_mem + mds->dynamic_cap;
> > +
> >  	if (!cxlds->media_ready) {
> >  		cxlds->dpa_res = DEFINE_RES_MEM(0, 0);
> >  		cxlds->ram_res = DEFINE_RES_MEM(0, 0);
> > @@ -1217,8 +1382,16 @@ int cxl_mem_create_range_info(struct cxl_memdev_state *mds)
> >  		return 0;
> >  	}
> >  
> > -	cxlds->dpa_res =
> > -		(struct resource)DEFINE_RES_MEM(0, mds->total_bytes);
> > +	cxlds->dpa_res = (struct resource)DEFINE_RES_MEM(0, mds->total_bytes);
> 
> Beat back that auto-formater! Or just run it once and fix everything before
> doing anything new.

Will do.

[snip]

> >  
> > @@ -2234,7 +2247,7 @@ static struct cxl_region *cxl_region_alloc(struct cxl_root_decoder *cxlrd, int i
> >   * devm_cxl_add_region - Adds a region to a decoder
> >   * @cxlrd: root decoder
> >   * @id: memregion id to create, or memregion_free() on failure
> > - * @mode: mode for the endpoint decoders of this region
> > + * @mode: mode of this region
> >   * @type: select whether this is an expander or accelerator (type-2 or type-3)
> >   *
> >   * This is the second step of region initialization. Regions exist within an
> > @@ -2245,7 +2258,7 @@ static struct cxl_region *cxl_region_alloc(struct cxl_root_decoder *cxlrd, int i
> >   */
> >  static struct cxl_region *devm_cxl_add_region(struct cxl_root_decoder *cxlrd,
> >  					      int id,
> > -					      enum cxl_decoder_mode mode,
> > +					      enum cxl_region_mode mode,
> >  					      enum cxl_decoder_type type)
> >  {
> >  	struct cxl_port *port = to_cxl_port(cxlrd->cxlsd.cxld.dev.parent);
> > @@ -2254,11 +2267,12 @@ static struct cxl_region *devm_cxl_add_region(struct cxl_root_decoder *cxlrd,
> >  	int rc;
> >  
> >  	switch (mode) {
> > -	case CXL_DECODER_RAM:
> > -	case CXL_DECODER_PMEM:
> > +	case CXL_REGION_RAM:
> > +	case CXL_REGION_PMEM:
> >  		break;
> >  	default:
> > -		dev_err(&cxlrd->cxlsd.cxld.dev, "unsupported mode %d\n", mode);
> 
> Arguably should have been moved to the cxl_decoder_mode_name() in patch 1
> before being changed to cxl_region_mode_name() when the two are separated in this
> patch.  You could just add a note to patch 1 to say 'other instances will be
> covered by refactors shortly'. 

Ah well I've already split that out and sent it.  I was hoping little
things like that could land quickly and we could get to the larger patches
in this series.  For now I'm going to leave it (But split out as part of
the region mode patch).

[snip]

> > diff --git a/drivers/cxl/cxl.h b/drivers/cxl/cxl.h
> > index cd4a9ffdacc7..ed282dcd5cf5 100644
> > --- a/drivers/cxl/cxl.h
> > +++ b/drivers/cxl/cxl.h
> > @@ -374,6 +374,28 @@ static inline const char *cxl_decoder_mode_name(enum cxl_decoder_mode mode)
> >  	return "mixed";
> >  }
> >  
> > +enum cxl_region_mode {
> > +	CXL_REGION_NONE,
> > +	CXL_REGION_RAM,
> > +	CXL_REGION_PMEM,
> > +	CXL_REGION_MIXED,
> > +	CXL_REGION_DEAD,
> > +};
> 
> It feels to me like you could have yanked the introduction and use of cxl_region_mode
> out as a trivial precursor patch with a note saying the separation will be needed
> shortly and why it will be needed.

Yep done.  Like I said I think I had this split out at some point ...
It's immaterial now.

[snip]

> >  
> > +#define CXL_DC_REGION_STRLEN 7
> > +struct cxl_dc_region_info {
> > +	u64 base;
> > +	u64 decode_len;
> > +	u64 len;
> > +	u64 blk_size;
> > +	u32 dsmad_handle;
> > +	u8 flags;
> > +	u8 name[CXL_DC_REGION_STRLEN];
> > +};
> > +
> >  /**
> >   * struct cxl_memdev_state - Generic Type-3 Memory Device Class driver data
> >   *
> > @@ -449,6 +464,8 @@ struct cxl_dev_state {
> >   * @enabled_cmds: Hardware commands found enabled in CEL.
> >   * @exclusive_cmds: Commands that are kernel-internal only
> >   * @total_bytes: sum of all possible capacities
> > + * @static_cap: Sum of RAM and PMEM capacities
> 
> Sum of static RAM and PMEM capacities
> 
> Dynamic cap may well be RAM or PMEM!

Indeed!  Done.

[snip]

> >  
> >  /*
> > @@ -741,9 +771,31 @@ struct cxl_mbox_set_partition_info {
> >  	__le64 volatile_capacity;
> >  	u8 flags;
> >  } __packed;
> > -
> 
> ?

I just missed it when self reviewing.  Fixed.

> 
> >  #define  CXL_SET_PARTITION_IMMEDIATE_FLAG	BIT(0)
> >  
> > +struct cxl_mbox_get_dc_config {
> > +	u8 region_count;
> > +	u8 start_region_index;
> > +} __packed;
> > +
> > +/* See CXL 3.0 Table 125 get dynamic capacity config Output Payload */
> > +struct cxl_mbox_dynamic_capacity {
> 
> Can we rename to make it more clear which payload this is?

Sure.

> 
> > +	u8 avail_region_count;
> > +	u8 rsvd[7];
> > +	struct cxl_dc_region_config {
> > +		__le64 region_base;
> > +		__le64 region_decode_length;
> > +		__le64 region_length;
> > +		__le64 region_block_size;
> > +		__le32 region_dsmad_handle;
> > +		u8 flags;
> > +		u8 rsvd[3];
> > +	} __packed region[];
> > +} __packed;
> > +#define CXL_DYNAMIC_CAPACITY_SANITIZE_ON_RELEASE_FLAG BIT(0)
> > +#define CXL_REGIONS_RETURNED(size_out) \
> > +	((size_out - 8) / sizeof(struct cxl_dc_region_config))
> > +
> >  /* Set Timestamp CXL 3.0 Spec 8.2.9.4.2 */
> >  struct cxl_mbox_set_timestamp_in {
> >  	__le64 timestamp;
> > @@ -867,6 +919,7 @@ enum {
> >  int cxl_internal_send_cmd(struct cxl_memdev_state *mds,
> >  			  struct cxl_mbox_cmd *cmd);
> >  int cxl_dev_state_identify(struct cxl_memdev_state *mds);
> > +int cxl_dev_dynamic_capacity_identify(struct cxl_memdev_state *mds);
> >  int cxl_await_media_ready(struct cxl_dev_state *cxlds);
> >  int cxl_enumerate_cmds(struct cxl_memdev_state *mds);
> >  int cxl_mem_create_range_info(struct cxl_memdev_state *mds);
> 
> ta

ta?

Ira

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id A6CEBC83F2C
	for <linux-cxl@archiver.kernel.org>; Sun,  3 Sep 2023 03:38:30 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S232565AbjICDic (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Sat, 2 Sep 2023 23:38:32 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:38224 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S229938AbjICDib (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Sat, 2 Sep 2023 23:38:31 -0400
Received: from mgamail.intel.com (mgamail.intel.com [134.134.136.100])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 0A15E1B1;
        Sat,  2 Sep 2023 20:38:26 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1693712307; x=1725248307;
  h=date:from:to:cc:subject:message-id:references:
   in-reply-to:mime-version;
  bh=6jb1KHIhmaLH1Pum7U/n5w3MmV+UU1sExE1EZH87fKQ=;
  b=XJy9SMT/jd7v0Gj/9V52I1Ya+En61UP0ak6GUlmL2i4yY/6uon8xUpXo
   UlYKV68p0SQjyHXzj7wI/cMEamvGPPztWjjzKdWdLHirQiqBVG+UYvZip
   /04XRXJkw0z8UyeWKRWTCFpBB7cEgSRqW1XVIy8QJx1sI5uuaXlN+PaD6
   n11zfTZYtaDfowAWFXKixJ0IF1NnrhxD9l2VQ/a38GfbrnoyS0USctJMq
   QYmbD/mgVMWP5IvDYuVRJSRyyr9UHIkFuh5PQdEm72TONHfJCoqHxljO3
   fAPI1vXLRdr8JQfNFxyrDfm5O6dZV1bFKmWfuuB8PmrJ8308pWbHfoqHp
   Q==;
X-IronPort-AV: E=McAfee;i="6600,9927,10821"; a="442822530"
X-IronPort-AV: E=Sophos;i="6.02,223,1688454000"; 
   d="scan'208";a="442822530"
Received: from fmsmga004.fm.intel.com ([10.253.24.48])
  by orsmga105.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 02 Sep 2023 20:38:26 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10821"; a="810506879"
X-IronPort-AV: E=Sophos;i="6.02,223,1688454000"; 
   d="scan'208";a="810506879"
Received: from orsmsx602.amr.corp.intel.com ([10.22.229.15])
  by fmsmga004.fm.intel.com with ESMTP/TLS/AES256-GCM-SHA384; 02 Sep 2023 20:38:26 -0700
Received: from orsmsx610.amr.corp.intel.com (10.22.229.23) by
 ORSMSX602.amr.corp.intel.com (10.22.229.15) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27; Sat, 2 Sep 2023 20:38:25 -0700
Received: from ORSEDG602.ED.cps.intel.com (10.7.248.7) by
 orsmsx610.amr.corp.intel.com (10.22.229.23) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27 via Frontend Transport; Sat, 2 Sep 2023 20:38:25 -0700
Received: from NAM10-BN7-obe.outbound.protection.outlook.com (104.47.70.106)
 by edgegateway.intel.com (134.134.137.103) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.27; Sat, 2 Sep 2023 20:38:19 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=ino8BQrUiCJqpC0155VXmyVKAlNNkm5kOADlUYy7ZlLidFHH/fXiohizD+ar8bS4vGwIFMUv0qN/6KNCSmaK3uLh0XYnYaujPj4P9reWGU7Z85BWYVM0h/bG1nuVkaidISqO3PlIwfT1mK+qarxsS2Dw9fgZnibXGXdEK2Ux97LUZubps4JyJvqiXSaSyaQSdlWT4ytKlHTymvjqEgfB7UOScIZY1xXsNfg8vRNkPCFkiOUc1tZMBe9+/WEyuSRecD52ikDdVORpdgdFEYFmsXYwUybTBUzpS0lmDfGTLyEQXrgtvFFJLnW5efQeFBps6CcLoLAfG0FGrUj3vnIWIQ==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=eqv44CrSdr0bvINbmLYAqw/GnRF2mEfkV+cHcnzeOL4=;
 b=MD0ppDlTpaQwGWP6zKnI2AJQUV1ffLwfrAfg8XnYj/JPWqIoo5LaOro/pDdB1zIZrZGms6BtdET4sPse2dMC6eFyFP1jzt+CxSDCjCw2RfKIRShF9WcbPr8CVz8TzWjPWYdBbBLDFrFGq9uHaDe5yjCLz85dll4GnpU58IvChOJYMxh3FVmqGVaVJxTkdjtEt7XtrTVhtolVCESIQvbxgKQoHe5T65LbDXCk5DqyT4OCUjLd0FcssakPVNueDpkwynZ/I2IP3jmmAaWVgqBkh1lBpgwEvrGtBhRW+VUESa28oC4xn/4OMPJsLon2Lej8aPeFvzS2KpCPRISRsY4lgw==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from SA1PR11MB6733.namprd11.prod.outlook.com (2603:10b6:806:25c::17)
 by CY5PR11MB6305.namprd11.prod.outlook.com (2603:10b6:930:23::18) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.6745.30; Sun, 3 Sep
 2023 03:38:17 +0000
Received: from SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938]) by SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938%6]) with mapi id 15.20.6745.030; Sun, 3 Sep 2023
 03:38:17 +0000
Date: Sat, 2 Sep 2023 20:38:13 -0700
From: Ira Weiny <ira.weiny@intel.com>
To: Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Ira Weiny <ira.weiny@intel.com>
CC: Dan Williams <dan.j.williams@intel.com>,
        Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
Subject: Re: [PATCH RFC v2 02/18] cxl/mbox: Flag support for Dynamic Capacity
 Devices (DCD)
Message-ID: <64f3ffa572f2a_1e8e7829410@iweiny-mobl.notmuch>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
 <20230604-dcd-type2-upstream-v2-2-f740c47e7916@intel.com>
 <20230829150732.00004181@Huawei.com>
Content-Type: text/plain; charset="us-ascii"
Content-Disposition: inline
In-Reply-To: <20230829150732.00004181@Huawei.com>
X-ClientProxiedBy: BY5PR20CA0033.namprd20.prod.outlook.com
 (2603:10b6:a03:1f4::46) To SA1PR11MB6733.namprd11.prod.outlook.com
 (2603:10b6:806:25c::17)
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: SA1PR11MB6733:EE_|CY5PR11MB6305:EE_
X-MS-Office365-Filtering-Correlation-Id: bf3b66a4-d340-4fdb-0fdc-08dbac2f35cc
X-LD-Processed: 46c98d88-e344-4ed4-8496-4ed7712e255d,ExtAddr
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;
X-Microsoft-Antispam-Message-Info: OJvNOqD09bKRSVV7YexluDuRZVUc2DB5HiLLFKIJ1kl9JlKlsl8ZD6pwKHd1oVcAM8jFm3h5/gRmNUDqj8uaYNG+EBs7K9okXifj4ixs31TvIeHuu5W0rAh+lzQHnvYDz0fh+IXlosoGCZS3naf/2gsLfxDHp+6daDISLXPbI+VY6sWZ8RgSKK/pVvUNR8Go120RAQKJua05w1Kr3WhIUqUTjPGrPLqTiiwVKWGsFY9kPzpYlc8h29jPId3EBrsyQNSdoE0FdiTWwVVy9XtIj0HTiGE9VDQseLEiuR5BZQvlubIF43il37NGXvWdh2ODEHFOPUPk4y9EPfbRYnG18EJUvafsNpnCOgQVUSM5pVsUuVFtGThquM8dvmlaktRrDDizLj6APmUFhfQUlJRnKZmHct1BzHEDqvxuYlyVUcmbHutKSTyQq/Subuc6OxK/aon2rSre82TwC1wkCzCdv4MRRkmJ+kO7UwFqJ2zP5NH8iXEELO+7SzuILnfYwdWm/ADBoJiOxjqq0CwfihoRdSIyR2xg0wrzVnNwgA/xlKthJ58pKzmLbwxiQtTzvn9W
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:SA1PR11MB6733.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230031)(376002)(346002)(396003)(366004)(136003)(39860400002)(186009)(1800799009)(451199024)(41300700001)(82960400001)(38100700002)(6666004)(86362001)(478600001)(83380400001)(26005)(9686003)(6512007)(6506007)(6486002)(66946007)(66476007)(2906002)(110136005)(54906003)(316002)(66556008)(8676002)(8936002)(5660300002)(44832011)(4326008);DIR:OUT;SFP:1102;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?us-ascii?Q?RgRbXnF1OIG9QNT7/NnGoHNWUzLPp/Be21kaLxgi8Dc4llKXAGnuqyZ5pbC8?=
 =?us-ascii?Q?1xv5LJ3suBVEOjOIRD7hzqIJLvNif0odJ4VsfDZnx8KsxYoDToaU903raByV?=
 =?us-ascii?Q?07eyOacVyaV6CVuDle1YBmRTU/6KHkVcdg4Io1kEqE0oU2R5VeX98gSq90iO?=
 =?us-ascii?Q?A6QPQ81gvIf4gAVhYnJwhzWCrcH793dRjeS08Kc+Hdcsc7daIncTFU1CJnLd?=
 =?us-ascii?Q?wm7w8aHOAyvpQsQdsNE7dVSodl3YfDKV2czouHhq8cTSeoM294ICvHzJjlml?=
 =?us-ascii?Q?C4jKl/BXg6si06fJuhI3xMnKiFHsUEHZ+GsL6tyoJTaJfia3XDM1HR3Tsib3?=
 =?us-ascii?Q?Qsupq4+nC97PIIMWT+/xyaxntQ0RW2yLGYOUwoVDj1s5lG5WZRS3Q9FKzGld?=
 =?us-ascii?Q?eMHfKwpIKLmmIzPtvkU6lFaZRyEMVbtcKQKC4HqGC2l34g8tB24Ny8Um8a+e?=
 =?us-ascii?Q?o2UroOh33Lvw/wzu4id3iz75bpRu2uHwyv5sDjP6WWMcpP9lhY93YgqVSj8g?=
 =?us-ascii?Q?Ljpu7FwHng+LvqkaLhmU8eSkFGqZ01JGVyzzWCv5MQrZ8oDnpmkOWR2uBUwq?=
 =?us-ascii?Q?NsFGMGxiupB/sSpFm5z71niIm3KJK3lB6zERsg4JoISCg+RiIlQgKQNXXK2P?=
 =?us-ascii?Q?P2Gcn1E9xcEoNz63YBv4/+TYY5QViV4n0Ld75I+6tFuoDC293Vv8EPdMvvf4?=
 =?us-ascii?Q?cn2+Cmk19xMVE3+kr/jVL3qhlSt43wFqUG7peiOfNFkZIov/gu3mXAXBGjWs?=
 =?us-ascii?Q?bKb892+b9fMwPwYL4cdznLwmhyJ5jvLvUKC2snxpvn81hKKsvu9InBFaQZxs?=
 =?us-ascii?Q?z4vy2+Kmxq2mCSNgARfx2Oxg+wNiDAT7lf2f3jDlYIhjYu023fYqHRtGRxGy?=
 =?us-ascii?Q?g8abn0oWddubKSNvDON2b4vROLalBPmEowEQ6maeVqPrONuq/jIFR5ES9nZQ?=
 =?us-ascii?Q?sk4K6f8It6s3IlJGDcS0YvtlzT7S+k89Wbvu/qsAy3sgfHTyD9wlgaG5D2ys?=
 =?us-ascii?Q?+xMV6wDx2WvqMI/WMv7B23amp307ecAz4RYavzvafY/B1SRoc/xAg/1c6xqX?=
 =?us-ascii?Q?yc5NvB5UEQW1C8GmYXyJSYGqhw33nDnweS4Uiw7yp5JZxDADgpmCezFUVUOH?=
 =?us-ascii?Q?CXrM1BG4BzqqsI0IQuyX1dmKFmdYY2cBPhPEGSn2zBfLVzzlCLC7IU485+f4?=
 =?us-ascii?Q?P9nrti4YuQ1VBQhObh6B5cuUEkGsr67r1ex3fZtgtX+cp/hwmrCU3q6xRvc7?=
 =?us-ascii?Q?GV4jLPOx+Sp4xagXSh4TfNzAfYccHCZCURDV4/t1jK/cd6XikFtVIPHu+iBr?=
 =?us-ascii?Q?cfc59eQfdKWgnFzv3v4SuvOc087/wrQy70n4TJPJxMxWU5kXWDWI/IFNhII6?=
 =?us-ascii?Q?60XtSlUXKH5cfiDuE+aHAZqRSMnib605wqz6aGn96IBSyKnjCOSOFryLI0OB?=
 =?us-ascii?Q?VcI+9k+fu8DPX5wBpBLZvI4Ye3nz9PJIr07bEtu1ptbuhI9d7Za3ALZ9o2eZ?=
 =?us-ascii?Q?278vJCJ7Z4muvn0CXivbLfltjbkHqR377uC+ODLMtbeGhkVg7nllRc3OEjZ1?=
 =?us-ascii?Q?2KOp5YE9pB3ygSWqnQwN+YeeXLto7xPfcdyj6w7f?=
X-MS-Exchange-CrossTenant-Network-Message-Id: bf3b66a4-d340-4fdb-0fdc-08dbac2f35cc
X-MS-Exchange-CrossTenant-AuthSource: SA1PR11MB6733.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 03 Sep 2023 03:38:17.2085
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: GwcSS4QaVEshnEAknLw3pT4sKfdOJQydzUTo/u5bZkdRnyLBKmzmUC2MZZuFpavSU3dxog9t6Z+pC3DkJId+uw==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: CY5PR11MB6305
X-OriginatorOrg: intel.com
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

Jonathan Cameron wrote:
> On Mon, 28 Aug 2023 22:20:53 -0700
> Ira Weiny <ira.weiny@intel.com> wrote:
> 
> > Per the CXL 3.0 specification software must check the Command Effects
> > Log (CEL) to know if a device supports DC.  If the device does support
> > DC the specifics of the DC Regions (0-7) are read through the mailbox.
> > 
> > Flag DC Device (DCD) commands in a device if they are supported.
> > Subsequent patches will key off these bits to configure a DCD.
> > 
> > Co-developed-by: Navneet Singh <navneet.singh@intel.com>
> > Signed-off-by: Navneet Singh <navneet.singh@intel.com>
> > Signed-off-by: Ira Weiny <ira.weiny@intel.com>
> > 
> 
> Trivial unrelated change seems to have sneaked in. Other than that
> this looks good to me.
> 
> So with that tidied up.
> 
> Reviewed-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
> 
> 
> Thanks,
> 
> Jonathan
> 
> > +
> >  static bool cxl_is_security_command(u16 opcode)
> >  {
> >  	int i;
> > @@ -677,9 +705,10 @@ static void cxl_walk_cel(struct cxl_memdev_state *mds, size_t size, u8 *cel)
> >  		u16 opcode = le16_to_cpu(cel_entry[i].opcode);
> >  		struct cxl_mem_command *cmd = cxl_mem_find_command(opcode);
> >  
> > -		if (!cmd && !cxl_is_poison_command(opcode)) {
> > -			dev_dbg(dev,
> > -				"Opcode 0x%04x unsupported by driver\n", opcode);
> > +		if (!cmd && !cxl_is_poison_command(opcode) &&
> > +		    !cxl_is_dcd_command(opcode)) {
> > +			dev_dbg(dev, "Opcode 0x%04x unsupported by driver\n",
> > +				opcode);
> 
> Clang format has been playing?
> Better to leave this alone and save reviewers wondering what the change
> in the dev_dbg() was.

Fixed.  Thanks for the review,
Ira

> 
> >  			continue;
> >  		}
> 



From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 12E83C71153
	for <linux-cxl@archiver.kernel.org>; Sun,  3 Sep 2023 02:55:19 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S235071AbjICCzU (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Sat, 2 Sep 2023 22:55:20 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:39050 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S232539AbjICCzT (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Sat, 2 Sep 2023 22:55:19 -0400
Received: from mgamail.intel.com (mgamail.intel.com [192.55.52.115])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 01F13110;
        Sat,  2 Sep 2023 19:55:16 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1693709717; x=1725245717;
  h=date:from:to:cc:subject:message-id:references:
   in-reply-to:mime-version;
  bh=kIrMNhlFv/XKFFRNsEmRNXymCe6XnhPY24lq+XqO/4k=;
  b=gnq0sb7HNWWsK9dOCZ72SZEau+1ue04EpYTwSXT4ExhNxetlidK4kYyg
   1LemRQ+KXcydQBY7kjGAstyxTvi1cHBcCJzgG/ElQt5aHgm6CRHloovOD
   p7NGx/ioD3FapsvoZIbvnHK/9smhjPXG2pAG3bw3vZ6srd5pK7RYjTuAZ
   jE7XmTkIhaUPNevyxnszOUHeaWm8XVjC5qeqMlOvPH4yLd01ca41BhKEl
   01VBsCxnFIDEwJKxbMFEu7J08qWTAyDYs3fCSLvr+Zbms99DB8o1bSizM
   tW5RBQCQs2eoD9iqQ9NPWuyar9iNDlhcqemaBFBreJP2B0HRjTcY9Yq7n
   Q==;
X-IronPort-AV: E=McAfee;i="6600,9927,10821"; a="376349142"
X-IronPort-AV: E=Sophos;i="6.02,223,1688454000"; 
   d="scan'208";a="376349142"
Received: from orsmga008.jf.intel.com ([10.7.209.65])
  by fmsmga103.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 02 Sep 2023 19:55:16 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10821"; a="769623951"
X-IronPort-AV: E=Sophos;i="6.02,223,1688454000"; 
   d="scan'208";a="769623951"
Received: from orsmsx602.amr.corp.intel.com ([10.22.229.15])
  by orsmga008.jf.intel.com with ESMTP/TLS/AES256-GCM-SHA384; 02 Sep 2023 19:55:16 -0700
Received: from orsmsx602.amr.corp.intel.com (10.22.229.15) by
 ORSMSX602.amr.corp.intel.com (10.22.229.15) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27; Sat, 2 Sep 2023 19:55:15 -0700
Received: from ORSEDG602.ED.cps.intel.com (10.7.248.7) by
 orsmsx602.amr.corp.intel.com (10.22.229.15) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27 via Frontend Transport; Sat, 2 Sep 2023 19:55:15 -0700
Received: from NAM11-DM6-obe.outbound.protection.outlook.com (104.47.57.174)
 by edgegateway.intel.com (134.134.137.103) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.27; Sat, 2 Sep 2023 19:55:15 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=ebRCvM1ZK/8jlXnT8Lo9NEID8K81g8380J+ddH3y7ymLCrwFlsr3sfzwG/J9pfLof6uleJMyc+DTeB9SXSorA7OSIbaMfrjb6/NCYJ1hikuNF81mlU99q4nUkPT+VMSWqA+oUZGSarM2NbSIuUIW03UedlDLiTQ/nZfyr1LRLTpon3cHbhUlit6mRD3OsdrUOR4GiWGeQh8wYU7VHqi0t0mCcz1szdcbNTdId68f8dEah23Wm5bLXV/p81KEaUoRNWev9cqu3L91u+BBrtVoA006/ughZGCf4FSqMxrt5Zi6UczHYC1PwQr6cpDXaNbMR9Mlsi6sFcYqJPqSuV3CMw==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=SiXLQ8+lHhRKJSaAIslx4KshpK3448n7WWRZqz5bcfk=;
 b=hXP6E/uRdQ+RikTbepxbwLi0m4HpVGNRfC/ak+uF/uyXpFXlF9JTtltznXhhX5h/TSDJ7XmkHEpVxX20PrkvmXCd/LlxQMW2TaYrtbUeuuKgj9YtBagljJUBr8vD6VwPzziazbzuDNpOMkhy1OSuCCdbAPDTjUlJIsIBR3NF0DRSFxqN5WxckUSSmO2DeatFloTtrm7TKFdW/Tq/uLbpGBC+ZuTJ5PiKs6pGd4yGSFaVqzwZCeiQLdKKCTSPfX1r6UpEcifcX2rmCuDBR2Rre8ItnDSoCnmazd43CfTG5tmn/o2rKpqwu0ZJPwW/T09/5JEqbOGUCGWM6D9TZ3p6kw==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from SA1PR11MB6733.namprd11.prod.outlook.com (2603:10b6:806:25c::17)
 by CY5PR11MB6260.namprd11.prod.outlook.com (2603:10b6:930:23::16) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.6745.30; Sun, 3 Sep
 2023 02:55:12 +0000
Received: from SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938]) by SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938%6]) with mapi id 15.20.6745.030; Sun, 3 Sep 2023
 02:55:12 +0000
Date: Sat, 2 Sep 2023 19:55:09 -0700
From: Ira Weiny <ira.weiny@intel.com>
To: Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Ira Weiny <ira.weiny@intel.com>
CC: Dan Williams <dan.j.williams@intel.com>,
        Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
Subject: Re: [PATCH RFC v2 01/18] cxl/hdm: Debug, use decoder name function
Message-ID: <64f3f58d8405_1e8e7829461@iweiny-mobl.notmuch>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
 <20230604-dcd-type2-upstream-v2-1-f740c47e7916@intel.com>
 <20230829150320.00007f08@Huawei.com>
Content-Type: text/plain; charset="us-ascii"
Content-Disposition: inline
In-Reply-To: <20230829150320.00007f08@Huawei.com>
X-ClientProxiedBy: SJ0PR03CA0148.namprd03.prod.outlook.com
 (2603:10b6:a03:33c::33) To SA1PR11MB6733.namprd11.prod.outlook.com
 (2603:10b6:806:25c::17)
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: SA1PR11MB6733:EE_|CY5PR11MB6260:EE_
X-MS-Office365-Filtering-Correlation-Id: ddb9f702-bf3b-41df-ee41-08dbac29311d
X-LD-Processed: 46c98d88-e344-4ed4-8496-4ed7712e255d,ExtAddr
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;
X-Microsoft-Antispam-Message-Info: M2+qDkq6bYJpxmocBCfIdrRyw+SjyW5jDC2XJvAB2oHHH8uk7GWskDAVZdhAYvJ8wklg8DX9J4ofrDH8v1sBlfp77YoZ69DaIDw8zM+2X/1EgJhjeQXBOjnHJiO8w/PNMW9XVaRP5K2ISqtJegWr3QHzCk3RoSQ1uSVhSnwQQ0fVgO3ag5cD+d9nqC8p/YcgdBv/DU2GZCMwxLfwygKqwWPEfvumMBctnDr+wrPR2+7My4741Ad+TJWfKN5PgYKbHN4yk9piTEZOTrqoPoPAJmjf0Kr7PzgjGEBNJLZ0W7EzjYV8GqJaMtcnRIYVBYVL09fwH193EbZSyovpqvqk9/oDY3dNDWvwT2pkii5wx7kY8ZNjUHANWa6P3FGw6BrjfhXCVblNRSrm+riLw9yDsSI/S5OCeoYqGjjWiDvFk4c8YiYr7qBpBii4GGheoXsSRWiifivnyd9vJiCRHwGzvxD4C8NHLIHPjBh/YyY94HEih69KcRhlNzaxI3dpp1Gev1VaQHqiCZdo2JFy3S804PgRHifQFDJdMwr3dbv0WT0=
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:SA1PR11MB6733.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230031)(376002)(346002)(396003)(366004)(136003)(39860400002)(186009)(1800799009)(451199024)(41300700001)(82960400001)(38100700002)(6666004)(86362001)(966005)(478600001)(26005)(9686003)(6512007)(6506007)(6486002)(66946007)(66476007)(2906002)(110136005)(54906003)(316002)(66556008)(4744005)(8676002)(8936002)(5660300002)(44832011)(4326008);DIR:OUT;SFP:1102;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?us-ascii?Q?N2B2sIUMgPmNOVA9hILfnNq5gQGEh5+bgCdFwNLdTstIKIIJRfSsklULabZy?=
 =?us-ascii?Q?R79nFSGv+CCynIyNgUDcaDHyuWX+t/52wvli6lIkOF13B7oF9vlG98R+mz3Y?=
 =?us-ascii?Q?Cp1EURYH4I1eDbSc0RQMsu7ftl19yX1qTRAst3uKmR/huqJF2pv+rzx5Qydx?=
 =?us-ascii?Q?A2DQEbhP8kSNlG6DB7n4ShGQ1VbQTj0O4Ku+64PunxqywhWHrF1HiAHRxvZk?=
 =?us-ascii?Q?XlJnTEd6NTeJupfGu2ygYju/7I+ad1CJgmyfDNtm+s0canceRPmAvOJJbtSO?=
 =?us-ascii?Q?zfvb0fhZqZElx+TFae7Z228p5yi73EkdBSSDYiQiHt46zdetc4F05PrMtQdi?=
 =?us-ascii?Q?ohgBrmkkyuaoxo9octn629otvLrO0mEz8fvrQmsa3QrOxwKd0cBZzKuA5HnB?=
 =?us-ascii?Q?uMau0fFVLJUxivIkWxiQcaMztOFoV6jWtTJ2uHSJsins2ia2Xd/lzXrfdH4D?=
 =?us-ascii?Q?mkXLOexGCMPDM1r4oezwPmMNSEsQIeqzVIVT0A1Z1YNCjIUks91LUDDgy0at?=
 =?us-ascii?Q?KOx8rkM4Lg6Ol3BHmL5itb8k8S1Pj5xD1EsvUBgwf62ff1yqzwjX3Y3KIoPV?=
 =?us-ascii?Q?0dtCLUUtbOqZuP3PzBotFAZyr5jWNwoea53q6FZaKxuuRr8Tt9caYmRJH2yA?=
 =?us-ascii?Q?PPp+oM/vbubcrk2cEfT5DFH+XmqaRMq/5e2UtxFreFHqg5W/5U294y31BmR1?=
 =?us-ascii?Q?byLYzRi5OokqjIiHvSY4n8rJXRUSzH4gyvqoZyMIk22c0m5S9nj/Bj/46Glg?=
 =?us-ascii?Q?xTsXGCHnfcZmKectKJlHcT3CCboNTdOztWc/f+Hrakzm1gY6Wtkomp1UUa6C?=
 =?us-ascii?Q?U66e2ub4MjCNGtmdwWenTcTtWTfbodJOxp1OSieOQR3DmK2mOQScl/ohnP1d?=
 =?us-ascii?Q?S0J6JrK+20mx/OcAfS2lFBDfa9WF40EORDW8wGQXz8feZfXRR64rad7vx1iA?=
 =?us-ascii?Q?AYHJAIgnQfyx7tInuu8A36JzMw38FA00rKd4iXQnoTLoFahudV3E6RJOzXkT?=
 =?us-ascii?Q?7eDn4ONBEFXK/SLZEebhU4QRSGspdC84KedWRdzlqFuGe7EhJmWbJxu8O4hB?=
 =?us-ascii?Q?w45VwChQCqZLOq3izgC6f897L6eNBFBz2Zaio8iHWFNcTQXOiyUaW3l8oixW?=
 =?us-ascii?Q?ROGmGZKYt9vMsupRM1igHBGzdUKxBg28o5n+mqmeHpNs9fWXsfq9bUeIYKiT?=
 =?us-ascii?Q?PTM/Pmjas5EFcjiYVQFUf+1b6sqLaUp1gs6WcyUcWH5lwRJ0ywYMZCysfTXX?=
 =?us-ascii?Q?Sg9vUqTwZ9JZmijR7PG6a670KfWTA9nJBYm3Dkk4j7EwajIl5+gb9j/UMT6E?=
 =?us-ascii?Q?eX/ZQ6XeUbYdVP4s79ibpXfsYZC83RhAbApL6ibftJz4JOn+7oM0Fq/3wewl?=
 =?us-ascii?Q?44OdHb4xSUYhh2fE2sfgNMh9wSckta1g44BDZmUWI/FsUV7WSdl+EQBg0jgH?=
 =?us-ascii?Q?7RRsQAAS2UG1DTHMVF4ZWQQPQrn9OFKFqJbXy/tBU33GQ5cCMGiIYR7xpLjb?=
 =?us-ascii?Q?S8xX48vbZtR3hfeOYaxSC8iLFRE/9l/aXr9xIn/N8Z3jvEFtme4OoK2gDf33?=
 =?us-ascii?Q?vITytbr25Q+joRP3Ah2k4akG/itO6APGegNghs1H?=
X-MS-Exchange-CrossTenant-Network-Message-Id: ddb9f702-bf3b-41df-ee41-08dbac29311d
X-MS-Exchange-CrossTenant-AuthSource: SA1PR11MB6733.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 03 Sep 2023 02:55:12.2199
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: Or5NoH9ETLw5qVTpiO5zMYJvpYxsziANeWVqMC8NphjEFtNA36O9r0PqtCYbLD/i5hul55W15AKUPsQtMBIThw==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: CY5PR11MB6260
X-OriginatorOrg: intel.com
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

Jonathan Cameron wrote:
> On Mon, 28 Aug 2023 22:20:52 -0700
> Ira Weiny <ira.weiny@intel.com> wrote:
> 
> > The decoder enum has a name conversion function defined now.
> > 
> > Use that instead of open coding.
> > 
> > Suggested-by: Navneet Singh <navneet.singh@intel.com>
> > Signed-off-by: Ira Weiny <ira.weiny@intel.com>
> > 
> 
> Perhaps pull this one out so it can go upstream before the rest are ready,
> or could be picked up from here.

Good idea, sent separately.

https://lore.kernel.org/all/20230902-use-decoder-name-v1-1-06374ed7a400@intel.com/

Ira

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id DB752CA0FE2
	for <linux-cxl@archiver.kernel.org>; Thu, 31 Aug 2023 23:21:00 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S230012AbjHaXVB (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Thu, 31 Aug 2023 19:21:01 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:34988 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1347861AbjHaXVA (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Thu, 31 Aug 2023 19:21:00 -0400
Received: from mgamail.intel.com (mgamail.intel.com [192.55.52.93])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 2057DE56;
        Thu, 31 Aug 2023 16:20:57 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1693524057; x=1725060057;
  h=message-id:date:subject:to:cc:references:from:
   in-reply-to:content-transfer-encoding:mime-version;
  bh=nVwY3owFxZWFpmq91bjVxNX9Sy8kuWwgWNQsf4DpvWs=;
  b=QySyqY2S85P+fUNVLLcyknfOqMz/ylILLAbTEbhRoCSpaSkrk40BvyW+
   DNFKKQKRrdxTOk9phpAHY78ilom+oQW6y9yTOxWw6XNBgNSxRME55UgcJ
   MzFV7jS/wJp1N4t+3fze6T3w9gWVPF7K1zTnKqvfrERo6cMv4PnmKCwNg
   sxWzwnG2/1wqAQZmQNFl8yS1uirtWdPIbFRCiRaa92x0fD55X1AbSUw41
   U0OX6AhpIpjKcj1JPj0PnBOd+QEuPl8BmM1vfQ4aJllapP+BMBZp5dNe1
   lq6zlFGE6r++jFpjtcmcGqkF9BQ0ccCZ7O+YEgkzqfgHlr5t8DPeLQR/Y
   w==;
X-IronPort-AV: E=McAfee;i="6600,9927,10819"; a="373487726"
X-IronPort-AV: E=Sophos;i="6.02,218,1688454000"; 
   d="scan'208";a="373487726"
Received: from orsmga007.jf.intel.com ([10.7.209.58])
  by fmsmga102.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 31 Aug 2023 16:20:56 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10819"; a="733327328"
X-IronPort-AV: E=Sophos;i="6.02,218,1688454000"; 
   d="scan'208";a="733327328"
Received: from fmsmsx602.amr.corp.intel.com ([10.18.126.82])
  by orsmga007.jf.intel.com with ESMTP/TLS/AES256-GCM-SHA384; 31 Aug 2023 16:20:55 -0700
Received: from fmsmsx611.amr.corp.intel.com (10.18.126.91) by
 fmsmsx602.amr.corp.intel.com (10.18.126.82) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27; Thu, 31 Aug 2023 16:20:55 -0700
Received: from fmsmsx602.amr.corp.intel.com (10.18.126.82) by
 fmsmsx611.amr.corp.intel.com (10.18.126.91) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27; Thu, 31 Aug 2023 16:20:54 -0700
Received: from fmsedg601.ED.cps.intel.com (10.1.192.135) by
 fmsmsx602.amr.corp.intel.com (10.18.126.82) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27 via Frontend Transport; Thu, 31 Aug 2023 16:20:54 -0700
Received: from NAM10-BN7-obe.outbound.protection.outlook.com (104.47.70.102)
 by edgegateway.intel.com (192.55.55.70) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.27; Thu, 31 Aug 2023 16:20:54 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=Cl99OgDR1lAXAW8jmFVhkEX6VlXnbW54fe0GOKfON9NSjHhPJS3vJhpbWA5t224pRE/tSGj3807Ug8KAEXIriZL1mqewzz2d2b9wt61I25jppxAoQvfHNJrvvngNW1IvRtBEjmaOfId40I3wu5jQwQsWa/Cpua3ZKCDKb29XwK1+C2Xxm/HTDMUzPe9qzjzh7VPsqJbW/MCIm0lughPlEtR4QaQ5q48UPmrIuzP8TuR6ZzTvbCuz5pHuB3cw36ETWElCn2cVTTouN5xPGIc/cOs/Jfg/37EiNbrrri0tsAv8JoukTGT1rfxFAIHwaZko3zqD/LwmXftaX49cicTMtA==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=hGqYpOA0k2sU0smTtZ6RlcRNoSpQFQumqpY3H3cCKUo=;
 b=OEuGRyGrBSsqOylslD1wu0IUY4JRpVUonxh/GhxdVvikGeHphC6sr8MbcNjxNW3UASOz7GYCUg6wwVKlWgRv+bm564XiDtkfpA8LRO9UtLnpubWhzRyP6JtqLvKD58INlxGEqlnho93Ino2l38AzQxQyKeIfDekzWTSkIT4oSMUT73XXUFOb+xtfgBBQRNjgUw7iNDq1DpiGOoPRMxDvyxJz56OKHy+LR2ZDfvxPoXw08AkhfMPAnKg3kd5EiJEpSAzUNaOJn7s8X0N4kAaKXNiv2zOxyxp8JksYZDUROqqBD7jBmjL1q4E2UdUUu1FL+mqfsN7qzUaG+amGsxx5zQ==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from PH7PR11MB5984.namprd11.prod.outlook.com (2603:10b6:510:1e3::15)
 by CYYPR11MB8407.namprd11.prod.outlook.com (2603:10b6:930:c1::11) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.6745.18; Thu, 31 Aug
 2023 23:20:52 +0000
Received: from PH7PR11MB5984.namprd11.prod.outlook.com
 ([fe80::9563:9642:bbde:293f]) by PH7PR11MB5984.namprd11.prod.outlook.com
 ([fe80::9563:9642:bbde:293f%7]) with mapi id 15.20.6745.022; Thu, 31 Aug 2023
 23:20:52 +0000
Message-ID: <b5ae72a8-baf2-c92b-8174-394c51c33388@intel.com>
Date: Thu, 31 Aug 2023 16:20:49 -0700
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101
 Betterbird/102.13.0
Subject: Re: [PATCH RFC v2 18/18] tools/testing/cxl: Add Dynamic Capacity
 events
To: Ira Weiny <ira.weiny@intel.com>,
        Dan Williams <dan.j.williams@intel.com>
CC: Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Alison Schofield <alison.schofield@intel.com>,
        "Vishal Verma" <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
 <20230604-dcd-type2-upstream-v2-18-f740c47e7916@intel.com>
Content-Language: en-US
From: Dave Jiang <dave.jiang@intel.com>
In-Reply-To: <20230604-dcd-type2-upstream-v2-18-f740c47e7916@intel.com>
Content-Type: text/plain; charset="UTF-8"; format=flowed
Content-Transfer-Encoding: 7bit
X-ClientProxiedBy: BY5PR13CA0016.namprd13.prod.outlook.com
 (2603:10b6:a03:180::29) To PH7PR11MB5984.namprd11.prod.outlook.com
 (2603:10b6:510:1e3::15)
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: PH7PR11MB5984:EE_|CYYPR11MB8407:EE_
X-MS-Office365-Filtering-Correlation-Id: c43411bd-ffd7-405c-708e-08dbaa78eb2f
X-LD-Processed: 46c98d88-e344-4ed4-8496-4ed7712e255d,ExtAddr
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;
X-Microsoft-Antispam-Message-Info: AOfQQZBV1KN35VRvuWbnC1Miu34gJMQntZXI+HD0yFCNo5hspy8rbQdgDV4nsyeTsdyedFIkgU8WaIj0vBhdlg+tpgF8ZdPVVJaDVq6rKEHVqaVeukCVOrAw1reSOUuDjSBVOZjTV1dMnM2+u8jKAgLBzgfnScguQ6/0kAl5yaon5KtKnfGoNg2KMF+4Hv4Co31vLb/7Rn7iXKlxqndNNAUdJNwfTDjDE8/GN05H18CkmqoMCR8RZG8zMwn/YxFopQHSTgQxGqecZ+pvOQ1ki+XeOj60IBqu6rrpSkDWLCTgRVlXHdB93c/G70FoHb4Qb6GQfqnNMi/j23rxruuNKbeiSWk9ELiPTO0bvsyfBzgkLNUaeoSRBgB8gvSl7VEn0Zd+zfz/w5kd0AqNV7+2t09EbWIH+iBdfMT4ldEdgxgbbeW6E0X9tX7R/MYJhyxGTPvyVe4k5dxqglcO/CG493EHrj4YrQKKWuv1VUXCMWcAnyiQVvbXy9SVmBZhqmzx+FIFE6yifK7EAACIJai1bJzP1nOCcVoM706f78xKPyp/IJC02JiXwbXMhxUeWZ0I8929FIp+3MKMAq4eLouLFnd3eWwnJRCikB2RnanR5dVYYTE1XiPoOlf+RP+/o8ohc2dguuwGIVb7rzyeHMwh7Q==
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:PH7PR11MB5984.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230031)(376002)(396003)(346002)(136003)(39860400002)(366004)(186009)(1800799009)(451199024)(8936002)(6666004)(478600001)(110136005)(53546011)(31686004)(66946007)(66556008)(6506007)(6486002)(66476007)(54906003)(6636002)(316002)(38100700002)(41300700001)(82960400001)(6512007)(44832011)(26005)(83380400001)(5660300002)(36756003)(2616005)(2906002)(31696002)(86362001)(8676002)(4326008)(45980500001)(43740500002);DIR:OUT;SFP:1102;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?utf-8?B?K0NXY1Q0Sy9kc25mZndWYzdubWRaMVFFTzh5cFpwTVJsTU1CbW9tcTJzSzJz?=
 =?utf-8?B?enZHenVUd1hDVHhGcXV6S3JESktFNis5Qk80TjYrZStINWtpaXFmNVM4WEFB?=
 =?utf-8?B?MFlQYVRJZ3p6cTJRVlJTQmVsZmtRUmhqY3FRRXV6ZjNOMVZtWEVXUUFVajU2?=
 =?utf-8?B?VENUNGM3a2dtQXJTWHFWTlh3THB2OGZ4aHZlUnZrdU02QmxNNTBxZjdXT213?=
 =?utf-8?B?MW9JYXdsaEZTZk1PYnJHL082ZzVncWFYVlpzZWxwY0pBVHp6dkRKQ0RIblNL?=
 =?utf-8?B?em1EVUlsTWJrbnhFT1JvbWhXTi8vMWYxS1BBRFdUOUpMQk8yRldvWkd5QjBv?=
 =?utf-8?B?SEI5S211Q0VJYWZKN21BcitlMVVYOVVQUy9zUzVWbG1KT1loU3dwdGVvdGsx?=
 =?utf-8?B?ZVpWaXpnVWk2V2I5REp3SFZnTVk2bDNnNXFMZnNKM2FlMmRMVTMvcW5Mblg2?=
 =?utf-8?B?UWJNVkZQWi9wUTNiN1k0cjJxQmxhYXc4QzQrbEg5TDBna3I5WXlrZitzWHNI?=
 =?utf-8?B?bXhzZkdvWUxDU3dnSWh2bFM5SXNKQlF1SEhTSkFJcTVlMEx2ejBvUks4dEhC?=
 =?utf-8?B?UC9GaVQxV1cwQWwxNWN3ZVc2K0FMY2NFUjVZNDJaZnBzS3lSV3Rsd29yMW12?=
 =?utf-8?B?amgvODN1MWxOdm5tVUhMVllUVWNreUlVanhRZEJrSTZvVHRBdlFQTGdqNm0z?=
 =?utf-8?B?S3UwZE5mWGVBOERuM2dyY0pVUFQ3dERHeTJCL29heXhGWkNONTg3VEllZWtM?=
 =?utf-8?B?VnVmaDdxS1hpVCtWTytLanA5WlBkZ0FJR0dpY1k4RjQ4VW9ZTmtVZzNMbDNY?=
 =?utf-8?B?ZkFtdCtvZS9MSEJhMHlkejB2STdnTVZSdlVPblRCa2pBSU1OTk9icVNuMUxk?=
 =?utf-8?B?NmlqK3czcEo1a295V0FUQ0hzSEtna0lQZDVjYWs5c0I4cDJTWkNvTFlNb2ly?=
 =?utf-8?B?a1Q0MjA5T3pzVHVHTk1hM1VJWTRhNGE5Tmc4UjJGeGNMaUpIZzQxemtEOHZF?=
 =?utf-8?B?biswNitjU1Uxam8vQmVJTzJjWGU5UE5KTTRzSnB1cWVsaXdhbndoa2lrQ3F4?=
 =?utf-8?B?QmFZYnZCaW1CN0N2c1ppTW82eUdTdEF3dGJyL1ZIN3A4dENlT0lKNlhQdHZN?=
 =?utf-8?B?YjRMZkR5cmFmZi9uVkRoNmVpL3d3UDRGZTVDeisrVmNKd0prcUd2RU9IeGpq?=
 =?utf-8?B?SEgzRHV0dzA4OE02UkIrQkNMR2VYVlFKc3FTM2FOeUUwbnZsZENaQ1NFQTIx?=
 =?utf-8?B?MFNCYzVDZWhOZmJYMElNdmlNYjZscEhHNThlYklTbVpNTlljNWJCOWd1aThz?=
 =?utf-8?B?WitJTUpKOXJ1RUxwTkFDRWJRZWRSYm5ub0FkeVVycGpmclUxTmh1d3RremFq?=
 =?utf-8?B?ZmxBSm1Ga1I4TjRKeUN3SDhkYWcrckliYlFWWjZFaHowc294NHBZeDJKWDk5?=
 =?utf-8?B?emJzUm9Fd3lBdVoxN1pzOStOY3p6bS94dkFvclVtQ0xWVEFTeFV6NmplcVJW?=
 =?utf-8?B?SHdzWndOUmZaMXBUSlhkMHdIWTB0RnJ4YTQvTDJLMVRMSko2SllMeFBKMm5P?=
 =?utf-8?B?cEYyRW5mcUVxcFROMlhIZ3FmUzEyZXRDeFBVNlFDY1A2K2VRWWtLTmYrdWh5?=
 =?utf-8?B?OGxDVUNIMVZUckdLZVJwOTZ4UEFRZ0NjQ0NEa2p6UW5UN3lDaElLWFV1UGNR?=
 =?utf-8?B?bzNOT1hLa1FkZGdrWkczRGxMM3BLUnpybk9OWCtuaitiMnhvOER2R2NScW1o?=
 =?utf-8?B?b1dOR1lEWDNwbkhzRHVRQVBCeXdFRHR4cnkrYk4xMnZDTzNVdlNKbzhPM2d2?=
 =?utf-8?B?THdWZW91cWhoZ2lHWFp4WGVRdHcvU0ZmaW5teDJ3TXdVMFFHMFNDeVpHd2pO?=
 =?utf-8?B?UlBESW5YcmxqV3F3dG9HRXRtN0hHdTllRTR5WHRuSkhXL2FLZnRpVXM0SmtC?=
 =?utf-8?B?aVhVZ3BjTmltQ3dvMEVPQjlqSmxESE1jQmhHUTVWdUVRZkczcm1iSC9VQnVG?=
 =?utf-8?B?d1VEU3RDdnNMSEg1ZGJ0dGR6VjVMU21wbjZnT2lLb242RStJSVZnN0JQRkQ5?=
 =?utf-8?B?cVk2TnNReXV4dWdPN3hMbzdNeWloS0VQVDRQdGE1amZFYUxMZ3JidjRNaEdT?=
 =?utf-8?Q?khlQYClHr5npWc5dLY37ieMO5?=
X-MS-Exchange-CrossTenant-Network-Message-Id: c43411bd-ffd7-405c-708e-08dbaa78eb2f
X-MS-Exchange-CrossTenant-AuthSource: PH7PR11MB5984.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 31 Aug 2023 23:20:52.2706
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: xvRpkMt/Spz/zv5WMGIxLnHkrUq7n95c4mWIc4awfSOIpXpFdcWpk/qec1aD7jHyrguXxUHFnldaVLJ/NBG23A==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: CYYPR11MB8407
X-OriginatorOrg: intel.com
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org



On 8/28/23 22:21, Ira Weiny wrote:
> OS software needs to be alerted when new extents arrive on a Dynamic
> Capacity Device (DCD).  On test DCDs extents are added through sysfs.
> 
> Add events on DCD extent injection.  Directly call the event irq
> callback to simulate irqs to process the test extents.
> 
> Signed-off-by: Ira Weiny <ira.weiny@intel.com>

Reviewed-by: Dave Jiang <dave.jiang@intel.com>

> ---
>   tools/testing/cxl/test/mem.c | 57 ++++++++++++++++++++++++++++++++++++++++++++
>   1 file changed, 57 insertions(+)
> 
> diff --git a/tools/testing/cxl/test/mem.c b/tools/testing/cxl/test/mem.c
> index d6041a2145c5..20364fee9df9 100644
> --- a/tools/testing/cxl/test/mem.c
> +++ b/tools/testing/cxl/test/mem.c
> @@ -2008,6 +2008,41 @@ static bool new_extent_valid(struct device *dev, size_t new_start,
>   	return false;
>   }
>   
> +struct dcd_event_dyn_cap dcd_event_rec_template = {
> +	.hdr = {
> +		.id = UUID_INIT(0xca95afa7, 0xf183, 0x4018,
> +				0x8c, 0x2f, 0x95, 0x26, 0x8e, 0x10, 0x1a, 0x2a),
> +		.length = sizeof(struct dcd_event_dyn_cap),
> +	},
> +};
> +
> +static int send_dc_event(struct mock_event_store *mes, enum dc_event type,
> +			 u64 start, u64 length, const char *tag_str)
> +{
> +	struct device *dev = mes->mds->cxlds.dev;
> +	struct dcd_event_dyn_cap *dcd_event_rec;
> +
> +	dcd_event_rec = devm_kzalloc(dev, sizeof(*dcd_event_rec), GFP_KERNEL);
> +	if (!dcd_event_rec)
> +		return -ENOMEM;
> +
> +	memcpy(dcd_event_rec, &dcd_event_rec_template, sizeof(*dcd_event_rec));
> +	dcd_event_rec->data.event_type = type;
> +	dcd_event_rec->data.extent.start_dpa = cpu_to_le64(start);
> +	dcd_event_rec->data.extent.length = cpu_to_le64(length);
> +	memcpy(dcd_event_rec->data.extent.tag, tag_str,
> +	       min(sizeof(dcd_event_rec->data.extent.tag),
> +		   strlen(tag_str)));
> +
> +	mes_add_event(mes, CXL_EVENT_TYPE_DCD,
> +		      (struct cxl_event_record_raw *)dcd_event_rec);
> +
> +	/* Fake the irq */
> +	cxl_mem_get_event_records(mes->mds, CXLDEV_EVENT_STATUS_DCD);
> +
> +	return 0;
> +}
> +
>   /*
>    * Format <start>:<length>:<tag>
>    *
> @@ -2021,6 +2056,7 @@ static ssize_t dc_inject_extent_store(struct device *dev,
>   				      const char *buf, size_t count)
>   {
>   	char *start_str __free(kfree) = kstrdup(buf, GFP_KERNEL);
> +	struct cxl_mockmem_data *mdata = dev_get_drvdata(dev);
>   	unsigned long long start, length;
>   	char *len_str, *tag_str;
>   	size_t buf_len = count;
> @@ -2063,6 +2099,13 @@ static ssize_t dc_inject_extent_store(struct device *dev,
>   	if (rc)
>   		return rc;
>   
> +	rc = send_dc_event(&mdata->mes, DCD_ADD_CAPACITY, start, length,
> +			   tag_str);
> +	if (rc) {
> +		dev_err(dev, "Failed to add event %d\n", rc);
> +		return rc;
> +	}
> +
>   	return count;
>   }
>   static DEVICE_ATTR_WO(dc_inject_extent);
> @@ -2071,6 +2114,7 @@ static ssize_t dc_del_extent_store(struct device *dev,
>   				   struct device_attribute *attr,
>   				   const char *buf, size_t count)
>   {
> +	struct cxl_mockmem_data *mdata = dev_get_drvdata(dev);
>   	unsigned long long start;
>   	int rc;
>   
> @@ -2083,6 +2127,12 @@ static ssize_t dc_del_extent_store(struct device *dev,
>   	if (rc)
>   		return rc;
>   
> +	rc = send_dc_event(&mdata->mes, DCD_RELEASE_CAPACITY, start, 0, "");
> +	if (rc) {
> +		dev_err(dev, "Failed to add event %d\n", rc);
> +		return rc;
> +	}
> +
>   	return count;
>   }
>   static DEVICE_ATTR_WO(dc_del_extent);
> @@ -2111,6 +2161,13 @@ static ssize_t dc_force_del_extent_store(struct device *dev,
>   	if (rc)
>   		return rc;
>   
> +	rc = send_dc_event(&mdata->mes, DCD_FORCED_CAPACITY_RELEASE,
> +			      start, 0, "");
> +	if (rc) {
> +		dev_err(dev, "Failed to add event %d\n", rc);
> +		return rc;
> +	}
> +
>   	return count;
>   }
>   static DEVICE_ATTR_WO(dc_force_del_extent);
> 

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 56259CA0FE1
	for <linux-cxl@archiver.kernel.org>; Thu, 31 Aug 2023 23:19:58 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S241061AbjHaXT7 (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Thu, 31 Aug 2023 19:19:59 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:58048 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S230143AbjHaXT7 (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Thu, 31 Aug 2023 19:19:59 -0400
Received: from mgamail.intel.com (mgamail.intel.com [192.55.52.115])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 9010FE54;
        Thu, 31 Aug 2023 16:19:55 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1693523995; x=1725059995;
  h=message-id:date:subject:to:cc:references:from:
   in-reply-to:content-transfer-encoding:mime-version;
  bh=hh1LFQ4DYtoSthtgI/YqAirLSV8B9G4zGLUEZOGL6J8=;
  b=Dtl9RQOuYWo8mqDgwOlAzBSfXlSt7Jwl/v8eagDMU1BTFyI8/GfTc8p4
   aGm9eVnKK0/6Yd0/uxqc21hM1QXOdeo20A0cFA777rTbNNyaLjl/w3DE8
   bK1LX8dborcNG4XmLUhyC86pEkLDCAr/RgR6otHUG7YEqIcgpFnpq+f5r
   piXhkwrMU6fSkhfMNyoqbmXVJPe6OXz3ak3S7cN2t8rSYxihzn/vXbBNA
   C06SY0MUGqz8w0BTLwuydJqIZViayqYXzom6SlQPMY+d+xkFSCXW2aGR2
   dVlavWTyEY/RN94hbGKgMBriKLZnEp38TyqwfyVVma7goZVRmZngA4FRx
   w==;
X-IronPort-AV: E=McAfee;i="6600,9927,10819"; a="376026105"
X-IronPort-AV: E=Sophos;i="6.02,218,1688454000"; 
   d="scan'208";a="376026105"
Received: from orsmga008.jf.intel.com ([10.7.209.65])
  by fmsmga103.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 31 Aug 2023 16:19:55 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10819"; a="768981033"
X-IronPort-AV: E=Sophos;i="6.02,218,1688454000"; 
   d="scan'208";a="768981033"
Received: from orsmsx603.amr.corp.intel.com ([10.22.229.16])
  by orsmga008.jf.intel.com with ESMTP/TLS/AES256-GCM-SHA384; 31 Aug 2023 16:19:54 -0700
Received: from orsmsx602.amr.corp.intel.com (10.22.229.15) by
 ORSMSX603.amr.corp.intel.com (10.22.229.16) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27; Thu, 31 Aug 2023 16:19:54 -0700
Received: from ORSEDG602.ED.cps.intel.com (10.7.248.7) by
 orsmsx602.amr.corp.intel.com (10.22.229.15) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27 via Frontend Transport; Thu, 31 Aug 2023 16:19:54 -0700
Received: from NAM10-BN7-obe.outbound.protection.outlook.com (104.47.70.104)
 by edgegateway.intel.com (134.134.137.103) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.27; Thu, 31 Aug 2023 16:19:52 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=Qv9IvMTRz8vlh0s8NvvHBPw4nv8QCZlwcmrS0DK0geynJrig85/wXHQ5oxmIhj0aobTlPipqSH4SVQyBGNhNV0qqDdq3JNVPZBnXV/lS+6obKXQ7CrclVMIKTemp2KOeqgQ/jp3jEWF/eXX9UzXEQv0e/Nbt8yFUsdg6+iEb69BNVBhWXOad41x9CG4Ep/oYj3RGPROTIN6z1NWe1KdbO+hskvjoVWF2BarYi4iUHctbmD3SPU3I0Molhw7wk17dDWdVy94pXjBCTIt4jjkBmecGxyZmtyNLFnzNKk3Ogl3LKEQqcnEyUimwCgPr5r9xhFvpYOSt3FkihHzMUGBsug==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=W8zxQ83MlkKKzrPFlmrhmUEAHU5JcZCtpuYPV1oTZGs=;
 b=SW/CeEMogBdRp8tbrfxOSkOBmDyQFhtFZwTCh3eKj51wGkMFw52M5BeCyffoOqMLe8YaCMPopMGD7nmTcpHjJeZCcXCbWpWLG+O1SbaxKK1q6eFkbXQ7KIajKzU7Ph9ZRAnZRxmXl7SN2q8kwEoscaofXUQeXaHQTP7gsjIT2oF+r7PhjgRAzvlcrVnfHFtkqYuqmsyzsOt4VfKbhgz7ijL76DNB7oarobyXrsDkKhJiSAcrC3LXLDe8XitpXfMAHOnju9eJ2eGqFdToM9147qa9xBp1Pm4UdoM64CQB/ZGjTFY+c/38HfJaxC7Sj61dAotZRE1eL2DqcxGS0lEjQw==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from PH7PR11MB5984.namprd11.prod.outlook.com (2603:10b6:510:1e3::15)
 by CYYPR11MB8407.namprd11.prod.outlook.com (2603:10b6:930:c1::11) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.6745.18; Thu, 31 Aug
 2023 23:19:49 +0000
Received: from PH7PR11MB5984.namprd11.prod.outlook.com
 ([fe80::9563:9642:bbde:293f]) by PH7PR11MB5984.namprd11.prod.outlook.com
 ([fe80::9563:9642:bbde:293f%7]) with mapi id 15.20.6745.022; Thu, 31 Aug 2023
 23:19:49 +0000
Message-ID: <65c609be-3dd9-8b73-d4b1-cb8cacb1a40a@intel.com>
Date: Thu, 31 Aug 2023 16:19:45 -0700
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101
 Betterbird/102.13.0
Subject: Re: [PATCH RFC v2 17/18] tools/testing/cxl: Add DC Regions to mock
 mem data
To: Ira Weiny <ira.weiny@intel.com>,
        Dan Williams <dan.j.williams@intel.com>
CC: Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Alison Schofield <alison.schofield@intel.com>,
        "Vishal Verma" <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
 <20230604-dcd-type2-upstream-v2-17-f740c47e7916@intel.com>
Content-Language: en-US
From: Dave Jiang <dave.jiang@intel.com>
In-Reply-To: <20230604-dcd-type2-upstream-v2-17-f740c47e7916@intel.com>
Content-Type: text/plain; charset="UTF-8"; format=flowed
Content-Transfer-Encoding: 7bit
X-ClientProxiedBy: BY5PR13CA0024.namprd13.prod.outlook.com
 (2603:10b6:a03:180::37) To PH7PR11MB5984.namprd11.prod.outlook.com
 (2603:10b6:510:1e3::15)
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: PH7PR11MB5984:EE_|CYYPR11MB8407:EE_
X-MS-Office365-Filtering-Correlation-Id: 38219083-4220-4a87-1c46-08dbaa78c55f
X-LD-Processed: 46c98d88-e344-4ed4-8496-4ed7712e255d,ExtAddr
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;
X-Microsoft-Antispam-Message-Info: RSnaTRQyo9yGs9O8DnfvYPzVXwUz3LfECTfQBUv6mj/sOV2c3IZACqXEWqXSk8SfnSZfq1myDPub5Vayg8VmfGlONLK9CCVUKFV/ylAcutQioUdLVjPkaU+JqRH2DOg5AKryOVoycMcVBVpKqml6vHb3KpASVTlJ11OHxXRMcV+Eo7V+xGl1vYLfo9eDagS+mNVnbYDqonU2ACcAr2Qb/sIdRl6pm8enKX0K00uNvkbkdscI3ktG3S3O67qqyQhFAH3gX5cKx3oPEk2yZ84DfdvfBta6KPMefxmloPzHU+okgjcuu7LkRLEKG17NbDAhXj4I4e0/FVkks9/Q8NM7xd83olZnr6ZI+lGx3EVuYS7D1llOdEYxWPx/PKIWzHB+w5jt9GKEQFpHIsC9Vt4gf6bvMiVxcEm39jU37wahsz6Q3Z6BfikHq54U/1F7bjBpwzSLB7NJUowcmhVdm3rBAWg/5ZaolYVvffajecY+PkeI6nRBnnVkNJK2x2GqFag+M7AKAslsi5pMv6EBCS1Gqir6bLYBgFVoa8NNO3+Fx7SxROwVMehrzE5ozGuvoB7sW4r3O67zmWwzs9vYHF9gTnU/Sj1mXSmdaH8fsygz21i2ZGe1BCmR21arC4UujhfI8z06yd1fgJK0WE4k1BStaQ==
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:PH7PR11MB5984.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230031)(376002)(396003)(346002)(136003)(39860400002)(366004)(186009)(1800799009)(451199024)(8936002)(6666004)(478600001)(110136005)(53546011)(31686004)(66946007)(66556008)(6506007)(6486002)(66476007)(54906003)(6636002)(316002)(38100700002)(41300700001)(82960400001)(6512007)(44832011)(26005)(83380400001)(5660300002)(36756003)(2616005)(2906002)(31696002)(86362001)(30864003)(8676002)(4326008)(45980500001)(43740500002);DIR:OUT;SFP:1102;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?utf-8?B?ai9JZGtyWXkvbElzR01QZktrUUUyOEJYSk5QSlZpckRJdXNUWHNrRXdjR0Vh?=
 =?utf-8?B?emZuV0JsdXoxTjI1c1ZoSjY4WG1rQTk2cytPcy9xVWZGU1Rpb2JLcml1RGpJ?=
 =?utf-8?B?RGRZREljMFR0bWhRcEdETzF0RHVrMzQ5aWFPVDNKM1ZJZkVRUE9nZFp2djZY?=
 =?utf-8?B?cnd5SVVobGgrSC8yRGFpaUhxZVRKUzhEdHpUOUk3akZRdWlpTDJ4WFRSVjhi?=
 =?utf-8?B?MU04RHE3SjFJN0pucUQ1clNVRkliQVBQbnMvVXI1Tk43elorWmVGeWN4Y054?=
 =?utf-8?B?NGw2emttS3I2aEpJNGgwNklWTGpSdUtzcmhwck5uV3BnaU9FVHhGdDM5UDZq?=
 =?utf-8?B?VjFBLyt5eWJ1Z0hpeUNqaEFRWFlaN1k0TEZqS1VybXB2ZlN0SUp0bW42U1NK?=
 =?utf-8?B?Ump5RFJKMlg2V3FOVm03ZXhrN1RVcjZNd1QvcjZ4bTI3N25LRFRMSW5Ma2h5?=
 =?utf-8?B?WmFnd1d3NGNuOCthQlJBeGpwcnUyNG9TVGh6bmp5ZVlQYnpRODQ0Y3pJZHBE?=
 =?utf-8?B?SG93bFVDNUhxUVJWN1M5MldFeTVCZlN4RTVvTnVZTGVIbkVZN0wwanFKbGVE?=
 =?utf-8?B?aEFZNUhWdW00RVdSeUtyOStVbzBWd3h5NmFNWGdkNFRRa2UxTERXWWt4cXJy?=
 =?utf-8?B?S1Vsa05hYnNBcHY5RTZTSjJ3Z3k2NDFsWXB5dDNkcVlCc2EvbmhRL2ZxSURz?=
 =?utf-8?B?WWVtcUp0VHRDNzVQTTBEdGdCa2lZeUVqVUhMTnhGOStVdmgwZ3M5NjV6ZmVL?=
 =?utf-8?B?WHlMM2d1MEkxMThxMFo4V0pBVXo1cHVvZ0hNcll0Q0VwbnZzS2YxbnJTMkRM?=
 =?utf-8?B?cjhoa0JZRnc0ck1uSk5KcnFkNzBpOEtTM21tSURrVS9zNExaS1Fta1FBNU4z?=
 =?utf-8?B?L2tickNyczV0RFFzdjVkVlMrR0JmeU9jMXhUNGFxbG5ZTUhyYmZvWUJEMi9l?=
 =?utf-8?B?MFdTMDhrYVlwbnZQS0JRaFh0Wm9YUDJTdUM3ZVFXdUZrUnBOY2VOWDdRVklV?=
 =?utf-8?B?aVo0T1JVV0hXY0NGdlMzK3FVU21nL2MxYkRhdlF4S0dFOTdQR0JsTjgzMUEw?=
 =?utf-8?B?T2tOc0dFWEFWcUcwblozQWdlQUVlWldMK3V4cEUwVGdmbWRYUjA0eXVjMEVZ?=
 =?utf-8?B?WTcwK0VGRVJIb3RUblIrYXZlVkpiSGVOTTlUUVc4NlRrV2VQUFdVWWpFc0tj?=
 =?utf-8?B?OWJmeEZGbXdaRmxlVjJuNE5PWThVbm1xTVlRazlrODhuS2tQdjNtRHZpWjBj?=
 =?utf-8?B?RjYxZjM2UnVCS0grelRlY2RRNXdnY2hqYW9Yc3hQUVRDQ3lWcTRkUW45dUpQ?=
 =?utf-8?B?WFBmN29rVlc2WUprU2xzR013dGhRR1ZxL28vQjd5NllRa2FKZXF0NnpWekp2?=
 =?utf-8?B?ZnVFUHpCWFNXTjJQNzAzVll3bk1xbFBEUmZwd2ltS0ZZUVVOTUdwdFVTbWtw?=
 =?utf-8?B?R0Rubi9aa2E5SWpCaWU4Z3RlaTc3Q3FmN0tEd2Z4bFU1dkxOT0dUWlVIK2ht?=
 =?utf-8?B?Q0ZXWFFmYTAvY0U0WXYyVWg0Y1pDUWxZMXdqT2Jya25wL2hOWUJRenBmbDh2?=
 =?utf-8?B?VlJPOFhqRSs2aWo1K2c3R3MzeC9iUDdaSjh6bXQ1VjVHWjBGUnkxRTYra2w1?=
 =?utf-8?B?aDd5ZDdnZVl1R2dVSjRzenlDZjJLM2JFWWJiZEZPU1MzeFRPV2ozZ0Rpb1dr?=
 =?utf-8?B?Mm80OEJaNU84aHphY2tCV00vTWlSQWE0L0NCd3ZPVFdLSS9DVEdJYWg2emZx?=
 =?utf-8?B?VklzdjZXbkd0WGlhVTNob2tKNzJBL0V5L2ZGbnBmaXl4YzhVNktncDJDaE5V?=
 =?utf-8?B?SjhLN2M3UTZIRnZ4eGZkMVJsV0xPWnFBSGZ3a3ZYTUwzYnI0TXpJV0RWazM0?=
 =?utf-8?B?RGZ4YU95SUpTdWd3L1U2RUdNZXZEaXZOTWJvaHk3N3hWd2ZRalh6ckVRS0Zu?=
 =?utf-8?B?SWZIWHBDV2M5N1hNakZVSVFCWnBTNklZbUhFMHFJbjJteEhpMS9WeDNmbDdh?=
 =?utf-8?B?c1JlRVk0Q2xWdy9obW05Q0ludkExWE9uZnY0aVZBV3FIRkF2SjA0NXVjbEJG?=
 =?utf-8?B?cjkvTWhPTitNaXdaK0phYTVCNXVRazZqNytqOTdFMUM5cUtmQmJKNWExR1hI?=
 =?utf-8?Q?IZyVgx7OMpCifj02poUHjynwT?=
X-MS-Exchange-CrossTenant-Network-Message-Id: 38219083-4220-4a87-1c46-08dbaa78c55f
X-MS-Exchange-CrossTenant-AuthSource: PH7PR11MB5984.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 31 Aug 2023 23:19:48.9723
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: uaNyGJ8H35NbFNJBThzqcNKZRwahfCYmdKQojzc2I1gZXgthtFZzpB6mCWKCSdRxXsTg1bz4HDu4qREa8db0qA==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: CYYPR11MB8407
X-OriginatorOrg: intel.com
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org



On 8/28/23 22:21, Ira Weiny wrote:
> To test DC regions the mock memory devices will need to store
> information about the regions and manage fake extent data.
> 
> Define mock_dc_region information within the mock memory data.  Add
> sysfs entries on the mock device to inject and delete extents.
> 
> The inject format is <start>:<length>:<tag>
> The delete format is <start>
> 
> Add DC mailbox commands to the CEL and implement those commands.
> 
> Signed-off-by: Ira Weiny <ira.weiny@intel.com>

Reviewed-by: Dave Jiang <dave.jiang@intel.com>
> ---
>   tools/testing/cxl/test/mem.c | 449 +++++++++++++++++++++++++++++++++++++++++++
>   1 file changed, 449 insertions(+)
> 
> diff --git a/tools/testing/cxl/test/mem.c b/tools/testing/cxl/test/mem.c
> index 6a036c8d215d..d6041a2145c5 100644
> --- a/tools/testing/cxl/test/mem.c
> +++ b/tools/testing/cxl/test/mem.c
> @@ -18,6 +18,7 @@
>   #define FW_SLOTS 3
>   #define DEV_SIZE SZ_2G
>   #define EFFECT(x) (1U << x)
> +#define BASE_DYNAMIC_CAP_DPA DEV_SIZE
>   
>   #define MOCK_INJECT_DEV_MAX 8
>   #define MOCK_INJECT_TEST_MAX 128
> @@ -89,6 +90,22 @@ static struct cxl_cel_entry mock_cel[] = {
>   		.effect = cpu_to_le16(EFFECT(CONF_CHANGE_COLD_RESET) |
>   				      EFFECT(CONF_CHANGE_IMMEDIATE)),
>   	},
> +	{
> +		.opcode = cpu_to_le16(CXL_MBOX_OP_GET_DC_CONFIG),
> +		.effect = CXL_CMD_EFFECT_NONE,
> +	},
> +	{
> +		.opcode = cpu_to_le16(CXL_MBOX_OP_GET_DC_EXTENT_LIST),
> +		.effect = CXL_CMD_EFFECT_NONE,
> +	},
> +	{
> +		.opcode = cpu_to_le16(CXL_MBOX_OP_ADD_DC_RESPONSE),
> +		.effect = cpu_to_le16(EFFECT(CONF_CHANGE_IMMEDIATE)),
> +	},
> +	{
> +		.opcode = cpu_to_le16(CXL_MBOX_OP_RELEASE_DC),
> +		.effect = cpu_to_le16(EFFECT(CONF_CHANGE_IMMEDIATE)),
> +	},
>   };
>   
>   /* See CXL 2.0 Table 181 Get Health Info Output Payload */
> @@ -147,6 +164,7 @@ struct mock_event_store {
>   	u32 ev_status;
>   };
>   
> +#define NUM_MOCK_DC_REGIONS 2
>   struct cxl_mockmem_data {
>   	void *lsa;
>   	void *fw;
> @@ -161,6 +179,10 @@ struct cxl_mockmem_data {
>   	struct mock_event_store mes;
>   	u8 event_buf[SZ_4K];
>   	u64 timestamp;
> +	struct cxl_dc_region_config dc_regions[NUM_MOCK_DC_REGIONS];
> +	u32 dc_ext_generation;
> +	struct xarray dc_extents;
> +	struct xarray dc_accepted_exts;
>   };
>   
>   static struct mock_event_log *event_find_log(struct device *dev, int log_type)
> @@ -529,6 +551,98 @@ static void cxl_mock_event_trigger(struct device *dev)
>   	cxl_mem_get_event_records(mes->mds, mes->ev_status);
>   }
>   
> +static int devm_add_extent(struct device *dev, u64 start, u64 length,
> +			   const char *tag)
> +{
> +	struct cxl_mockmem_data *mdata = dev_get_drvdata(dev);
> +	struct cxl_dc_extent_data *extent;
> +
> +	extent = devm_kzalloc(dev, sizeof(*extent), GFP_KERNEL);
> +	if (!extent) {
> +		dev_dbg(dev, "Failed to allocate extent\n");
> +		return -ENOMEM;
> +	}
> +	extent->dpa_start = start;
> +	extent->length = length;
> +	memcpy(extent->tag, tag, min(sizeof(extent->tag), strlen(tag)));
> +
> +	if (xa_insert(&mdata->dc_extents, start, extent, GFP_KERNEL)) {
> +		devm_kfree(dev, extent);
> +		dev_err(dev, "Failed xarry insert %llx\n", start);
> +		return -EINVAL;
> +	}
> +	mdata->dc_ext_generation++;
> +
> +	return 0;
> +}
> +
> +static int dc_accept_extent(struct device *dev, u64 start)
> +{
> +	struct cxl_mockmem_data *mdata = dev_get_drvdata(dev);
> +
> +	dev_dbg(dev, "Accepting extent 0x%llx\n", start);
> +	return xa_insert(&mdata->dc_accepted_exts, start, (void *)start,
> +			 GFP_KERNEL);
> +}
> +
> +static void release_dc_ext(void *md)
> +{
> +	struct cxl_mockmem_data *mdata = md;
> +
> +	xa_destroy(&mdata->dc_extents);
> +	xa_destroy(&mdata->dc_accepted_exts);
> +}
> +
> +static int cxl_mock_dc_region_setup(struct device *dev)
> +{
> +#define DUMMY_EXT_OFFSET SZ_256M
> +#define DUMMY_EXT_LENGTH SZ_256M
> +	struct cxl_mockmem_data *mdata = dev_get_drvdata(dev);
> +	u64 base_dpa = BASE_DYNAMIC_CAP_DPA;
> +	u32 dsmad_handle = 0xFADE;
> +	u64 decode_length = SZ_2G;
> +	u64 block_size = SZ_512;
> +	/* For testing make this smaller than decode length */
> +	u64 length = SZ_1G;
> +	int rc;
> +
> +	xa_init(&mdata->dc_extents);
> +	xa_init(&mdata->dc_accepted_exts);
> +
> +	rc = devm_add_action_or_reset(dev, release_dc_ext, mdata);
> +	if (rc)
> +		return rc;
> +
> +	for (int i = 0; i < NUM_MOCK_DC_REGIONS; i++) {
> +		struct cxl_dc_region_config *conf = &mdata->dc_regions[i];
> +
> +		dev_dbg(dev, "Creating DC region DC%d DPA:%llx LEN:%llx\n",
> +			i, base_dpa, length);
> +
> +		conf->region_base = cpu_to_le64(base_dpa);
> +		conf->region_decode_length = cpu_to_le64(decode_length /
> +						CXL_CAPACITY_MULTIPLIER);
> +		conf->region_length = cpu_to_le64(length);
> +		conf->region_block_size = cpu_to_le64(block_size);
> +		conf->region_dsmad_handle = cpu_to_le32(dsmad_handle);
> +		dsmad_handle++;
> +
> +		/* Pretend we have some previous accepted extents */
> +		rc = devm_add_extent(dev, base_dpa + DUMMY_EXT_OFFSET,
> +				     DUMMY_EXT_LENGTH, "CXL-TEST");
> +		if (rc)
> +			return rc;
> +
> +		rc = dc_accept_extent(dev, base_dpa + DUMMY_EXT_OFFSET);
> +		if (rc)
> +			return rc;
> +
> +		base_dpa += decode_length;
> +	}
> +
> +	return 0;
> +}
> +
>   static int mock_gsl(struct cxl_mbox_cmd *cmd)
>   {
>   	if (cmd->size_out < sizeof(mock_gsl_payload))
> @@ -1315,6 +1429,148 @@ static int mock_activate_fw(struct cxl_mockmem_data *mdata,
>   	return -EINVAL;
>   }
>   
> +static int mock_get_dc_config(struct device *dev,
> +			      struct cxl_mbox_cmd *cmd)
> +{
> +	struct cxl_mbox_get_dc_config *dc_config = cmd->payload_in;
> +	struct cxl_mockmem_data *mdata = dev_get_drvdata(dev);
> +	u8 region_requested, region_start_idx, region_ret_cnt;
> +	struct cxl_mbox_dynamic_capacity *resp;
> +
> +	region_requested = dc_config->region_count;
> +	if (NUM_MOCK_DC_REGIONS < region_requested)
> +		region_requested = NUM_MOCK_DC_REGIONS;
> +
> +	if (cmd->size_out < struct_size(resp, region, region_requested))
> +		return -EINVAL;
> +
> +	memset(cmd->payload_out, 0, cmd->size_out);
> +	resp = cmd->payload_out;
> +
> +	region_start_idx = dc_config->start_region_index;
> +	region_ret_cnt = 0;
> +	for (int i = 0; i < NUM_MOCK_DC_REGIONS; i++) {
> +		if (i >= region_start_idx) {
> +			memcpy(&resp->region[region_ret_cnt],
> +				&mdata->dc_regions[i],
> +				sizeof(resp->region[region_ret_cnt]));
> +			region_ret_cnt++;
> +		}
> +	}
> +	resp->avail_region_count = region_ret_cnt;
> +
> +	dev_dbg(dev, "Returning %d dc regions\n", region_ret_cnt);
> +	return 0;
> +}
> +
> +
> +static int mock_get_dc_extent_list(struct device *dev,
> +				   struct cxl_mbox_cmd *cmd)
> +{
> +	struct cxl_mockmem_data *mdata = dev_get_drvdata(dev);
> +	struct cxl_mbox_get_dc_extent *get = cmd->payload_in;
> +	struct cxl_mbox_dc_extents *resp = cmd->payload_out;
> +	u32 total_avail = 0, total_ret = 0;
> +	struct cxl_dc_extent_data *ext;
> +	u32 ext_count, start_idx;
> +	unsigned long i;
> +
> +	ext_count = le32_to_cpu(get->extent_cnt);
> +	start_idx = le32_to_cpu(get->start_extent_index);
> +
> +	memset(resp, 0, sizeof(*resp));
> +
> +	/*
> +	 * Total available needs to be calculated and returned regardless of
> +	 * how many can actually be returned.
> +	 */
> +	xa_for_each(&mdata->dc_extents, i, ext)
> +		total_avail++;
> +
> +	if (start_idx > total_avail)
> +		return -EINVAL;
> +
> +	xa_for_each(&mdata->dc_extents, i, ext) {
> +		if (total_ret >= ext_count)
> +			break;
> +
> +		if (total_ret >= start_idx) {
> +			resp->extent[total_ret].start_dpa =
> +						cpu_to_le64(ext->dpa_start);
> +			resp->extent[total_ret].length =
> +						cpu_to_le64(ext->length);
> +			memcpy(&resp->extent[total_ret].tag, ext->tag,
> +					sizeof(resp->extent[total_ret]));
> +			resp->extent[total_ret].shared_extn_seq =
> +					cpu_to_le16(ext->shared_extent_seq);
> +			total_ret++;
> +		}
> +	}
> +
> +	resp->ret_extent_cnt = cpu_to_le32(total_ret);
> +	resp->total_extent_cnt = cpu_to_le32(total_avail);
> +	resp->extent_list_num = cpu_to_le32(mdata->dc_ext_generation);
> +
> +	dev_dbg(dev, "Returning %d extents of %d total\n",
> +		total_ret, total_avail);
> +
> +	return 0;
> +}
> +
> +static int mock_add_dc_response(struct device *dev,
> +				struct cxl_mbox_cmd *cmd)
> +{
> +	struct cxl_mbox_dc_response *req = cmd->payload_in;
> +	u32 list_size = le32_to_cpu(req->extent_list_size);
> +
> +	for (int i = 0; i < list_size; i++) {
> +		u64 start = le64_to_cpu(req->extent_list[i].dpa_start);
> +		int rc;
> +
> +		dev_dbg(dev, "Extent 0x%llx accepted by HOST\n", start);
> +		rc = dc_accept_extent(dev, start);
> +		if (rc)
> +			return rc;
> +	}
> +
> +	return 0;
> +}
> +
> +static int dc_delete_extent(struct device *dev, unsigned long long start)
> +{
> +	struct cxl_mockmem_data *mdata = dev_get_drvdata(dev);
> +	void *ext;
> +
> +	dev_dbg(dev, "Deleting extent at %llx\n", start);
> +
> +	ext = xa_erase(&mdata->dc_extents, start);
> +	if (!ext) {
> +		dev_err(dev, "No extent found at %llx\n", start);
> +		return -EINVAL;
> +	}
> +	devm_kfree(dev, ext);
> +	mdata->dc_ext_generation++;
> +
> +	return 0;
> +}
> +
> +static int mock_dc_release(struct device *dev,
> +			   struct cxl_mbox_cmd *cmd)
> +{
> +	struct cxl_mockmem_data *mdata = dev_get_drvdata(dev);
> +	struct cxl_mbox_dc_response *req = cmd->payload_in;
> +	u32 list_size = le32_to_cpu(req->extent_list_size);
> +
> +	for (int i = 0; i < list_size; i++) {
> +		u64 start = le64_to_cpu(req->extent_list[i].dpa_start);
> +
> +		dev_dbg(dev, "Extent 0x%llx released by HOST\n", start);
> +		xa_erase(&mdata->dc_accepted_exts, start);
> +	}
> +
> +	return 0;
> +}
> +
>   static int cxl_mock_mbox_send(struct cxl_memdev_state *mds,
>   			      struct cxl_mbox_cmd *cmd)
>   {
> @@ -1399,6 +1655,18 @@ static int cxl_mock_mbox_send(struct cxl_memdev_state *mds,
>   	case CXL_MBOX_OP_ACTIVATE_FW:
>   		rc = mock_activate_fw(mdata, cmd);
>   		break;
> +	case CXL_MBOX_OP_GET_DC_CONFIG:
> +		rc = mock_get_dc_config(dev, cmd);
> +		break;
> +	case CXL_MBOX_OP_GET_DC_EXTENT_LIST:
> +		rc = mock_get_dc_extent_list(dev, cmd);
> +		break;
> +	case CXL_MBOX_OP_ADD_DC_RESPONSE:
> +		rc = mock_add_dc_response(dev, cmd);
> +		break;
> +	case CXL_MBOX_OP_RELEASE_DC:
> +		rc = mock_dc_release(dev, cmd);
> +		break;
>   	default:
>   		break;
>   	}
> @@ -1467,6 +1735,10 @@ static int __cxl_mock_mem_probe(struct platform_device *pdev)
>   		return -ENOMEM;
>   	dev_set_drvdata(dev, mdata);
>   
> +	rc = cxl_mock_dc_region_setup(dev);
> +	if (rc)
> +		return rc;
> +
>   	mdata->lsa = vmalloc(LSA_SIZE);
>   	if (!mdata->lsa)
>   		return -ENOMEM;
> @@ -1515,6 +1787,10 @@ static int __cxl_mock_mem_probe(struct platform_device *pdev)
>   	if (rc)
>   		return rc;
>   
> +	rc = cxl_dev_dynamic_capacity_identify(mds);
> +	if (rc)
> +		return rc;
> +
>   	rc = cxl_mem_create_range_info(mds);
>   	if (rc)
>   		return rc;
> @@ -1528,6 +1804,10 @@ static int __cxl_mock_mem_probe(struct platform_device *pdev)
>   	if (IS_ERR(cxlmd))
>   		return PTR_ERR(cxlmd);
>   
> +	rc = cxl_dev_get_dynamic_capacity_extents(mds);
> +	if (rc)
> +		return rc;
> +
>   	rc = cxl_memdev_setup_fw_upload(mds);
>   	if (rc)
>   		return rc;
> @@ -1669,10 +1949,179 @@ static ssize_t fw_buf_checksum_show(struct device *dev,
>   
>   static DEVICE_ATTR_RO(fw_buf_checksum);
>   
> +/* Returns if the proposed extent is valid */
> +static bool new_extent_valid(struct device *dev, size_t new_start,
> +			     size_t new_len)
> +{
> +	struct cxl_mockmem_data *mdata = dev_get_drvdata(dev);
> +	struct cxl_dc_extent_data *extent;
> +	size_t new_end, i;
> +
> +	if (!new_len)
> +		return -EINVAL;
> +
> +	new_end = new_start + new_len;
> +
> +	dev_dbg(dev, "New extent %zx-%zx\n", new_start, new_end);
> +
> +	/* Overlap with other extent? */
> +	xa_for_each(&mdata->dc_extents, i, extent) {
> +		size_t ext_end = extent->dpa_start + extent->length;
> +
> +		if (extent->dpa_start <= new_start && new_start < ext_end) {
> +			dev_err(dev, "Extent overlap: Start %llu ?<= %zx ?<= %zx\n",
> +				extent->dpa_start, new_start, ext_end);
> +			return false;
> +		}
> +		if (extent->dpa_start <= new_end && new_end < ext_end) {
> +			dev_err(dev, "Extent overlap: End %llx ?<= %zx ?<= %zx\n",
> +				extent->dpa_start, new_end, ext_end);
> +			return false;
> +		}
> +	}
> +
> +	/* Ensure it is in a region and is valid for that regions block size */
> +	for (int i = 0; i < NUM_MOCK_DC_REGIONS; i++) {
> +		struct cxl_dc_region_config *dc_region = &mdata->dc_regions[i];
> +		size_t reg_start, reg_end;
> +
> +		reg_start = le64_to_cpu(dc_region->region_base);
> +		reg_end = le64_to_cpu(dc_region->region_length);
> +		reg_end += reg_start;
> +
> +		dev_dbg(dev, "Region %d: %zx-%zx\n", i, reg_start, reg_end);
> +
> +		if (reg_start >= new_start && new_end < reg_end) {
> +			u64 block_size = le64_to_cpu(dc_region->region_block_size);
> +
> +			if (new_start % block_size || new_len % block_size) {
> +				dev_err(dev, "Extent not aligned to block size: start %zx; len %zx; block_size 0x%llx\n",
> +					new_start, new_len, block_size);
> +				return false;
> +			}
> +
> +			dev_dbg(dev, "Extent in region %d\n", i);
> +			return true;
> +		}
> +	}
> +
> +	return false;
> +}
> +
> +/*
> + * Format <start>:<length>:<tag>
> + *
> + * start and length must be a multiple of the configured region block size.
> + * Tag can be any string up to 16 bytes.
> + *
> + * Extents must be exclusive of other extents
> + */
> +static ssize_t dc_inject_extent_store(struct device *dev,
> +				      struct device_attribute *attr,
> +				      const char *buf, size_t count)
> +{
> +	char *start_str __free(kfree) = kstrdup(buf, GFP_KERNEL);
> +	unsigned long long start, length;
> +	char *len_str, *tag_str;
> +	size_t buf_len = count;
> +	int rc;
> +
> +	if (!start_str)
> +		return -ENOMEM;
> +
> +	len_str = strnchr(start_str, buf_len, ':');
> +	if (!len_str) {
> +		dev_err(dev, "Extent failed to find len_str: %s\n", start_str);
> +		return -EINVAL;
> +	}
> +
> +	*len_str = '\0';
> +	len_str += 1;
> +	buf_len -= strlen(start_str);
> +
> +	tag_str = strnchr(len_str, buf_len, ':');
> +	if (!tag_str) {
> +		dev_err(dev, "Extent failed to find tag_str: %s\n", len_str);
> +		return -EINVAL;
> +	}
> +	*tag_str = '\0';
> +	tag_str += 1;
> +
> +	if (kstrtoull(start_str, 0, &start)) {
> +		dev_err(dev, "Extent failed to parse start: %s\n", start_str);
> +		return -EINVAL;
> +	}
> +	if (kstrtoull(len_str, 0, &length)) {
> +		dev_err(dev, "Extent failed to parse length: %s\n", len_str);
> +		return -EINVAL;
> +	}
> +
> +	if (!new_extent_valid(dev, start, length))
> +		return -EINVAL;
> +
> +	rc = devm_add_extent(dev, start, length, tag_str);
> +	if (rc)
> +		return rc;
> +
> +	return count;
> +}
> +static DEVICE_ATTR_WO(dc_inject_extent);
> +
> +static ssize_t dc_del_extent_store(struct device *dev,
> +				   struct device_attribute *attr,
> +				   const char *buf, size_t count)
> +{
> +	unsigned long long start;
> +	int rc;
> +
> +	if (kstrtoull(buf, 0, &start)) {
> +		dev_err(dev, "Extent failed to parse start value\n");
> +		return -EINVAL;
> +	}
> +
> +	rc = dc_delete_extent(dev, start);
> +	if (rc)
> +		return rc;
> +
> +	return count;
> +}
> +static DEVICE_ATTR_WO(dc_del_extent);
> +
> +static ssize_t dc_force_del_extent_store(struct device *dev,
> +					 struct device_attribute *attr,
> +					 const char *buf, size_t count)
> +{
> +	struct cxl_mockmem_data *mdata = dev_get_drvdata(dev);
> +	unsigned long long start;
> +	void *ext;
> +	int rc;
> +
> +	if (kstrtoull(buf, 0, &start)) {
> +		dev_err(dev, "Extent failed to parse start value\n");
> +		return -EINVAL;
> +	}
> +
> +	ext = xa_erase(&mdata->dc_accepted_exts, start);
> +	if (ext)
> +		dev_dbg(dev, "Forcing remove of accepted extent: %llx\n",
> +			start);
> +
> +	dev_dbg(dev, "Forcing delete of extent at %llx\n", start);
> +	rc = dc_delete_extent(dev, start);
> +	if (rc)
> +		return rc;
> +
> +	return count;
> +}
> +static DEVICE_ATTR_WO(dc_force_del_extent);
> +
>   static struct attribute *cxl_mock_mem_attrs[] = {
>   	&dev_attr_security_lock.attr,
>   	&dev_attr_event_trigger.attr,
>   	&dev_attr_fw_buf_checksum.attr,
> +	&dev_attr_dc_inject_extent.attr,
> +	&dev_attr_dc_del_extent.attr,
> +	&dev_attr_dc_force_del_extent.attr,
>   	NULL
>   };
>   ATTRIBUTE_GROUPS(cxl_mock_mem);
> 

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 5FFD2C88CB2
	for <linux-cxl@archiver.kernel.org>; Thu, 31 Aug 2023 21:48:41 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1347612AbjHaVsm (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Thu, 31 Aug 2023 17:48:42 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:36366 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1347608AbjHaVsl (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Thu, 31 Aug 2023 17:48:41 -0400
Received: from mgamail.intel.com (mgamail.intel.com [192.55.52.151])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 299D810CB;
        Thu, 31 Aug 2023 14:48:27 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1693518507; x=1725054507;
  h=message-id:date:subject:to:cc:references:from:
   in-reply-to:content-transfer-encoding:mime-version;
  bh=E2MUvGomcaDLRRQ2W8QhMBn1Z2fhpnx1GrJqgtA2PV0=;
  b=CPv7roRlK73z1PIPgC8fvSHj5yKzAZUQmCxRGpg4J20F7m3v506lcK5I
   htAPffT4GOlWkOVSlI89wyMG/OPbBDip5QD0ioaK+txCGJ6hYLH08Jayy
   tGfVtl7jxm1c9dOyANhh1Gd8yXVuLWN3kBliSGoBK1J7U3r4Jvzk6/C7L
   A6YMOGe7dU/qbN+OAtkKKYoTT7yd8YdLYIYU6ZoxPUVHkDqWuc+bM11SI
   EMAcUWQoYqfNRLCc1zPeuzXwtWchFLp6r9UxSjvokjSw+hg0lINh8EZEs
   GUPaHZX8t0EGdw8G6ZzsR8WHbMal8UGewKVRuLb+UNaBbBu3JeB6sSQNh
   Q==;
X-IronPort-AV: E=McAfee;i="6600,9927,10819"; a="356388262"
X-IronPort-AV: E=Sophos;i="6.02,217,1688454000"; 
   d="scan'208";a="356388262"
Received: from orsmga007.jf.intel.com ([10.7.209.58])
  by fmsmga107.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 31 Aug 2023 14:48:26 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10819"; a="733292071"
X-IronPort-AV: E=Sophos;i="6.02,217,1688454000"; 
   d="scan'208";a="733292071"
Received: from fmsmsx602.amr.corp.intel.com ([10.18.126.82])
  by orsmga007.jf.intel.com with ESMTP/TLS/AES256-GCM-SHA384; 31 Aug 2023 14:48:24 -0700
Received: from fmsmsx610.amr.corp.intel.com (10.18.126.90) by
 fmsmsx602.amr.corp.intel.com (10.18.126.82) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27; Thu, 31 Aug 2023 14:48:24 -0700
Received: from FMSEDG603.ED.cps.intel.com (10.1.192.133) by
 fmsmsx610.amr.corp.intel.com (10.18.126.90) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27 via Frontend Transport; Thu, 31 Aug 2023 14:48:24 -0700
Received: from NAM10-BN7-obe.outbound.protection.outlook.com (104.47.70.102)
 by edgegateway.intel.com (192.55.55.68) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.27; Thu, 31 Aug 2023 14:48:24 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=B3nFdNyji6FF1tDGnEmcXiyX46MT4TfRThm+QmtvNhgK+mZWm53tugBa4X25ZKlghPfRn5l4ZNmF97c4xddVsVTwPym8omOvzCabtiTUIYqRuTiTLfbp0L7sqccpZUH6zsyyaMdgL33L6YiF8s9I+0fHYZGmZPwRVDhXgmFXntUT4H6c2Shn/uQaB2yKAgzJ3ZrEHkKl8PmOzoB3YlugoiRj4Y7oK7wkOWfeQDAUoU+nugl2ZLAKh4aT3M5YoJRQZOUtQeH0wXn+5xme9WApCy1NNSAMCv+YKYSjuzbi108BBLINyGOF5tVDJqq8Rm6yQ1MvoBzm7+D/YjYZ2CY7Ug==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=SAc7X1KfYrvQo+Z7PU/EMccycokK8lC+hJ8tPmRhOz4=;
 b=m2L5+25mEGtJtmj93oBJdl1gmNPkSw6Y4KeHd4dRbLehkqn08oifLl9n8DEV+7zqAj8Kso/eJ06aUyy4GmwJ/3XSaXWN81tZ+bixjh/SA94GE/0ZvfURxnZA128IuBNX/+w9d2zQ3G5zTv7P/UJ3yMKdeXAVBR929sG9kSytG9x9ZF3Et/x9Wy5IhVga6rDd4fBSlb5PGyI8aIg5MbdJYsbV3HKjcl4cZkNsPzXKUrFjkO+BD+oUpcCD6ZpvInye7NlWZZ1bMERZLy2NrqndgJgCyA4alfyDrYha0OdBIA7yBALNTPPvYyJLg2JANigmvZt6fvNGTyuh56cFt39m3A==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from PH7PR11MB5984.namprd11.prod.outlook.com (2603:10b6:510:1e3::15)
 by PH0PR11MB5595.namprd11.prod.outlook.com (2603:10b6:510:e5::16) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.6745.18; Thu, 31 Aug
 2023 21:48:22 +0000
Received: from PH7PR11MB5984.namprd11.prod.outlook.com
 ([fe80::9563:9642:bbde:293f]) by PH7PR11MB5984.namprd11.prod.outlook.com
 ([fe80::9563:9642:bbde:293f%7]) with mapi id 15.20.6745.022; Thu, 31 Aug 2023
 21:48:21 +0000
Message-ID: <83a9a5e9-c876-7d26-f119-342237216dc1@intel.com>
Date: Thu, 31 Aug 2023 14:48:17 -0700
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101
 Betterbird/102.13.0
Subject: Re: [PATCH RFC v2 13/18] dax/bus: Factor out dev dax resize logic
To: Ira Weiny <ira.weiny@intel.com>,
        Dan Williams <dan.j.williams@intel.com>
CC: Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Alison Schofield <alison.schofield@intel.com>,
        "Vishal Verma" <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
 <20230604-dcd-type2-upstream-v2-13-f740c47e7916@intel.com>
Content-Language: en-US
From: Dave Jiang <dave.jiang@intel.com>
In-Reply-To: <20230604-dcd-type2-upstream-v2-13-f740c47e7916@intel.com>
Content-Type: text/plain; charset="UTF-8"; format=flowed
Content-Transfer-Encoding: 7bit
X-ClientProxiedBy: BYAPR06CA0023.namprd06.prod.outlook.com
 (2603:10b6:a03:d4::36) To PH7PR11MB5984.namprd11.prod.outlook.com
 (2603:10b6:510:1e3::15)
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: PH7PR11MB5984:EE_|PH0PR11MB5595:EE_
X-MS-Office365-Filtering-Correlation-Id: 8f79f681-8ed2-4437-c42a-08dbaa6bfe8f
X-LD-Processed: 46c98d88-e344-4ed4-8496-4ed7712e255d,ExtAddr
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;
X-Microsoft-Antispam-Message-Info: Jf1fUiDo8giwJqEbLzCavkmTA/Fu4+P9ubUsggGrBUxdqwKxaL9M+T9z++iEllQUAWdrqJSiqrWaFLDYEQd+jQ+BPhiu2wfH7Iqvc4a7Bza16iuO9rYxz2H6UqVXhGIG+BTkSNR7SmZJ4BYOhltCfjYSOxeemnT4fqRrYgxRHs1g5lRYt95hIQrerH4MP1BkOQHgVro62yKKhKGKtN3fGUyVeHybmEG0phqvQJxn9HrfWQyS0CUwjX+r4GhC6Lt44pQ1HXZbCzzCC1N/uUhl2bp081faLJWAo57KKAUM4LjM/3vewFe39Xbf9umStiv9JEvR4W3OUnYz0xl7Oe0aCdXFewojF43LQ24rreUIy4wyPLwuWpW7lzPi4lQZS21C0idPg35rw2WJWm5Cgu7gieMFRWXubOUniRvQ+myIR1XPNT1OKufwLEuZDHfNHpII+QhYa2CnCVUXUo4SQLV1UxUslB3l5O8KqX81uTKnRpMUCUSA3d1gfKo5ECvzVmKkZx4d9EmnQCaEtry3Kgh0kQeJXhH04i3SHQvv+u0qnVTFqRvmxJLlD39KVDm1w5iWr5eujGxVXnQGFDB06tZ2ispc9mRq9reM2Jp3pGrlL8sc21fxyrTGLy5I9ajhlHtEEDpkbNpDLUtB2otJzzK7pg==
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:PH7PR11MB5984.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230031)(376002)(346002)(39860400002)(396003)(136003)(366004)(451199024)(186009)(1800799009)(2906002)(6506007)(6512007)(6666004)(6486002)(53546011)(478600001)(26005)(2616005)(5660300002)(66946007)(54906003)(8676002)(316002)(41300700001)(4326008)(66556008)(44832011)(83380400001)(66476007)(6636002)(110136005)(36756003)(31696002)(82960400001)(38100700002)(86362001)(8936002)(31686004)(66899024)(43740500002)(45980500001);DIR:OUT;SFP:1102;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?utf-8?B?cUJsNGgybnNGOW9uUVJvbE4xTmQ5OWppSTVDK2R1bFQ2LzRCWVBkY3dEYW8x?=
 =?utf-8?B?WFI5RFhpK3BNVm81L0JlSnFsN0ZwZWtOdkkvRldNaHpTRmhZVDcybjkzanBD?=
 =?utf-8?B?RGhJS25ZSWtwSitpODlacUtXZUplT2pyMVl6Q2NqVWN3SG80V0d1YUhGd0hv?=
 =?utf-8?B?c082M1ZuT0JBTG1xelloOGRZVGYxUnQ4bVpQTzlTblVCSWVEN0hJdm1jUXUy?=
 =?utf-8?B?aVNOeGdiYTBZRkx1eU9MNDZKcC9HSjhIMWVsRU83STlhM0Fub2VhWmJyODVI?=
 =?utf-8?B?Mzk4OElmYk5oTmhPOG5NaXJFRk9FMktlb3VOaE5ZNllQTVlBM2x5MmVnd01V?=
 =?utf-8?B?TlQ5Vnl3SjZ6MllpeHRHeitDMEZsOU1CaC9GcWdtaFQzUG5vMVNpemJycEV0?=
 =?utf-8?B?eU5qWVNuVFRVR0JyUkszSlRicjgzNFhrT3lieFIySk9UZU85bWJmUTRWODZt?=
 =?utf-8?B?amFoNmYxSlhTQzVMdmJxSlo1cjREQ3dsV2VobHBvWk1iVFBSYmZYMmdURGhz?=
 =?utf-8?B?S3RtdnNDV0hRUHc5a3VGcU5mblAvQzRRR0lodzNoRkQ1OVdvaEorL045cEEx?=
 =?utf-8?B?ZVhlNGtQWXUvN3gvblJGV2F2MEtqMnR6UXhPVzhNYnNlNW1FMDgrbXVBcCts?=
 =?utf-8?B?TG5HMjB1dHJhbjUwQUI4VEF3cFo1RzI4d2tDNVFKR21ZN21BYkgyVlJlQ0Ur?=
 =?utf-8?B?TUx2MGU5MVZsejVmK1ZLTVdIc2pabEVkTEdkUXcxeXNMdDJaMkgyMzFDSnkw?=
 =?utf-8?B?d2NMRjRvODc0SnFsVGh0bnFpKzNDODBLZUJwRGplaHlkR2dUaVluWjRPQTE0?=
 =?utf-8?B?RlFaRjVDeTNzOTlwNFl1YWZyQ1ovRGgwbVVuQ1lMTkR5c28rbkp3ZFl1aTZG?=
 =?utf-8?B?dC9JVElQb21qZDNUUHpjSUNyMGczY0xSZVNXTU4wS05XcHluM3ZITGxkR3gr?=
 =?utf-8?B?TWV0S3hRU0swV0VZWjhROElKTlZYNEpZYmFibkZoM0dEODg0VVprbEp4by9S?=
 =?utf-8?B?RFlJay9KWWpqRnIvc2ZKV0gvOTU1UU54Vk93SFRNay8zelpnYWpwZ0NUZkla?=
 =?utf-8?B?aWQ5RHc3ODlwY0FEQllKa3VJQllyWStiM2FpT2FtWlN2dEExUmdYdjRVMlBu?=
 =?utf-8?B?Y2VldXVKV1ozd0Mxdk1YeExzOUxFaXhoRzRrR0VoOUw4YnhMTWY3TkpJUmcw?=
 =?utf-8?B?am0rQ3Nvd1hvMlFCdUs2bHVVQ1IrTXJCM2pGRk44T05wZzk4cUxoNjhaMDlo?=
 =?utf-8?B?bGdudVZyZy9lS2VPNUxFenhMVERxQUFoY2p1QTBEcGExRVhXdEVQMVVUaURa?=
 =?utf-8?B?dzJESVBBOHpHMEluK1BuMUxyZjFMcktIVXlJS2gvTTd0WU13OEd6YStKZE0r?=
 =?utf-8?B?Z2gwN01RaHBpaHZJWWJranZ5MDA4bjAyNmpCTmlGams5bUdOMWFUQUQvMFRU?=
 =?utf-8?B?R3JCRFFSYXVYSTc3YW9WMVJheklCMThLMy94ZGRHRUhyOUZaUGgzdTU5MzJX?=
 =?utf-8?B?ckJjb2NRU2o3ejlHZ0hGRFZ3N2hvTnNXWGkyRkNEeGdSejRNSmlYV0d5L0Ju?=
 =?utf-8?B?aUJWcmh3VncxNW41V3h5OGpobmJsd3R2b01GaHRFVDBLQitJWHVFaThxOHFs?=
 =?utf-8?B?Vi9pWVUzOWNTMmQ3VVNLWHZXM203UElQVklweTM5MUJ6b3lnSmV5ZEJENHJF?=
 =?utf-8?B?ajRMbnlOTjZXYUtYLzQ1dWlkVXludmg0U1FxbUdJcXlrUDZTYUxEbnJQMkEz?=
 =?utf-8?B?NWE3a05VMUxSMG10S3BocXJjTzl2UlVZRURIRGtleVIvb3NaWnZrdjhJc0ln?=
 =?utf-8?B?SnVGRE12MWNtcUVrRkpTd2NaeVhWNUpKMlQySEQvSno3bnlhbWI4dkN5RzNp?=
 =?utf-8?B?czE2bnNMekd5QndPWktYU1RUZVVYZmlsMjFSY3NoNUNUdGhiaHQvZkNoV0dw?=
 =?utf-8?B?aUJlOS9FK1dpendadEV6dzNuOTdUYlVtT3llektaMTVLTmdJdlpPVDIwRUMx?=
 =?utf-8?B?Tk1vdzJ5QXhncUZBVmdHVFRBcDRXdDBzak9zWEQ0ZTRLb2xrMjcxa25LcERa?=
 =?utf-8?B?TjJ6Y0FGL0tvUlhGYktJYk5uVlFtTGZEZHFjK3B6eGV5Z09YUzViTjY0K3Z3?=
 =?utf-8?Q?em+XiE6bW8E7RG3MHpx34dof5?=
X-MS-Exchange-CrossTenant-Network-Message-Id: 8f79f681-8ed2-4437-c42a-08dbaa6bfe8f
X-MS-Exchange-CrossTenant-AuthSource: PH7PR11MB5984.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 31 Aug 2023 21:48:21.5496
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: yBimXBnPo7rK2yMjLTln+DEWQYJ/VC5T93Tec1jdggpzgtntVk3mZyjCh3ISLgmB+S8zgSBhdAuBBejIL33eVQ==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: PH0PR11MB5595
X-OriginatorOrg: intel.com
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org



On 8/28/23 22:21, Ira Weiny wrote:
> Dynamic Capacity regions must limit dev dax resources to those areas
> which have extents backing real memory.  Four alternatives were
> considered to manage the intersection of region space and extents:
> 
> 1) Create a single region resource child on region creation which
>     reserves the entire region.  Then as extents are added punch holes in
>     this reservation.  This requires new resource manipulation to punch
>     the holes and still requires an additional iteration over the extent
>     areas which may already have existing dev dax resources used.
> 
> 2) Maintain an ordered xarray of extents which can be queried while
>     processing the resize logic.  The issue is that existing region->res
>     children may artificially limit the allocation size sent to
>     alloc_dev_dax_range().  IE the resource children can't be directly
>     used in the resize logic to find where space in the region is.
> 
> 3) Maintain a separate resource tree with extents.  This option is the
>     same as 2) but with a different data structure.  Most ideally we have
>     some unified representation of the resource tree.
> 
> 4) Create region resource children for each extent.  Manage the dax dev
>     resize logic in the same way as before but use a region child
>     (extent) resource as the parents to find space within each extent.
> 
> Option 4 can leverage the existing resize algorithm to find space within
> the extents.
> 
> In preparation for this change, factor out the dev_dax_resize logic.
> For static regions use dax_region->res as the parent to find space for
> the dax ranges.  Future patches will use the same algorithm with
> individual extent resources as the parent.
> 
> Signed-off-by: Ira Weiny <ira.weiny@intel.com>

Reviewed-by: Dave Jiang <dave.jiang@intel.com>
> ---
>   drivers/dax/bus.c | 128 +++++++++++++++++++++++++++++++++---------------------
>   1 file changed, 79 insertions(+), 49 deletions(-)
> 
> diff --git a/drivers/dax/bus.c b/drivers/dax/bus.c
> index b76e49813a39..ea7ae82b4687 100644
> --- a/drivers/dax/bus.c
> +++ b/drivers/dax/bus.c
> @@ -817,11 +817,10 @@ static int devm_register_dax_mapping(struct dev_dax *dev_dax, int range_id)
>   	return 0;
>   }
>   
> -static int alloc_dev_dax_range(struct dev_dax *dev_dax, u64 start,
> -		resource_size_t size)
> +static int alloc_dev_dax_range(struct resource *parent, struct dev_dax *dev_dax,
> +			       u64 start, resource_size_t size)
>   {
>   	struct dax_region *dax_region = dev_dax->region;
> -	struct resource *res = &dax_region->res;
>   	struct device *dev = &dev_dax->dev;
>   	struct dev_dax_range *ranges;
>   	unsigned long pgoff = 0;
> @@ -839,14 +838,14 @@ static int alloc_dev_dax_range(struct dev_dax *dev_dax, u64 start,
>   		return 0;
>   	}
>   
> -	alloc = __request_region(res, start, size, dev_name(dev), 0);
> +	alloc = __request_region(parent, start, size, dev_name(dev), 0);
>   	if (!alloc)
>   		return -ENOMEM;
>   
>   	ranges = krealloc(dev_dax->ranges, sizeof(*ranges)
>   			* (dev_dax->nr_range + 1), GFP_KERNEL);
>   	if (!ranges) {
> -		__release_region(res, alloc->start, resource_size(alloc));
> +		__release_region(parent, alloc->start, resource_size(alloc));
>   		return -ENOMEM;
>   	}
>   
> @@ -997,50 +996,45 @@ static bool adjust_ok(struct dev_dax *dev_dax, struct resource *res)
>   	return true;
>   }
>   
> -static ssize_t dev_dax_resize(struct dax_region *dax_region,
> -		struct dev_dax *dev_dax, resource_size_t size)
> +/*
> + * dev_dax_resize_static - Expand the device into the unused portion of the
> + * region. This may involve adjusting the end of an existing resource, or
> + * allocating a new resource.
> + *
> + * @parent: parent resource to allocate this range in.
> + * @dev_dax: DAX device we are creating this range for
> + * @to_alloc: amount of space to alloc; must be <= space available in @parent
> + *
> + * Return the amount of space allocated or -ERRNO on failure
> + */
> +static ssize_t dev_dax_resize_static(struct resource *parent,
> +				     struct dev_dax *dev_dax,
> +				     resource_size_t to_alloc)
>   {
> -	resource_size_t avail = dax_region_avail_size(dax_region), to_alloc;
> -	resource_size_t dev_size = dev_dax_size(dev_dax);
> -	struct resource *region_res = &dax_region->res;
> -	struct device *dev = &dev_dax->dev;
>   	struct resource *res, *first;
> -	resource_size_t alloc = 0;
>   	int rc;
>   
> -	if (dev->driver)
> -		return -EBUSY;
> -	if (size == dev_size)
> -		return 0;
> -	if (size > dev_size && size - dev_size > avail)
> -		return -ENOSPC;
> -	if (size < dev_size)
> -		return dev_dax_shrink(dev_dax, size);
> -
> -	to_alloc = size - dev_size;
> -	if (dev_WARN_ONCE(dev, !alloc_is_aligned(dev_dax, to_alloc),
> -			"resize of %pa misaligned\n", &to_alloc))
> -		return -ENXIO;
> -
> -	/*
> -	 * Expand the device into the unused portion of the region. This
> -	 * may involve adjusting the end of an existing resource, or
> -	 * allocating a new resource.
> -	 */
> -retry:
> -	first = region_res->child;
> -	if (!first)
> -		return alloc_dev_dax_range(dev_dax, dax_region->res.start, to_alloc);
> +	first = parent->child;
> +	if (!first) {
> +		rc = alloc_dev_dax_range(parent, dev_dax,
> +					   parent->start, to_alloc);
> +		if (rc)
> +			return rc;
> +		return to_alloc;
> +	}
>   
> -	rc = -ENOSPC;
>   	for (res = first; res; res = res->sibling) {
>   		struct resource *next = res->sibling;
> +		resource_size_t alloc;
>   
>   		/* space at the beginning of the region */
> -		if (res == first && res->start > dax_region->res.start) {
> -			alloc = min(res->start - dax_region->res.start, to_alloc);
> -			rc = alloc_dev_dax_range(dev_dax, dax_region->res.start, alloc);
> -			break;
> +		if (res == first && res->start > parent->start) {
> +			alloc = min(res->start - parent->start, to_alloc);
> +			rc = alloc_dev_dax_range(parent, dev_dax,
> +						 parent->start, alloc);
> +			if (rc)
> +				return rc;
> +			return alloc;
>   		}
>   
>   		alloc = 0;
> @@ -1049,21 +1043,55 @@ static ssize_t dev_dax_resize(struct dax_region *dax_region,
>   			alloc = min(next->start - (res->end + 1), to_alloc);
>   
>   		/* space at the end of the region */
> -		if (!alloc && !next && res->end < region_res->end)
> -			alloc = min(region_res->end - res->end, to_alloc);
> +		if (!alloc && !next && res->end < parent->end)
> +			alloc = min(parent->end - res->end, to_alloc);
>   
>   		if (!alloc)
>   			continue;
>   
>   		if (adjust_ok(dev_dax, res)) {
>   			rc = adjust_dev_dax_range(dev_dax, res, resource_size(res) + alloc);
> -			break;
> +			if (rc)
> +				return rc;
> +			return alloc;
>   		}
> -		rc = alloc_dev_dax_range(dev_dax, res->end + 1, alloc);
> -		break;
> +		rc = alloc_dev_dax_range(parent, dev_dax, res->end + 1, alloc);
> +		if (rc)
> +			return rc;
> +		return alloc;
>   	}
> -	if (rc)
> -		return rc;
> +
> +	/* available was already calculated and should never be an issue */
> +	dev_WARN_ONCE(&dev_dax->dev, 1, "space not found?");
> +	return 0;
> +}
> +
> +static ssize_t dev_dax_resize(struct dax_region *dax_region,
> +		struct dev_dax *dev_dax, resource_size_t size)
> +{
> +	resource_size_t avail = dax_region_avail_size(dax_region), to_alloc;
> +	resource_size_t dev_size = dev_dax_size(dev_dax);
> +	struct device *dev = &dev_dax->dev;
> +	resource_size_t alloc = 0;
> +
> +	if (dev->driver)
> +		return -EBUSY;
> +	if (size == dev_size)
> +		return 0;
> +	if (size > dev_size && size - dev_size > avail)
> +		return -ENOSPC;
> +	if (size < dev_size)
> +		return dev_dax_shrink(dev_dax, size);
> +
> +	to_alloc = size - dev_size;
> +	if (dev_WARN_ONCE(dev, !alloc_is_aligned(dev_dax, to_alloc),
> +			"resize of %pa misaligned\n", &to_alloc))
> +		return -ENXIO;
> +
> +retry:
> +	alloc = dev_dax_resize_static(&dax_region->res, dev_dax, to_alloc);
> +	if (alloc <= 0)
> +		return alloc;
>   	to_alloc -= alloc;
>   	if (to_alloc)
>   		goto retry;
> @@ -1154,7 +1182,8 @@ static ssize_t mapping_store(struct device *dev, struct device_attribute *attr,
>   
>   	to_alloc = range_len(&r);
>   	if (alloc_is_aligned(dev_dax, to_alloc))
> -		rc = alloc_dev_dax_range(dev_dax, r.start, to_alloc);
> +		rc = alloc_dev_dax_range(&dax_region->res, dev_dax, r.start,
> +					 to_alloc);
>   	device_unlock(dev);
>   	device_unlock(dax_region->dev);
>   
> @@ -1371,7 +1400,8 @@ struct dev_dax *devm_create_dev_dax(struct dev_dax_data *data)
>   	device_initialize(dev);
>   	dev_set_name(dev, "dax%d.%d", dax_region->id, dev_dax->id);
>   
> -	rc = alloc_dev_dax_range(dev_dax, dax_region->res.start, data->size);
> +	rc = alloc_dev_dax_range(&dax_region->res, dev_dax, dax_region->res.start,
> +				 data->size);
>   	if (rc)
>   		goto err_range;
>   
> 

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 7D6A2C83F37
	for <linux-cxl@archiver.kernel.org>; Thu, 31 Aug 2023 18:38:18 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S234772AbjHaSiT (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Thu, 31 Aug 2023 14:38:19 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:51198 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S234565AbjHaSiT (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Thu, 31 Aug 2023 14:38:19 -0400
Received: from mgamail.intel.com (mgamail.intel.com [192.55.52.120])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 4DD47E5D;
        Thu, 31 Aug 2023 11:38:15 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1693507095; x=1725043095;
  h=message-id:date:subject:to:cc:references:from:
   in-reply-to:content-transfer-encoding:mime-version;
  bh=rmXkq5qn7f3cLBcHFkKj/mxolkEXMfmB0JyHMvhk9Tg=;
  b=XD2ltz8k6KO5KqwY9KKbOR79kfzUVV8R2We+ZyDOOtfTX74rdQPN4Hsi
   Gm14u5NbLc384ypERLasumTTL6vAh6UJSOUIf599hwF0Gv94Y8pltHajj
   OTst/9/mjCOa14Trw+H0QUeYfdlnrELjN3QhM3RKn2oHrsxgQn+HIB0vx
   5jTG6s2oMVWMahP61rC6zdhUbyNO7A5MlcGbVeqteO87ZCUZ+NE8j9+f8
   VyL6Qfh9g9e/wpbVeEh8i2SiA4Fii31W/q7h97pD9oTWBRvagLdHOkyxd
   I9mu3bkkxkA8KhyhfcrLOz+T4IIfhIq6DqVuWmH4py//AdEc7HVFhz4PU
   Q==;
X-IronPort-AV: E=McAfee;i="6600,9927,10819"; a="374940539"
X-IronPort-AV: E=Sophos;i="6.02,217,1688454000"; 
   d="scan'208";a="374940539"
Received: from orsmga006.jf.intel.com ([10.7.209.51])
  by fmsmga104.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 31 Aug 2023 11:38:14 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10819"; a="716457272"
X-IronPort-AV: E=Sophos;i="6.02,217,1688454000"; 
   d="scan'208";a="716457272"
Received: from orsmsx603.amr.corp.intel.com ([10.22.229.16])
  by orsmga006.jf.intel.com with ESMTP/TLS/AES256-GCM-SHA384; 31 Aug 2023 11:38:14 -0700
Received: from orsmsx611.amr.corp.intel.com (10.22.229.24) by
 ORSMSX603.amr.corp.intel.com (10.22.229.16) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27; Thu, 31 Aug 2023 11:38:13 -0700
Received: from orsmsx602.amr.corp.intel.com (10.22.229.15) by
 ORSMSX611.amr.corp.intel.com (10.22.229.24) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27; Thu, 31 Aug 2023 11:38:13 -0700
Received: from ORSEDG601.ED.cps.intel.com (10.7.248.6) by
 orsmsx602.amr.corp.intel.com (10.22.229.15) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27 via Frontend Transport; Thu, 31 Aug 2023 11:38:13 -0700
Received: from NAM11-BN8-obe.outbound.protection.outlook.com (104.47.58.168)
 by edgegateway.intel.com (134.134.137.102) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.27; Thu, 31 Aug 2023 11:38:13 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=ZKhPhUhdGICFVZgTv3LH48Y3c6oEO15N33qn8YMLbcrTiuw/ly0cZzM1ZnxO2dTDF5cexkKUruFQ/uabeawIK1cii9HjTOHp/7i65wvAmjrqo9u5g6VZMGA8qIgVINtvyqwKaF0G5RfR00BRoenT3yH2es75zubP5N1T6ZjAaty2bNhqE03Gwt37RdK4EaioVToeOknY+hMWLajnrss6UQD/RNrsUAt8Mu4LZEfXMY5UKYrzZenuuxPwv4M1VyfVBYwqRkZ9khdrNLVWiulAHxSZPCmMjTqFi0Ir9RlRGgGJ/OI9yPxq2MmP6cy8vCIoVLOtSuXDv8SmjDdFpgvc3A==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=hwAs5prtdYfj19Yy6IGzQr2JhzIJ5+hA/HBM8C+UyfU=;
 b=ZqBQNJXfAfU/nVlB7uRjSJIuBTytYLIm4G0fnBEkOaHMlVkECL9s8anJ+rkR88H9E98hOU6cjn5GkGM7Adk09/J78WQ+gS1myNJocQ1Jlp09WbV800BUDTs0EDN/oElk/HOHL/adyBOob11oVPEBKID/cgI+RBHr4SgTn78ZxxUZuiydwFivRz3NJ6dvTKzS/kifkP9hcVgxvS/toJ2ap5WjoAWTZ88j62IsYQVhH+uHpyPRsJ7hZW7QPw5+sP1grLFG1mHnLSn9F0pHG2+lVgwh7e9LEAEg2hIrKioS7dXcbENeg9GjxiYC5VpkFTJ5BtjpqGL4mVRSL+vRkTBe+Q==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from PH7PR11MB5984.namprd11.prod.outlook.com (2603:10b6:510:1e3::15)
 by PH8PR11MB6658.namprd11.prod.outlook.com (2603:10b6:510:1c1::16) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.6745.20; Thu, 31 Aug
 2023 18:38:10 +0000
Received: from PH7PR11MB5984.namprd11.prod.outlook.com
 ([fe80::9563:9642:bbde:293f]) by PH7PR11MB5984.namprd11.prod.outlook.com
 ([fe80::9563:9642:bbde:293f%7]) with mapi id 15.20.6745.022; Thu, 31 Aug 2023
 18:38:10 +0000
Message-ID: <f834c62d-bcbc-899b-db72-117c6e7b13af@intel.com>
Date: Thu, 31 Aug 2023 11:38:06 -0700
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101
 Betterbird/102.13.0
Subject: Re: [PATCH RFC v2 11/18] cxl/region: Expose DC extents on region
 driver load
To: Ira Weiny <ira.weiny@intel.com>,
        Dan Williams <dan.j.williams@intel.com>
CC: Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Alison Schofield <alison.schofield@intel.com>,
        "Vishal Verma" <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
 <20230604-dcd-type2-upstream-v2-11-f740c47e7916@intel.com>
Content-Language: en-US
From: Dave Jiang <dave.jiang@intel.com>
In-Reply-To: <20230604-dcd-type2-upstream-v2-11-f740c47e7916@intel.com>
Content-Type: text/plain; charset="UTF-8"; format=flowed
Content-Transfer-Encoding: 7bit
X-ClientProxiedBy: BYAPR02CA0015.namprd02.prod.outlook.com
 (2603:10b6:a02:ee::28) To PH7PR11MB5984.namprd11.prod.outlook.com
 (2603:10b6:510:1e3::15)
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: PH7PR11MB5984:EE_|PH8PR11MB6658:EE_
X-MS-Office365-Filtering-Correlation-Id: a7c558bd-4998-4a76-5c01-08dbaa516cf4
X-LD-Processed: 46c98d88-e344-4ed4-8496-4ed7712e255d,ExtAddr
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;
X-Microsoft-Antispam-Message-Info: qHvwYDGMOFlytarVYoW+KWOPcdtiMOv4yVd/2Ne2n5qMuL4OYwvX8mtneXXd0CirzaNhwGiOetW86C/EJUMTIYoe8VnfacNLu4pFd6Hcm17jBVvwfDkBcDlOsV430PeNJG2e30gsqRzsfNWwWd+xJH/0u9Ij6ibFgJ6MpYyRMrVcLSQvvYOccTY0YYyacGishxsc4HbTbk2RZsK33FTty9wRa9tXHiqcPgrx0HPugJvOdSjBRHRVrfINpM+Jv09mPK15+1+KfVu+0syQR9g+mL34GIdXXeDymZAxRWzR0CARxNvam7Ph879LRkH55r2saR7axga8BNpmKuUoUkO97S2G3fs07s5lWtNuiS8wCVoyQEzk2LSM83GHhnuaShUyt+PhuVa0jA2+w0/ajj8Gm98bYvN0inqC8HPht+es0WUIuWAyypVeMO8WEdIn86ak8xK4i3i0F64D+HKhIUyAnMdM47t4Ouip79mqHWLC9bbyKQq6aEpoEii9hSD6eHiLvO4N3f2uw4nj8Rak8gnL6h2hZzD3fWd9X+Khxob4TKCkNNjuhtxBk1AiJP3B4bY5V0tJG5ZSzfV6T3oaEonHa76xEseOU0PyPkwHBsPAGlD0W7vODXHs6thpMyz24qUqhkhVEBUA/2jOPdj9KTrCJQ==
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:PH7PR11MB5984.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230031)(346002)(396003)(376002)(136003)(366004)(39860400002)(451199024)(186009)(1800799009)(36756003)(31686004)(83380400001)(4326008)(53546011)(44832011)(41300700001)(86362001)(8936002)(5660300002)(31696002)(8676002)(26005)(6506007)(6666004)(6486002)(2616005)(6512007)(2906002)(30864003)(110136005)(38100700002)(478600001)(54906003)(6636002)(82960400001)(66946007)(66556008)(66476007)(316002)(45980500001)(43740500002);DIR:OUT;SFP:1102;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?utf-8?B?bWE1QUhkNXNmQnYxekRXS2RxQTMzTkVCMm5nVy9SVm1TNmZLWTFsS01OTUN0?=
 =?utf-8?B?OTc1ZDF1QTd0NFZOVTk5VHJJeWFpdXo4TnZVRGRnYys4MjQxaVhDSlRkQXFL?=
 =?utf-8?B?OFdMbUJENEJENHg5T0wrUHFsQ2M1MnF2bW5WWUdTU3p4M09McFl4aWp5QWE2?=
 =?utf-8?B?QmtBSUQrelIrdXFDaW1HYStQWk0wUUJ0Z2JHNjZ0U2VLOHdqNlpVcUpLSWVy?=
 =?utf-8?B?STg4WGdlMW1lMmdOQWZOK09YeVU3Uk5OMUdBRzFMNXBIUDN3TmpQV2xXSms5?=
 =?utf-8?B?VjNWUEhuWDlpTHJUQVJqekpLMXVhR3ZhOHJMclVUa2JVbE82WFVKcmp5eEZT?=
 =?utf-8?B?V2VuczF1cXhWcGZxaThYdmhxdlJzL0twV0pyZnNiRGFIM3RDUm9FS0YzTEV4?=
 =?utf-8?B?NUxRb3ByOUg2Tng3NmFRd0R0QkIxd2piSytwOERuTC9ZRWt3N0sxcExoNmlj?=
 =?utf-8?B?UlpUUURYQmpWd0cwdjQrWEpSVFlUcTE1NFFwZWNBdUFhR1l4OCtkMWJrQUUy?=
 =?utf-8?B?RFBvclV2NThiU3FzZGFrRlUrZG5oRVN6RkQ1M2tXWkpGazJNdlJkNWZLT0tD?=
 =?utf-8?B?RWlycmwraEprb2FONVVZTi9oQzdTZnFSd0d2YXZxUTVCTzJUWmZQa3ZHWGxO?=
 =?utf-8?B?UE1DOFE2SndhamVHSE1Mc1VubGpCcEFIemZrM3Mrc2lyYjdhRGRjaWticU5q?=
 =?utf-8?B?ZTg1RXJFMzh2WnJzTzlQa05WRU5zckQ4aXlRVEs0cWxqa3Bya2RadVhTaFQx?=
 =?utf-8?B?M2VJVlVocGtvUi9BYkxGOUFOaFAyalRjVDBpSGZDSmJkWlV1V3N4OHVOR3RM?=
 =?utf-8?B?NHo4M09vZzIwMzNCckhzRk1neHo4UG55dGdNLzAwdzhCMGR5SjVvaXZTSnkw?=
 =?utf-8?B?VG9lQVp2UDNmVi9tY1NkdWN6MGZ3L254NjEvOHREL045WVlaWldDZWlCL1dn?=
 =?utf-8?B?ekVyMU1uMmtxM1RFQkFja3I2c3pPREFNRG0rc2pwdTk5R21hMjFHNkk1bjEz?=
 =?utf-8?B?c1YvRVJCMW15Mm5aK1ZvSVN6QUJrQ2M5VE9zalNTOWl6ZlFmMmNCTGNqNVd1?=
 =?utf-8?B?RmxRbUU0Rnc2UFZnbkE4U05XVHZOaDhIY3djb0hweWN0VVhKYUpma1JIZkZi?=
 =?utf-8?B?NGQzcFlKVm90TFpySzc5ckV0dE5VZUdEQXlMYUJzbzFqeThuMVJxMnlIM2Ro?=
 =?utf-8?B?b2x0Nk1jS3JqaktXNndzUzhwR3FTeGFOMlovTDBDQWRSRGJyQnloL1ZWZVVo?=
 =?utf-8?B?a0hRczRHWXdna0dSdlpqQzdTa2Rrajh0VnRnTDRyUjN1a3RSbWRlWnQ2NUV0?=
 =?utf-8?B?Zms0ZlkvcE1QVWIzQzdEcHhLZFNGRVNTUm41VU4zTTJOYmZ1bGlqOVlLRFND?=
 =?utf-8?B?Qmtod01QZUJVMDVhdGtEeGJsWjRxbjViMXRFVnFleWY1cjl0QmtabkdLM0tk?=
 =?utf-8?B?RnE4bi92TmxjRWJQZExRWVNCMkpmYmF2SnBCK2t0VE5xN0Q3SGg1T3A2WkhI?=
 =?utf-8?B?RnR1UkQxWjBWL2ZkaFVOZVVyY1FqblZBSjNka2kzV3dRUDM5SUFGajB3TDlv?=
 =?utf-8?B?eTlTcWdKekZ4QkdUbXVpWWQ1ZlRaTHkxcGN0RVV3Zkd3Q2NlY3V5TjVZUHpm?=
 =?utf-8?B?VEJSTGViOVMrOC9WdXhNZW5QbnBLTDZLSnZoc0w1eFY5UkhmczZNYVJKemJ6?=
 =?utf-8?B?aFRENTdzT0I5NmY1RnV0cWxwU29SMXhvRGtBenl6UDh6T20xU1U2dTZLS2tQ?=
 =?utf-8?B?YjlWZGtwWjNETmV2UlVMUHNJdFdQYjVXMXVUUi9GMFZDcm02d0JnY3g4NTcx?=
 =?utf-8?B?TEpUSC96NWVrQ3Z0bWh4bk5wblc4Z2NmWEF5RW0xODdvUlM4UjZpb1doZE5T?=
 =?utf-8?B?cHNRaWRjNHJXZTRxV0R0Tk9kMkVrQkIycGpzaCtkZG5QV0VsMklyYTlqdk1I?=
 =?utf-8?B?U1hDcjJUcHViM2hjQWp3NjN5N2NTZm9tWEpta05mTktuWkt2b2FIT2NxdWZW?=
 =?utf-8?B?WjBPRTRZWFladnNaQ1ZGendEb3lLYWlieDNpeXBjYmZ0WlY5LzZSSys1YjJ4?=
 =?utf-8?B?cVdiMlEwVTVoWG1rOE1vRkZzVWo3OUZLOVhpMm51Qm5xTlZ4b0tadlBjQS85?=
 =?utf-8?Q?f3D7UMVWhGnE2Pu/f5zO2DSQI?=
X-MS-Exchange-CrossTenant-Network-Message-Id: a7c558bd-4998-4a76-5c01-08dbaa516cf4
X-MS-Exchange-CrossTenant-AuthSource: PH7PR11MB5984.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 31 Aug 2023 18:38:10.1892
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: 1xyrkVsuYM71HN9Ti/Mn83YRkUuCaL7yBlrSA3ncKE11KJUh2Et7/57HWAElazwc63leu7l+SNdyFNQKpkwjdA==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: PH8PR11MB6658
X-OriginatorOrg: intel.com
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org



On 8/28/23 22:21, Ira Weiny wrote:
> Ultimately user space must associate Dynamic Capacity (DC) extents with
> DAX devices.  Remember also that DCD extents may have been accepted
> previous to regions being created and must have references held until
> all higher level regions and DAX devices are done with the memory.
> 
> On CXL region driver load scan existing device extents and create CXL
> DAX region extents as needed.
> 
> Create abstractions for the extents to be used in DAX region.  This
> includes a generic interface to take proper references on the lower
> level CXL region extents.
> 
> Also maintain separate objects for the DAX region extent device vs the
> DAX region extent.  The DAX region extent device has a shorter life span
> which corresponds to the removal of an extent while a DAX device is
> still using it.  In this case an extent continues to exist whilst the
> ability to create new DAX devices on that extent is prevented.
> 
> NOTE: Without interleaving; the device, CXL region, and DAX region
> extents have a 1:1:1 relationship.  Future support for interleaving will
> maintain a 1:N relationship between CXL region extents and the hardware
> extents.
> 
> While the ability to create DAX devices on an extent exists; expose the
> necessary details of DAX region extents by creating a device with the
> following sysfs entries.
> 
> /sys/bus/cxl/devices/dax_regionX/extentY
> /sys/bus/cxl/devices/dax_regionX/extentY/length
> /sys/bus/cxl/devices/dax_regionX/extentY/label
> 
> Label is a rough analogy to the DC extent tag.  As such the DC extent
> tag is used to initially populate the label.  However, the label is made
> writeable so that it can be adjusted in the future when forming a DAX
> device.
> 
> Signed-off-by: Navneet Singh <navneet.singh@intel.com>
> Co-developed-by: Navneet Singh <navneet.singh@intel.com>
> Signed-off-by: Ira Weiny <ira.weiny@intel.com>
> 
> ---
> Changes from v1
> [iweiny: move dax_region_extents to dax layer]
> [iweiny: adjust for kreference of extents]
> [iweiny: adjust naming to cxl_dr_extent]
> [iweiny: Remove region_extent xarray; use child devices instead]
> [iweiny: ensure dax region devices are destroyed on region destruction]
> [iweiny: use xa_insert]
> [iweiny: hpa_offset is a dr_extent parameter not an extent parameter]
> [iweiny: Add dc_region_extents when the region driver is loaded]
> ---
>   drivers/cxl/core/mbox.c   |  12 ++++
>   drivers/cxl/core/region.c | 179 ++++++++++++++++++++++++++++++++++++++++++++--
>   drivers/cxl/cxl.h         |  16 +++++
>   drivers/cxl/cxlmem.h      |   2 +
>   drivers/dax/Makefile      |   1 +
>   drivers/dax/cxl.c         | 101 ++++++++++++++++++++++++--
>   drivers/dax/dax-private.h |  53 ++++++++++++++
>   drivers/dax/extent.c      | 119 ++++++++++++++++++++++++++++++
>   8 files changed, 473 insertions(+), 10 deletions(-)
> 
> diff --git a/drivers/cxl/core/mbox.c b/drivers/cxl/core/mbox.c
> index 8474a28b16ca..5472ab1d0370 100644
> --- a/drivers/cxl/core/mbox.c
> +++ b/drivers/cxl/core/mbox.c
> @@ -1055,6 +1055,18 @@ static void dc_extent_release(struct kref *kref)
>   	kfree(extent);
>   }
>   
> +int __must_check cxl_dc_extent_get_not_zero(struct cxl_dc_extent_data *extent)
> +{
> +	return kref_get_unless_zero(&extent->region_ref);
> +}
> +EXPORT_SYMBOL_NS_GPL(cxl_dc_extent_get_not_zero, CXL);
> +
> +void cxl_dc_extent_get(struct cxl_dc_extent_data *extent)
> +{
> +	kref_get(&extent->region_ref);
> +}
> +EXPORT_SYMBOL_NS_GPL(cxl_dc_extent_get, CXL);
> +
>   void cxl_dc_extent_put(struct cxl_dc_extent_data *extent)
>   {
>   	kref_put(&extent->region_ref, dc_extent_release);
> diff --git a/drivers/cxl/core/region.c b/drivers/cxl/core/region.c
> index fc8dee469244..0aeea50550f6 100644
> --- a/drivers/cxl/core/region.c
> +++ b/drivers/cxl/core/region.c
> @@ -1547,6 +1547,122 @@ static int cxl_region_validate_position(struct cxl_region *cxlr,
>   	return 0;
>   }
>   
> +static bool cxl_dc_extent_in_ed(struct cxl_endpoint_decoder *cxled,
> +				struct cxl_dc_extent_data *extent)
> +{
> +	struct range dpa_range = (struct range){
> +		.start = extent->dpa_start,
> +		.end = extent->dpa_start + extent->length - 1,
> +	};
> +	struct device *dev = &cxled->cxld.dev;
> +
> +	dev_dbg(dev, "Checking extent DPA:%llx LEN:%llx\n",
> +		extent->dpa_start, extent->length);
> +
> +	if (!cxled->cxld.region || !cxled->dpa_res)
> +		return false;
> +
> +	dev_dbg(dev, "Cxled start:%llx end:%llx\n",
> +		cxled->dpa_res->start, cxled->dpa_res->end);

Just use %pr?

> +	return (cxled->dpa_res->start <= dpa_range.start &&
> +		dpa_range.end <= cxled->dpa_res->end);

I may be easier to read for some if you have (dpa_range.start > 
cxled->dpa_res->start && ...) instead.

> +}
> +
> +static int cxl_ed_add_one_extent(struct cxl_endpoint_decoder *cxled,
> +				 struct cxl_dc_extent_data *extent)
> +{
> +	struct cxl_dr_extent *cxl_dr_ext;
> +	struct cxl_dax_region *cxlr_dax;
> +	resource_size_t dpa_offset, hpa;
> +	struct range *ed_hpa_range;
> +	struct device *dev;
> +	int rc;
> +
> +	cxlr_dax = cxled->cxld.region->cxlr_dax;
> +	dev = &cxlr_dax->dev;
> +	dev_dbg(dev, "Adding DC extent DPA:%llx LEN:%llx\n",
> +		extent->dpa_start, extent->length);
> +
> +	/*
> +	 * Interleave ways == 1 means this coresponds to a 1:1 mapping between
> +	 * device extents and DAX region extents.  Future implementations
> +	 * should hold DC region extents here until the full dax region extent
> +	 * can be realized.
> +	 */
> +	if (cxlr_dax->cxlr->params.interleave_ways != 1) {
> +		dev_err(dev, "Interleaving DC not supported\n");
> +		return -EINVAL;
> +	}
> +
> +	cxl_dr_ext = kzalloc(sizeof(*cxl_dr_ext), GFP_KERNEL);
> +	if (!cxl_dr_ext)
> +		return -ENOMEM;
> +
> +	cxl_dr_ext->extent = extent;
> +	kref_init(&cxl_dr_ext->region_ref);
> +
> +	/*
> +	 * Without interleave...
> +	 * HPA offset == DPA offset
> +	 * ... but do the math anyway
> +	 */
> +	dpa_offset = extent->dpa_start - cxled->dpa_res->start;
> +	ed_hpa_range = &cxled->cxld.hpa_range;
> +	hpa = ed_hpa_range->start + dpa_offset;
> +	cxl_dr_ext->hpa_offset = hpa - cxlr_dax->hpa_range.start;
> +
> +	/* Without interleave carry length and label through */
> +	cxl_dr_ext->hpa_length = extent->length;
> +	snprintf(cxl_dr_ext->label, CXL_EXTENT_LABEL_LEN, "%s",
> +		 extent->tag);
> +
> +	dev_dbg(dev, "Inserting at HPA:%llx\n", cxl_dr_ext->hpa_offset);
> +	rc = xa_insert(&cxlr_dax->extents, cxl_dr_ext->hpa_offset, cxl_dr_ext,
> +		       GFP_KERNEL);
> +	if (rc) {
> +		dev_err(dev, "Failed to insert extent %d\n", rc);
> +		kfree(cxl_dr_ext);
> +		return rc;
> +	}
> +	/* Put in cxl_dr_release() */
> +	cxl_dc_extent_get(cxl_dr_ext->extent);
> +	return 0;
> +}
> +
> +static int cxl_ed_add_extents(struct cxl_endpoint_decoder *cxled)
> +{
> +	struct cxl_memdev *cxlmd = cxled_to_memdev(cxled);
> +	struct cxl_dev_state *cxlds = cxlmd->cxlds;
> +	struct cxl_memdev_state *mds = container_of(cxlds,
> +						    struct cxl_memdev_state,
> +						    cxlds);
> +	struct device *dev = &cxled->cxld.dev;
> +	struct cxl_dc_extent_data *extent;
> +	unsigned long index;
> +
> +	dev_dbg(dev, "Searching for DC extents\n");
> +	xa_for_each(&mds->dc_extent_list, index, extent) {
> +		/*
> +		 * get not zero is important because this is racing with the
> +		 * memory device which could be removing the extent at the same
> +		 * time.
> +		 */
> +		if (cxl_dc_extent_get_not_zero(extent)) {
> +			int rc = 0;
> +
> +			if (cxl_dc_extent_in_ed(cxled, extent)) {
> +				dev_dbg(dev, "Found extent DPA:%llx LEN:%llx\n",
> +					extent->dpa_start, extent->length);
> +				rc = cxl_ed_add_one_extent(cxled, extent);
> +			}
> +			cxl_dc_extent_put(extent);
> +			if (rc)
> +				return rc;
> +		}
> +	}
> +	return 0;
> +}
> +
>   static int cxl_region_attach_position(struct cxl_region *cxlr,
>   				      struct cxl_root_decoder *cxlrd,
>   				      struct cxl_endpoint_decoder *cxled,
> @@ -2702,10 +2818,44 @@ static struct cxl_pmem_region *cxl_pmem_region_alloc(struct cxl_region *cxlr)
>   	return cxlr_pmem;
>   }
>   
> +int __must_check cxl_dr_extent_get_not_zero(struct cxl_dr_extent *cxl_dr_ext)
> +{
> +	return kref_get_unless_zero(&cxl_dr_ext->region_ref);
> +}
> +EXPORT_SYMBOL_NS_GPL(cxl_dr_extent_get_not_zero, CXL);
> +
> +void cxl_dr_extent_get(struct cxl_dr_extent *cxl_dr_ext)
> +{
> +	return kref_get(&cxl_dr_ext->region_ref);
> +}
> +EXPORT_SYMBOL_NS_GPL(cxl_dr_extent_get, CXL);
> +
> +static void cxl_dr_release(struct kref *kref)
> +{
> +	struct cxl_dr_extent *cxl_dr_ext = container_of(kref,
> +						struct cxl_dr_extent,
> +						region_ref);
> +
> +	cxl_dc_extent_put(cxl_dr_ext->extent);
> +	kfree(cxl_dr_ext);
> +}
> +
> +void cxl_dr_extent_put(struct cxl_dr_extent *cxl_dr_ext)
> +{
> +	kref_put(&cxl_dr_ext->region_ref, cxl_dr_release);
> +}
> +EXPORT_SYMBOL_NS_GPL(cxl_dr_extent_put, CXL);
> +
>   static void cxl_dax_region_release(struct device *dev)
>   {
>   	struct cxl_dax_region *cxlr_dax = to_cxl_dax_region(dev);
> +	struct cxl_dr_extent *cxl_dr_ext;
> +	unsigned long index;
>   
> +	xa_for_each(&cxlr_dax->extents, index, cxl_dr_ext) {
> +		xa_erase(&cxlr_dax->extents, index);
> +		cxl_dr_extent_put(cxl_dr_ext);
> +	}
>   	kfree(cxlr_dax);
>   }
>   
> @@ -2756,6 +2906,7 @@ static struct cxl_dax_region *cxl_dax_region_alloc(struct cxl_region *cxlr)
>   
>   	cxlr_dax->hpa_range.start = p->res->start;
>   	cxlr_dax->hpa_range.end = p->res->end;
> +	xa_init(&cxlr_dax->extents);
>   
>   	dev = &cxlr_dax->dev;
>   	cxlr_dax->cxlr = cxlr;
> @@ -2862,7 +3013,17 @@ static void cxlr_dax_unregister(void *_cxlr_dax)
>   	device_unregister(&cxlr_dax->dev);
>   }
>   
> -static int __devm_cxl_add_dax_region(struct cxl_region *cxlr)
> +static int cxl_region_add_dc_extents(struct cxl_region *cxlr)
> +{
> +	for (int i = 0; i < cxlr->params.nr_targets; i++) {
> +		int rc = cxl_ed_add_extents(cxlr->params.targets[i]);
> +		if (rc)
> +			return rc;
> +	}
> +	return 0;
> +}
> +
> +static int __devm_cxl_add_dax_region(struct cxl_region *cxlr, bool is_dc)
>   {
>   	struct cxl_dax_region *cxlr_dax;
>   	struct device *dev;
> @@ -2877,6 +3038,17 @@ static int __devm_cxl_add_dax_region(struct cxl_region *cxlr)
>   	if (rc)
>   		goto err;
>   
> +	cxlr->cxlr_dax = cxlr_dax;
> +	if (is_dc) {
> +		/*
> +		 * Process device extents prior to surfacing the device to
> +		 * ensure the cxl_dax_region driver has access to prior extents
> +		 */
> +		rc = cxl_region_add_dc_extents(cxlr);
> +		if (rc)
> +			goto err;
> +	}
> +
>   	rc = device_add(dev);
>   	if (rc)
>   		goto err;
> @@ -2893,7 +3065,7 @@ static int __devm_cxl_add_dax_region(struct cxl_region *cxlr)
>   
>   static int devm_cxl_add_dax_region(struct cxl_region *cxlr)
>   {
> -	return __devm_cxl_add_dax_region(cxlr);
> +	return __devm_cxl_add_dax_region(cxlr, false);
>   }
>   
>   static int devm_cxl_add_dc_dax_region(struct cxl_region *cxlr)
> @@ -2902,8 +3074,7 @@ static int devm_cxl_add_dc_dax_region(struct cxl_region *cxlr)
>   		dev_err(&cxlr->dev, "Interleaving DC not supported\n");
>   		return -EINVAL;
>   	}
> -
> -	return __devm_cxl_add_dax_region(cxlr);
> +	return __devm_cxl_add_dax_region(cxlr, true);
>   }
>   
>   static int match_decoder_by_range(struct device *dev, void *data)
> diff --git a/drivers/cxl/cxl.h b/drivers/cxl/cxl.h
> index 81ca76ae1d02..177b892ac53f 100644
> --- a/drivers/cxl/cxl.h
> +++ b/drivers/cxl/cxl.h
> @@ -555,6 +555,7 @@ struct cxl_region_params {
>    * @type: Endpoint decoder target type
>    * @cxl_nvb: nvdimm bridge for coordinating @cxlr_pmem setup / shutdown
>    * @cxlr_pmem: (for pmem regions) cached copy of the nvdimm bridge
> + * @cxlr_dax: (for DC regions) cached copy of CXL DAX bridge
>    * @flags: Region state flags
>    * @params: active + config params for the region
>    */
> @@ -565,6 +566,7 @@ struct cxl_region {
>   	enum cxl_decoder_type type;
>   	struct cxl_nvdimm_bridge *cxl_nvb;
>   	struct cxl_pmem_region *cxlr_pmem;
> +	struct cxl_dax_region *cxlr_dax;
>   	unsigned long flags;
>   	struct cxl_region_params params;
>   };
> @@ -614,8 +616,22 @@ struct cxl_dax_region {
>   	struct device dev;
>   	struct cxl_region *cxlr;
>   	struct range hpa_range;
> +	struct xarray extents;
>   };
>   
> +/* Interleave will manage multiple cxl_dc_extent_data objects */
> +#define CXL_EXTENT_LABEL_LEN 64
> +struct cxl_dr_extent {
> +	struct kref region_ref;
> +	u64 hpa_offset;
> +	u64 hpa_length;
> +	char label[CXL_EXTENT_LABEL_LEN];
> +	struct cxl_dc_extent_data *extent;
> +};
> +int cxl_dr_extent_get_not_zero(struct cxl_dr_extent *cxl_dr_ext);
> +void cxl_dr_extent_get(struct cxl_dr_extent *cxl_dr_ext);
> +void cxl_dr_extent_put(struct cxl_dr_extent *cxl_dr_ext);
> +
>   /**
>    * struct cxl_port - logical collection of upstream port devices and
>    *		     downstream port devices to construct a CXL memory
> diff --git a/drivers/cxl/cxlmem.h b/drivers/cxl/cxlmem.h
> index 118392229174..8ca81fd067c2 100644
> --- a/drivers/cxl/cxlmem.h
> +++ b/drivers/cxl/cxlmem.h
> @@ -1002,6 +1002,8 @@ int cxl_trigger_poison_list(struct cxl_memdev *cxlmd);
>   int cxl_inject_poison(struct cxl_memdev *cxlmd, u64 dpa);
>   int cxl_clear_poison(struct cxl_memdev *cxlmd, u64 dpa);
>   
> +int cxl_dc_extent_get_not_zero(struct cxl_dc_extent_data *extent);
> +void cxl_dc_extent_get(struct cxl_dc_extent_data *extent);
>   void cxl_dc_extent_put(struct cxl_dc_extent_data *extent);
>   
>   #ifdef CONFIG_CXL_SUSPEND
> diff --git a/drivers/dax/Makefile b/drivers/dax/Makefile
> index 5ed5c39857c8..38cd3c4c0898 100644
> --- a/drivers/dax/Makefile
> +++ b/drivers/dax/Makefile
> @@ -7,6 +7,7 @@ obj-$(CONFIG_DEV_DAX_CXL) += dax_cxl.o
>   
>   dax-y := super.o
>   dax-y += bus.o
> +dax-y += extent.o
>   device_dax-y := device.o
>   dax_pmem-y := pmem.o
>   dax_cxl-y := cxl.o
> diff --git a/drivers/dax/cxl.c b/drivers/dax/cxl.c
> index 147c8c69782b..057b00b1d914 100644
> --- a/drivers/dax/cxl.c
> +++ b/drivers/dax/cxl.c
> @@ -5,6 +5,87 @@
>   
>   #include "../cxl/cxl.h"
>   #include "bus.h"
> +#include "dax-private.h"
> +
> +static void dax_reg_ext_get(struct dax_region_extent *dr_extent)
> +{
> +	kref_get(&dr_extent->ref);
> +}
> +
> +static void dr_release(struct kref *kref)
> +{
> +	struct dax_region_extent *dr_extent;
> +	struct cxl_dr_extent *cxl_dr_ext;
> +
> +	dr_extent = container_of(kref, struct dax_region_extent, ref);
> +	cxl_dr_ext = dr_extent->private_data;
> +	cxl_dr_extent_put(cxl_dr_ext);
> +	kfree(dr_extent);
> +}
> +
> +static void dax_reg_ext_put(struct dax_region_extent *dr_extent)
> +{
> +	kref_put(&dr_extent->ref, dr_release);
> +}
> +
> +static int cxl_dax_region_create_extent(struct dax_region *dax_region,
> +					struct cxl_dr_extent *cxl_dr_ext)
> +{
> +	struct dax_region_extent *dr_extent;
> +	int rc;
> +
> +	dr_extent = kzalloc(sizeof(*dr_extent), GFP_KERNEL);
> +	if (!dr_extent)
> +		return -ENOMEM;
> +
> +	dr_extent->private_data = cxl_dr_ext;
> +	dr_extent->get = dax_reg_ext_get;
> +	dr_extent->put = dax_reg_ext_put;
> +
> +	/* device manages the dr_extent on success */
> +	kref_init(&dr_extent->ref);
> +
> +	rc = dax_region_ext_create_dev(dax_region, dr_extent,
> +				       cxl_dr_ext->hpa_offset,
> +				       cxl_dr_ext->hpa_length,
> +				       cxl_dr_ext->label);
> +	if (rc) {
> +		kfree(dr_extent);
> +		return rc;
> +	}
> +
> +	/* extent accepted */
> +	cxl_dr_extent_get(cxl_dr_ext);
> +	return 0;
> +}
> +
> +static int cxl_dax_region_create_extents(struct cxl_dax_region *cxlr_dax)
> +{
> +	struct cxl_dr_extent *cxl_dr_ext;
> +	unsigned long index;
> +
> +	dev_dbg(&cxlr_dax->dev, "Adding extents\n");
> +	xa_for_each(&cxlr_dax->extents, index, cxl_dr_ext) {
> +		/*
> +		 * get not zero is important because this is racing with the
> +		 * region driver which is racing with the memory device which
> +		 * could be removing the extent at the same time.
> +		 */
> +		if (cxl_dr_extent_get_not_zero(cxl_dr_ext)) {
> +			struct dax_region *dax_region;
> +			int rc;
> +
> +			dax_region = dev_get_drvdata(&cxlr_dax->dev);
> +			dev_dbg(&cxlr_dax->dev, "Found OFF:%llx LEN:%llx\n",
> +				cxl_dr_ext->hpa_offset, cxl_dr_ext->hpa_length);
> +			rc = cxl_dax_region_create_extent(dax_region, cxl_dr_ext);
> +			cxl_dr_extent_put(cxl_dr_ext);
> +			if (rc)
> +				return rc;
> +		}
> +	}
> +	return 0;
> +}
>   
>   static int cxl_dax_region_probe(struct device *dev)
>   {
> @@ -19,20 +100,28 @@ static int cxl_dax_region_probe(struct device *dev)
>   	if (nid == NUMA_NO_NODE)
>   		nid = memory_add_physaddr_to_nid(cxlr_dax->hpa_range.start);
>   
> -	dev_size = range_len(&cxlr_dax->hpa_range);
> -
>   	flags = IORESOURCE_DAX_KMEM;
> -	if (cxlr->mode == CXL_REGION_DC) {
> -		/* Add empty seed dax device */
> -		dev_size = 0;
> +	if (cxlr->mode == CXL_REGION_DC)
>   		flags |= IORESOURCE_DAX_DYNAMIC_CAP;
> -	}
>   
>   	dax_region = alloc_dax_region(dev, cxlr->id, &cxlr_dax->hpa_range, nid,
>   				      PMD_SIZE, flags);
>   	if (!dax_region)
>   		return -ENOMEM;
>   
> +	dev_size = range_len(&cxlr_dax->hpa_range);
> +	if (cxlr->mode == CXL_REGION_DC) {
> +		int rc;
> +
> +		/* NOTE: Depends on dax_region being set in driver data */
> +		rc = cxl_dax_region_create_extents(cxlr_dax);
> +		if (rc)
> +			return rc;
> +
> +		/* Add empty seed dax device */
> +		dev_size = 0;
> +	}
> +
>   	data = (struct dev_dax_data) {
>   		.dax_region = dax_region,
>   		.id = -1,
> diff --git a/drivers/dax/dax-private.h b/drivers/dax/dax-private.h
> index 27cf2daaaa79..4dab52496c3f 100644
> --- a/drivers/dax/dax-private.h
> +++ b/drivers/dax/dax-private.h
> @@ -5,6 +5,7 @@
>   #ifndef __DAX_PRIVATE_H__
>   #define __DAX_PRIVATE_H__
>   
> +#include <linux/pgtable.h>
>   #include <linux/device.h>
>   #include <linux/cdev.h>
>   #include <linux/idr.h>
> @@ -40,6 +41,58 @@ struct dax_region {
>   	struct device *youngest;
>   };
>   
> +/*
> + * struct dax_region_extent - extent data defined by the low level region
> + * driver.
> + * @private_data: lower level region driver data
> + * @ref: track number of dax devices which are using this extent
> + * @get: get reference to low level data
> + * @put: put reference to low level data
> + */
> +struct dax_region_extent {
> +	void *private_data;
> +	struct kref ref;
> +	void (*get)(struct dax_region_extent *dr_extent);
> +	void (*put)(struct dax_region_extent *dr_extent);
> +};
> +
> +static inline void dr_extent_get(struct dax_region_extent *dr_extent)
> +{
> +	if (dr_extent->get)
> +		dr_extent->get(dr_extent);
> +}
> +
> +static inline void dr_extent_put(struct dax_region_extent *dr_extent)
> +{
> +	if (dr_extent->put)
> +		dr_extent->put(dr_extent);
> +}
> +
> +#define DAX_EXTENT_LABEL_LEN 64
> +/**
> + * struct dax_reg_ext_dev - Device object to expose extent information
> + * @dev: device representing this extent
> + * @dr_extent: reference back to private extent data
> + * @offset: offset of this extent
> + * @length: size of this extent
> + * @label: identifier to group extents
> + */
> +struct dax_reg_ext_dev {
> +	struct device dev;
> +	struct dax_region_extent *dr_extent;
> +	resource_size_t offset;
> +	resource_size_t length;
> +	char label[DAX_EXTENT_LABEL_LEN];
> +};
> +
> +int dax_region_ext_create_dev(struct dax_region *dax_region,
> +			      struct dax_region_extent *dr_extent,
> +			      resource_size_t offset,
> +			      resource_size_t length,
> +			      const char *label);
> +#define to_dr_ext_dev(dev)	\
> +	container_of(dev, struct dax_reg_ext_dev, dev)
> +
>   struct dax_mapping {
>   	struct device dev;
>   	int range_id;


This is a rather large patch. Can the code below be broken out to a 
separate patch?

> diff --git a/drivers/dax/extent.c b/drivers/dax/extent.c
> new file mode 100644
> index 000000000000..2075ccfb21cb
> --- /dev/null
> +++ b/drivers/dax/extent.c
> @@ -0,0 +1,119 @@
> +// SPDX-License-Identifier: GPL-2.0
> +/* Copyright(c) 2023 Intel Corporation. All rights reserved. */
> +
> +#include <linux/device.h>
> +#include <linux/slab.h>
> +#include "dax-private.h"
> +
> +static ssize_t length_show(struct device *dev, struct device_attribute *attr,
> +			 char *buf)
> +{
> +	struct dax_reg_ext_dev *dr_reg_ext_dev = to_dr_ext_dev(dev);
> +
> +	return sysfs_emit(buf, "%#llx\n", dr_reg_ext_dev->length);
> +}
> +static DEVICE_ATTR_RO(length);
> +
> +static ssize_t label_show(struct device *dev, struct device_attribute *attr,
> +			  char *buf)
> +{
> +	struct dax_reg_ext_dev *dr_reg_ext_dev = to_dr_ext_dev(dev);
> +
> +	return sysfs_emit(buf, "%s\n", dr_reg_ext_dev->label);
> +}
> +
> +static ssize_t label_store(struct device *dev, struct device_attribute *attr,
> +			   const char *buf, size_t len)
> +{
> +	struct dax_reg_ext_dev *dr_reg_ext_dev = to_dr_ext_dev(dev);
> +
> +	snprintf(dr_reg_ext_dev->label, DAX_EXTENT_LABEL_LEN, "%s", buf);
> +	return len;
> +}
> +static DEVICE_ATTR_RW(label);
> +
> +static struct attribute *dr_extent_attrs[] = {
> +	&dev_attr_length.attr,
> +	&dev_attr_label.attr,
> +	NULL,
> +};
> +
> +static const struct attribute_group dr_extent_attribute_group = {
> +	.attrs = dr_extent_attrs,
> +};
> +
> +static void dr_extent_release(struct device *dev)
> +{
> +	struct dax_reg_ext_dev *dr_reg_ext_dev = to_dr_ext_dev(dev);
> +
> +	kfree(dr_reg_ext_dev);
> +}
> +
> +static const struct attribute_group *dr_extent_attribute_groups[] = {
> +	&dr_extent_attribute_group,
> +	NULL,
> +};
> +
> +const struct device_type dr_extent_type = {
> +	.name = "extent",
> +	.release = dr_extent_release,
> +	.groups = dr_extent_attribute_groups,
> +};
> +
> +static void unregister_dr_extent(void *ext)
> +{
> +	struct dax_reg_ext_dev *dr_reg_ext_dev = ext;
> +	struct dax_region_extent *dr_extent;
> +
> +	dr_extent = dr_reg_ext_dev->dr_extent;
> +	dev_dbg(&dr_reg_ext_dev->dev, "Unregister DAX region ext OFF:%llx L:%s\n",
> +		dr_reg_ext_dev->offset, dr_reg_ext_dev->label);
> +	dr_extent_put(dr_extent);
> +	device_unregister(&dr_reg_ext_dev->dev);
> +}
> +
> +int dax_region_ext_create_dev(struct dax_region *dax_region,
> +			      struct dax_region_extent *dr_extent,
> +			      resource_size_t offset,
> +			      resource_size_t length,
> +			      const char *label)
> +{
> +	struct dax_reg_ext_dev *dr_reg_ext_dev;
> +	struct device *dev;
> +	int rc;
> +
> +	dr_reg_ext_dev = kzalloc(sizeof(*dr_reg_ext_dev), GFP_KERNEL);
> +	if (!dr_reg_ext_dev)
> +		return -ENOMEM;
> +
> +	dr_reg_ext_dev->dr_extent = dr_extent;
> +	dr_reg_ext_dev->offset = offset;
> +	dr_reg_ext_dev->length = length;
> +	snprintf(dr_reg_ext_dev->label, DAX_EXTENT_LABEL_LEN, "%s", label);
> +
> +	dev = &dr_reg_ext_dev->dev;
> +	device_initialize(dev);
> +	dev->id = offset / PMD_SIZE ;
> +	device_set_pm_not_required(dev);
> +	dev->parent = dax_region->dev;
> +	dev->type = &dr_extent_type;
> +	rc = dev_set_name(dev, "extent%d", dev->id);
> +	if (rc)
> +		goto err;
> +
> +	rc = device_add(dev);
> +	if (rc)
> +		goto err;
> +
> +	dev_dbg(dev, "DAX region extent OFF:%llx LEN:%llx\n",
> +		dr_reg_ext_dev->offset, dr_reg_ext_dev->length);
> +	return devm_add_action_or_reset(dax_region->dev, unregister_dr_extent,
> +					dr_reg_ext_dev);
> +
> +err:
> +	dev_err(dev, "Failed to initialize DAX extent dev OFF:%llx LEN:%llx\n",
> +		dr_reg_ext_dev->offset, dr_reg_ext_dev->length);
> +	put_device(dev);
> +	return rc;
> +}
> +EXPORT_SYMBOL_GPL(dax_region_ext_create_dev);
> 

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 7287AC83F35
	for <linux-cxl@archiver.kernel.org>; Thu, 31 Aug 2023 17:28:21 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S235142AbjHaR2W (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Thu, 31 Aug 2023 13:28:22 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:51376 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S232584AbjHaR2W (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Thu, 31 Aug 2023 13:28:22 -0400
Received: from mgamail.intel.com (mgamail.intel.com [134.134.136.100])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id F2A4AE5E;
        Thu, 31 Aug 2023 10:28:17 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1693502898; x=1725038898;
  h=message-id:date:subject:to:cc:references:from:
   in-reply-to:content-transfer-encoding:mime-version;
  bh=qfgpQe8JSD80zPn6b4jsimP/HhM7LmqNAyM+K4Ls1rM=;
  b=DPvRo67ZlqG40lQvYXYmRtmbmC9Z/Ex+DtsR5BxTRjl0mqKiXDYrCxpt
   cPmk110w4bo0tZMzrrZBLnNoobVQhU4uJmfVVI8GCflHjh+PEs9I/UBQY
   US8xgePQG4XY/ZXb62gQgOJ/maUDZR2AIMbOoyJUlvKdTM8lZrNzlhDDw
   CB1KUx2fChPB1jduEES21L6e4xBdK68Do+j7AbRBeGOU9Qlf7JBe2uDgs
   5X9cfOind6SVz3EhAKcKMuKFnw3NGUHa0k/Dxqz1Bw61qwQSlfNdGv5/O
   cja1insTRXRjWyTAHFPv+qr1GFIGPkOPd3dG5Q/HycRgRo9uS1OoXR0xD
   Q==;
X-IronPort-AV: E=McAfee;i="6600,9927,10819"; a="442408407"
X-IronPort-AV: E=Sophos;i="6.02,217,1688454000"; 
   d="scan'208";a="442408407"
Received: from fmsmga004.fm.intel.com ([10.253.24.48])
  by orsmga105.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 31 Aug 2023 10:28:17 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10819"; a="809726588"
X-IronPort-AV: E=Sophos;i="6.02,217,1688454000"; 
   d="scan'208";a="809726588"
Received: from orsmsx603.amr.corp.intel.com ([10.22.229.16])
  by fmsmga004.fm.intel.com with ESMTP/TLS/AES256-GCM-SHA384; 31 Aug 2023 10:28:16 -0700
Received: from orsmsx612.amr.corp.intel.com (10.22.229.25) by
 ORSMSX603.amr.corp.intel.com (10.22.229.16) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27; Thu, 31 Aug 2023 10:28:16 -0700
Received: from orsmsx603.amr.corp.intel.com (10.22.229.16) by
 ORSMSX612.amr.corp.intel.com (10.22.229.25) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27; Thu, 31 Aug 2023 10:28:16 -0700
Received: from ORSEDG602.ED.cps.intel.com (10.7.248.7) by
 orsmsx603.amr.corp.intel.com (10.22.229.16) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27 via Frontend Transport; Thu, 31 Aug 2023 10:28:16 -0700
Received: from NAM10-DM6-obe.outbound.protection.outlook.com (104.47.58.108)
 by edgegateway.intel.com (134.134.137.103) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.27; Thu, 31 Aug 2023 10:28:15 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=U6l2JGRmxSsFjwx+bLd1rjhjEg9fngYN6UL4fwvXyeTtB8AJVLQv4aEOiEWaU353cSPcXPEORXbe55EcWHvSRVSlK6Ro9UyCNyQPcJwiT6Chh863ULyS1NeJcb7LBLF8PUsIsCd58oJrg0yt2ybkGtMFqrZQ3Z7MxxJiFksYLW1VgaBwsykqwYA9eEvxvjyh5N+cEWkMatMmBzuqDVxZgpZOdYAg5VmVZ6ET6CCq6NySy2MLStcEnqJFRI0BZkn/Y4JhntK55pE9ifHG6RCzDtnr6g7hVNxL2BZ7vYIjha9OaIbJowubnFYGh061lVQ9Apxy0+8RlVElAUCZZOceUA==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=HjE8K5iJKL6kgPdA50C35X6mammm0DU7P7xlkFxP0HU=;
 b=bPzwpsro9HTavxHmpBN8DPjSTGJsWLwwBTru+i7wTEz9gYI3AbyWLBYJXWCT2+SCrj6hZB+fqmvAsJ4fgxHvBy4xUqwMdcpYNflovzqWYC0R7agGMaqKHLJJEafG7cZROzXjEfVeuTDvQt9efWl51UmnV/rqG+RA5Yb+PsIVpqTvj1TKu04S8nXroB5q7Cv0kslYGAHvznk3fdE0E4btnAyEctma2AIN+UKew0oViImUnB4mztyPH3zVweON4C4jvaB+K1m8Lm+Npv8zj8JuQL/zl6aW2cRxGyuUqVARj0IEJyxOBrh9F4nm/6YECAbBvre0bKqC6uraxknDkk3YAw==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from PH7PR11MB5984.namprd11.prod.outlook.com (2603:10b6:510:1e3::15)
 by CY5PR11MB6533.namprd11.prod.outlook.com (2603:10b6:930:43::13) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.6745.18; Thu, 31 Aug
 2023 17:28:13 +0000
Received: from PH7PR11MB5984.namprd11.prod.outlook.com
 ([fe80::9563:9642:bbde:293f]) by PH7PR11MB5984.namprd11.prod.outlook.com
 ([fe80::9563:9642:bbde:293f%7]) with mapi id 15.20.6745.022; Thu, 31 Aug 2023
 17:28:13 +0000
Message-ID: <3546729d-d67d-fc93-5c03-fc864fd23b4e@intel.com>
Date: Thu, 31 Aug 2023 10:28:09 -0700
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101
 Betterbird/102.13.0
Subject: Re: [PATCH RFC v2 10/18] cxl/mem: Handle DCD add and release capacity
 events.
To: Ira Weiny <ira.weiny@intel.com>,
        Dan Williams <dan.j.williams@intel.com>
CC: Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Alison Schofield <alison.schofield@intel.com>,
        "Vishal Verma" <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
 <20230604-dcd-type2-upstream-v2-10-f740c47e7916@intel.com>
Content-Language: en-US
From: Dave Jiang <dave.jiang@intel.com>
In-Reply-To: <20230604-dcd-type2-upstream-v2-10-f740c47e7916@intel.com>
Content-Type: text/plain; charset="UTF-8"; format=flowed
Content-Transfer-Encoding: 7bit
X-ClientProxiedBy: SJ0PR03CA0269.namprd03.prod.outlook.com
 (2603:10b6:a03:3a0::34) To PH7PR11MB5984.namprd11.prod.outlook.com
 (2603:10b6:510:1e3::15)
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: PH7PR11MB5984:EE_|CY5PR11MB6533:EE_
X-MS-Office365-Filtering-Correlation-Id: 283232bb-ed5a-4c89-fd4b-08dbaa47a739
X-LD-Processed: 46c98d88-e344-4ed4-8496-4ed7712e255d,ExtAddr
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;
X-Microsoft-Antispam-Message-Info: x6kXi9p3Ss6pMT+c0ESjHumapc/ozeYnp5A8ohO1lilsdH1h9hp4peyamxl9RGTwdBzmYTnHkD4PuGyW/Irj3Nx5ZKkC3HercVdXcWpZ4soP/QsM35o3drMYIPip4dV6liYo3MKZI/Ncd3fLXIvFvp0X7JDOkG3NiQsnodD+PUofDCDCP9hy1+epsC1hqOD6UhwYvtRpwB/bVGo1TLxZJZ6ZbheBEopElVugowdUohX+px5wWHw9udhCHbig//PVAjEXL4Y7ivwYqHDd4DzdPayZVvnVq2dbgMIgX0w+kYTQb17a4Zv+LsXBvGdVS7L5tfrkDqOj/s8V+S5lPfEm6LNOfFNBsScLmaUh8W9SHJrkml8suicCCZRlhLP+OalS2WVQ7Aokdv1Y4FJaOytag3ZokkSFatI5zAkGgGGyadDQ4x7B5dHDZZ+pQ6fAtwGFgNyPi3cu50yO3BbERq6WMf85bnmEIvK+Y8xPUwlC0+uvJG0F5o+YSJk5yRkQCWDZOflWIGk+t36hlKkIVZyG1HBovo6meOnL9cZH+2EAHNDIF58dU0XkdBDhUP2liI5mIg+sMhZAzvDVHPa+2lWh7R1ZGHIojmJ5jvkhvcoJUk8hggva5SxiW+LHyLQKFsHIScjj3PmajCTyynzJVqJxeg==
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:PH7PR11MB5984.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230031)(136003)(376002)(396003)(346002)(366004)(39860400002)(186009)(1800799009)(451199024)(8936002)(6666004)(478600001)(110136005)(53546011)(31686004)(66946007)(66556008)(6506007)(66476007)(6486002)(54906003)(6636002)(316002)(38100700002)(41300700001)(66899024)(82960400001)(6512007)(44832011)(26005)(83380400001)(5660300002)(36756003)(2616005)(31696002)(2906002)(86362001)(30864003)(8676002)(4326008)(45980500001)(43740500002);DIR:OUT;SFP:1102;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?utf-8?B?RmFrcisrU2FmdWViY1lyaW9wUTNpenN3VEZlUkhjMlplb1ZhSVNLb2FtQlQ0?=
 =?utf-8?B?dWozZURqT1B6WmhKOGUreW5JQ1NjYWlGajFRYW8xRWIxWUtDdUNweEtTMW90?=
 =?utf-8?B?U0FBVk1nWTZuZkZOUzU4cHlWMlpsL05oYzZPM2pxNmpjQlhOUmNTbU90U2k0?=
 =?utf-8?B?bjAwMUdVdHFjSzk3ZlRPT052bWwrRTh4Q09RUmJsa3JmdmxxemVjN3hIUmFa?=
 =?utf-8?B?N3p2Mkk2dy93T2d1Snd6MWZqYnFCTllRcmZjZzlXaFMwZ0JLYnhFY1FWZENl?=
 =?utf-8?B?eVV4L0VWbVFpVTkwSXdwVnIvRXZqQzJQMzVneXVPdG5mK3cxNEt5NmN4ZzR4?=
 =?utf-8?B?bmRhcS9aU2NPTkxQaFF1WkIrQ3BLRHNYVHJRYTZrbHRsSSsycEVVZ1FzOStL?=
 =?utf-8?B?dVBMV08wb3FiZ0xwcWRReEdTVmhaclFqYlVTKzMzU1k1dUVoU3RvMUlqU3M0?=
 =?utf-8?B?aGVJRDZGV0hjWTlYQTZSMHRndnVBZjZoYnMxZGJwa3hVQWdra2F1TFJrdUM2?=
 =?utf-8?B?MUppbmt6bGgvQ05EZldHNXFlc2JlN01OMHNkbDJwMmZmZVhOOWdsNXVpUkYx?=
 =?utf-8?B?TE1aRjVVYW1ldGNrZ3dUSzJMUDM4dUJwN0V4NHdiamZtTTc3UU0rS2ZUSWEz?=
 =?utf-8?B?R3dwMWMxbWtTemxNL3B1bnBsMjBzSk96eTcrOGtyRm5ObmV0cUM0UG5ONzR3?=
 =?utf-8?B?OHR5Sy9kdXg0ZHhybS9kTWhhcHozVkRBS3dScHozZ1VzUm5oSXJNNjdZRk92?=
 =?utf-8?B?SmkyTzNFVDZ2bmd2NjNsRHBmSFFtb2YrU3FPUW1kY2srSVc1bTk3MkFRKzBR?=
 =?utf-8?B?ODZNY3dRdURxa3NYYUltNXdBcll2dndhTHptQjVZeFF2dEUzMkxzOGkyQU5L?=
 =?utf-8?B?Rk5XK1dZZCsrQVRmOGZtdjZBS0hIQjJCVmM2UG5VMnFrRmJtM3h5N1pocVF3?=
 =?utf-8?B?SmRmdzVCT3pRZ0NoUjNxeU9TTjFmK2M5RFVtaG02bmM5aE1rK0Z6QzlWNjNS?=
 =?utf-8?B?NGdpUEo0MFhad1dhREZET3FQZGUvczc0TUdOcm0zU2owZ2xyejl4TW56dldH?=
 =?utf-8?B?b0VSMG11MzFXSUtDaURwWlI5REwwSFoxRDJDZEh0bjJQQ1RaRlIyZG51cU05?=
 =?utf-8?B?VkpzQS9RcnFMakRuOW9VbTlKYVJDdWtrWnJtVGRlTkFEVEd1Yi9abFJwblBm?=
 =?utf-8?B?cFlpdVFWZHlGTXl1YVQ5dDlRclpBSGpoMVQvZHF5bjNJQXR1dWNFQnNCeFhk?=
 =?utf-8?B?RFhaekdDeWZPWTNyU0tCZEVKYnk2UW9KOC9ZaGZyd3B6RkE4eS8wWmNKVnMw?=
 =?utf-8?B?NENtWEFBNi9wUUtYN1A4RklEdHVPYjh1WXVXbHo1MEZqYldFdzFZRkVyTGlZ?=
 =?utf-8?B?WUxjL1AzMVhLM0dVUTZuMDFCamp3VGkvb2VJWlFRUkltVk1aaW1aTUZUbEJV?=
 =?utf-8?B?M05DWlRnekJRQjNPejIrbE1MZTQ0azM5RFMvay9majhkU2syeGdtMytXb1lB?=
 =?utf-8?B?TlZNVENYM1JjeHlyM2pLT2xjQVZuZUs5Nk92a0h1ZmVUc2thSDlnK2RhL1Zl?=
 =?utf-8?B?UjVjemFxUTZ4MXduZ2dGaUJVUHJaZFJ0aW9yZ0V3c2VvUXNQN0k1L3hqY1M3?=
 =?utf-8?B?SXZEUnE2cVV6ekdTU3l0Y1d5Z1hDOHBGYjZaQVFpY3V5cC8waXhuVWdobVRQ?=
 =?utf-8?B?bUpJbDNDQlJSbnZ3YnEvWHZzS1BIOCszVWJrSXVORlZYZ29uTFBoOUdTK3hI?=
 =?utf-8?B?MXBqNS9PNy9SV29zNm9lMndzZHFEUUtaR2FYczZudG1GMlB4R21zYk1PMEs5?=
 =?utf-8?B?RGdEQWo4TUJwcDVxUWRhVkFVYWhZdTdTQmRaZUlqRThWYTlCZ285OEd3ZXFC?=
 =?utf-8?B?YnVFdUhNcDdQRFR1ZDBBSGhDcW8zWndHUzBrVWNDeDRvQklobkM2bTVDYWNm?=
 =?utf-8?B?YWtVK2IxU0tCKzA2WDU0cjI4MzRUSTUxeXk4ZVp4OW9HTDJvek94WlBCNFM5?=
 =?utf-8?B?NnlPYnRtYTJyVngwYnZMcGpadDVuMVlXTThHcXNyeS9TOEpXRFRYdVFBSG41?=
 =?utf-8?B?Y3ptZldSczAxcGJNcTRSaGFSQnpsa2Q2Y29pemZRWGg0RjIyeFNJUkV5UEVF?=
 =?utf-8?Q?7BIXQeKORd7PQQWXa6b0pZEUJ?=
X-MS-Exchange-CrossTenant-Network-Message-Id: 283232bb-ed5a-4c89-fd4b-08dbaa47a739
X-MS-Exchange-CrossTenant-AuthSource: PH7PR11MB5984.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 31 Aug 2023 17:28:13.0190
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: D09LRt9EZF86UglgMC4AVC8rhMgoEPQWlCXZlhhl5StYG6+9IzvUBHVLc+a5Kh43h4K9VmzHCm8bHaZot949qA==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: CY5PR11MB6533
X-OriginatorOrg: intel.com
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org



On 8/28/23 22:21, Ira Weiny wrote:
> A Dynamic Capacity Device (DCD) utilizes events to signal the host about
> the changes to the allocation of Dynamic Capacity (DC) extents. The
> device communicates the state of DC extents through an extent list that
> describes the starting DPA, length, and meta data of the blocks the host
> can access.
> 
> Process the dynamic capacity add and release events.  The addition or
> removal of extents can occur at any time.  Adding asynchronous memory is
> straight forward.  Also remember the host is under no obligation to
> respond to a release event until it is done with the memory.  Introduce
> extent kref's to handle the delay of extent release.
> 
> In the case of a force removal, access to the memory will fail and may
> cause a crash.  However, the extent tracking object is preserved for the
> region to safely tear down as long as the memory is not accessed.
> 
> Signed-off-by: Navneet Singh <navneet.singh@intel.com>
> Co-developed-by: Ira Weiny <ira.weiny@intel.com>
> Signed-off-by: Ira Weiny <ira.weiny@intel.com>
> 
> ---
> changes for v2:
> [iweiny: Totally new version of the patch]
> [iweiny: use kref to track when to release an extent]
> [iweiny: rebased to latest master/type2 work]
> [iweiny: use a kref to track if extents are being referenced]
> [alison: align commit message paragraphs]
> [alison: remove unnecessary return]
> [iweiny: Adjust for the new __devm_cxl_add_dax_region()]
> [navneet: Fix debug prints in adding/releasing extent]
> [alison: deal with odd if/else logic]
> [alison: reverse x-tree]
> [alison: reverse x-tree]
> [alison: s/total_extent_cnt/count/]
> [alison: make handle event reverse x-tree]
> [alison: cleanup/shorten/remove handle event comment]
> [iweiny/Alison: refactor cxl_handle_dcd_event_records function]
> [iweiny: keep cxl_dc_extent_data local to mbox.c]
> [jonathan: eliminate 'rc']
> [iweiny: use proper type for mailbox size]
> [jonathan: put dc_extents on the stack]
> [jonathan: use direct returns instead of goto]
> [iweiny: Clean up comment]
> [Jonathan: define CXL_DC_EXTENT_TAG_LEN]
> [Jonathan: remove extraneous changes]
> [Jonathan: fix blank line issues]
> ---
>   drivers/cxl/core/mbox.c | 186 +++++++++++++++++++++++++++++++++++++++++++++++-
>   drivers/cxl/cxl.h       |   9 +++
>   drivers/cxl/cxlmem.h    |  30 ++++++++
>   3 files changed, 224 insertions(+), 1 deletion(-)
> 
> diff --git a/drivers/cxl/core/mbox.c b/drivers/cxl/core/mbox.c
> index 9b08c40ef484..8474a28b16ca 100644
> --- a/drivers/cxl/core/mbox.c
> +++ b/drivers/cxl/core/mbox.c
> @@ -839,6 +839,8 @@ static int cxl_store_dc_extent(struct cxl_memdev_state *mds,
>   	extent->length = le64_to_cpu(dc_extent->length);
>   	memcpy(extent->tag, dc_extent->tag, sizeof(extent->tag));
>   	extent->shared_extent_seq = le16_to_cpu(dc_extent->shared_extn_seq);
> +	kref_init(&extent->region_ref);
> +	extent->mds = mds;
>   
>   	dev_dbg(dev, "dynamic capacity extent DPA:0x%llx LEN:%llx\n",
>   		extent->dpa_start, extent->length);
> @@ -879,6 +881,14 @@ static const uuid_t mem_mod_event_uuid =
>   	UUID_INIT(0xfe927475, 0xdd59, 0x4339,
>   		  0xa5, 0x86, 0x79, 0xba, 0xb1, 0x13, 0xb7, 0x74);
>   
> +/*
> + * Dynamic Capacity Event Record
> + * CXL rev 3.0 section 8.2.9.2.1.3; Table 8-45
> + */
> +static const uuid_t dc_event_uuid =
> +	UUID_INIT(0xca95afa7, 0xf183, 0x4018, 0x8c,
> +		  0x2f, 0x95, 0x26, 0x8e, 0x10, 0x1a, 0x2a);
> +
>   static void cxl_event_trace_record(const struct cxl_memdev *cxlmd,
>   				   enum cxl_event_log_type type,
>   				   struct cxl_event_record_raw *record)
> @@ -973,6 +983,171 @@ static int cxl_clear_event_record(struct cxl_memdev_state *mds,
>   	return rc;
>   }
>   
> +static int cxl_send_dc_cap_response(struct cxl_memdev_state *mds,
> +				struct cxl_mbox_dc_response *res,
> +				int extent_cnt, int opcode)
> +{
> +	struct cxl_mbox_cmd mbox_cmd;
> +	size_t size;
> +
> +	size = struct_size(res, extent_list, extent_cnt);
> +	res->extent_list_size = cpu_to_le32(extent_cnt);
> +
> +	mbox_cmd = (struct cxl_mbox_cmd) {
> +		.opcode = opcode,
> +		.size_in = size,
> +		.payload_in = res,
> +	};
> +
> +	return cxl_internal_send_cmd(mds, &mbox_cmd);
> +}
> +
> +static int cxl_prepare_ext_list(struct cxl_mbox_dc_response **res,
> +				int *n, struct range *extent)
> +{
> +	struct cxl_mbox_dc_response *dc_res;
> +	unsigned int size;
> +
> +	if (!extent)
> +		size = struct_size(dc_res, extent_list, 0);
> +	else
> +		size = struct_size(dc_res, extent_list, *n + 1);
> +
> +	dc_res = krealloc(*res, size, GFP_KERNEL);
> +	if (!dc_res)
> +		return -ENOMEM;
> +
> +	if (extent) {
> +		dc_res->extent_list[*n].dpa_start = cpu_to_le64(extent->start);
> +		memset(dc_res->extent_list[*n].reserved, 0, 8);
> +		dc_res->extent_list[*n].length = cpu_to_le64(range_len(extent));
> +		(*n)++;
> +	}
> +
> +	*res = dc_res;
> +	return 0;
> +}
> +
> +static void dc_extent_release(struct kref *kref)
> +{
> +	struct cxl_dc_extent_data *extent = container_of(kref,
> +						struct cxl_dc_extent_data,
> +						region_ref);
> +	struct cxl_memdev_state *mds = extent->mds;
> +	struct cxl_mbox_dc_response *dc_res = NULL;
> +	struct range rel_range = (struct range) {
> +		.start = extent->dpa_start,
> +		.end = extent->dpa_start + extent->length - 1,
> +	};
> +	struct device *dev = mds->cxlds.dev;
> +	int extent_cnt = 0, rc;
> +
> +	rc = cxl_prepare_ext_list(&dc_res, &extent_cnt, &rel_range);
> +	if (rc < 0) {
> +		dev_err(dev, "Failed to create release response %d\n", rc);
> +		goto free_extent;
> +	}
> +	rc = cxl_send_dc_cap_response(mds, dc_res, extent_cnt,
> +				      CXL_MBOX_OP_RELEASE_DC);
> +	kfree(dc_res);
> +
> +free_extent:
> +	kfree(extent);
> +}
> +
> +void cxl_dc_extent_put(struct cxl_dc_extent_data *extent)
> +{
> +	kref_put(&extent->region_ref, dc_extent_release);
> +}
> +EXPORT_SYMBOL_NS_GPL(cxl_dc_extent_put, CXL);
> +
> +static int cxl_handle_dcd_release_event(struct cxl_memdev_state *mds,
> +					struct cxl_dc_extent *rel_extent)
> +{
> +	struct device *dev = mds->cxlds.dev;
> +	struct cxl_dc_extent_data *extent;
> +	resource_size_t dpa, size;
> +
> +	dpa = le64_to_cpu(rel_extent->start_dpa);
> +	size = le64_to_cpu(rel_extent->length);
> +	dev_dbg(dev, "Release DC extent DPA:0x%llx LEN:%llx\n",
> +		dpa, size);
> +
> +	extent = xa_erase(&mds->dc_extent_list, dpa);
> +	if (!extent) {
> +		dev_err(dev, "No extent found with DPA:0x%llx\n", dpa);
> +		return -EINVAL;
> +	}
> +	cxl_dc_extent_put(extent);
> +	return 0;
> +}
> +
> +static int cxl_handle_dcd_add_event(struct cxl_memdev_state *mds,
> +				    struct cxl_dc_extent *add_extent)
> +{
> +	struct cxl_mbox_dc_response *dc_res = NULL;
> +	struct range alloc_range, *resp_range;
> +	struct device *dev = mds->cxlds.dev;
> +	int extent_cnt = 0;
> +	int rc;
> +
> +	dev_dbg(dev, "Add DC extent DPA:0x%llx LEN:%llx\n",
> +		le64_to_cpu(add_extent->start_dpa),
> +		le64_to_cpu(add_extent->length));
> +
> +	alloc_range = (struct range){
> +		.start = le64_to_cpu(add_extent->start_dpa),
> +		.end = le64_to_cpu(add_extent->start_dpa) +
> +			le64_to_cpu(add_extent->length) - 1,
> +	};
> +	resp_range = &alloc_range;
> +
> +	rc = cxl_store_dc_extent(mds, add_extent);
> +	if (rc) {
> +		dev_dbg(dev, "unconsumed DC extent DPA:0x%llx LEN:%llx\n",
> +			le64_to_cpu(add_extent->start_dpa),
> +			le64_to_cpu(add_extent->length));
> +		resp_range = NULL;
> +	}
> +
> +	rc = cxl_prepare_ext_list(&dc_res, &extent_cnt, resp_range);
> +	if (rc < 0) {
> +		dev_err(dev, "Couldn't create extent list %d\n", rc);
> +		return rc;
> +	}
> +
> +	rc = cxl_send_dc_cap_response(mds, dc_res, extent_cnt,
> +				      CXL_MBOX_OP_ADD_DC_RESPONSE);
> +	kfree(dc_res);
> +	return rc;
> +}
> +
> +/* Returns 0 if the event was handled successfully. */
Is this comment necessary?

> +static int cxl_handle_dcd_event_records(struct cxl_memdev_state *mds,
> +					struct cxl_event_record_raw *rec)
> +{
> +	struct dcd_event_dyn_cap *record = (struct dcd_event_dyn_cap *)rec;
> +	uuid_t *id = &rec->hdr.id;
> +	int rc;
> +
> +	if (!uuid_equal(id, &dc_event_uuid))
> +		return -EINVAL;
> +
> +	switch (record->data.event_type) {
> +	case DCD_ADD_CAPACITY:
> +		rc = cxl_handle_dcd_add_event(mds, &record->data.extent);

Just return?
> +		break;
> +	case DCD_RELEASE_CAPACITY:
> +        case DCD_FORCED_CAPACITY_RELEASE:

Extra 2 spaces of indentation?

> +		rc = cxl_handle_dcd_release_event(mds, &record->data.extent);

Same here about return.

DJ

> +		break;
> +	default:
> +		return -EINVAL;
> +	}
> +
> +	return rc;
> +}
> +
>   static void cxl_mem_get_records_log(struct cxl_memdev_state *mds,
>   				    enum cxl_event_log_type type)
>   {
> @@ -1016,6 +1191,13 @@ static void cxl_mem_get_records_log(struct cxl_memdev_state *mds,
>   				le16_to_cpu(payload->records[i].hdr.handle));
>   			cxl_event_trace_record(cxlmd, type,
>   					       &payload->records[i]);
> +			if (type == CXL_EVENT_TYPE_DCD) {
> +				rc = cxl_handle_dcd_event_records(mds,
> +								  &payload->records[i]);
> +				if (rc)
> +					dev_err_ratelimited(dev, "dcd event failed: %d\n",
> +							    rc);
> +			}
>   		}
>   
>   		if (payload->flags & CXL_GET_EVENT_FLAG_OVERFLOW)
> @@ -1056,6 +1238,8 @@ void cxl_mem_get_event_records(struct cxl_memdev_state *mds, u32 status)
>   		cxl_mem_get_records_log(mds, CXL_EVENT_TYPE_WARN);
>   	if (status & CXLDEV_EVENT_STATUS_INFO)
>   		cxl_mem_get_records_log(mds, CXL_EVENT_TYPE_INFO);
> +	if (status & CXLDEV_EVENT_STATUS_DCD)
> +		cxl_mem_get_records_log(mds, CXL_EVENT_TYPE_DCD);
>   }
>   EXPORT_SYMBOL_NS_GPL(cxl_mem_get_event_records, CXL);
>   
> @@ -1712,7 +1896,7 @@ static void cxl_destroy_mds(void *_mds)
>   
>   	xa_for_each(&mds->dc_extent_list, index, extent) {
>   		xa_erase(&mds->dc_extent_list, index);
> -		kfree(extent);
> +		cxl_dc_extent_put(extent);
>   	}
>   	xa_destroy(&mds->dc_extent_list);
>   }
> diff --git a/drivers/cxl/cxl.h b/drivers/cxl/cxl.h
> index 0a225b0c20bf..81ca76ae1d02 100644
> --- a/drivers/cxl/cxl.h
> +++ b/drivers/cxl/cxl.h
> @@ -163,6 +163,7 @@ static inline int ways_to_eiw(unsigned int ways, u8 *eiw)
>   #define CXLDEV_EVENT_STATUS_WARN		BIT(1)
>   #define CXLDEV_EVENT_STATUS_FAIL		BIT(2)
>   #define CXLDEV_EVENT_STATUS_FATAL		BIT(3)
> +#define CXLDEV_EVENT_STATUS_DCD                 BIT(4)
>   
>   #define CXLDEV_EVENT_STATUS_ALL (CXLDEV_EVENT_STATUS_INFO |	\
>   				 CXLDEV_EVENT_STATUS_WARN |	\
> @@ -601,6 +602,14 @@ struct cxl_pmem_region {
>   	struct cxl_pmem_region_mapping mapping[];
>   };
>   
> +/* See CXL 3.0 8.2.9.2.1.5 */
> +enum dc_event {
> +        DCD_ADD_CAPACITY,
> +        DCD_RELEASE_CAPACITY,
> +        DCD_FORCED_CAPACITY_RELEASE,
> +        DCD_REGION_CONFIGURATION_UPDATED,
> +};
> +
>   struct cxl_dax_region {
>   	struct device dev;
>   	struct cxl_region *cxlr;
> diff --git a/drivers/cxl/cxlmem.h b/drivers/cxl/cxlmem.h
> index ad690600c1b9..118392229174 100644
> --- a/drivers/cxl/cxlmem.h
> +++ b/drivers/cxl/cxlmem.h
> @@ -582,6 +582,16 @@ enum cxl_opcode {
>   	UUID_INIT(0xe1819d9, 0x11a9, 0x400c, 0x81, 0x1f, 0xd6, 0x07, 0x19,     \
>   		  0x40, 0x3d, 0x86)
>   
> +struct cxl_mbox_dc_response {
> +	__le32 extent_list_size;
> +	u8 reserved[4];
> +	struct updated_extent_list {
> +		__le64 dpa_start;
> +		__le64 length;
> +		u8 reserved[8];
> +	} __packed extent_list[];
> +} __packed;
> +
>   struct cxl_mbox_get_supported_logs {
>   	__le16 entries;
>   	u8 rsvd[6];
> @@ -667,6 +677,7 @@ enum cxl_event_log_type {
>   	CXL_EVENT_TYPE_WARN,
>   	CXL_EVENT_TYPE_FAIL,
>   	CXL_EVENT_TYPE_FATAL,
> +	CXL_EVENT_TYPE_DCD,
>   	CXL_EVENT_TYPE_MAX
>   };
>   
> @@ -757,6 +768,8 @@ struct cxl_dc_extent_data {
>   	u64 length;
>   	u8 tag[CXL_DC_EXTENT_TAG_LEN];
>   	u16 shared_extent_seq;
> +	struct cxl_memdev_state *mds;
> +	struct kref region_ref;
>   };
>   
>   /*
> @@ -771,6 +784,21 @@ struct cxl_dc_extent {
>   	u8 reserved[6];
>   } __packed;
>   
> +struct dcd_record_data {
> +	u8 event_type;
> +	u8 reserved;
> +	__le16 host_id;
> +	u8 region_index;
> +	u8 reserved1[3];
> +	struct cxl_dc_extent extent;
> +	u8 reserved2[32];
> +} __packed;
> +
> +struct dcd_event_dyn_cap {
> +	struct cxl_event_record_hdr hdr;
> +	struct dcd_record_data data;
> +} __packed;
> +
>   struct cxl_mbox_get_partition_info {
>   	__le64 active_volatile_cap;
>   	__le64 active_persistent_cap;
> @@ -974,6 +1002,8 @@ int cxl_trigger_poison_list(struct cxl_memdev *cxlmd);
>   int cxl_inject_poison(struct cxl_memdev *cxlmd, u64 dpa);
>   int cxl_clear_poison(struct cxl_memdev *cxlmd, u64 dpa);
>   
> +void cxl_dc_extent_put(struct cxl_dc_extent_data *extent);
> +
>   #ifdef CONFIG_CXL_SUSPEND
>   void cxl_mem_active_inc(void);
>   void cxl_mem_active_dec(void);
> 

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 38FBFC83F10
	for <linux-cxl@archiver.kernel.org>; Thu, 31 Aug 2023 17:26:20 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S231377AbjHaR0U (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Thu, 31 Aug 2023 13:26:20 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:60462 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S242561AbjHaR0U (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Thu, 31 Aug 2023 13:26:20 -0400
Received: from mout.gmx.net (mout.gmx.net [212.227.17.22])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 5559D1B2;
        Thu, 31 Aug 2023 10:26:16 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=gmx.us;
 s=s31663417; t=1693502752; x=1694107552; i=fan.ni@gmx.us;
 bh=QkNThFNl/IRsfsmzhYGbjpsuKXfa7sROQrJsuIPp6Fk=;
 h=X-UI-Sender-Class:Date:From:To:Cc:Subject:References:In-Reply-To;
 b=G8BLnDniCevNBthds3xwEAkfC3HvKYHAuMK5hKt11nSmZuAdWOxv+0B0Fhk2Yxp+VfwMza4
 J7GfQMDVLMWf+jQJbSZsz5hwKHSIBgoRgplhUH0KRfI/UPRt1ouIUh9gBaPKkxx5ePnHizSQF
 XTTXjrPZdgUwPtIRB11K0xoK0V8q2RhDPL7Dygpzoy/QeicqMAnMLhg7JQ0ukLsG2dl3FI9bk
 QnUbGoqAExUAfBfPPNlrmazHwpGTTHTLcrwelCxbNwEw1naxivLcOAJIYzrCzyWmhBJYkJAwB
 1sg0MZxqMf1SC67Qze8Kk1fhBMlJgE08wSOTmMzCTwPmOAquUqMA==
X-UI-Sender-Class: 724b4f7f-cbec-4199-ad4e-598c01a50d3a
Received: from debian ([99.13.228.231]) by mail.gmx.net (mrgmx104
 [212.227.17.174]) with ESMTPSA (Nemesis) id 1MatVb-1q5RkC2JcR-00cQYl; Thu, 31
 Aug 2023 19:25:52 +0200
Date: Thu, 31 Aug 2023 10:25:40 -0700
From: Fan Ni <fan.ni@gmx.us>
To: Ira Weiny <ira.weiny@intel.com>
Cc: Dan Williams <dan.j.williams@intel.com>,
        Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        linux-cxl@vger.kernel.org, linux-kernel@vger.kernel.org
Subject: Re: [PATCH RFC v2 05/18] cxl/port: Add Dynamic Capacity mode support
 to endpoint decoders
Message-ID: <ZPDNFEi1RRGoTWhr@debian>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
 <20230604-dcd-type2-upstream-v2-5-f740c47e7916@intel.com>
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: <20230604-dcd-type2-upstream-v2-5-f740c47e7916@intel.com>
X-Provags-ID: V03:K1:RV9VBC88o9a7oe/0Gorhbc6mBMd4dbP0AzLP+3WmJC2WF3f4qWo
 XGSRCAgrD92VfjcL3Io/bjl3VipVm24adn/ifUDmdRvKC0T6pKDM+XLVr30VYMYAWeLs/oX
 OvbGcM2Ah8OWAHQ/6/6zZ7FkfJ7pklAHneZ2gIcpZ2i+JrsPrmzvhaKG/2SHf9cCjGc+nXf
 CcUmtQ0/+NvgGq1Amip3Q==
UI-OutboundReport: notjunk:1;M01:P0:bn6trh9Em5A=;nPjKzDeny4W4Pu5WCtxkCvjmE0g
 LiYcHPfgxV5W3j0VbENfJvuf0jof7TKHwFhDZHLoQT6YxJ/DtJtn0EIgGtl2sOyfBVMHoPs63
 axBojDjap9VBm0/R4pMQfaWLSaIsDLk2O+Hm4JmCCHEHlzuE05zFHc9v+xmK4y6SvgGdW6692
 nvCXpg8/QAqdi3EwPZQSh5OLj/Z+kkQbRS8Y6UsaZbH5pKKBABatLGDDsSneA3ftz3L6rLnN5
 VCzuq3yMBIBo0fy8GjivZVS0yQtUOgB2XaUbfQZh4YYLMrhYZMhyo8aUlbRm7EVE0nWPxXsv9
 huxQ+XRZxoHojR4rCNdOXYNV8Ge/kQHMoEHnxtt4rRLc7J0hW3kcPMwP57yQzWrPzKoFPEhhs
 KuNzXWMxz0rEDkAz0iE0NI2mtGGnl3101k31rUmdxE9g/D9qKrGKnDDOn1lfceA8SzMBO8G1b
 xWSfjqshXlGF9qlR8uQtrplhKcqYnh2DrADzCXSwIxOJE+Nro4/WiL1vni+AJz2azWNjeSPgC
 OTU0MfrKMqjym6COxYtTmQWTyuUtOX9qlQFa7lGzfJyb7y3p0AgNOcPTVQWN73vl33woJo2y6
 izT5kwrYfpHYkp83erBNDZBJCFzLXTb3Zn+ov9Omv6tW1/p7wBIvS2eFSY3CvFk2nO8KDoCcx
 jRp5qq6SLwC/30B+U9XNjQdbohIdkedhx5FnMt4j60AsbhVmp9jysXPxJnj5Aubg8ZTKJx7Qw
 ew2/6EM2hnHVmnqm6DSzaj4+HSAGFA3Hx6NQuIst5DRmj7XwPOqdBdaG/XdJIEfikrwwooNGO
 QAu8SpCmqaAwWrfI6ikz6p8nzpkOatv3Gnih83P4j2OemHXbA/rdDJpD/amUb0UvXku/018XJ
 pIqF8f5h4SbDBlWVbMdO6nm8H4/PadG4VSOofsX87wYkNrGBuneW83XGUxzzC4Wnz1IkES/P5
 e9xKnmWjUnVvtu/1GFWsjjm1M4I=
Content-Transfer-Encoding: quoted-printable
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

On Mon, Aug 28, 2023 at 10:20:56PM -0700, Ira Weiny wrote:
> Endpoint decoders used to map Dynamic Capacity must be configured to
> point to the correct Dynamic Capacity (DC) Region.  The decoder mode
> currently represents the partition the decoder points to such as ram or
> pmem.
>
> Expand the mode to include DC Regions.
>
> Co-developed-by: Navneet Singh <navneet.singh@intel.com>
> Signed-off-by: Navneet Singh <navneet.singh@intel.com>
> Signed-off-by: Ira Weiny <ira.weiny@intel.com>
>

I have the same question about how dc_mode_to_region_index is
implemented and used as Jonathan.

Nice to see the code spit out, it is easier to review now.

Fan

> ---
> Changes for v2:
> [iweiny: split from region creation patch]
> ---
>  Documentation/ABI/testing/sysfs-bus-cxl | 19 ++++++++++---------
>  drivers/cxl/core/hdm.c                  | 24 ++++++++++++++++++++++++
>  drivers/cxl/core/port.c                 | 16 ++++++++++++++++
>  3 files changed, 50 insertions(+), 9 deletions(-)
>
> diff --git a/Documentation/ABI/testing/sysfs-bus-cxl b/Documentation/ABI=
/testing/sysfs-bus-cxl
> index 6350dd82b9a9..2268ffcdb604 100644
> --- a/Documentation/ABI/testing/sysfs-bus-cxl
> +++ b/Documentation/ABI/testing/sysfs-bus-cxl
> @@ -257,22 +257,23 @@ Description:
>
>  What:		/sys/bus/cxl/devices/decoderX.Y/mode
>  Date:		May, 2022
> -KernelVersion:	v6.0
> +KernelVersion:	v6.0, v6.6 (dcY)
>  Contact:	linux-cxl@vger.kernel.org
>  Description:
>  		(RW) When a CXL decoder is of devtype "cxl_decoder_endpoint" it
>  		translates from a host physical address range, to a device local
>  		address range. Device-local address ranges are further split
> -		into a 'ram' (volatile memory) range and 'pmem' (persistent
> -		memory) range. The 'mode' attribute emits one of 'ram', 'pmem',
> -		'mixed', or 'none'. The 'mixed' indication is for error cases
> -		when a decoder straddles the volatile/persistent partition
> -		boundary, and 'none' indicates the decoder is not actively
> -		decoding, or no DPA allocation policy has been set.
> +		into a 'ram' (volatile memory) range, 'pmem' (persistent
> +		memory) range, or Dynamic Capacity (DC) range. The 'mode'
> +		attribute emits one of 'ram', 'pmem', 'dcY', 'mixed', or
> +		'none'. The 'mixed' indication is for error cases when a
> +		decoder straddles the volatile/persistent partition boundary,
> +		and 'none' indicates the decoder is not actively decoding, or
> +		no DPA allocation policy has been set.
>
>  		'mode' can be written, when the decoder is in the 'disabled'
> -		state, with either 'ram' or 'pmem' to set the boundaries for the
> -		next allocation.
> +		state, with 'ram', 'pmem', or 'dcY' to set the boundaries for
> +		the next allocation.
>
>
>  What:		/sys/bus/cxl/devices/decoderX.Y/dpa_resource
> diff --git a/drivers/cxl/core/hdm.c b/drivers/cxl/core/hdm.c
> index a254f79dd4e8..3f4af1f5fac8 100644
> --- a/drivers/cxl/core/hdm.c
> +++ b/drivers/cxl/core/hdm.c
> @@ -267,6 +267,19 @@ static void devm_cxl_dpa_release(struct cxl_endpoin=
t_decoder *cxled)
>  	__cxl_dpa_release(cxled);
>  }
>
> +static int dc_mode_to_region_index(enum cxl_decoder_mode mode)
> +{
> +	int index =3D 0;
> +
> +	for (int i =3D CXL_DECODER_DC0; i <=3D CXL_DECODER_DC7; i++) {
> +		if (mode =3D=3D i)
> +			return index;
> +		index++;
> +	}
> +
> +	return -EINVAL;
> +}
> +
>  static int __cxl_dpa_reserve(struct cxl_endpoint_decoder *cxled,
>  			     resource_size_t base, resource_size_t len,
>  			     resource_size_t skipped)
> @@ -429,6 +442,7 @@ int cxl_dpa_set_mode(struct cxl_endpoint_decoder *cx=
led,
>  	switch (mode) {
>  	case CXL_DECODER_RAM:
>  	case CXL_DECODER_PMEM:
> +	case CXL_DECODER_DC0 ... CXL_DECODER_DC7:
>  		break;
>  	default:
>  		dev_dbg(dev, "unsupported mode: %d\n", mode);
> @@ -456,6 +470,16 @@ int cxl_dpa_set_mode(struct cxl_endpoint_decoder *c=
xled,
>  		goto out;
>  	}
>
> +	for (int i =3D CXL_DECODER_DC0; i <=3D CXL_DECODER_DC7; i++) {
> +		int index =3D dc_mode_to_region_index(i);
> +
> +		if (mode =3D=3D i && !resource_size(&cxlds->dc_res[index])) {
> +			dev_dbg(dev, "no available dynamic capacity\n");
> +			rc =3D -ENXIO;
> +			goto out;
> +		}
> +	}
> +
>  	cxled->mode =3D mode;
>  	rc =3D 0;
>  out:
> diff --git a/drivers/cxl/core/port.c b/drivers/cxl/core/port.c
> index f58cf01f8d2c..ce4a66865db3 100644
> --- a/drivers/cxl/core/port.c
> +++ b/drivers/cxl/core/port.c
> @@ -197,6 +197,22 @@ static ssize_t mode_store(struct device *dev, struc=
t device_attribute *attr,
>  		mode =3D CXL_DECODER_PMEM;
>  	else if (sysfs_streq(buf, "ram"))
>  		mode =3D CXL_DECODER_RAM;
> +	else if (sysfs_streq(buf, "dc0"))
> +		mode =3D CXL_DECODER_DC0;
> +	else if (sysfs_streq(buf, "dc1"))
> +		mode =3D CXL_DECODER_DC1;
> +	else if (sysfs_streq(buf, "dc2"))
> +		mode =3D CXL_DECODER_DC2;
> +	else if (sysfs_streq(buf, "dc3"))
> +		mode =3D CXL_DECODER_DC3;
> +	else if (sysfs_streq(buf, "dc4"))
> +		mode =3D CXL_DECODER_DC4;
> +	else if (sysfs_streq(buf, "dc5"))
> +		mode =3D CXL_DECODER_DC5;
> +	else if (sysfs_streq(buf, "dc6"))
> +		mode =3D CXL_DECODER_DC6;
> +	else if (sysfs_streq(buf, "dc7"))
> +		mode =3D CXL_DECODER_DC7;
>  	else
>  		return -EINVAL;
>
>
> --
> 2.41.0
>

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id F1576C83F2F
	for <linux-cxl@archiver.kernel.org>; Thu, 31 Aug 2023 17:01:31 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S239828AbjHaRBd (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Thu, 31 Aug 2023 13:01:33 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:48112 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S236107AbjHaRBc (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Thu, 31 Aug 2023 13:01:32 -0400
Received: from mout.gmx.net (mout.gmx.net [212.227.17.21])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 0B85CD1;
        Thu, 31 Aug 2023 10:01:27 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=gmx.us;
 s=s31663417; t=1693501265; x=1694106065; i=fan.ni@gmx.us;
 bh=12xJbrsFviKVQ6obHknRx+VPF50PuuJTDbIVzk6hhXQ=;
 h=X-UI-Sender-Class:Date:From:To:Cc:Subject:References:In-Reply-To;
 b=Vxf9y1yoqlziysECGrBWWhHShju+yas7a0zOHisUbhz1Gikj3nwN/n8W1w5ulS6JrzsNt2q
 pP5U44vrqo5yAVTEV5bQxpk7JvmQArOqFP1o7q+J5XU8e80mmg4yFglvUWdNUaF2B6F9+I94z
 qo+qn7bU8Ur85pmj0xVJO9JsSZQjYyOPUfQD9LE+2HyKxkOcaiX+YuUpBxTCzpPXcwTnoodCu
 HHT7SNjtw+kc0rkMVD3ix9a/Gh53RW3wXT0woIYJbM9hGk6qmwsz5wSYRY+49squyVU6GM17X
 M0UGv9lYCieKnMVW2+MYbN7lLh9G6wsVwAe9j3ENQqxSx80Q53Aw==
X-UI-Sender-Class: 724b4f7f-cbec-4199-ad4e-598c01a50d3a
Received: from debian ([99.13.228.231]) by mail.gmx.net (mrgmx104
 [212.227.17.174]) with ESMTPSA (Nemesis) id 1M2O2Q-1qfbrS2TF8-003uwQ; Thu, 31
 Aug 2023 19:01:05 +0200
Date: Thu, 31 Aug 2023 10:00:50 -0700
From: Fan Ni <fan.ni@gmx.us>
To: Ira Weiny <ira.weiny@intel.com>
Cc: Dan Williams <dan.j.williams@intel.com>,
        Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        linux-cxl@vger.kernel.org, linux-kernel@vger.kernel.org
Subject: Re: [PATCH RFC v2 04/18] cxl/region: Add Dynamic Capacity decoder
 and region modes
Message-ID: <ZPDHQnLctLmRIxaS@debian>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
 <20230604-dcd-type2-upstream-v2-4-f740c47e7916@intel.com>
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: <20230604-dcd-type2-upstream-v2-4-f740c47e7916@intel.com>
X-Provags-ID: V03:K1:Wo30mn8KL5AYnbXla4xHQE/ks0lbOf6H+vps7K5NMiSPQmOo86H
 yHdYKjwSZeorZVLVgvOSjtIE1Pj6VK/1HDhIr/Z3/bhieC6Q1eKZfW6FepxDkfmsK1gyYbL
 nWDYPHmXCHyQNi6V9Ru4Ob//shufS6rmFaqxRs2GU3Z/rpblLcE9l94haCnwvDtt7a+PP4b
 Bz2NWD9MMuAy3jogTmljg==
UI-OutboundReport: notjunk:1;M01:P0:YRBXR8R57cE=;TOED1LF3wD16BU3J2YyjnBOtFxv
 kGl/08Otca/LP4aJcIY6BmKTdjYzubRe+Lkan0QwtdHRZvOZt+1umW24N7UYPLGUSxipUjRHi
 seyLo6jXq0lW+nfVuqsaGlTJihL43gDmR4GZ7mDPPaV0K5MsF0XweWIiFwUqptscRZzm9z9GD
 xEmJb1gpcHr6JU2zl1KmDS30hhwNTWGJTmuzHtRCU9+psjkjoXrYS2RFMHWzcUqVYmOTXVzzv
 bUA4XT0m9UQqpqNKkyF7zyUIEnZZ2poflsQAtPT1ptJSyZOcBZhsOYvZDyxlJqmEZ3SBZ4vHx
 hIk8621FE/lfB1qSfzP4iG/QAt6mqGYI2lWnXOegwiZC9ay607Z5HuHEv3R3Zid6WChEKkmcE
 6AyIx97VwtJAE9vsECsy05NGPNx4M7rWSzj4HjrxkWQ8WXAB+Lyv2zImODcb58K2+13PpV2rt
 8QXa4xINx5uOF6a4pKFHbCBPxlsL+Ql1W7Xo5wBwuxQ4RTcGDGDTgi4F1rsn/73bHRjdScLF9
 p48FDfpsVS8ca9c04/+j/qIybYWYuXy6xr3jD2l068VH7X26KDg3sVPXNzcp7ZTjeIJWfK1yn
 BcYKxdqPVHBrTjFC4ykbTyU+txYAt9k9SIVpELVLQwtMiQkLVkpIfV28Tx/d7BEDPcEChdqHE
 hyZPTGQbIu/PD2T/Cw5yapWzIq/KmeqiQV32aiFkmOJMyWYL/1EDei/GzYGUZb02vC8fxo4UK
 6z8Fv7v4izEZ/NQU/vh5opFkB1iNFvRtaC63FDJMCoRc+Ly/XX+bCU05c0XsJGBtaImy+3vpi
 u4GwnTfb0uGUXmFGwf7oNiDLDgrzjKNXsmladindObLkhAw2TMj2jUEzusXvsFYuWNBkkxffs
 on676OcLGnuFND0wkoJrwdy9Wjdz2VutLyRsc5Bk2DpVWfjX1/otmbWt13MVytk3BkNP9zy7Q
 fnaO2nxw7z/B8b18+odW8pi7APc=
Content-Transfer-Encoding: quoted-printable
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

On Mon, Aug 28, 2023 at 10:20:55PM -0700, Ira Weiny wrote:
> Both regions and decoders will need a new mode to reflect the new type
> of partition they are targeting on a device.  Regions reflect a dynamic
> capacity type which may point to different Dynamic Capacity (DC)
> Regions.  Decoder mode reflects a specific DC Region.
>
> Define the new modes to use in subsequent patches and the helper
> functions associated with them.
>
> Co-developed-by: Navneet Singh <navneet.singh@intel.com>
> Signed-off-by: Navneet Singh <navneet.singh@intel.com>
> Signed-off-by: Ira Weiny <ira.weiny@intel.com>
>

Reviewed-by: Fan Ni <fan.ni@samsung.com>

> ---
> Changes for v2:
> [iweiny: split out from: Add dynamic capacity cxl region support.]
> ---
>  drivers/cxl/core/region.c |  4 ++++
>  drivers/cxl/cxl.h         | 23 +++++++++++++++++++++++
>  2 files changed, 27 insertions(+)
>
> diff --git a/drivers/cxl/core/region.c b/drivers/cxl/core/region.c
> index 75041903b72c..69af1354bc5b 100644
> --- a/drivers/cxl/core/region.c
> +++ b/drivers/cxl/core/region.c
> @@ -1772,6 +1772,8 @@ static bool cxl_modes_compatible(enum cxl_region_m=
ode rmode,
>  		return true;
>  	if (rmode =3D=3D CXL_REGION_PMEM && dmode =3D=3D CXL_DECODER_PMEM)
>  		return true;
> +	if (rmode =3D=3D CXL_REGION_DC && cxl_decoder_mode_is_dc(dmode))
> +		return true;
>
>  	return false;
>  }
> @@ -2912,6 +2914,8 @@ cxl_decoder_to_region_mode(enum cxl_decoder_mode m=
ode)
>  		return CXL_REGION_PMEM;
>  	case CXL_DECODER_DEAD:
>  		return CXL_REGION_DEAD;
> +	case CXL_DECODER_DC0 ... CXL_DECODER_DC7:
> +		return CXL_REGION_DC;
>  	case CXL_DECODER_MIXED:
>  	default:
>  		return CXL_REGION_MIXED;
> diff --git a/drivers/cxl/cxl.h b/drivers/cxl/cxl.h
> index ed282dcd5cf5..d41f3f14fbe3 100644
> --- a/drivers/cxl/cxl.h
> +++ b/drivers/cxl/cxl.h
> @@ -356,6 +356,14 @@ enum cxl_decoder_mode {
>  	CXL_DECODER_NONE,
>  	CXL_DECODER_RAM,
>  	CXL_DECODER_PMEM,
> +	CXL_DECODER_DC0,
> +	CXL_DECODER_DC1,
> +	CXL_DECODER_DC2,
> +	CXL_DECODER_DC3,
> +	CXL_DECODER_DC4,
> +	CXL_DECODER_DC5,
> +	CXL_DECODER_DC6,
> +	CXL_DECODER_DC7,
>  	CXL_DECODER_MIXED,
>  	CXL_DECODER_DEAD,
>  };
> @@ -366,6 +374,14 @@ static inline const char *cxl_decoder_mode_name(enu=
m cxl_decoder_mode mode)
>  		[CXL_DECODER_NONE] =3D "none",
>  		[CXL_DECODER_RAM] =3D "ram",
>  		[CXL_DECODER_PMEM] =3D "pmem",
> +		[CXL_DECODER_DC0] =3D "dc0",
> +		[CXL_DECODER_DC1] =3D "dc1",
> +		[CXL_DECODER_DC2] =3D "dc2",
> +		[CXL_DECODER_DC3] =3D "dc3",
> +		[CXL_DECODER_DC4] =3D "dc4",
> +		[CXL_DECODER_DC5] =3D "dc5",
> +		[CXL_DECODER_DC6] =3D "dc6",
> +		[CXL_DECODER_DC7] =3D "dc7",
>  		[CXL_DECODER_MIXED] =3D "mixed",
>  	};
>
> @@ -374,10 +390,16 @@ static inline const char *cxl_decoder_mode_name(en=
um cxl_decoder_mode mode)
>  	return "mixed";
>  }
>
> +static inline bool cxl_decoder_mode_is_dc(enum cxl_decoder_mode mode)
> +{
> +	return (mode >=3D CXL_DECODER_DC0 && mode <=3D CXL_DECODER_DC7);
> +}
> +
>  enum cxl_region_mode {
>  	CXL_REGION_NONE,
>  	CXL_REGION_RAM,
>  	CXL_REGION_PMEM,
> +	CXL_REGION_DC,
>  	CXL_REGION_MIXED,
>  	CXL_REGION_DEAD,
>  };
> @@ -388,6 +410,7 @@ static inline const char *cxl_region_mode_name(enum =
cxl_region_mode mode)
>  		[CXL_REGION_NONE] =3D "none",
>  		[CXL_REGION_RAM] =3D "ram",
>  		[CXL_REGION_PMEM] =3D "pmem",
> +		[CXL_REGION_DC] =3D "dc",
>  		[CXL_REGION_MIXED] =3D "mixed",
>  	};
>
>
> --
> 2.41.0
>

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 29A90C6FA8F
	for <linux-cxl@archiver.kernel.org>; Wed, 30 Aug 2023 23:27:55 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1344474AbjH3X1z (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Wed, 30 Aug 2023 19:27:55 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:40532 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1344463AbjH3X1z (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Wed, 30 Aug 2023 19:27:55 -0400
Received: from mgamail.intel.com (mgamail.intel.com [192.55.52.151])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 1AEB8122;
        Wed, 30 Aug 2023 16:27:51 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1693438070; x=1724974070;
  h=message-id:date:subject:to:cc:references:from:
   in-reply-to:content-transfer-encoding:mime-version;
  bh=q02e8eVAuh7lsIOwy0OnwHXUVnd9RbDKonvZh/YB3ms=;
  b=kO6MAgqkRXt5lztraEHUK1SlERFZbbsXeuD3UU8yvqOsCJmOt4ZhE1xt
   CG+wqGzEh5jMQ8M8m3r+rf4fZUArFr694T+FpGhINm71wTPuK4ZiknC+j
   Nw+qt7ss3kMH4R+eMyyjMK/bJnTxhi7G0M6kkry/UGvc33xP4CC2We3LH
   ufgTloMwTdVh7SepCBvomvHjRkmA4L3VfTkRBuQUHFgipF1NW55DRNz6A
   yUmnLQ+3emSJBkM0eKucU7lCZ9uqkIU8XC2TwOsaOEyr9vhFk+VB3Ch0k
   B3x1rIMCqHEX1kbrvFAUGaTkTymoSjZQF0QIp5Gsb7bkDMtdWX3ZITeGS
   g==;
X-IronPort-AV: E=McAfee;i="6600,9927,10818"; a="356088420"
X-IronPort-AV: E=Sophos;i="6.02,214,1688454000"; 
   d="scan'208";a="356088420"
Received: from orsmga003.jf.intel.com ([10.7.209.27])
  by fmsmga107.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 30 Aug 2023 16:27:28 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10818"; a="689086727"
X-IronPort-AV: E=Sophos;i="6.02,214,1688454000"; 
   d="scan'208";a="689086727"
Received: from orsmsx601.amr.corp.intel.com ([10.22.229.14])
  by orsmga003.jf.intel.com with ESMTP; 30 Aug 2023 16:27:27 -0700
Received: from orsmsx610.amr.corp.intel.com (10.22.229.23) by
 ORSMSX601.amr.corp.intel.com (10.22.229.14) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27; Wed, 30 Aug 2023 16:27:27 -0700
Received: from orsmsx610.amr.corp.intel.com (10.22.229.23) by
 ORSMSX610.amr.corp.intel.com (10.22.229.23) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27; Wed, 30 Aug 2023 16:27:27 -0700
Received: from orsedg603.ED.cps.intel.com (10.7.248.4) by
 orsmsx610.amr.corp.intel.com (10.22.229.23) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27 via Frontend Transport; Wed, 30 Aug 2023 16:27:27 -0700
Received: from NAM10-BN7-obe.outbound.protection.outlook.com (104.47.70.108)
 by edgegateway.intel.com (134.134.137.100) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.27; Wed, 30 Aug 2023 16:27:25 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=PnrVckPGnAgf1Fcdu8R8F/XNnJCveV7bUsEDvBrLhJYslMyJT+kkRqnbd8FledLC8Os/pat7Mc8oT8vEF+X+oPYt2Dh81EVvsd8rPx91/kc5lL0kmyJGHxlIkMw66l+DCM23pMsrSMP5N6NZLbjxUc/Hl3VCJhQMqc/ccWNTJjkjbgrQkwixNtPdk5fDBPPqH2h6QInmbhTcVOS49O1wU045XAyFRm0+HW06XvCoqSNWIthn2mhk5voukleRQb4cq8HSNwTUNxd57EZTx91IuiiGf2ArVGxD+U3Ush0DZTx9qH8sjpaaUJjc6AxwtXaPUV6rdMATYQasJh6UkK1lvw==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=eKIMGXalhtjV/XbPor5+r8RFVh14BApUcUrGZ/yV1Vg=;
 b=GdxzVWCA8aRgQXGjGgNiInciJhnN+NhB2Y7Mf9nXqVcGw2F0bXICR3a4QHh4E3aiUCVktiMxs7BnkI3fxXWoVy3wV0qW4AiOHlouNcUBlvw9sSXpe0wKOtXrNM+QsvP0ZNKR0XQZZN+6x/zJiJ550LSBIkjQYjAfapuPoW2/Z2K7QvONPm+cCdHWEqROMdDklwVXoWlLvjXkNa3xxI0GIhqAcjwqoj1dz/JsNK8i0Xeo7DgXbS9obFZwMd5S95Zst+SKPn08RtpsOLmYXXXZGCWt5j0W8KmM5Ma6lQKVDN3SkNFkD6iLLwN9lXW0UqtwNrWy2BsSCnWAMBapeIrsog==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from PH7PR11MB5984.namprd11.prod.outlook.com (2603:10b6:510:1e3::15)
 by CH3PR11MB7762.namprd11.prod.outlook.com (2603:10b6:610:151::15) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.6699.35; Wed, 30 Aug
 2023 23:27:23 +0000
Received: from PH7PR11MB5984.namprd11.prod.outlook.com
 ([fe80::9563:9642:bbde:293f]) by PH7PR11MB5984.namprd11.prod.outlook.com
 ([fe80::9563:9642:bbde:293f%7]) with mapi id 15.20.6699.034; Wed, 30 Aug 2023
 23:27:23 +0000
Message-ID: <bb4716e5-5ebf-e818-3c37-7ff2f0cdde23@intel.com>
Date: Wed, 30 Aug 2023 16:27:19 -0700
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101
 Betterbird/102.13.0
Subject: Re: [PATCH RFC v2 08/18] cxl/region: Add Dynamic Capacity CXL region
 support
To: Ira Weiny <ira.weiny@intel.com>,
        Dan Williams <dan.j.williams@intel.com>
CC: Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Alison Schofield <alison.schofield@intel.com>,
        "Vishal Verma" <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
 <20230604-dcd-type2-upstream-v2-8-f740c47e7916@intel.com>
Content-Language: en-US
From: Dave Jiang <dave.jiang@intel.com>
In-Reply-To: <20230604-dcd-type2-upstream-v2-8-f740c47e7916@intel.com>
Content-Type: text/plain; charset="UTF-8"; format=flowed
Content-Transfer-Encoding: 7bit
X-ClientProxiedBy: SJ0PR05CA0101.namprd05.prod.outlook.com
 (2603:10b6:a03:334::16) To PH7PR11MB5984.namprd11.prod.outlook.com
 (2603:10b6:510:1e3::15)
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: PH7PR11MB5984:EE_|CH3PR11MB7762:EE_
X-MS-Office365-Filtering-Correlation-Id: ab89dfcc-8f68-463d-db9a-08dba9b0a9ba
X-LD-Processed: 46c98d88-e344-4ed4-8496-4ed7712e255d,ExtAddr
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;
X-Microsoft-Antispam-Message-Info: GfLnzL3webho/6RPxdpICX3JCOiZh3N3FjdnzG7FmA4/71KkieWXw/zWqs8wggymrYKxxX6QDUybnv4U7ABJ0Ai6DmmS5JKxnQJpbZDESF91IpaOT0cXT/34z99Ma8BCkllZ7Bszd0HsskDmMOneFceaXVpEdFqGB0UwW0DlLFyVBjRiMg5DZRMA35n3t5aaYatPgr4zcvi7p2RE5X55EROyreXJStTpjOSdKPC7cPbmxll9y/6s1QBOXuuWEnTvnubOYBRyBrNvGwRHj7FbjCk7hdi/jbJ99O6jI2VYA0IM5qXq+Zwy4KAv56JjDbABw15utKAUlGG30uAD+vmokuChJx1RLcD1wM1TWbndp8NnEjEXLvXZQ6Jci1jAlF18ECgm6qQenTE/a5N+CrE+jRejfm98x6xOF1uAEpZBsIbtif02uCSwgXn4f/UgRHNgtcz8k0i1OtheMngOomEFBeJsItf3QoG/LUu7nBmDVCZW8fuWb5kioiacm38fyO1elYVcoWntVwtsOzrghOIPjpyD83dGsWdciNXgPwlBRAjUj+iYvEWj9HLWkV4ti19CGsKXPrUnxexHNKX01No11Yas0k5l94hEpS1GY74uruH+0wYzTMz4f2J7ZeIjCp4pajjEOyCO8NPX0iJ6qKmR1Q==
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:PH7PR11MB5984.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230031)(346002)(136003)(366004)(376002)(396003)(39860400002)(186009)(451199024)(1800799009)(6512007)(2616005)(6486002)(82960400001)(86362001)(38100700002)(53546011)(6666004)(110136005)(31696002)(478600001)(83380400001)(6506007)(26005)(36756003)(54906003)(4326008)(66556008)(5660300002)(8676002)(66946007)(41300700001)(8936002)(44832011)(316002)(66476007)(30864003)(2906002)(31686004)(6636002)(43740500002)(45980500001);DIR:OUT;SFP:1102;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?utf-8?B?ME9Ob1FFUUxQbGFnSDZuMnYyRTU5TEZxUzVoL284WDdqd3I4K0JkUFdDbEl4?=
 =?utf-8?B?Z0J6U2JvOXBFM3lhRk1ycjZZNTI4Y1QvaHp1OW4zeFhYQkxueFFMMUxodGdo?=
 =?utf-8?B?NzBaRyt2dk1CL1RrNjFLbEtodWtSQWFyeE1mekdpTFM0VGt3My83UlVzN1pz?=
 =?utf-8?B?bk45SzY0cE9nL0N6RUJRQXRDMnFSL0NaT09YRjFlWElTeXhiYW1lZjhSUjcr?=
 =?utf-8?B?UVhzS1Vua2NVbFJPSFVicDEreEJYMTdWbU5kQ3V3TDBaeXh1RWZlcjl5czZl?=
 =?utf-8?B?ck9qRUxrZzBxeTBnendvY2hmSmhDWkxQNEppdzVSNTU4U2Y5S295OTlTMHB2?=
 =?utf-8?B?Ky9OQkxCUEhtemZnZE1tVTNIb1RwOHVUOERuRmNwSXczN1V4Z1drWHhaNDRZ?=
 =?utf-8?B?bHJqSVlvS2NreVJGV3phdEI5b1lNZ1h3d2dTWndaN2sxaUdIYUNSU0MrYlB3?=
 =?utf-8?B?QlJXRDMwRTRHR3Eyak5OMGdkaDJBc1VoYkZTSEZTaVYvb29UYTVNOVZyeEoy?=
 =?utf-8?B?Q01XSWFOVjdjM3NaUlIzcXBwSFN6NFpCTHRrMHpkbWI0N21ZMEozUVNzQ3J0?=
 =?utf-8?B?bm0wZTg2Ujhud0xhcm56ZG95ZjRuVFV5eXR1WXVESjdsZFdEZDE3M2YvazRi?=
 =?utf-8?B?N2dhV3FTWEFHbUNUNURDdFlIQVpLbUdydldpRGtvUnlwQVlnK05mVzEvajEy?=
 =?utf-8?B?VllwRlZZZTk2QkhJY2JWTi9kcHdNeDhKcFVPUFNMbzVGWXN1SUJVaU5hbTd5?=
 =?utf-8?B?SjQ1bEVYc3g1OGpZek9NZzZzQ0lEK3RVaVFmTk83SUdDbG9lSzN1TnF4THlo?=
 =?utf-8?B?MzFJWW9KdUFaUktqTVdiV09xRUtLUkdXcDhSM2IvbTd2U0tNczBPb0MrMkdT?=
 =?utf-8?B?a0w3V3BjVDNjZVBGUUcyQzhMeVFYL1Y1RzhBbWRDNWZOTVo4a2NXK0VyM2RI?=
 =?utf-8?B?bHNXaVliV1A4RjRJK2NYeTNRY1ZwQ3B2Z3VscWp4YmJWbzA2dkhhT2NVOWEv?=
 =?utf-8?B?M0FpMGF6WE16TGtxWmVlRkNieEpvcEkxR2dPZjdTNVJ2RnRXQXI3cEtCdWpW?=
 =?utf-8?B?c3d4UDBtY0NnaDcrWjhRK3N3Wkx4VU43UWZvdDlWMjVobWd3anZoRUtyM2ZT?=
 =?utf-8?B?dUk1andtM1NoYVA0RVJ1VHdpNEN1MUJWZEhqckc3RUlXb1dTUkVVZ1MzSjFD?=
 =?utf-8?B?K3UyZm5TQXN1S0I4MkxJK1FFMSsyNUVBUTRqMkZRUkpOa3dxZDZEZ0krMTJi?=
 =?utf-8?B?cThsNFNXZ2tzTVpwa1oraEZQK0diNTZqZm9rSDF3OWVHa1M0YlVuTHdtcmY4?=
 =?utf-8?B?Y2hyMEJXQkdhOGFYVURqZ1YwSG9vOGV2OHQvdFY2TTBCdnNWcG14dnV2WEJU?=
 =?utf-8?B?eFpUSW1kdTMvaUxtaXNUcUpwalVwUDhoY3lnVkhjbHFLWFJCckZrdm44eGZO?=
 =?utf-8?B?NTk0TFowSnpVTXdFM0lGZW9LSHVWSFNTS0IzYjA0V2duNDhzUitXRXhZS0k5?=
 =?utf-8?B?YnZNT1dZSzBHSXlkRzhTUjVMWThHMVVGMjFKL09FVHdwcHFtdnBhOFRUSU40?=
 =?utf-8?B?Y2hqUGZqR05YVGFmTjZML1k1ZUJGK0NSRnlIQmd0RXF2eGFGMFJ1ZVpVSDV1?=
 =?utf-8?B?a1FXTm9IeEhjZ1ZlREVzcEE5WXZjUkFURW4vb1BxMlk5K3R5VXNEQ1Rna2Ux?=
 =?utf-8?B?YUQrUjh3VUx4blVWaWVubXhuRlhncVhoSytCcjAxVTZTN2dQNWt2eXArOTZj?=
 =?utf-8?B?MDV1dmxWRDdEdkhKeXByQ2N4ajNYZUoveUxyNm9Oc2Rna1FmbklYNGxxZ2Vi?=
 =?utf-8?B?V2xFeHFDUGwxU3UyUjdBUng2Z1hHcXFpUTZmR1g0Y2FyakphZ0xmRXl0MFpz?=
 =?utf-8?B?QkFGU0FHY0pFZjlQdWR1L0pDdGFEcnNlaVFvMFRQMEZQM0FlQWtKOVFBVCtT?=
 =?utf-8?B?QUNJNmFwU2xmZHVhQ2Q2YVdKY0lWWFhhTWQ2bXROUE1GL1pOVWZaSmZYYXV3?=
 =?utf-8?B?QTVualJCSmcrQ1FUZ2pJRW5tNTdZU245UmFMNENTeE1JYnNHYzgyNkFMU1VN?=
 =?utf-8?B?TVc5Z2xBV25aN1hIY3NtZmRsMlh2L3J1ZnBuSnIwdG4wWjl4Wm5meXJ2NUJR?=
 =?utf-8?B?YmtCUTZYenhJd2dPQko4c1ZLaGExR3A3UUd6U21wYkp5MnZUa1h5WEY3cGZ6?=
 =?utf-8?B?REE9PQ==?=
X-MS-Exchange-CrossTenant-Network-Message-Id: ab89dfcc-8f68-463d-db9a-08dba9b0a9ba
X-MS-Exchange-CrossTenant-AuthSource: PH7PR11MB5984.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 30 Aug 2023 23:27:23.1558
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: oSGY9TtNOM+gbLF1bmNpTjznGVIR0ZDYGLhoxJdw16N2Q8A7gZPyEdM+Mxh9h/We9QTujnCn8CgoIzDUx0oyUQ==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: CH3PR11MB7762
X-OriginatorOrg: intel.com
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org



On 8/28/23 22:20, Ira Weiny wrote:
> CXL devices optionally support dynamic capacity.  CXL Regions must be
> configured correctly to access this capacity.  Similar to ram and pmem
> partitions, DC Regions represent different partitions of the DPA space.
> 
> Interleaving is deferred due to the complexity of managing extents on
> multiple devices at the same time.  However, there is nothing which
> directly prevents interleave support at this time.  The check allows
> for early rejection.
> 
> To maintain backwards compatibility with older software, CXL regions
> need a default DAX device to hold the reference for the region until it
> is deleted.
> 
> Add create_dc_region sysfs entry to create DC regions.  Share the logic
> of devm_cxl_add_dax_region() and region_is_system_ram().  Special case
> DC capable CXL regions to create a 0 sized seed DAX device until others
> can be created on dynamic space later.
> 
> Flag dax_regions to indicate 0 capacity available until dax_region
> extents are supported by the region.
> 
> Co-developed-by: Navneet Singh <navneet.singh@intel.com>
> Signed-off-by: Navneet Singh <navneet.singh@intel.com>
> Signed-off-by: Ira Weiny <ira.weiny@intel.com>

You probably should update kernel version to v6.7. Otherwise
Reviewed-by: Dave Jiang <dave.jiang@intel.com>

> 
> ---
> changes for v2:
> [iweiny: flag empty dax regions]
> [iweiny: Split out anything not directly related to creating a DC CXL
> 	 region]
> [iweiny: Separate out dev dax stuff]
> [iweiny/navneet: create 0 sized DAX device by default]
> [iweiny: use new DC region mode]
> ---
>   Documentation/ABI/testing/sysfs-bus-cxl | 20 +++++-----
>   drivers/cxl/core/core.h                 |  1 +
>   drivers/cxl/core/port.c                 |  1 +
>   drivers/cxl/core/region.c               | 71 ++++++++++++++++++++++++++++-----
>   drivers/dax/bus.c                       |  8 ++++
>   drivers/dax/bus.h                       |  1 +
>   drivers/dax/cxl.c                       | 15 ++++++-
>   7 files changed, 96 insertions(+), 21 deletions(-)
> 
> diff --git a/Documentation/ABI/testing/sysfs-bus-cxl b/Documentation/ABI/testing/sysfs-bus-cxl
> index aa65dc5b4e13..a0562938ecac 100644
> --- a/Documentation/ABI/testing/sysfs-bus-cxl
> +++ b/Documentation/ABI/testing/sysfs-bus-cxl
> @@ -351,20 +351,20 @@ Description:
>   		interleave_granularity).
>   
>   
> -What:		/sys/bus/cxl/devices/decoderX.Y/create_{pmem,ram}_region
> +What:		/sys/bus/cxl/devices/decoderX.Y/create_{pmem,ram,dc}_region
>   Date:		May, 2022, January, 2023
> -KernelVersion:	v6.0 (pmem), v6.3 (ram)
> +KernelVersion:	v6.0 (pmem), v6.3 (ram), v6.6 (dc)
>   Contact:	linux-cxl@vger.kernel.org
>   Description:
>   		(RW) Write a string in the form 'regionZ' to start the process
> -		of defining a new persistent, or volatile memory region
> -		(interleave-set) within the decode range bounded by root decoder
> -		'decoderX.Y'. The value written must match the current value
> -		returned from reading this attribute. An atomic compare exchange
> -		operation is done on write to assign the requested id to a
> -		region and allocate the region-id for the next creation attempt.
> -		EBUSY is returned if the region name written does not match the
> -		current cached value.
> +		of defining a new persistent, volatile, or Dynamic Capacity
> +		(DC) memory region (interleave-set) within the decode range
> +		bounded by root decoder 'decoderX.Y'. The value written must
> +		match the current value returned from reading this attribute.
> +		An atomic compare exchange operation is done on write to assign
> +		the requested id to a region and allocate the region-id for the
> +		next creation attempt.  EBUSY is returned if the region name
> +		written does not match the current cached value.
>   
>   
>   What:		/sys/bus/cxl/devices/decoderX.Y/delete_region
> diff --git a/drivers/cxl/core/core.h b/drivers/cxl/core/core.h
> index 45e7e044cf4a..cf3cf01cb95d 100644
> --- a/drivers/cxl/core/core.h
> +++ b/drivers/cxl/core/core.h
> @@ -13,6 +13,7 @@ extern struct attribute_group cxl_base_attribute_group;
>   #ifdef CONFIG_CXL_REGION
>   extern struct device_attribute dev_attr_create_pmem_region;
>   extern struct device_attribute dev_attr_create_ram_region;
> +extern struct device_attribute dev_attr_create_dc_region;
>   extern struct device_attribute dev_attr_delete_region;
>   extern struct device_attribute dev_attr_region;
>   extern const struct device_type cxl_pmem_region_type;
> diff --git a/drivers/cxl/core/port.c b/drivers/cxl/core/port.c
> index a5db710a63bc..608901bb7d91 100644
> --- a/drivers/cxl/core/port.c
> +++ b/drivers/cxl/core/port.c
> @@ -314,6 +314,7 @@ static struct attribute *cxl_decoder_root_attrs[] = {
>   	&dev_attr_target_list.attr,
>   	SET_CXL_REGION_ATTR(create_pmem_region)
>   	SET_CXL_REGION_ATTR(create_ram_region)
> +	SET_CXL_REGION_ATTR(create_dc_region)
>   	SET_CXL_REGION_ATTR(delete_region)
>   	NULL,
>   };
> diff --git a/drivers/cxl/core/region.c b/drivers/cxl/core/region.c
> index 69af1354bc5b..fc8dee469244 100644
> --- a/drivers/cxl/core/region.c
> +++ b/drivers/cxl/core/region.c
> @@ -2271,6 +2271,7 @@ static struct cxl_region *devm_cxl_add_region(struct cxl_root_decoder *cxlrd,
>   	switch (mode) {
>   	case CXL_REGION_RAM:
>   	case CXL_REGION_PMEM:
> +	case CXL_REGION_DC:
>   		break;
>   	default:
>   		dev_err(&cxlrd->cxlsd.cxld.dev, "unsupported mode %s\n",
> @@ -2383,6 +2384,33 @@ static ssize_t create_ram_region_store(struct device *dev,
>   }
>   DEVICE_ATTR_RW(create_ram_region);
>   
> +static ssize_t create_dc_region_show(struct device *dev,
> +				     struct device_attribute *attr, char *buf)
> +{
> +	return __create_region_show(to_cxl_root_decoder(dev), buf);
> +}
> +
> +static ssize_t create_dc_region_store(struct device *dev,
> +				      struct device_attribute *attr,
> +				      const char *buf, size_t len)
> +{
> +	struct cxl_root_decoder *cxlrd = to_cxl_root_decoder(dev);
> +	struct cxl_region *cxlr;
> +	int rc, id;
> +
> +	rc = sscanf(buf, "region%d\n", &id);
> +	if (rc != 1)
> +		return -EINVAL;
> +
> +	cxlr = __create_region(cxlrd, id, CXL_REGION_DC,
> +			       CXL_DECODER_HOSTONLYMEM);
> +	if (IS_ERR(cxlr))
> +		return PTR_ERR(cxlr);
> +
> +	return len;
> +}
> +DEVICE_ATTR_RW(create_dc_region);
> +
>   static ssize_t region_show(struct device *dev, struct device_attribute *attr,
>   			   char *buf)
>   {
> @@ -2834,7 +2862,7 @@ static void cxlr_dax_unregister(void *_cxlr_dax)
>   	device_unregister(&cxlr_dax->dev);
>   }
>   
> -static int devm_cxl_add_dax_region(struct cxl_region *cxlr)
> +static int __devm_cxl_add_dax_region(struct cxl_region *cxlr)
>   {
>   	struct cxl_dax_region *cxlr_dax;
>   	struct device *dev;
> @@ -2863,6 +2891,21 @@ static int devm_cxl_add_dax_region(struct cxl_region *cxlr)
>   	return rc;
>   }
>   
> +static int devm_cxl_add_dax_region(struct cxl_region *cxlr)
> +{
> +	return __devm_cxl_add_dax_region(cxlr);
> +}
> +
> +static int devm_cxl_add_dc_dax_region(struct cxl_region *cxlr)
> +{
> +	if (cxlr->params.interleave_ways != 1) {
> +		dev_err(&cxlr->dev, "Interleaving DC not supported\n");
> +		return -EINVAL;
> +	}
> +
> +	return __devm_cxl_add_dax_region(cxlr);
> +}
> +
>   static int match_decoder_by_range(struct device *dev, void *data)
>   {
>   	struct range *r1, *r2 = data;
> @@ -3203,6 +3246,19 @@ static int is_system_ram(struct resource *res, void *arg)
>   	return 1;
>   }
>   
> +/*
> + * The region can not be manged by CXL if any portion of
> + * it is already online as 'System RAM'
> + */
> +static bool region_is_system_ram(struct cxl_region *cxlr,
> +				 struct cxl_region_params *p)
> +{
> +	return (walk_iomem_res_desc(IORES_DESC_NONE,
> +				    IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY,
> +				    p->res->start, p->res->end, cxlr,
> +				    is_system_ram) > 0);
> +}
> +
>   static int cxl_region_probe(struct device *dev)
>   {
>   	struct cxl_region *cxlr = to_cxl_region(dev);
> @@ -3242,14 +3298,7 @@ static int cxl_region_probe(struct device *dev)
>   	case CXL_REGION_PMEM:
>   		return devm_cxl_add_pmem_region(cxlr);
>   	case CXL_REGION_RAM:
> -		/*
> -		 * The region can not be manged by CXL if any portion of
> -		 * it is already online as 'System RAM'
> -		 */
> -		if (walk_iomem_res_desc(IORES_DESC_NONE,
> -					IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY,
> -					p->res->start, p->res->end, cxlr,
> -					is_system_ram) > 0)
> +		if (region_is_system_ram(cxlr, p))
>   			return 0;
>   
>   		/*
> @@ -3261,6 +3310,10 @@ static int cxl_region_probe(struct device *dev)
>   
>   		/* HDM-H routes to device-dax */
>   		return devm_cxl_add_dax_region(cxlr);
> +	case CXL_REGION_DC:
> +		if (region_is_system_ram(cxlr, p))
> +			return 0;
> +		return devm_cxl_add_dc_dax_region(cxlr);
>   	default:
>   		dev_dbg(&cxlr->dev, "unsupported region mode: %s\n",
>   			cxl_region_mode_name(cxlr->mode));
> diff --git a/drivers/dax/bus.c b/drivers/dax/bus.c
> index 0ee96e6fc426..b76e49813a39 100644
> --- a/drivers/dax/bus.c
> +++ b/drivers/dax/bus.c
> @@ -169,6 +169,11 @@ static bool is_static(struct dax_region *dax_region)
>   	return (dax_region->res.flags & IORESOURCE_DAX_STATIC) != 0;
>   }
>   
> +static bool is_dynamic(struct dax_region *dax_region)
> +{
> +	return (dax_region->res.flags & IORESOURCE_DAX_DYNAMIC_CAP) != 0;
> +}
> +
>   bool static_dev_dax(struct dev_dax *dev_dax)
>   {
>   	return is_static(dev_dax->region);
> @@ -285,6 +290,9 @@ static unsigned long long dax_region_avail_size(struct dax_region *dax_region)
>   
>   	device_lock_assert(dax_region->dev);
>   
> +	if (is_dynamic(dax_region))
> +		return 0;
> +
>   	for_each_dax_region_resource(dax_region, res)
>   		size -= resource_size(res);
>   	return size;
> diff --git a/drivers/dax/bus.h b/drivers/dax/bus.h
> index 1ccd23360124..74d8fe4a5532 100644
> --- a/drivers/dax/bus.h
> +++ b/drivers/dax/bus.h
> @@ -13,6 +13,7 @@ struct dax_region;
>   /* dax bus specific ioresource flags */
>   #define IORESOURCE_DAX_STATIC BIT(0)
>   #define IORESOURCE_DAX_KMEM BIT(1)
> +#define IORESOURCE_DAX_DYNAMIC_CAP BIT(2)
>   
>   struct dax_region *alloc_dax_region(struct device *parent, int region_id,
>   		struct range *range, int target_node, unsigned int align,
> diff --git a/drivers/dax/cxl.c b/drivers/dax/cxl.c
> index 8bc9d04034d6..147c8c69782b 100644
> --- a/drivers/dax/cxl.c
> +++ b/drivers/dax/cxl.c
> @@ -13,19 +13,30 @@ static int cxl_dax_region_probe(struct device *dev)
>   	struct cxl_region *cxlr = cxlr_dax->cxlr;
>   	struct dax_region *dax_region;
>   	struct dev_dax_data data;
> +	resource_size_t dev_size;
> +	unsigned long flags;
>   
>   	if (nid == NUMA_NO_NODE)
>   		nid = memory_add_physaddr_to_nid(cxlr_dax->hpa_range.start);
>   
> +	dev_size = range_len(&cxlr_dax->hpa_range);
> +
> +	flags = IORESOURCE_DAX_KMEM;
> +	if (cxlr->mode == CXL_REGION_DC) {
> +		/* Add empty seed dax device */
> +		dev_size = 0;
> +		flags |= IORESOURCE_DAX_DYNAMIC_CAP;
> +	}
> +
>   	dax_region = alloc_dax_region(dev, cxlr->id, &cxlr_dax->hpa_range, nid,
> -				      PMD_SIZE, IORESOURCE_DAX_KMEM);
> +				      PMD_SIZE, flags);
>   	if (!dax_region)
>   		return -ENOMEM;
>   
>   	data = (struct dev_dax_data) {
>   		.dax_region = dax_region,
>   		.id = -1,
> -		.size = range_len(&cxlr_dax->hpa_range),
> +		.size = dev_size,
>   	};
>   
>   	return PTR_ERR_OR_ZERO(devm_create_dev_dax(&data));
> 

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 515DAC83F14
	for <linux-cxl@archiver.kernel.org>; Wed, 30 Aug 2023 22:46:37 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1344166AbjH3Wqh (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Wed, 30 Aug 2023 18:46:37 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:45588 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1344112AbjH3Wqg (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Wed, 30 Aug 2023 18:46:36 -0400
Received: from mgamail.intel.com (mgamail.intel.com [134.134.136.20])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 4F93ACD8;
        Wed, 30 Aug 2023 15:46:18 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1693435578; x=1724971578;
  h=message-id:date:subject:to:cc:references:from:
   in-reply-to:content-transfer-encoding:mime-version;
  bh=yrirVc3btB7pWepC427XSvq12dFBJ3/+xSk3OBbi5cM=;
  b=laGCYO5a5Ki9heMiMcHbRp9G/e67MatuhUoNPuah/VigCqmOHcRFhwCc
   44UKPzik3Eq6204CW5pyC5dk+1F9onOunUx7kBG9hTAb1WBHCHImLjt/6
   v8wp7v4eBfl6elm44cJh80Ss44SZhBTaQHwwXwwkRg7fa0teTU9hBo8wr
   kM+SAhe+tpUbd3R19anxOZZQQpXjJj4zcKOESsbZQOBVLqaW5PHBnjZbx
   JzbMM2EJXwnZwnURZQJXDTTNOAc/1k5nF00+3bFsApjdQei+q7okmPOqS
   hIMonsKZpjBSC3lxloQI+at3C2qOAxH+NNM2j65NpE7XNEdlE3dHjpBfm
   Q==;
X-IronPort-AV: E=McAfee;i="6600,9927,10818"; a="365967766"
X-IronPort-AV: E=Sophos;i="6.02,214,1688454000"; 
   d="scan'208";a="365967766"
Received: from fmsmga008.fm.intel.com ([10.253.24.58])
  by orsmga101.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 30 Aug 2023 15:46:14 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10818"; a="804715866"
X-IronPort-AV: E=Sophos;i="6.02,214,1688454000"; 
   d="scan'208";a="804715866"
Received: from orsmsx603.amr.corp.intel.com ([10.22.229.16])
  by fmsmga008.fm.intel.com with ESMTP; 30 Aug 2023 15:46:13 -0700
Received: from orsmsx611.amr.corp.intel.com (10.22.229.24) by
 ORSMSX603.amr.corp.intel.com (10.22.229.16) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27; Wed, 30 Aug 2023 15:46:13 -0700
Received: from orsmsx610.amr.corp.intel.com (10.22.229.23) by
 ORSMSX611.amr.corp.intel.com (10.22.229.24) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27; Wed, 30 Aug 2023 15:46:12 -0700
Received: from ORSEDG602.ED.cps.intel.com (10.7.248.7) by
 orsmsx610.amr.corp.intel.com (10.22.229.23) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27 via Frontend Transport; Wed, 30 Aug 2023 15:46:12 -0700
Received: from NAM12-MW2-obe.outbound.protection.outlook.com (104.47.66.47) by
 edgegateway.intel.com (134.134.137.103) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.27; Wed, 30 Aug 2023 15:46:12 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=WquT9jB86YTk0ZYNfdN94Q5SwmXXrbMJ0+Y2d1gzNSvDZIRUi2v/TsbInUYGvuTv4ordo2rXAmSr4am2FZclNuidxhr4Fcrp5jIf4DBziNHfNf9JTcOxPi6YWRc8PJYV2Be8xCBkfyOzwviyfjgN+d0BJ45hKGppNl6OVhmuJr6ruyZnalRgkJamMNu40muajnNdW0F3wIomjiuXeOH+Xy+YAB+xxq3GY8HVsQgydI0ycOK0l17fkj4UhMxgnARBxd2MCOOd3RO1PpUV6ih9DEPjKAz7ocF1Toc5/UlYa3iNCRvKeaC4SXzKfN3Nlw+8EnTozUUnllmQjAhtOLJ0uQ==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=tAIF8xYHf01Gig1VbpihXUb3Jwf+QneOPVYiuT7VBP4=;
 b=cXkU/SH9tR+V2Rtkup8yRz4fCx0e9iSslNBoWPpoRkXyv357j/W/11bV5ToGD5+qrgNuzjbwmAVvkGJNpiKcEY5bMuqteyGl8o4Uf3rrkIs61sFxGEPx+s4rl4EwQ09d6hLf0AQLOgFEzhYquKz+Fa3kfyQ+k5Zj9T/EHCCtwImDLLTunnqgp1sABLBedULe03SHXZrRVWCjv/Joj+uf92sKfxtL3Ntx8FaMqQaYiD8miSAQNwhC+vDq20HzhQ7hyeizRI8J2bYVyQyyVRn0KlbWEm9iIkSOiyBnET1GXO9VDK85OohsvYJWihCxFcLwGJErKLuA4y11VCN9rU9PTA==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from PH7PR11MB5984.namprd11.prod.outlook.com (2603:10b6:510:1e3::15)
 by LV8PR11MB8488.namprd11.prod.outlook.com (2603:10b6:408:1e7::18) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.6699.34; Wed, 30 Aug
 2023 22:46:05 +0000
Received: from PH7PR11MB5984.namprd11.prod.outlook.com
 ([fe80::9563:9642:bbde:293f]) by PH7PR11MB5984.namprd11.prod.outlook.com
 ([fe80::9563:9642:bbde:293f%7]) with mapi id 15.20.6699.034; Wed, 30 Aug 2023
 22:46:05 +0000
Message-ID: <7e7dfcbd-22a0-c1c3-de1b-7a99edb7f22a@intel.com>
Date: Wed, 30 Aug 2023 15:46:00 -0700
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101
 Betterbird/102.13.0
Subject: Re: [PATCH RFC v2 07/18] cxl/mem: Expose device dynamic capacity
 configuration
To: <ira.weiny@intel.com>, Dan Williams <dan.j.williams@intel.com>
CC: Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Alison Schofield <alison.schofield@intel.com>,
        "Vishal Verma" <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
 <20230604-dcd-type2-upstream-v2-7-f740c47e7916@intel.com>
Content-Language: en-US
From: Dave Jiang <dave.jiang@intel.com>
In-Reply-To: <20230604-dcd-type2-upstream-v2-7-f740c47e7916@intel.com>
Content-Type: text/plain; charset="UTF-8"; format=flowed
Content-Transfer-Encoding: 7bit
X-ClientProxiedBy: BYAPR11CA0071.namprd11.prod.outlook.com
 (2603:10b6:a03:80::48) To PH7PR11MB5984.namprd11.prod.outlook.com
 (2603:10b6:510:1e3::15)
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: PH7PR11MB5984:EE_|LV8PR11MB8488:EE_
X-MS-Office365-Filtering-Correlation-Id: f83fe501-e74f-47e9-8ad3-08dba9aae45b
X-LD-Processed: 46c98d88-e344-4ed4-8496-4ed7712e255d,ExtAddr
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;
X-Microsoft-Antispam-Message-Info: Wud+XaxNcKkcvatTXwzYYdtmc3rTaTA1WV/enyQFR7BofWugry6GO0yaAOYLkhXFII/NcZBxUutMr0QcdXgn5EHQmTYFqRZfHLqlWRQ7a35XIM44+3TNAquvmWwatqgknixPXPeTkGw2ZSe4VEnuh2ipKXqWmtinkS2ZTYL7vD/DMNrZawEABHMpsxXYPsNT4UAgvrU84czllYd2GdbKrQD92sm7DnNlfvnV027uJKqpDy9xROnSQvyCPCgS2K7Rv/AK/mnlsa1KvroxCySxl/gUj58LeHIWuD4VCXZCl+XnBTd8biwb21EgbnhX1v5XvP0CeX/nEiw38KA7judvgtp1LfhUyFjuiCf5HuAOwx9mrROu5TYMCv4TzCzGiRth5L2CxnbsxdqUqX9j8+IhiKZ+rWlrTnP/XmFxnl1dd8MuDcyD5/LvitL/VmxzcuC0xp6KJaI9csjEJDY52TirWe249jl1QL31qd76MAMUPaYKN3fPJSdMB9v653RC69aqerDePt4Tg7jpSmXvWz5VJAxUIgNzjXGv92ZxwyWiM8IboSf3apXC2xFBh9k+y4rVd+kbfkf6KALnrFVefN69CR2nx4h72QWV/R9GVhhazBjUREbma1+5TZSzhJLbkOfQwvXsI/FX56Dpua+vZynMjg==
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:PH7PR11MB5984.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230031)(366004)(396003)(39860400002)(136003)(376002)(346002)(186009)(1800799009)(451199024)(6506007)(6486002)(6512007)(6666004)(53546011)(83380400001)(26005)(478600001)(6636002)(316002)(8676002)(37006003)(41300700001)(66556008)(66476007)(66946007)(8936002)(4326008)(5660300002)(54906003)(6862004)(2906002)(44832011)(36756003)(86362001)(2616005)(38100700002)(82960400001)(31696002)(31686004)(45980500001)(43740500002);DIR:OUT;SFP:1102;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?utf-8?B?TGdVMFN3Q3k5UFFHTnlnMDJWL2Y2S2c3R284NDN6clk0eEJCRE1na1JJK2JM?=
 =?utf-8?B?TGJvTllONEhQU29iaHdjZng3NFF1UXhzYnE4R2JWS3UxWkZCWkFuQW9tdmVY?=
 =?utf-8?B?ZXhkd2pGdTFBVHA2NnhZNEhobGxQWWlLNzRYMzROeTlVaU9zU3Exbm5ld1k0?=
 =?utf-8?B?Umd0QkY2eG9QTVpRa21oWjdFZ2w0Q3BVdGY1dmMzdmxMam1jODNnOEVFdjlG?=
 =?utf-8?B?VlZoVVJrQVFWcEpWR3FmUFNhcUczbkp0c0k1SkoxcFVRbjkrZ0FaVmxZK0Jm?=
 =?utf-8?B?ZWFEaXkvR1YxRi81cjRvL2I1Tkg0dCt2N1hVbmMxdXhOQXMydTV6SjhqMmZL?=
 =?utf-8?B?UzhuSmlhMlBXUCthdy9wUFgzcDVoQzBXa2Z1c3g4SVhCTjV6dzEvcnBOclNz?=
 =?utf-8?B?cXJmaHNGQ3lyRWMzeEtPMmV3N2xNa04zOWFOSmZWWXozM2xKcEk2RTBNWEZw?=
 =?utf-8?B?bDlhTXY3NmRBbCtiR0RaaERQSm5BeXBRYXZMeG4zVTJkQTVneW42MlFBTkFm?=
 =?utf-8?B?WmZnZGN3WUlXWXFEaTJaNm1mYUlBU2drZUk4Q3pmVGFsUlROVkIwbUxIT3Rl?=
 =?utf-8?B?Vyt3WHd6QWFTakVlczVoVTU5Q1o4VTlmaElDa3RUVDRNVnFPNzU5RFVTSWJY?=
 =?utf-8?B?N2wxZ1MrbS9KT2laT2x2bXZxSjBwTGJEWHhvQ1MwY1FON0JvZnBpcEluNURj?=
 =?utf-8?B?N2lWdHczK0lhNjZyd0xFdCsycmZ0RnhIYlFLZGErVlVqbE9mRjBJbWZML25W?=
 =?utf-8?B?ZGRxUlJvZzBuUEIzT2tWNXd2TGNCV2cxZ0lac3pxNjFyMGFXdjR4WVJoMEIx?=
 =?utf-8?B?Z01MdXM2ejhzbzUxNW5aV2FtRjh5YWYySHl6aWxaWlVjZ0J2RExadENSK1NZ?=
 =?utf-8?B?aGpoSVAzSG5Kek1wY1FHdjNNYTVPK2UxOVhseWRmSk5hSCtZZXA0QlE0THRn?=
 =?utf-8?B?OFdLV2JMYkJjTlF1ZTQ2dlVVc2UwWVdwcmRlNE1ZQTlOKzdiUCtYaDNsR0lM?=
 =?utf-8?B?czB3Y21Bb2UwV09FekdjMlg0eUdpeUpnUWtxNGlZVDFmdFB5bHNLeERWUjEr?=
 =?utf-8?B?aEMrMzMxQ3dMMHlIM1R3RGdFeW5JY3dIUWxyV3Y3bHNCMWVYTWtDTk5Od0lC?=
 =?utf-8?B?dm9zMnI2YXZ3WUxoeE9qV1pLajIzdmlwditDMGVQVExCNk1nY29tTUpJRnpX?=
 =?utf-8?B?RHhpUkZKTDUycE0za2Y3R01aNkRXZnNjN0NUaVNWOVVMRkF5R0F0c3JNcjZx?=
 =?utf-8?B?L3c4Mit0dm1NL0Z6eEVWQjRsRVpDWk1DOHQ4RDhtd0RzZnZxZEUzaVp0bll6?=
 =?utf-8?B?WS9JTTJ4emp6WCtyUVU1WDZJcjg0R0lwZkpUVnlsL0Jsdk9Xc2hmWmx6QnNI?=
 =?utf-8?B?d3d0czR0M2lJQVZjQzRtcnNHK2h3TlJoTEhmcW56TCtpRnZTYzJ1dGxINlRh?=
 =?utf-8?B?TkY4dlNrNmF2NzVwa1I5SXgyc0lGU2x3eWVNVmFVSlNUZ3FzVHZQR2NUV0VG?=
 =?utf-8?B?eG1kZlNXS2F6d1JxeUQ2WXNIbmNPWFNPU2VteW1WbStBLzB0amZvMDdVald3?=
 =?utf-8?B?eE8wSnZHVnhXNmZCSE1vOVA4STNUQzVDZTBvNEJsTERGd2RNNU5QWTFNV042?=
 =?utf-8?B?MFVUdC9uOHg1eDVVNlc0VHRzL0t4cUkxWGF6TGNscnJOeXhxYlQ5TUVNTTdT?=
 =?utf-8?B?alVkbkNhejhWM1JpK2tNdEFzZWlITW1ldXZPVXhCWXJPTFNKOFpCYVFsYmoz?=
 =?utf-8?B?NTVDclRxSERsMFBEU201Nm5zNXBxM3NlMVFhYktBNG5YckZQcFo2NVlYUDk2?=
 =?utf-8?B?VjkyMWdLR1FFcnhGV2F1RWJMNzFLVDdvOWl6ajZWbGFHLzZSZjNHSExVU2lI?=
 =?utf-8?B?dkJzOFZFVWZzb1czNy9vMGxHRW92NitTNjBvVXg2NHRmR2dneXRxcHMwbDdm?=
 =?utf-8?B?SmYxbkxyU3RGRUNJQ2k2WmJYUlV4MllmSkMvYXBBditRZ2NlVVNabnovMXZ0?=
 =?utf-8?B?TUI3VGhJOHl5VU5EdllMczBLY3ZvRGFid2FsVmMxMkdUTjZzZnFuQVVHNEV1?=
 =?utf-8?B?c0c4bFVBN1RwQ0M5NTYxY05LbXhWNE9TMlF6ZUtNdEZXZVVYL0ZLcHp6NTBB?=
 =?utf-8?Q?Nw5NSye9t1SrRXH3fnzs43Gjf?=
X-MS-Exchange-CrossTenant-Network-Message-Id: f83fe501-e74f-47e9-8ad3-08dba9aae45b
X-MS-Exchange-CrossTenant-AuthSource: PH7PR11MB5984.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 30 Aug 2023 22:46:05.0341
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: zSnPR5wTaQhsTdWo8e9ycqPyItT02WOjoAqOGkrA2bT/naM7F1+3M3gAv9jb2q/TAE1rPbjvxJxsfgBwom8rvw==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: LV8PR11MB8488
X-OriginatorOrg: intel.com
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org



On 8/28/23 22:20, ira.weiny@intel.com wrote:
> From: Navneet Singh <navneet.singh@intel.com>
> 
> To properly configure CXL regions on Dynamic Capacity Devices (DCD),
> user space will need to know the details of the DC Regions available on
> a device.
> 
> Expose driver dynamic capacity configuration through sysfs
> attributes.
> 
> Co-developed-by: Navneet Singh <navneet.singh@intel.com>
> Signed-off-by: Navneet Singh <navneet.singh@intel.com>
> Signed-off-by: Ira Weiny <ira.weiny@intel.com>
> 
> ---
> Changes for v2:
> [iweiny: Rebased on latest master/type2 work]
> [iweiny: add documentation for sysfs entries]
> [iweiny: s/dc_regions_count/region_count/]
> [iweiny: s/dcY_size/regionY_size/]
> [alison: change size format to %#llx]
> [iweiny: change count format to %d]
> [iweiny: Formatting updates]
> [iweiny: Fix crash when device is not a mem device: found with cxl-test]
> ---
>   Documentation/ABI/testing/sysfs-bus-cxl | 17 ++++++++
>   drivers/cxl/core/memdev.c               | 77 +++++++++++++++++++++++++++++++++
>   2 files changed, 94 insertions(+)
> 
> diff --git a/Documentation/ABI/testing/sysfs-bus-cxl b/Documentation/ABI/testing/sysfs-bus-cxl
> index 2268ffcdb604..aa65dc5b4e13 100644
> --- a/Documentation/ABI/testing/sysfs-bus-cxl
> +++ b/Documentation/ABI/testing/sysfs-bus-cxl
> @@ -37,6 +37,23 @@ Description:
>   		identically named field in the Identify Memory Device Output
>   		Payload in the CXL-2.0 specification.
>   
> +What:		/sys/bus/cxl/devices/memX/dc/region_count
> +Date:		July, 2023
> +KernelVersion:	v6.6
> +Contact:	linux-cxl@vger.kernel.org
> +Description:
> +		(RO) Number of Dynamic Capacity (DC) regions supported on the
> +		device.  May be 0 if the device does not support Dynamic
> +		Capacity.
> +
> +What:		/sys/bus/cxl/devices/memX/dc/regionY_size
> +Date:		July, 2023
> +KernelVersion:	v6.6
> +Contact:	linux-cxl@vger.kernel.org
> +Description:
> +		(RO) Size of the Dynamic Capacity (DC) region Y.  Only
> +		available on devices which support DC and only for those
> +		region indexes supported by the device.
>   
>   What:		/sys/bus/cxl/devices/memX/serial
>   Date:		January, 2022
> diff --git a/drivers/cxl/core/memdev.c b/drivers/cxl/core/memdev.c
> index 492486707fd0..397262e0ebd2 100644
> --- a/drivers/cxl/core/memdev.c
> +++ b/drivers/cxl/core/memdev.c
> @@ -101,6 +101,20 @@ static ssize_t pmem_size_show(struct device *dev, struct device_attribute *attr,
>   static struct device_attribute dev_attr_pmem_size =
>   	__ATTR(size, 0444, pmem_size_show, NULL);
>   
> +static ssize_t region_count_show(struct device *dev, struct device_attribute *attr,
> +				 char *buf)
> +{
> +	struct cxl_memdev *cxlmd = to_cxl_memdev(dev);
> +	struct cxl_memdev_state *mds = to_cxl_memdev_state(cxlmd->cxlds);
> +	int len = 0;
> +
> +	len = sysfs_emit(buf, "%d\n", mds->nr_dc_region);
> +	return len;
> +}
> +
> +struct device_attribute dev_attr_region_count =
> +	__ATTR(region_count, 0444, region_count_show, NULL);
> +
>   static ssize_t serial_show(struct device *dev, struct device_attribute *attr,
>   			   char *buf)
>   {
> @@ -454,6 +468,62 @@ static struct attribute *cxl_memdev_security_attributes[] = {
>   	NULL,
>   };
>   
> +static ssize_t show_size_regionN(struct cxl_memdev *cxlmd, char *buf, int pos)
> +{
> +	struct cxl_memdev_state *mds = to_cxl_memdev_state(cxlmd->cxlds);
> +
> +	return sysfs_emit(buf, "%#llx\n", mds->dc_region[pos].decode_len);
> +}
> +
> +#define REGION_SIZE_ATTR_RO(n)						\
> +static ssize_t region##n##_size_show(struct device *dev,		\
> +				     struct device_attribute *attr,	\
> +				     char *buf)				\
> +{									\
> +	return show_size_regionN(to_cxl_memdev(dev), buf, (n));		\
> +}									\
> +static DEVICE_ATTR_RO(region##n##_size)
> +REGION_SIZE_ATTR_RO(0);
> +REGION_SIZE_ATTR_RO(1);
> +REGION_SIZE_ATTR_RO(2);
> +REGION_SIZE_ATTR_RO(3);
> +REGION_SIZE_ATTR_RO(4);
> +REGION_SIZE_ATTR_RO(5);
> +REGION_SIZE_ATTR_RO(6);
> +REGION_SIZE_ATTR_RO(7);
> +
> +static struct attribute *cxl_memdev_dc_attributes[] = {
> +	&dev_attr_region0_size.attr,
> +	&dev_attr_region1_size.attr,
> +	&dev_attr_region2_size.attr,
> +	&dev_attr_region3_size.attr,
> +	&dev_attr_region4_size.attr,
> +	&dev_attr_region5_size.attr,
> +	&dev_attr_region6_size.attr,
> +	&dev_attr_region7_size.attr,
> +	&dev_attr_region_count.attr,
> +	NULL,
> +};
> +
> +static umode_t cxl_dc_visible(struct kobject *kobj, struct attribute *a, int n)
> +{
> +	struct device *dev = kobj_to_dev(kobj);
> +	struct cxl_memdev *cxlmd = to_cxl_memdev(dev);
> +	struct cxl_memdev_state *mds = to_cxl_memdev_state(cxlmd->cxlds);
> +
> +	/* Not a memory device */
> +	if (!mds)
> +		return 0;
> +
> +	if (a == &dev_attr_region_count.attr)
> +		return a->mode;
> +
> +	if (n < mds->nr_dc_region)
> +		return a->mode;

I would add a comment on who you are checking against nr_dc_region to 
make it obvious.

DJ

> +
> +	return 0;
> +}
> +
>   static umode_t cxl_memdev_visible(struct kobject *kobj, struct attribute *a,
>   				  int n)
>   {
> @@ -482,11 +552,18 @@ static struct attribute_group cxl_memdev_security_attribute_group = {
>   	.attrs = cxl_memdev_security_attributes,
>   };
>   
> +static struct attribute_group cxl_memdev_dc_attribute_group = {
> +	.name = "dc",
> +	.attrs = cxl_memdev_dc_attributes,
> +	.is_visible = cxl_dc_visible,
> +};
> +
>   static const struct attribute_group *cxl_memdev_attribute_groups[] = {
>   	&cxl_memdev_attribute_group,
>   	&cxl_memdev_ram_attribute_group,
>   	&cxl_memdev_pmem_attribute_group,
>   	&cxl_memdev_security_attribute_group,
> +	&cxl_memdev_dc_attribute_group,
>   	NULL,
>   };
>   
> 

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 86C4EC83F14
	for <linux-cxl@archiver.kernel.org>; Wed, 30 Aug 2023 21:46:51 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S242415AbjH3Vqw (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Wed, 30 Aug 2023 17:46:52 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:39160 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S242425AbjH3Vqv (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Wed, 30 Aug 2023 17:46:51 -0400
Received: from mout.gmx.net (mout.gmx.net [212.227.15.19])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 3050C1A1;
        Wed, 30 Aug 2023 14:46:16 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=gmx.us;
 s=s31663417; t=1693431887; x=1694036687; i=fan.ni@gmx.us;
 bh=a96elxncsmZYJ1v5mtoSAnJRURD4jXVFOWj3F+hokfk=;
 h=X-UI-Sender-Class:Date:From:To:Cc:Subject:References:In-Reply-To;
 b=dd0QKc4GnfuU/uWr9DFWLVdBH7DBdwbwmc4LyLco3Glc1XSwiFZLpzqkdw7EoaWG/V+At2S
 BABQvqoMqTJpxt2N+ah6esiyAiC7yVvrjLEWOdYd4CO6+k4ZgZ+Qnx2kg4K0IDIXlysWyRENm
 121iSu/BgHeiLZ2hNPad+AdLyYMMT8Ltzo5AGR3MnJo0+bMBu0/CEY5adVrUYlsfEZqYbTxmH
 2fbDw0sezIjUTHw0951c25r4mpJh6eigYCvC7VFBgEu+l4nU4nc4y18ZvQ6SYf9LMUiZBNtv0
 SOyeIyOkhjzGN6BUoSkTtpAwzXTIYgnjSitn8Ex2PfxrES+pQJvA==
X-UI-Sender-Class: 724b4f7f-cbec-4199-ad4e-598c01a50d3a
Received: from debian ([50.205.20.42]) by mail.gmx.net (mrgmx004
 [212.227.17.184]) with ESMTPSA (Nemesis) id 1Mz9Yv-1poA8649ml-00wC6M; Wed, 30
 Aug 2023 23:44:46 +0200
Date: Wed, 30 Aug 2023 14:44:34 -0700
From: Fan Ni <fan.ni@gmx.us>
To: ira.weiny@intel.com
Cc: Dan Williams <dan.j.williams@intel.com>,
        Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        linux-cxl@vger.kernel.org, linux-kernel@vger.kernel.org
Subject: Re: [PATCH RFC v2 03/18] cxl/mem: Read Dynamic capacity
 configuration from the device
Message-ID: <ZO+4Qql0rOslp0bl@debian>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
 <20230604-dcd-type2-upstream-v2-3-f740c47e7916@intel.com>
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: <20230604-dcd-type2-upstream-v2-3-f740c47e7916@intel.com>
X-Provags-ID: V03:K1:CMg7y4LAwRJLCKwlyh6aU43mmFT8F1YCGIRST3rTQRGgLU0oCzm
 7Ca4vm0PSeUP8I/F0cMiRmPEG00aKzLuoL5HUHzzUrza6KPLSe4hqRuVbOoieLE7O+U47E1
 cM+SEUTAdnvRYUJxryiKVjX3HmZV9sNI9jPO4hry09emIW+N/LhqkuTK/Nao0Ubod3vGgKv
 XTvZOG4fHKtZYX1QybXSg==
UI-OutboundReport: notjunk:1;M01:P0:cgCUXOUDkng=;tQM2O6XFljOCywWQVvq5jXIeU/t
 ZdELCzHLPPZtfc77emVb33NdKzbWtc5Okx/4DLsh0UEWcKnptX/Nc3d5YeONmr1FL0ksXr6El
 J5WgG89I1+lkkO6mUTKMcXz7zh46p3TiEH5pJmjE9Mi/8gDL2ik7bkWsfn7Q7pMW3EPxfuZN0
 qJky3q7icNybREFItOX+agrk2bi4GDNXc293rzfYB6Tur03AGYx3kr442rYdB4UQbSYASS6Zd
 O+Xb5IBa/4v8SYuj4TNNyo7yA8+I8t0wjYmblF4KgFvKQh75b/0xVfEpXZga/wZK0tWldZfvs
 1eVhIjGFmAM77V9FV1wxyRUOOyOK+ml7Ehj1Rm6L1LYx3ZFqxqxxFnw1huoNbrWNalEQulX8T
 PGn32eEOmS+WV84S8C0i4q2CR2hxrWPb3Zr2K0pZfc6klAP6exaoqyjFmtG9uCQMoitzRkGYR
 O9nIOhinG7auI1VcQhp/4ncKovFpe4QwEzJx9rRlf0SFbLDUbvMZ3bAJizC3qRD9uSmJwUQxh
 AGzsa7V8lnpw1TyHHtHPl9DwgZ8hH3V8RQOTCqRY3aewZghSNpOYgbQMjXI+If+sndstCuDQU
 O/c2LqmI+Q2sdtv5YRk3RuZhvz8JccJbrfe2X+DmM9Qvqar/ju6Nxkz40kgkIy5LtS0434XWj
 yRIYhKklCdII3nOEaX+hNXXJ6aOZ51t8Hp5Pq5BJ2aHtG/KJYbKEs+v6C5oSGaTSqKzz1v7cq
 5IiMrGIrIHLLziC9ZxtI5/5enJgAE4kseLqXwwbcUh5st52GeIGpu9iE/S11OFtJ2azEJFPaT
 dFHfaLUKAQfNH3Tsk/LxJ1XrIENZ39O8zYAVLkDPa4RwKrjpAKEqL2COgtP6ysGawej62PIJQ
 9nTF34gfZF7yk8vMXrbrBg1WhADXpCd7iYFSph4Xb7t26m6u8yMGSck1wztF9VuoS4laVRP/A
 P4p4lEcaTjOyu2G3ohZ14ps69Lg=
Content-Transfer-Encoding: quoted-printable
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

On Mon, Aug 28, 2023 at 10:20:54PM -0700, ira.weiny@intel.com wrote:
> From: Navneet Singh <navneet.singh@intel.com>
>
> Devices can optionally support Dynamic Capacity (DC).  These devices are
> known as Dynamic Capacity Devices (DCD).
>
> Implement the DC (opcode 48XXh) mailbox commands as specified in CXL 3.0
> section 8.2.9.8.9.  Read the DC configuration and store the DC region
> information in the device state.
>
> Co-developed-by: Navneet Singh <navneet.singh@intel.com>
> Signed-off-by: Navneet Singh <navneet.singh@intel.com>
> Signed-off-by: Ira Weiny <ira.weiny@intel.com>
>
> ---
> Changes for v2
> [iweiny: Rebased to latest master type2 work]
> [jonathan: s/dc/dc_resp/]
> [iweiny: Clean up commit message]
> [iweiny: Clean kernel docs]
> [djiang: Fix up cxl_is_dcd_command]
> [djiang: extra blank line]
> [alison: s/total_capacity/cap/ etc...]
> [alison: keep partition flag with partition structures]
> [alison: reformat untenanted_mem declaration]
> [alison: move 'cmd' definition back]
> [alison: fix comment line length]
> [alison: reverse x-tree]
> [jonathan: fix and adjust CXL_DC_REGION_STRLEN]
> [Jonathan/iweiny: Factor out storing each DC region read from the device=
]
> [Jonathan: place all dcr initializers together]
> [Jonathan/iweiny: flip around the region DPA order check]
> [jonathan: Account for short read of mailbox command]
> [iweiny: use snprintf for region name]
> [iweiny: use '<nil>' for missing region names]
> [iweiny: factor out struct cxl_dc_region_info]
> [iweiny: Split out reading CEL]
> ---
>  drivers/cxl/core/mbox.c   | 179 +++++++++++++++++++++++++++++++++++++++=
++++++-
>  drivers/cxl/core/region.c |  75 +++++++++++++------
>  drivers/cxl/cxl.h         |  27 ++++++-
>  drivers/cxl/cxlmem.h      |  55 +++++++++++++-
>  drivers/cxl/pci.c         |   4 ++
>  5 files changed, 314 insertions(+), 26 deletions(-)
>
> diff --git a/drivers/cxl/core/mbox.c b/drivers/cxl/core/mbox.c
> index 554ec97a7c39..d769814f80e2 100644
> --- a/drivers/cxl/core/mbox.c
> +++ b/drivers/cxl/core/mbox.c
> @@ -1096,7 +1096,7 @@ int cxl_dev_state_identify(struct cxl_memdev_state=
 *mds)
>  	if (rc < 0)
>  		return rc;
>
> -	mds->total_bytes =3D
> +	mds->static_cap =3D
>  		le64_to_cpu(id.total_capacity) * CXL_CAPACITY_MULTIPLIER;
>  	mds->volatile_only_bytes =3D
>  		le64_to_cpu(id.volatile_capacity) * CXL_CAPACITY_MULTIPLIER;
> @@ -1114,6 +1114,8 @@ int cxl_dev_state_identify(struct cxl_memdev_state=
 *mds)
>  		mds->poison.max_errors =3D min_t(u32, val, CXL_POISON_LIST_MAX);
>  	}
>
> +	mds->dc_event_log_size =3D le16_to_cpu(id.dc_event_log_size);
> +
>  	return 0;
>  }
>  EXPORT_SYMBOL_NS_GPL(cxl_dev_state_identify, CXL);
> @@ -1178,6 +1180,165 @@ int cxl_mem_sanitize(struct cxl_memdev_state *md=
s, u16 cmd)
>  }
>  EXPORT_SYMBOL_NS_GPL(cxl_mem_sanitize, CXL);
>
> +static int cxl_dc_save_region_info(struct cxl_memdev_state *mds, int in=
dex,
> +				   struct cxl_dc_region_config *region_config)
> +{
> +	struct cxl_dc_region_info *dcr =3D &mds->dc_region[index];
> +	struct device *dev =3D mds->cxlds.dev;
> +
> +	dcr->base =3D le64_to_cpu(region_config->region_base);
> +	dcr->decode_len =3D le64_to_cpu(region_config->region_decode_length);
> +	dcr->decode_len *=3D CXL_CAPACITY_MULTIPLIER;
> +	dcr->len =3D le64_to_cpu(region_config->region_length);
> +	dcr->blk_size =3D le64_to_cpu(region_config->region_block_size);
> +	dcr->dsmad_handle =3D le32_to_cpu(region_config->region_dsmad_handle);
> +	dcr->flags =3D region_config->flags;
> +	snprintf(dcr->name, CXL_DC_REGION_STRLEN, "dc%d", index);
> +
> +	/* Check regions are in increasing DPA order */
> +	if (index > 0) {
> +		struct cxl_dc_region_info *prev_dcr =3D &mds->dc_region[index - 1];
> +
> +		if ((prev_dcr->base + prev_dcr->decode_len) > dcr->base) {
> +			dev_err(dev,
> +				"DPA ordering violation for DC region %d and %d\n",
> +				index - 1, index);
> +			return -EINVAL;
> +		}
> +	}
> +
> +	/* Check the region is 256 MB aligned */
> +	if (!IS_ALIGNED(dcr->base, SZ_256M)) {
> +		dev_err(dev, "DC region %d not aligned to 256MB: %#llx\n",
> +			index, dcr->base);
> +		return -EINVAL;
> +	}
> +
> +	/* Check Region base and length are aligned to block size */
> +	if (!IS_ALIGNED(dcr->base, dcr->blk_size) ||
> +	    !IS_ALIGNED(dcr->len, dcr->blk_size)) {
> +		dev_err(dev, "DC region %d not aligned to %#llx\n", index,
> +			dcr->blk_size);
> +		return -EINVAL;
> +	}

Based on on cxl 3.0 spec: Table 8-126, we may need some extra checks
here:
1. region len <=3D decode_len
2. region block size should be power of 2 and a multiple of 40H.

Also, if region len or block size is 0, it mentions that DC will not be
available, we may also need to handle that.

Fan

> +
> +	dev_dbg(dev,
> +		"DC region %s DPA: %#llx LEN: %#llx BLKSZ: %#llx\n",
> +		dcr->name, dcr->base, dcr->decode_len, dcr->blk_size);
> +
> +	return 0;
> +}
> +
> +/* Returns the number of regions in dc_resp or -ERRNO */
> +static int cxl_get_dc_id(struct cxl_memdev_state *mds, u8 start_region,
> +			 struct cxl_mbox_dynamic_capacity *dc_resp,
> +			 size_t dc_resp_size)
> +{
> +	struct cxl_mbox_get_dc_config get_dc =3D (struct cxl_mbox_get_dc_confi=
g) {
> +		.region_count =3D CXL_MAX_DC_REGION,
> +		.start_region_index =3D start_region,
> +	};
> +	struct cxl_mbox_cmd mbox_cmd =3D (struct cxl_mbox_cmd) {
> +		.opcode =3D CXL_MBOX_OP_GET_DC_CONFIG,
> +		.payload_in =3D &get_dc,
> +		.size_in =3D sizeof(get_dc),
> +		.size_out =3D dc_resp_size,
> +		.payload_out =3D dc_resp,
> +		.min_out =3D 1,
> +	};
> +	struct device *dev =3D mds->cxlds.dev;
> +	int rc;
> +
> +	rc =3D cxl_internal_send_cmd(mds, &mbox_cmd);
> +	if (rc < 0)
> +		return rc;
> +
> +	rc =3D dc_resp->avail_region_count - start_region;
> +
> +	/*
> +	 * The number of regions in the payload may have been truncated due to
> +	 * payload_size limits; if so adjust the count in this query.
> +	 */
> +	if (mbox_cmd.size_out < sizeof(*dc_resp))
> +		rc =3D CXL_REGIONS_RETURNED(mbox_cmd.size_out);
> +
> +	dev_dbg(dev, "Read %d/%d DC regions\n", rc, dc_resp->avail_region_coun=
t);
> +
> +	return rc;
> +}
> +
> +/**
> + * cxl_dev_dynamic_capacity_identify() - Reads the dynamic capacity
> + *					 information from the device.
> + * @mds: The memory device state
> + *
> + * This will dispatch the get_dynamic_capacity command to the device
> + * and on success populate structures to be exported to sysfs.
> + *
> + * Return: 0 if identify was executed successfully, -ERRNO on error.
> + */
> +int cxl_dev_dynamic_capacity_identify(struct cxl_memdev_state *mds)
> +{
> +	struct cxl_mbox_dynamic_capacity *dc_resp;
> +	struct device *dev =3D mds->cxlds.dev;
> +	size_t dc_resp_size =3D mds->payload_size;
> +	u8 start_region;
> +	int i, rc =3D 0;
> +
> +	for (i =3D 0; i < CXL_MAX_DC_REGION; i++)
> +		snprintf(mds->dc_region[i].name, CXL_DC_REGION_STRLEN, "<nil>");
> +
> +	/* Check GET_DC_CONFIG is supported by device */
> +	if (!test_bit(CXL_DCD_ENABLED_GET_CONFIG, mds->dcd_cmds)) {
> +		dev_dbg(dev, "unsupported cmd: get_dynamic_capacity_config\n");
> +		return 0;
> +	}
> +
> +	dc_resp =3D kvmalloc(dc_resp_size, GFP_KERNEL);
> +	if (!dc_resp)
> +		return -ENOMEM;
> +
> +	start_region =3D 0;
> +	do {
> +		int j;
> +
> +		rc =3D cxl_get_dc_id(mds, start_region, dc_resp, dc_resp_size);
> +		if (rc < 0)
> +			goto free_resp;
> +
> +		mds->nr_dc_region +=3D rc;
> +
> +		if (mds->nr_dc_region < 1 || mds->nr_dc_region > CXL_MAX_DC_REGION) {
> +			dev_err(dev, "Invalid num of dynamic capacity regions %d\n",
> +				mds->nr_dc_region);
> +			rc =3D -EINVAL;
> +			goto free_resp;
> +		}
> +
> +		for (i =3D start_region, j =3D 0; i < mds->nr_dc_region; i++, j++) {
> +			rc =3D cxl_dc_save_region_info(mds, i, &dc_resp->region[j]);
> +			if (rc)
> +				goto free_resp;
> +		}
> +
> +		start_region =3D mds->nr_dc_region;
> +
> +	} while (mds->nr_dc_region < dc_resp->avail_region_count);
> +
> +	mds->dynamic_cap =3D
> +		mds->dc_region[mds->nr_dc_region - 1].base +
> +		mds->dc_region[mds->nr_dc_region - 1].decode_len -
> +		mds->dc_region[0].base;
> +	dev_dbg(dev, "Total dynamic capacity: %#llx\n", mds->dynamic_cap);
> +
> +free_resp:
> +	kfree(dc_resp);
> +	if (rc)
> +		dev_err(dev, "Failed to get DC info: %d\n", rc);
> +	return rc;
> +}
> +EXPORT_SYMBOL_NS_GPL(cxl_dev_dynamic_capacity_identify, CXL);
> +
>  static int add_dpa_res(struct device *dev, struct resource *parent,
>  		       struct resource *res, resource_size_t start,
>  		       resource_size_t size, const char *type)
> @@ -1208,8 +1369,12 @@ int cxl_mem_create_range_info(struct cxl_memdev_s=
tate *mds)
>  {
>  	struct cxl_dev_state *cxlds =3D &mds->cxlds;
>  	struct device *dev =3D cxlds->dev;
> +	size_t untenanted_mem;
>  	int rc;
>
> +	untenanted_mem =3D mds->dc_region[0].base - mds->static_cap;
> +	mds->total_bytes =3D mds->static_cap + untenanted_mem + mds->dynamic_c=
ap;
> +
>  	if (!cxlds->media_ready) {
>  		cxlds->dpa_res =3D DEFINE_RES_MEM(0, 0);
>  		cxlds->ram_res =3D DEFINE_RES_MEM(0, 0);
> @@ -1217,8 +1382,16 @@ int cxl_mem_create_range_info(struct cxl_memdev_s=
tate *mds)
>  		return 0;
>  	}
>
> -	cxlds->dpa_res =3D
> -		(struct resource)DEFINE_RES_MEM(0, mds->total_bytes);
> +	cxlds->dpa_res =3D (struct resource)DEFINE_RES_MEM(0, mds->total_bytes=
);
> +
> +	for (int i =3D 0; i < mds->nr_dc_region; i++) {
> +		struct cxl_dc_region_info *dcr =3D &mds->dc_region[i];
> +
> +		rc =3D add_dpa_res(dev, &cxlds->dpa_res, &cxlds->dc_res[i],
> +				 dcr->base, dcr->decode_len, dcr->name);
> +		if (rc)
> +			return rc;
> +	}
>
>  	if (mds->partition_align_bytes =3D=3D 0) {
>  		rc =3D add_dpa_res(dev, &cxlds->dpa_res, &cxlds->ram_res, 0,
> diff --git a/drivers/cxl/core/region.c b/drivers/cxl/core/region.c
> index 252bc8e1f103..75041903b72c 100644
> --- a/drivers/cxl/core/region.c
> +++ b/drivers/cxl/core/region.c
> @@ -46,7 +46,7 @@ static ssize_t uuid_show(struct device *dev, struct de=
vice_attribute *attr,
>  	rc =3D down_read_interruptible(&cxl_region_rwsem);
>  	if (rc)
>  		return rc;
> -	if (cxlr->mode !=3D CXL_DECODER_PMEM)
> +	if (cxlr->mode !=3D CXL_REGION_PMEM)
>  		rc =3D sysfs_emit(buf, "\n");
>  	else
>  		rc =3D sysfs_emit(buf, "%pUb\n", &p->uuid);
> @@ -359,7 +359,7 @@ static umode_t cxl_region_visible(struct kobject *ko=
bj, struct attribute *a,
>  	 * Support tooling that expects to find a 'uuid' attribute for all
>  	 * regions regardless of mode.
>  	 */
> -	if (a =3D=3D &dev_attr_uuid.attr && cxlr->mode !=3D CXL_DECODER_PMEM)
> +	if (a =3D=3D &dev_attr_uuid.attr && cxlr->mode !=3D CXL_REGION_PMEM)
>  		return 0444;
>  	return a->mode;
>  }
> @@ -537,7 +537,7 @@ static ssize_t mode_show(struct device *dev, struct =
device_attribute *attr,
>  {
>  	struct cxl_region *cxlr =3D to_cxl_region(dev);
>
> -	return sysfs_emit(buf, "%s\n", cxl_decoder_mode_name(cxlr->mode));
> +	return sysfs_emit(buf, "%s\n", cxl_region_mode_name(cxlr->mode));
>  }
>  static DEVICE_ATTR_RO(mode);
>
> @@ -563,7 +563,7 @@ static int alloc_hpa(struct cxl_region *cxlr, resour=
ce_size_t size)
>
>  	/* ways, granularity and uuid (if PMEM) need to be set before HPA */
>  	if (!p->interleave_ways || !p->interleave_granularity ||
> -	    (cxlr->mode =3D=3D CXL_DECODER_PMEM && uuid_is_null(&p->uuid)))
> +	    (cxlr->mode =3D=3D CXL_REGION_PMEM && uuid_is_null(&p->uuid)))
>  		return -ENXIO;
>
>  	div_u64_rem(size, SZ_256M * p->interleave_ways, &remainder);
> @@ -1765,6 +1765,17 @@ static int cxl_region_sort_targets(struct cxl_reg=
ion *cxlr)
>  	return rc;
>  }
>
> +static bool cxl_modes_compatible(enum cxl_region_mode rmode,
> +				 enum cxl_decoder_mode dmode)
> +{
> +	if (rmode =3D=3D CXL_REGION_RAM && dmode =3D=3D CXL_DECODER_RAM)
> +		return true;
> +	if (rmode =3D=3D CXL_REGION_PMEM && dmode =3D=3D CXL_DECODER_PMEM)
> +		return true;
> +
> +	return false;
> +}
> +
>  static int cxl_region_attach(struct cxl_region *cxlr,
>  			     struct cxl_endpoint_decoder *cxled, int pos)
>  {
> @@ -1778,9 +1789,11 @@ static int cxl_region_attach(struct cxl_region *c=
xlr,
>  	lockdep_assert_held_write(&cxl_region_rwsem);
>  	lockdep_assert_held_read(&cxl_dpa_rwsem);
>
> -	if (cxled->mode !=3D cxlr->mode) {
> -		dev_dbg(&cxlr->dev, "%s region mode: %d mismatch: %d\n",
> -			dev_name(&cxled->cxld.dev), cxlr->mode, cxled->mode);
> +	if (!cxl_modes_compatible(cxlr->mode, cxled->mode)) {
> +		dev_dbg(&cxlr->dev, "%s region mode: %s mismatch decoder: %s\n",
> +			dev_name(&cxled->cxld.dev),
> +			cxl_region_mode_name(cxlr->mode),
> +			cxl_decoder_mode_name(cxled->mode));
>  		return -EINVAL;
>  	}
>
> @@ -2234,7 +2247,7 @@ static struct cxl_region *cxl_region_alloc(struct =
cxl_root_decoder *cxlrd, int i
>   * devm_cxl_add_region - Adds a region to a decoder
>   * @cxlrd: root decoder
>   * @id: memregion id to create, or memregion_free() on failure
> - * @mode: mode for the endpoint decoders of this region
> + * @mode: mode of this region
>   * @type: select whether this is an expander or accelerator (type-2 or =
type-3)
>   *
>   * This is the second step of region initialization. Regions exist with=
in an
> @@ -2245,7 +2258,7 @@ static struct cxl_region *cxl_region_alloc(struct =
cxl_root_decoder *cxlrd, int i
>   */
>  static struct cxl_region *devm_cxl_add_region(struct cxl_root_decoder *=
cxlrd,
>  					      int id,
> -					      enum cxl_decoder_mode mode,
> +					      enum cxl_region_mode mode,
>  					      enum cxl_decoder_type type)
>  {
>  	struct cxl_port *port =3D to_cxl_port(cxlrd->cxlsd.cxld.dev.parent);
> @@ -2254,11 +2267,12 @@ static struct cxl_region *devm_cxl_add_region(st=
ruct cxl_root_decoder *cxlrd,
>  	int rc;
>
>  	switch (mode) {
> -	case CXL_DECODER_RAM:
> -	case CXL_DECODER_PMEM:
> +	case CXL_REGION_RAM:
> +	case CXL_REGION_PMEM:
>  		break;
>  	default:
> -		dev_err(&cxlrd->cxlsd.cxld.dev, "unsupported mode %d\n", mode);
> +		dev_err(&cxlrd->cxlsd.cxld.dev, "unsupported mode %s\n",
> +			cxl_region_mode_name(mode));
>  		return ERR_PTR(-EINVAL);
>  	}
>
> @@ -2308,7 +2322,7 @@ static ssize_t create_ram_region_show(struct devic=
e *dev,
>  }
>
>  static struct cxl_region *__create_region(struct cxl_root_decoder *cxlr=
d,
> -					  int id, enum cxl_decoder_mode mode,
> +					  int id, enum cxl_region_mode mode,
>  					  enum cxl_decoder_type type)
>  {
>  	int rc;
> @@ -2337,7 +2351,7 @@ static ssize_t create_pmem_region_store(struct dev=
ice *dev,
>  	if (rc !=3D 1)
>  		return -EINVAL;
>
> -	cxlr =3D __create_region(cxlrd, id, CXL_DECODER_PMEM,
> +	cxlr =3D __create_region(cxlrd, id, CXL_REGION_PMEM,
>  			       CXL_DECODER_HOSTONLYMEM);
>  	if (IS_ERR(cxlr))
>  		return PTR_ERR(cxlr);
> @@ -2358,7 +2372,7 @@ static ssize_t create_ram_region_store(struct devi=
ce *dev,
>  	if (rc !=3D 1)
>  		return -EINVAL;
>
> -	cxlr =3D __create_region(cxlrd, id, CXL_DECODER_RAM,
> +	cxlr =3D __create_region(cxlrd, id, CXL_REGION_RAM,
>  			       CXL_DECODER_HOSTONLYMEM);
>  	if (IS_ERR(cxlr))
>  		return PTR_ERR(cxlr);
> @@ -2886,10 +2900,31 @@ static void construct_region_end(void)
>  	up_write(&cxl_region_rwsem);
>  }
>
> +static enum cxl_region_mode
> +cxl_decoder_to_region_mode(enum cxl_decoder_mode mode)
> +{
> +	switch (mode) {
> +	case CXL_DECODER_NONE:
> +		return CXL_REGION_NONE;
> +	case CXL_DECODER_RAM:
> +		return CXL_REGION_RAM;
> +	case CXL_DECODER_PMEM:
> +		return CXL_REGION_PMEM;
> +	case CXL_DECODER_DEAD:
> +		return CXL_REGION_DEAD;
> +	case CXL_DECODER_MIXED:
> +	default:
> +		return CXL_REGION_MIXED;
> +	}
> +
> +	return CXL_REGION_MIXED;
> +}
> +
>  static struct cxl_region *
>  construct_region_begin(struct cxl_root_decoder *cxlrd,
>  		       struct cxl_endpoint_decoder *cxled)
>  {
> +	enum cxl_region_mode mode =3D cxl_decoder_to_region_mode(cxled->mode);
>  	struct cxl_memdev *cxlmd =3D cxled_to_memdev(cxled);
>  	struct cxl_region_params *p;
>  	struct cxl_region *cxlr;
> @@ -2897,7 +2932,7 @@ construct_region_begin(struct cxl_root_decoder *cx=
lrd,
>
>  	do {
>  		cxlr =3D __create_region(cxlrd, atomic_read(&cxlrd->region_id),
> -				       cxled->mode, cxled->cxld.target_type);
> +				       mode, cxled->cxld.target_type);
>  	} while (IS_ERR(cxlr) && PTR_ERR(cxlr) =3D=3D -EBUSY);
>
>  	if (IS_ERR(cxlr)) {
> @@ -3200,9 +3235,9 @@ static int cxl_region_probe(struct device *dev)
>  		return rc;
>
>  	switch (cxlr->mode) {
> -	case CXL_DECODER_PMEM:
> +	case CXL_REGION_PMEM:
>  		return devm_cxl_add_pmem_region(cxlr);
> -	case CXL_DECODER_RAM:
> +	case CXL_REGION_RAM:
>  		/*
>  		 * The region can not be manged by CXL if any portion of
>  		 * it is already online as 'System RAM'
> @@ -3223,8 +3258,8 @@ static int cxl_region_probe(struct device *dev)
>  		/* HDM-H routes to device-dax */
>  		return devm_cxl_add_dax_region(cxlr);
>  	default:
> -		dev_dbg(&cxlr->dev, "unsupported region mode: %d\n",
> -			cxlr->mode);
> +		dev_dbg(&cxlr->dev, "unsupported region mode: %s\n",
> +			cxl_region_mode_name(cxlr->mode));
>  		return -ENXIO;
>  	}
>  }
> diff --git a/drivers/cxl/cxl.h b/drivers/cxl/cxl.h
> index cd4a9ffdacc7..ed282dcd5cf5 100644
> --- a/drivers/cxl/cxl.h
> +++ b/drivers/cxl/cxl.h
> @@ -374,6 +374,28 @@ static inline const char *cxl_decoder_mode_name(enu=
m cxl_decoder_mode mode)
>  	return "mixed";
>  }
>
> +enum cxl_region_mode {
> +	CXL_REGION_NONE,
> +	CXL_REGION_RAM,
> +	CXL_REGION_PMEM,
> +	CXL_REGION_MIXED,
> +	CXL_REGION_DEAD,
> +};
> +
> +static inline const char *cxl_region_mode_name(enum cxl_region_mode mod=
e)
> +{
> +	static const char * const names[] =3D {
> +		[CXL_REGION_NONE] =3D "none",
> +		[CXL_REGION_RAM] =3D "ram",
> +		[CXL_REGION_PMEM] =3D "pmem",
> +		[CXL_REGION_MIXED] =3D "mixed",
> +	};
> +
> +	if (mode >=3D CXL_REGION_NONE && mode <=3D CXL_REGION_MIXED)
> +		return names[mode];
> +	return "mixed";
> +}
> +
>  /*
>   * Track whether this decoder is reserved for region autodiscovery, or
>   * free for userspace provisioning.
> @@ -502,7 +524,8 @@ struct cxl_region_params {
>   * struct cxl_region - CXL region
>   * @dev: This region's device
>   * @id: This region's id. Id is globally unique across all regions
> - * @mode: Endpoint decoder allocation / access mode
> + * @mode: Region mode which defines which endpoint decoder mode the reg=
ion is
> + *        compatible with
>   * @type: Endpoint decoder target type
>   * @cxl_nvb: nvdimm bridge for coordinating @cxlr_pmem setup / shutdown
>   * @cxlr_pmem: (for pmem regions) cached copy of the nvdimm bridge
> @@ -512,7 +535,7 @@ struct cxl_region_params {
>  struct cxl_region {
>  	struct device dev;
>  	int id;
> -	enum cxl_decoder_mode mode;
> +	enum cxl_region_mode mode;
>  	enum cxl_decoder_type type;
>  	struct cxl_nvdimm_bridge *cxl_nvb;
>  	struct cxl_pmem_region *cxlr_pmem;
> diff --git a/drivers/cxl/cxlmem.h b/drivers/cxl/cxlmem.h
> index 5f2e65204bf9..8c8f47b397ab 100644
> --- a/drivers/cxl/cxlmem.h
> +++ b/drivers/cxl/cxlmem.h
> @@ -396,6 +396,7 @@ enum cxl_devtype {
>  	CXL_DEVTYPE_CLASSMEM,
>  };
>
> +#define CXL_MAX_DC_REGION 8
>  /**
>   * struct cxl_dev_state - The driver device state
>   *
> @@ -412,6 +413,8 @@ enum cxl_devtype {
>   * @dpa_res: Overall DPA resource tree for the device
>   * @pmem_res: Active Persistent memory capacity configuration
>   * @ram_res: Active Volatile memory capacity configuration
> + * @dc_res: Active Dynamic Capacity memory configuration for each possi=
ble
> + *          region
>   * @component_reg_phys: register base of component registers
>   * @serial: PCIe Device Serial Number
>   * @type: Generic Memory Class device or Vendor Specific Memory device
> @@ -426,11 +429,23 @@ struct cxl_dev_state {
>  	struct resource dpa_res;
>  	struct resource pmem_res;
>  	struct resource ram_res;
> +	struct resource dc_res[CXL_MAX_DC_REGION];
>  	resource_size_t component_reg_phys;
>  	u64 serial;
>  	enum cxl_devtype type;
>  };
>
> +#define CXL_DC_REGION_STRLEN 7
> +struct cxl_dc_region_info {
> +	u64 base;
> +	u64 decode_len;
> +	u64 len;
> +	u64 blk_size;
> +	u32 dsmad_handle;
> +	u8 flags;
> +	u8 name[CXL_DC_REGION_STRLEN];
> +};
> +
>  /**
>   * struct cxl_memdev_state - Generic Type-3 Memory Device Class driver =
data
>   *
> @@ -449,6 +464,8 @@ struct cxl_dev_state {
>   * @enabled_cmds: Hardware commands found enabled in CEL.
>   * @exclusive_cmds: Commands that are kernel-internal only
>   * @total_bytes: sum of all possible capacities
> + * @static_cap: Sum of RAM and PMEM capacities
> + * @dynamic_cap: Complete DPA range occupied by DC regions
>   * @volatile_only_bytes: hard volatile capacity
>   * @persistent_only_bytes: hard persistent capacity
>   * @partition_align_bytes: alignment size for partition-able capacity
> @@ -456,6 +473,10 @@ struct cxl_dev_state {
>   * @active_persistent_bytes: sum of hard + soft persistent
>   * @next_volatile_bytes: volatile capacity change pending device reset
>   * @next_persistent_bytes: persistent capacity change pending device re=
set
> + * @nr_dc_region: number of DC regions implemented in the memory device
> + * @dc_region: array containing info about the DC regions
> + * @dc_event_log_size: The number of events the device can store in the
> + * Dynamic Capacity Event Log before it overflows
>   * @event: event log driver state
>   * @poison: poison driver state info
>   * @fw: firmware upload / activation state
> @@ -473,7 +494,10 @@ struct cxl_memdev_state {
>  	DECLARE_BITMAP(dcd_cmds, CXL_DCD_ENABLED_MAX);
>  	DECLARE_BITMAP(enabled_cmds, CXL_MEM_COMMAND_ID_MAX);
>  	DECLARE_BITMAP(exclusive_cmds, CXL_MEM_COMMAND_ID_MAX);
> +
>  	u64 total_bytes;
> +	u64 static_cap;
> +	u64 dynamic_cap;
>  	u64 volatile_only_bytes;
>  	u64 persistent_only_bytes;
>  	u64 partition_align_bytes;
> @@ -481,6 +505,11 @@ struct cxl_memdev_state {
>  	u64 active_persistent_bytes;
>  	u64 next_volatile_bytes;
>  	u64 next_persistent_bytes;
> +
> +	u8 nr_dc_region;
> +	struct cxl_dc_region_info dc_region[CXL_MAX_DC_REGION];
> +	size_t dc_event_log_size;
> +
>  	struct cxl_event_state event;
>  	struct cxl_poison_state poison;
>  	struct cxl_security_state security;
> @@ -587,6 +616,7 @@ struct cxl_mbox_identify {
>  	__le16 inject_poison_limit;
>  	u8 poison_caps;
>  	u8 qos_telemetry_caps;
> +	__le16 dc_event_log_size;
>  } __packed;
>
>  /*
> @@ -741,9 +771,31 @@ struct cxl_mbox_set_partition_info {
>  	__le64 volatile_capacity;
>  	u8 flags;
>  } __packed;
> -
>  #define  CXL_SET_PARTITION_IMMEDIATE_FLAG	BIT(0)
>
> +struct cxl_mbox_get_dc_config {
> +	u8 region_count;
> +	u8 start_region_index;
> +} __packed;
> +
> +/* See CXL 3.0 Table 125 get dynamic capacity config Output Payload */
> +struct cxl_mbox_dynamic_capacity {
> +	u8 avail_region_count;
> +	u8 rsvd[7];
> +	struct cxl_dc_region_config {
> +		__le64 region_base;
> +		__le64 region_decode_length;
> +		__le64 region_length;
> +		__le64 region_block_size;
> +		__le32 region_dsmad_handle;
> +		u8 flags;
> +		u8 rsvd[3];
> +	} __packed region[];
> +} __packed;
> +#define CXL_DYNAMIC_CAPACITY_SANITIZE_ON_RELEASE_FLAG BIT(0)
> +#define CXL_REGIONS_RETURNED(size_out) \
> +	((size_out - 8) / sizeof(struct cxl_dc_region_config))
> +
>  /* Set Timestamp CXL 3.0 Spec 8.2.9.4.2 */
>  struct cxl_mbox_set_timestamp_in {
>  	__le64 timestamp;
> @@ -867,6 +919,7 @@ enum {
>  int cxl_internal_send_cmd(struct cxl_memdev_state *mds,
>  			  struct cxl_mbox_cmd *cmd);
>  int cxl_dev_state_identify(struct cxl_memdev_state *mds);
> +int cxl_dev_dynamic_capacity_identify(struct cxl_memdev_state *mds);
>  int cxl_await_media_ready(struct cxl_dev_state *cxlds);
>  int cxl_enumerate_cmds(struct cxl_memdev_state *mds);
>  int cxl_mem_create_range_info(struct cxl_memdev_state *mds);
> diff --git a/drivers/cxl/pci.c b/drivers/cxl/pci.c
> index 5242dbf0044d..a9b110ff1176 100644
> --- a/drivers/cxl/pci.c
> +++ b/drivers/cxl/pci.c
> @@ -879,6 +879,10 @@ static int cxl_pci_probe(struct pci_dev *pdev, cons=
t struct pci_device_id *id)
>  	if (rc)
>  		return rc;
>
> +	rc =3D cxl_dev_dynamic_capacity_identify(mds);
> +	if (rc)
> +		return rc;
> +
>  	rc =3D cxl_mem_create_range_info(mds);
>  	if (rc)
>  		return rc;
>
> --
> 2.41.0
>

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id CA0EEC83F14
	for <linux-cxl@archiver.kernel.org>; Wed, 30 Aug 2023 21:16:03 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S240978AbjH3VQC (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Wed, 30 Aug 2023 17:16:02 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:42350 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S234865AbjH3VQB (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Wed, 30 Aug 2023 17:16:01 -0400
Received: from mgamail.intel.com (mgamail.intel.com [192.55.52.115])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 6DD81E48;
        Wed, 30 Aug 2023 14:15:29 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1693430129; x=1724966129;
  h=message-id:date:subject:to:cc:references:from:
   in-reply-to:content-transfer-encoding:mime-version;
  bh=ljB4VrdDUzAsZQ/wdHvEk+4wRv0rXBog5345PxIFVoQ=;
  b=mQMHHIpl3UhCgFNbo9SJKOG5irF8y+sZ5nD+8kCXmnX/bVcgxJjOgsED
   xDb3MjGAWGZTOgaz6pIEDNlsAel61dnW0vp/iXEZUy2nmgenWTLfE+5vu
   0Dm2EPYiUsbIU/sIcvkctLK1hBeFzVLO8CJzDjXrgTW3jlF/Z+jWq8wE9
   nnYK+atgdy9ejStDm6M5ycGPs4tb6XuvNy4YZ845Tj6uSGIwXOfDmx0Oy
   KHJMYoEm2//irLw0jy7M3f5PHZDsJ/KoBjtmUZHJmB3jqlpuPmTISBWyh
   n1cBjoBuXV35P4ndwkCvYQVZMmjL4+wxcxq7ha3rx0zf6cvmazpSvsRqa
   Q==;
X-IronPort-AV: E=McAfee;i="6600,9927,10818"; a="375702043"
X-IronPort-AV: E=Sophos;i="6.02,214,1688454000"; 
   d="scan'208";a="375702043"
Received: from orsmga003.jf.intel.com ([10.7.209.27])
  by fmsmga103.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 30 Aug 2023 14:13:16 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10818"; a="689052959"
X-IronPort-AV: E=Sophos;i="6.02,214,1688454000"; 
   d="scan'208";a="689052959"
Received: from orsmsx602.amr.corp.intel.com ([10.22.229.15])
  by orsmga003.jf.intel.com with ESMTP; 30 Aug 2023 14:13:16 -0700
Received: from orsmsx612.amr.corp.intel.com (10.22.229.25) by
 ORSMSX602.amr.corp.intel.com (10.22.229.15) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27; Wed, 30 Aug 2023 14:13:15 -0700
Received: from orsmsx611.amr.corp.intel.com (10.22.229.24) by
 ORSMSX612.amr.corp.intel.com (10.22.229.25) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27; Wed, 30 Aug 2023 14:13:14 -0700
Received: from ORSEDG601.ED.cps.intel.com (10.7.248.6) by
 orsmsx611.amr.corp.intel.com (10.22.229.24) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27 via Frontend Transport; Wed, 30 Aug 2023 14:13:14 -0700
Received: from NAM02-BN1-obe.outbound.protection.outlook.com (104.47.51.45) by
 edgegateway.intel.com (134.134.137.102) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.27; Wed, 30 Aug 2023 14:13:13 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=UsXqYF+F8+Z0XhN0kcyWEzNt4KMtrR32fKE1DyxM61sYOAnnFaBS67Buu0Tf8lq5A758BDnYQO8RCRz9/OGZ6V14HxM0wzC/8A4ShlIRuY3SD9l8EqBmQrItTd6Ty2tx73kUXtsTkzVCVJFdWyM1hu9t8Rgj0TF/GlNYtYP9SHS8JGuXEqJseIioBjyi6wh4PlmDJJ5ffiYY764XQbXc1UWc7yPEs2gdsUULSKXWeg3T/Dd1JjpZ64Qhbp7T4ylAtqouIHght0DrXCYLrxVYbsuniMiGppOEf26InKM6k4mw968P99Jknd6l/xadygYDEWsFpl5FYqtlGBCcXeL5Yg==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=KiVHc5cNSgnl9ZFSJ0zuO8XcUAFY3PiQh4wHm36+w4c=;
 b=XeqV3hiP+9thEH87rGnP2Dj9Q9m28t5eXvz3XHS8DE9M3FwacZNgK/w1FWpXs//DFSzODoaLJglXk6IQUMN6ZEh8Hosn+OJYHLMU1YAq2jMb9ZvaRWhE0cOsgpfoqXyFFgD+pclcwSPGQJG0Vo85DSXGKTXFxRz+Yhy4K5U2LLwJ4AoruzgN1QzuVArCKCst2PzbZ9QUoAHCgjUxnoLmeKVLw2bwcFCQzT41C4oQVzMRS+Ina0t6AS1/Vt837rkL2T3Pk/jDgY3J3+LtVuHoxmR+kRRyHOkabY7YSyThQ0PgOLKQQB92BJDXi8qH5bgdHVf7l5maA19jBWks6aiPvw==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from PH7PR11MB5984.namprd11.prod.outlook.com (2603:10b6:510:1e3::15)
 by IA0PR11MB7307.namprd11.prod.outlook.com (2603:10b6:208:437::10) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.6745.20; Wed, 30 Aug
 2023 21:13:11 +0000
Received: from PH7PR11MB5984.namprd11.prod.outlook.com
 ([fe80::9563:9642:bbde:293f]) by PH7PR11MB5984.namprd11.prod.outlook.com
 ([fe80::9563:9642:bbde:293f%7]) with mapi id 15.20.6699.034; Wed, 30 Aug 2023
 21:13:11 +0000
Message-ID: <9706e50d-18fa-3360-ff79-d7e02587ac54@intel.com>
Date: Wed, 30 Aug 2023 14:13:07 -0700
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101
 Betterbird/102.13.0
Subject: Re: [PATCH RFC v2 04/18] cxl/region: Add Dynamic Capacity decoder and
 region modes
To: Ira Weiny <ira.weiny@intel.com>,
        Dan Williams <dan.j.williams@intel.com>
CC: Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Alison Schofield <alison.schofield@intel.com>,
        "Vishal Verma" <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
 <20230604-dcd-type2-upstream-v2-4-f740c47e7916@intel.com>
Content-Language: en-US
From: Dave Jiang <dave.jiang@intel.com>
In-Reply-To: <20230604-dcd-type2-upstream-v2-4-f740c47e7916@intel.com>
Content-Type: text/plain; charset="UTF-8"; format=flowed
Content-Transfer-Encoding: 7bit
X-ClientProxiedBy: BY5PR20CA0004.namprd20.prod.outlook.com
 (2603:10b6:a03:1f4::17) To PH7PR11MB5984.namprd11.prod.outlook.com
 (2603:10b6:510:1e3::15)
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: PH7PR11MB5984:EE_|IA0PR11MB7307:EE_
X-MS-Office365-Filtering-Correlation-Id: 175154f4-fe95-41f4-c992-08dba99dea61
X-LD-Processed: 46c98d88-e344-4ed4-8496-4ed7712e255d,ExtAddr
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;
X-Microsoft-Antispam-Message-Info: 5Ew5xK2PzqYlhvKmSvmr3mgqQx/XAyKDN6To3+21+E3aNo26rcbvjLGQsRYGuA3NyvcTPdpiKI8m9Rz/Rxt83tl565XPJK89llHBaVfSQQgqipfyRWcE71G14YeDy2o0hHjug/jrlYkoELPpbXOHXiG4YTt5COjGEyvjrOLQS2aUduzILF6AHsDACcm+qLua13smY7R+ax5Z6u9WS7o/GY0lnUckSLH+qXi3MkPmmVtrVrBvyYb+7bSMpHi7PFQFboLhKBEVCvAaobP+S4lFG/y6rZ9a/rMr2tFG7v8tdMQdmnQA81ODha5Lr7v4/dOp7036+iGi3OYM0LbFcgKvyjHUN5pOn7gA+fvlGPp9uvYxZjXJPp1BoVqF/NUmsXNc7vBJxCUBSKzIb/LtdUpxsud4x3/yY1hA0rPISM0GBdvq/OF05bQU3/uGijTPMwka1osRgDEXID9fAxeS9NSn5ladNdNExwn+YnOTtEz5Eld3xfUkK8sOChkG2j1YkEYA6ASW6mFM9dzreW+LxrpUek6kykBFRwhR/yX948IP59hR90owJpWOXQwqpI9qi70hya4B2KMwQUPTWs7H/DgreJ57NiCUrgbTgeZkirm0IlVn2CHSTZAe7QIpK6uCdUryAAXistK3VvMLKQLsQoovdQ==
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:PH7PR11MB5984.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230031)(346002)(396003)(39860400002)(136003)(376002)(366004)(186009)(451199024)(1800799009)(36756003)(31686004)(4326008)(53546011)(44832011)(41300700001)(31696002)(86362001)(5660300002)(8936002)(8676002)(26005)(6506007)(6666004)(6486002)(2616005)(6512007)(110136005)(478600001)(38100700002)(6636002)(66946007)(66556008)(66476007)(54906003)(82960400001)(316002)(2906002)(45980500001)(43740500002);DIR:OUT;SFP:1102;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?utf-8?B?WFRGV2tQQU1kSER5K2NEREFaQm1ETmRHS1RCY2tUYTZ2YVE4eFJEY1ExS2gr?=
 =?utf-8?B?clRoWHZUd2I4cktZczQxVDVzZEVmYTZ1SEp0L2NOS2dpS1phNkFqOVRQYlg2?=
 =?utf-8?B?K2pMYnMrVXFJc3M3MUJPUzM3VmdSQmxMaC9rVUczMk9LK3JUeThhaUk1VEtv?=
 =?utf-8?B?NWhuRUdvVTYwdmRYWlYvUGlVcHF4ZU9qWmVIVzdVWnZVSEhKNmFRejBraHdU?=
 =?utf-8?B?Y0c0WXJpMFJPSHRneFlTR1Y3V2ZsMVVxc3BQR0JrejE0d3Q5Qm9mK3dVQTho?=
 =?utf-8?B?aWRubmUwNkIxcHloRjRMNE56aEMxUnN4bHNLT3RESkNyTjVLRllFbnRrNVJC?=
 =?utf-8?B?L2x4ekNHVld3OE1hSmhRQkFiQzhwbXN2N1czTTVqM21YLzJORmRCU0kwVG9i?=
 =?utf-8?B?UlNuSU1BS3RLYSs2V0VmVGc3bHBUYlVqcHFhZGpSQTRaYms1ZVZKWE52d0xa?=
 =?utf-8?B?NTV1SjdBV1ozUG5pcG1kMEZvZEZEOUxSUDlGYkQwS2lOek9iZkl5bTNENzh3?=
 =?utf-8?B?dHBmZjQ5d1RGcDV6SXNJSlhpK0NFMnlzZ1R2bFBEeWdFOTlyVHFjN1NDMGQy?=
 =?utf-8?B?cHd1NHNIREYyVUJuRERJUm1XS25IUEhZZVE2RlVEaUlyTlVUMGVxbmg0N3l3?=
 =?utf-8?B?eXV3UlJGU3k4RlE1S0hjQ2NEZmxVWEpZNyt2QThaSG82bTVmZ3ptODN0aXQ3?=
 =?utf-8?B?NjBZaDRVS2hldUpRTTlSbVRPSFRtQWlyVkZremhtU0hJQ0JTT0VEc3I4VWFX?=
 =?utf-8?B?bThUQXVwMjA0djdqV1M5VHArc3k4OUxmWTNaWmVxR3NEVE5ReEJTZWZOUklR?=
 =?utf-8?B?QXR1c2MzR1puRFExWmM4WU9GUUhZM1VQbjV4Rjc2TzJEVVh2U0t5R0kyb2Zx?=
 =?utf-8?B?dkRiNjdvR0xibWpDRTFRZGVkTzhoZmRzWDBvVTFTVmNZZ2NIdHN5SGtkbCtR?=
 =?utf-8?B?UkxQbWJmMGhPR0VvMlJhdXU5RlNQWFhNdzJ6eEhqRndEYmpPUVpPOTZmQlhV?=
 =?utf-8?B?ODFNZUdUZ1hNMzN2eHoveW1nUGNYRU8zZWhvUFZBVDhEVkt6VWNhVHhKTVV3?=
 =?utf-8?B?Y3AvK2p5TEh1dWpjVDNYb2NoRlNydTY3MEIzTHU5bFZPZWlXY0MwZFhaRFhn?=
 =?utf-8?B?MWs1L014cmtMdFg4REdsbFJSbml1VVpvSERBMGpWZDFRMmgrSjhNQXhmaUZu?=
 =?utf-8?B?MjF3c2J3UXpCKzZuVjUrd3M0dEttUHJjektsQ3JLTDdPY2VHanhJVHFZMDJB?=
 =?utf-8?B?UnIrNGk1QjMvZUNkcVVzRzBUZm9lc3loamFJVzIxUzV6b3h4MVJ1MW9kSjFa?=
 =?utf-8?B?aXU3cHczbEZnTk5haEJXYVVuZ3BNTVYxYUwremlhWUxGK3NXZktPb3VMalBz?=
 =?utf-8?B?UFNGZTJWcmYvd2dzeUowUEtKNkRFTlp3T0FDc2cxckRmZzh4YmJUZ0VDM2VD?=
 =?utf-8?B?alF5MXZlY3BxRE9Xa0N0NTlDekxhYkdGTjRJWDI0cElMTUJIbUZ5VEVMNFFx?=
 =?utf-8?B?VEhoUDUwZTZTK2xsb2ZBR2czMEE5d20yNWJjaFVnSnhwTlFabUgwZXBId1A5?=
 =?utf-8?B?Vjk2cUs0MVVQdU5HSENLaWkyZFdNODAwSzZLaHpwTW5reFYwRjRlb0krdEVn?=
 =?utf-8?B?R1h0NnR1bEh2bTIwNDBRZnUvV2FvSEN0KysybWdLZ3dpMVhEQjRpYVh3N3ht?=
 =?utf-8?B?Vi9kK1R1U01icXdob21XdkpiUVFMaHc4ODVDclVYU0lucHJvdmNNZVJCNTgw?=
 =?utf-8?B?dEVXZ1lXSm5oQkdPL3VEM0x5QXh3ejZwZXc4R2UxZGY4WjJRRzhiek51dFlM?=
 =?utf-8?B?cXNxMWZLc0FLKzFnSHlTU0R6QmMrUDhRT1UzOE5WVndBRkxVc3VIM0VCUk5W?=
 =?utf-8?B?YlAyeHZYSFIyVFFHdFltVUlRb2JrU1pFMXgrNnYzOFdQZHduVXhEdmJSaEtQ?=
 =?utf-8?B?cTJNbWtRSEcyM0JUVGk0MUhnUElVS2VpOUNJRzBnNEtkRWJUbFQ2YzRVeGJ1?=
 =?utf-8?B?UVNVTFFsQUxKWVJkZUExa1V3eTgzM25tbzRtMDZ0UVgvam5TbCtoc0JaZmEw?=
 =?utf-8?B?T0JWcHhMUnpwaVVYMEJXR3lqVjk0L28xUllMbUZXQVNZdWFNL25HVjlmVjVo?=
 =?utf-8?B?MlVNVC96V0VZc0JmSGJoQzZsKzViMktGZk9CejNPU0NqOGxEMWR3YkZMUHoy?=
 =?utf-8?B?R1E9PQ==?=
X-MS-Exchange-CrossTenant-Network-Message-Id: 175154f4-fe95-41f4-c992-08dba99dea61
X-MS-Exchange-CrossTenant-AuthSource: PH7PR11MB5984.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 30 Aug 2023 21:13:11.1711
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: bWi/al5na5PvvCa9NlmNHXACr1Hx9ErCLLaGpvw1kf7GF2KcP11DJlyyF81SCvlaX8bGOOIYMaSF7W3rnru+Ww==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: IA0PR11MB7307
X-OriginatorOrg: intel.com
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org



On 8/28/23 22:20, Ira Weiny wrote:
> Both regions and decoders will need a new mode to reflect the new type
> of partition they are targeting on a device.  Regions reflect a dynamic
> capacity type which may point to different Dynamic Capacity (DC)
> Regions.  Decoder mode reflects a specific DC Region.
> 
> Define the new modes to use in subsequent patches and the helper
> functions associated with them.
> 
> Co-developed-by: Navneet Singh <navneet.singh@intel.com>
> Signed-off-by: Navneet Singh <navneet.singh@intel.com>
> Signed-off-by: Ira Weiny <ira.weiny@intel.com>
> 

Reviewed-by: Dave Jiang <dave.jiang@intel.com>
> ---
> Changes for v2:
> [iweiny: split out from: Add dynamic capacity cxl region support.]
> ---
>   drivers/cxl/core/region.c |  4 ++++
>   drivers/cxl/cxl.h         | 23 +++++++++++++++++++++++
>   2 files changed, 27 insertions(+)
> 
> diff --git a/drivers/cxl/core/region.c b/drivers/cxl/core/region.c
> index 75041903b72c..69af1354bc5b 100644
> --- a/drivers/cxl/core/region.c
> +++ b/drivers/cxl/core/region.c
> @@ -1772,6 +1772,8 @@ static bool cxl_modes_compatible(enum cxl_region_mode rmode,
>   		return true;
>   	if (rmode == CXL_REGION_PMEM && dmode == CXL_DECODER_PMEM)
>   		return true;
> +	if (rmode == CXL_REGION_DC && cxl_decoder_mode_is_dc(dmode))
> +		return true;
>   
>   	return false;
>   }
> @@ -2912,6 +2914,8 @@ cxl_decoder_to_region_mode(enum cxl_decoder_mode mode)
>   		return CXL_REGION_PMEM;
>   	case CXL_DECODER_DEAD:
>   		return CXL_REGION_DEAD;
> +	case CXL_DECODER_DC0 ... CXL_DECODER_DC7:
> +		return CXL_REGION_DC;
>   	case CXL_DECODER_MIXED:
>   	default:
>   		return CXL_REGION_MIXED;
> diff --git a/drivers/cxl/cxl.h b/drivers/cxl/cxl.h
> index ed282dcd5cf5..d41f3f14fbe3 100644
> --- a/drivers/cxl/cxl.h
> +++ b/drivers/cxl/cxl.h
> @@ -356,6 +356,14 @@ enum cxl_decoder_mode {
>   	CXL_DECODER_NONE,
>   	CXL_DECODER_RAM,
>   	CXL_DECODER_PMEM,
> +	CXL_DECODER_DC0,
> +	CXL_DECODER_DC1,
> +	CXL_DECODER_DC2,
> +	CXL_DECODER_DC3,
> +	CXL_DECODER_DC4,
> +	CXL_DECODER_DC5,
> +	CXL_DECODER_DC6,
> +	CXL_DECODER_DC7,
>   	CXL_DECODER_MIXED,
>   	CXL_DECODER_DEAD,
>   };
> @@ -366,6 +374,14 @@ static inline const char *cxl_decoder_mode_name(enum cxl_decoder_mode mode)
>   		[CXL_DECODER_NONE] = "none",
>   		[CXL_DECODER_RAM] = "ram",
>   		[CXL_DECODER_PMEM] = "pmem",
> +		[CXL_DECODER_DC0] = "dc0",
> +		[CXL_DECODER_DC1] = "dc1",
> +		[CXL_DECODER_DC2] = "dc2",
> +		[CXL_DECODER_DC3] = "dc3",
> +		[CXL_DECODER_DC4] = "dc4",
> +		[CXL_DECODER_DC5] = "dc5",
> +		[CXL_DECODER_DC6] = "dc6",
> +		[CXL_DECODER_DC7] = "dc7",
>   		[CXL_DECODER_MIXED] = "mixed",
>   	};
>   
> @@ -374,10 +390,16 @@ static inline const char *cxl_decoder_mode_name(enum cxl_decoder_mode mode)
>   	return "mixed";
>   }
>   
> +static inline bool cxl_decoder_mode_is_dc(enum cxl_decoder_mode mode)
> +{
> +	return (mode >= CXL_DECODER_DC0 && mode <= CXL_DECODER_DC7);
> +}
> +
>   enum cxl_region_mode {
>   	CXL_REGION_NONE,
>   	CXL_REGION_RAM,
>   	CXL_REGION_PMEM,
> +	CXL_REGION_DC,
>   	CXL_REGION_MIXED,
>   	CXL_REGION_DEAD,
>   };
> @@ -388,6 +410,7 @@ static inline const char *cxl_region_mode_name(enum cxl_region_mode mode)
>   		[CXL_REGION_NONE] = "none",
>   		[CXL_REGION_RAM] = "ram",
>   		[CXL_REGION_PMEM] = "pmem",
> +		[CXL_REGION_DC] = "dc",
>   		[CXL_REGION_MIXED] = "mixed",
>   	};
>   
> 

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 67258C83F14
	for <linux-cxl@archiver.kernel.org>; Wed, 30 Aug 2023 21:08:26 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S240117AbjH3VI1 (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Wed, 30 Aug 2023 17:08:27 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:38200 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S240139AbjH3VI0 (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Wed, 30 Aug 2023 17:08:26 -0400
Received: from mgamail.intel.com (mgamail.intel.com [134.134.136.100])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id E5A5C19A;
        Wed, 30 Aug 2023 14:07:55 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1693429676; x=1724965676;
  h=message-id:date:subject:to:cc:references:from:
   in-reply-to:content-transfer-encoding:mime-version;
  bh=tsS9bIzJcxJb50adGhYHX9rnG7+/pisE2wdkcB1UCOw=;
  b=nNsKhA6/oWkLuQwDqbST8MzDEvmvt4H1dUZp86eNrk0x4LEdWQDVddnf
   vO3HlEKJhbD8750Q4My2vM/MUEjCW0A3RqC3dp2HI+DwMDKu6yjf8eHIf
   nSGMie3IJy1xGJCQwZhFz/wqB5THE0qXlJN9EhsVt5ChQ/6V9IafFQ7Pu
   pd/dR4TBY7GeDWbnxxXj78CIL6d1MSulcFYnRfcquIk7fDaDJe+L0PoEe
   mE8/UjjD1DgTewycmt+pP524uWJdH/9vihMJsfojs3htKd4e5boXIK+/i
   2/pQuhdBnI4wctUe5I1VIiGBlA33Vg/am19kKQjNMOwPobk7vX2u8J//4
   Q==;
X-IronPort-AV: E=McAfee;i="6600,9927,10818"; a="442105639"
X-IronPort-AV: E=Sophos;i="6.02,214,1688454000"; 
   d="scan'208";a="442105639"
Received: from fmsmga005.fm.intel.com ([10.253.24.32])
  by orsmga105.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 30 Aug 2023 13:33:42 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10818"; a="1069958991"
X-IronPort-AV: E=Sophos;i="6.02,214,1688454000"; 
   d="scan'208";a="1069958991"
Received: from fmsmsx602.amr.corp.intel.com ([10.18.126.82])
  by fmsmga005.fm.intel.com with ESMTP; 30 Aug 2023 13:33:42 -0700
Received: from fmsmsx601.amr.corp.intel.com (10.18.126.81) by
 fmsmsx602.amr.corp.intel.com (10.18.126.82) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27; Wed, 30 Aug 2023 13:33:41 -0700
Received: from fmsedg602.ED.cps.intel.com (10.1.192.136) by
 fmsmsx601.amr.corp.intel.com (10.18.126.81) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27 via Frontend Transport; Wed, 30 Aug 2023 13:33:41 -0700
Received: from NAM11-CO1-obe.outbound.protection.outlook.com (104.47.56.176)
 by edgegateway.intel.com (192.55.55.71) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.27; Wed, 30 Aug 2023 13:33:41 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=DO1cREI9YgtUjhWmCC8mAzs9XBimh0nTHcQ4typ3fcn7eEfVuoObeNm6kzq9qw7cH2XaEV+q+qn7kWlATQdBSKX1uel9ne2UaH7i9VG+c4hGFM5nox+JUgMsq1miBeraeAtvdFYhpqXwS7N6uUug14LZsvwlJF5yYlAfvH35rhy2Vtul0e4/sNvlk9YuTDlT32eHOSEwRXtlFVi9NAUtP4Zx8xM37oBoh6zrY4wenrfplyg+7q4YF3QGsok4bOQsmLZZ8H7q/fyrKQlJVn/UrKjnX87KoX7Fyr5FkHdL0FuSXdxKw5drWwhu6Tg5WAw02CF343QyWZ6lyPwSGwJQ+w==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=9Qw8XKYBOj/45MMUgsgvr7sGtQVX9ZNK2+izjLrSypA=;
 b=K+1KhEj0FOLZPEowvtI1BaB02lLepfQR9cPqlNqEDFKvMN+fwaGm0vm/41N9OmA4G/Je7bH/8p6/ybFcidJMA3Si6N+Dh33kSr5oeE+FUAV7dfDNVWstBiMHErzhMtyY8/7eU5I1viwyQdHrdxNBWt6Bn8tQMGp96+Hv3QR3NcFGAHY6JHgufwbzFT+d2RmNHzRjQjL6t0vk5MqtgiED+tr3ME47QYnggXscTAkRXIxn4obwNcG2EiJm+kQenCxjs3rOk3qjbCnFI8oaGanpN6Pz2wGac6gr9/BObGMVJ4zKSItxaIX1wrwCvz/6wdPYalAUtg23rmiPixzpdJgTrA==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from PH7PR11MB5984.namprd11.prod.outlook.com (2603:10b6:510:1e3::15)
 by PH8PR11MB8015.namprd11.prod.outlook.com (2603:10b6:510:23b::18) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.6699.30; Wed, 30 Aug
 2023 20:33:40 +0000
Received: from PH7PR11MB5984.namprd11.prod.outlook.com
 ([fe80::9563:9642:bbde:293f]) by PH7PR11MB5984.namprd11.prod.outlook.com
 ([fe80::9563:9642:bbde:293f%7]) with mapi id 15.20.6699.034; Wed, 30 Aug 2023
 20:33:40 +0000
Message-ID: <226c2ec0-ddd3-b3e1-c178-896216f95d24@intel.com>
Date: Wed, 30 Aug 2023 13:33:36 -0700
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101
 Betterbird/102.13.0
Subject: Re: [PATCH RFC v2 02/18] cxl/mbox: Flag support for Dynamic Capacity
 Devices (DCD)
To: Ira Weiny <ira.weiny@intel.com>,
        Dan Williams <dan.j.williams@intel.com>
CC: Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Alison Schofield <alison.schofield@intel.com>,
        "Vishal Verma" <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
 <20230604-dcd-type2-upstream-v2-2-f740c47e7916@intel.com>
Content-Language: en-US
From: Dave Jiang <dave.jiang@intel.com>
In-Reply-To: <20230604-dcd-type2-upstream-v2-2-f740c47e7916@intel.com>
Content-Type: text/plain; charset="UTF-8"; format=flowed
Content-Transfer-Encoding: 7bit
X-ClientProxiedBy: SJ0PR03CA0035.namprd03.prod.outlook.com
 (2603:10b6:a03:33e::10) To PH7PR11MB5984.namprd11.prod.outlook.com
 (2603:10b6:510:1e3::15)
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: PH7PR11MB5984:EE_|PH8PR11MB8015:EE_
X-MS-Office365-Filtering-Correlation-Id: 0bd65272-2736-4bea-e093-08dba9986517
X-LD-Processed: 46c98d88-e344-4ed4-8496-4ed7712e255d,ExtAddr
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;
X-Microsoft-Antispam-Message-Info: /v+Lczkf9Wjpd6AOmGEScPPtkykMMA/WsPWxNQeh2SeUiMmu02PePYX4SCYe/m1cWWndnjUBqT8rSAAkCiTvQH0ie19xC8abA3JWgD0O1d19ohipwlMREXDWRuQqkbsm7PAjrdMlclGA9p4Bban7A3ouNPANe8uo2yaLLFCu0ofDRkxpSOqY87w9asukK6vtJJgjvJavczEPbbXcoEPD6ddiqIydTDYqBQto/1BtVaaOXEJcaTB3L+zx92P6LNllY9syJAynySQGJxV7231X86z7MeNZfCwCHiJEp8r8sgcbTiGj63ymNSP0kICBQxsWi0QxC4wabI4+fwqj1pjQlZQXH2cGH7Ue81YAYgr8OiFi432kvcjh+f/r9DcMtE+Wa2bXxS8/K6Sp+X9U3BOHE5A+7T3yE5YAu4svsUK0RU2bSBjzVn822yGrhqs3DjBjeZr/S6oGe4HLK/Sbgm+eeLKaI57EHojg+mD0Vt1QpAnOOFHMKL12dRodpHv9+S7qIs6koQgy2i0wVzufxmmJmV2b+dHyWTfcN47NyZnWS+xMVQiw19moq/+UK0wZxTkwfcdEDCy1jV+mbG0SC72XmNH7d5F+0tSitK0R58SDBLav6VEHai2KhK/oYvVUEkyx5LJdwDumNx/7jHecUI/NzQ==
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:PH7PR11MB5984.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230031)(376002)(366004)(396003)(346002)(136003)(39860400002)(186009)(1800799009)(451199024)(8936002)(6666004)(66946007)(31686004)(478600001)(110136005)(53546011)(66476007)(6506007)(54906003)(66556008)(6486002)(6636002)(38100700002)(316002)(82960400001)(41300700001)(6512007)(26005)(44832011)(5660300002)(36756003)(2616005)(8676002)(31696002)(2906002)(86362001)(83380400001)(4326008)(45980500001)(43740500002);DIR:OUT;SFP:1102;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?utf-8?B?c3Z0b1RmQzdIeHMrbXdDQTFDTHlZSkxld2xxSVpOTjVydzRCUXBXZjhVNlBB?=
 =?utf-8?B?MDRLbVRUNU9UMEhwV0VWUE9wb3BHZ01POXRuRVBobSs4Tlc2VHFEUzl2TWI1?=
 =?utf-8?B?allocDNqaWV4TUlYRjJaLysrRXg3ZW8xYUF5VmVSTUJQMVBsdS9zQ1UvMXJ3?=
 =?utf-8?B?KzRuMU5SUEFhclRoaEdvR2lsUFRFckR2dDgyajlRNllIRjV4aTc5TktVSENM?=
 =?utf-8?B?c3N0TW4rQ2xzR1JEZWpHd0lCaFgvblVmSHdqY01uTmlPeXMyMVBzNVNOMElI?=
 =?utf-8?B?NEtZS1ZXdVVDNmxFREEvVU5pS3pRSVRWeFp3SCtSclhHNnNORERTa1Y1RHFl?=
 =?utf-8?B?bGlqMDVydkNXOVVrd25MWDd3OW9TdTRXeWdVZ3pBQ2ExWk5tVzJ6dmRwN0Ur?=
 =?utf-8?B?UjFHNHpESHByTjlLMVFZc0ZUM1RTR2xLTDcxYi9Eby82TThVU0RhQ0VUMlRp?=
 =?utf-8?B?alhuL0cyOTFsK2xreFhudW9WeHZKQm5oSzBNMUFRUlFCY0dLS0t1SkdKUm56?=
 =?utf-8?B?dVAwcWI2Uk01UU9Tak9CVDZ0ZDhRWGhad016ZUhPRmE2MmZNQWF0cndybVdw?=
 =?utf-8?B?V3JvblQ2Y3RqVlVJUFRIdG85UDRXKzlka2FpRXF2ZXVHMUFaRzd6VWlyekJY?=
 =?utf-8?B?Z1pPbGRyT3plZ2F1L2ZEWFBpbG9GcXc2dURtWFpodHFNNjVKbUZuQlBqcE1X?=
 =?utf-8?B?cVppQi94dm1jS0hOUnk5VjZYUlBBREdvMjBUSGdoc1BleG05bElTdU9pZmxZ?=
 =?utf-8?B?bTNXS0YxMmFBNC9FQzJHeHBNcWhLNVJ1cnJTUmh1TG5QYk9VWXpudE1nYTBu?=
 =?utf-8?B?S0lrSE5UKzhPUnNZdXBVTWZWenBFU01zNmJEb25oV2VGQ25vajB5b1hzWFl1?=
 =?utf-8?B?aittQkxHUkkxR2thck9rQm5OZ25EWFVJV1haOTZDRzdWVXJYalUzS29SNTdT?=
 =?utf-8?B?dVJ5TmhIeHRraUpKTjl2V1IyWmE0M2FCK3hqdERZV0kvN1lNRU9jeHROd3R1?=
 =?utf-8?B?UzJlTjlWaTNDR3VRa2lUNnQvTXZmMTI4VjZqVmxUbWRFNmg3bGJEMUVvYy9U?=
 =?utf-8?B?VEwyK2JldEJZNzRTY0xGejdDT1UvV1dvSzI4QVJqU2lSaUxDNjlkOGNtQzFh?=
 =?utf-8?B?eHJYZEJZTysvU24xVUlHSFk5cjRjTkVONndiZ2pUYUFoL0NFOUhmNHNIVXJH?=
 =?utf-8?B?YUU1ZzFLdEhkRXh6dmJyYzNjNEtQNzVYSHVDaHppTDdCd2VLSzlKb3dhWU53?=
 =?utf-8?B?dW5odFZKM3dkanZIbXU3WmZIRlpubW5KNnBja1JwQk50eW5UeDk1Y3RnUlIz?=
 =?utf-8?B?eDVFRWQ3bUlSeTVIaUpoSVNkY3E0T3dlWmhxU2h2d2lhOVlVMGl1d041QmdJ?=
 =?utf-8?B?Qm52KzczcTNPMzZxMmFXUnlBajJTNmhESjFFNUh5T3lkT0dmblNoTHppTGp4?=
 =?utf-8?B?M3pSamFpSG9tWmlFb3MxZ0hZcm56eDcwWmQ5cTBlTk1DZ1JpT0tuOEh4WEZG?=
 =?utf-8?B?OUFrU0ladjgwZXgrMXdjNWw3cDEyQkhhR241M3p3WHFtd0FxYjZydU1JMFpH?=
 =?utf-8?B?c01OMUVJSXZ3ZWw5TTROc0hiQzYvQmhIeEdzK3Q0Mmh0TWtWMjhFMFM0RHlR?=
 =?utf-8?B?SWJrOW5Zc0p5Vld0MFBTd1FUUXg2Q0g2RW9WUFJIMkJIZnk0TE9pblpoRzVm?=
 =?utf-8?B?ZnZEbGNpTkJtWUtsQnRpblNDOFR3YVdUaGFVZ2pidXo4K1NLZndQK2FrSzEy?=
 =?utf-8?B?YzArcmN0NFFOU2M2NUZzdmlOYkl0bXpObTUxMGQwY2YrUnpXUGczNUR5clFC?=
 =?utf-8?B?SWFvdndEemlPdDBmcGVIVkRra1d3UlZyM25sckVndG9takx1TXVXRnpDMkh3?=
 =?utf-8?B?TFpHN1FrU2Jqa0tpUzJ2MFdubUtuV1FsejNsa3NoVGFucUcvMzN3OCtFem8y?=
 =?utf-8?B?WTRPd1ptOTE4K1g5SU9hRmMrdGZDWlVrempSVnZFRUdyNENOTTZ2OGl3SXZG?=
 =?utf-8?B?UE9vNU9mcU13QVl3aXNMVzkybVkxaUZWeEhQaVUvYUxkdWxNRTViaHpmZUpM?=
 =?utf-8?B?bUZkenFJdDhDRVQ0L0l4SXc0SCtoMTkyc1FraDluRnB2VWZzOFcwTGhIL2I3?=
 =?utf-8?B?VDhYZkZ4WUxFbm5EcXMzTms5aHVQZm93NDlDd1N3NHlXc2JCd2I0Y1R1TTFh?=
 =?utf-8?B?Snc9PQ==?=
X-MS-Exchange-CrossTenant-Network-Message-Id: 0bd65272-2736-4bea-e093-08dba9986517
X-MS-Exchange-CrossTenant-AuthSource: PH7PR11MB5984.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 30 Aug 2023 20:33:40.0358
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: MVNEACqxDltRR3yQGcF3clluKmPq3KiaWQlzqWTNc25rjRkeODzVB/Sd+twpcWzg1vmsK8elRZh9wl+PaNaB1A==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: PH8PR11MB8015
X-OriginatorOrg: intel.com
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org



On 8/28/23 22:20, Ira Weiny wrote:
> Per the CXL 3.0 specification software must check the Command Effects
> Log (CEL) to know if a device supports DC.  If the device does support
> DC the specifics of the DC Regions (0-7) are read through the mailbox.
> 
> Flag DC Device (DCD) commands in a device if they are supported.
> Subsequent patches will key off these bits to configure a DCD.
> 
> Co-developed-by: Navneet Singh <navneet.singh@intel.com>
> Signed-off-by: Navneet Singh <navneet.singh@intel.com>
> Signed-off-by: Ira Weiny <ira.weiny@intel.com>

Reviewed-by: Dave Jiang <dave.jiang@intel.com>
> 
> ---
> Changes for v2
> [iweiny: new patch]
> ---
>   drivers/cxl/core/mbox.c | 38 +++++++++++++++++++++++++++++++++++---
>   drivers/cxl/cxlmem.h    | 15 +++++++++++++++
>   2 files changed, 50 insertions(+), 3 deletions(-)
> 
> diff --git a/drivers/cxl/core/mbox.c b/drivers/cxl/core/mbox.c
> index f052d5f174ee..554ec97a7c39 100644
> --- a/drivers/cxl/core/mbox.c
> +++ b/drivers/cxl/core/mbox.c
> @@ -111,6 +111,34 @@ static u8 security_command_sets[] = {
>   	0x46, /* Security Passthrough */
>   };
>   
> +static bool cxl_is_dcd_command(u16 opcode)
> +{
> +#define CXL_MBOX_OP_DCD_CMDS 0x48
> +
> +	return (opcode >> 8) == CXL_MBOX_OP_DCD_CMDS;
> +}
> +
> +static void cxl_set_dcd_cmd_enabled(struct cxl_memdev_state *mds,
> +					u16 opcode)
> +{
> +	switch (opcode) {
> +	case CXL_MBOX_OP_GET_DC_CONFIG:
> +		set_bit(CXL_DCD_ENABLED_GET_CONFIG, mds->dcd_cmds);
> +		break;
> +	case CXL_MBOX_OP_GET_DC_EXTENT_LIST:
> +		set_bit(CXL_DCD_ENABLED_GET_EXTENT_LIST, mds->dcd_cmds);
> +		break;
> +	case CXL_MBOX_OP_ADD_DC_RESPONSE:
> +		set_bit(CXL_DCD_ENABLED_ADD_RESPONSE, mds->dcd_cmds);
> +		break;
> +	case CXL_MBOX_OP_RELEASE_DC:
> +		set_bit(CXL_DCD_ENABLED_RELEASE, mds->dcd_cmds);
> +		break;
> +	default:
> +		break;
> +	}
> +}
> +
>   static bool cxl_is_security_command(u16 opcode)
>   {
>   	int i;
> @@ -677,9 +705,10 @@ static void cxl_walk_cel(struct cxl_memdev_state *mds, size_t size, u8 *cel)
>   		u16 opcode = le16_to_cpu(cel_entry[i].opcode);
>   		struct cxl_mem_command *cmd = cxl_mem_find_command(opcode);
>   
> -		if (!cmd && !cxl_is_poison_command(opcode)) {
> -			dev_dbg(dev,
> -				"Opcode 0x%04x unsupported by driver\n", opcode);
> +		if (!cmd && !cxl_is_poison_command(opcode) &&
> +		    !cxl_is_dcd_command(opcode)) {
> +			dev_dbg(dev, "Opcode 0x%04x unsupported by driver\n",
> +				opcode);
>   			continue;
>   		}
>   
> @@ -689,6 +718,9 @@ static void cxl_walk_cel(struct cxl_memdev_state *mds, size_t size, u8 *cel)
>   		if (cxl_is_poison_command(opcode))
>   			cxl_set_poison_cmd_enabled(&mds->poison, opcode);
>   
> +		if (cxl_is_dcd_command(opcode))
> +			cxl_set_dcd_cmd_enabled(mds, opcode);
> +
>   		dev_dbg(dev, "Opcode 0x%04x enabled\n", opcode);
>   	}
>   }
> diff --git a/drivers/cxl/cxlmem.h b/drivers/cxl/cxlmem.h
> index adfba72445fc..5f2e65204bf9 100644
> --- a/drivers/cxl/cxlmem.h
> +++ b/drivers/cxl/cxlmem.h
> @@ -247,6 +247,15 @@ struct cxl_event_state {
>   	struct mutex log_lock;
>   };
>   
> +/* Device enabled DCD commands */
> +enum dcd_cmd_enabled_bits {
> +	CXL_DCD_ENABLED_GET_CONFIG,
> +	CXL_DCD_ENABLED_GET_EXTENT_LIST,
> +	CXL_DCD_ENABLED_ADD_RESPONSE,
> +	CXL_DCD_ENABLED_RELEASE,
> +	CXL_DCD_ENABLED_MAX
> +};
> +
>   /* Device enabled poison commands */
>   enum poison_cmd_enabled_bits {
>   	CXL_POISON_ENABLED_LIST,
> @@ -436,6 +445,7 @@ struct cxl_dev_state {
>    *                (CXL 2.0 8.2.9.5.1.1 Identify Memory Device)
>    * @mbox_mutex: Mutex to synchronize mailbox access.
>    * @firmware_version: Firmware version for the memory device.
> + * @dcd_cmds: List of DCD commands implemented by memory device
>    * @enabled_cmds: Hardware commands found enabled in CEL.
>    * @exclusive_cmds: Commands that are kernel-internal only
>    * @total_bytes: sum of all possible capacities
> @@ -460,6 +470,7 @@ struct cxl_memdev_state {
>   	size_t lsa_size;
>   	struct mutex mbox_mutex; /* Protects device mailbox and firmware */
>   	char firmware_version[0x10];
> +	DECLARE_BITMAP(dcd_cmds, CXL_DCD_ENABLED_MAX);
>   	DECLARE_BITMAP(enabled_cmds, CXL_MEM_COMMAND_ID_MAX);
>   	DECLARE_BITMAP(exclusive_cmds, CXL_MEM_COMMAND_ID_MAX);
>   	u64 total_bytes;
> @@ -525,6 +536,10 @@ enum cxl_opcode {
>   	CXL_MBOX_OP_UNLOCK		= 0x4503,
>   	CXL_MBOX_OP_FREEZE_SECURITY	= 0x4504,
>   	CXL_MBOX_OP_PASSPHRASE_SECURE_ERASE	= 0x4505,
> +	CXL_MBOX_OP_GET_DC_CONFIG	= 0x4800,
> +	CXL_MBOX_OP_GET_DC_EXTENT_LIST	= 0x4801,
> +	CXL_MBOX_OP_ADD_DC_RESPONSE	= 0x4802,
> +	CXL_MBOX_OP_RELEASE_DC		= 0x4803,
>   	CXL_MBOX_OP_MAX			= 0x10000
>   };
>   
> 

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id D4D06C83F14
	for <linux-cxl@archiver.kernel.org>; Wed, 30 Aug 2023 21:04:04 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S238834AbjH3VEG (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Wed, 30 Aug 2023 17:04:06 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:51206 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S235097AbjH3VEF (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Wed, 30 Aug 2023 17:04:05 -0400
Received: from mgamail.intel.com (mgamail.intel.com [134.134.136.31])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 93EF8CE0;
        Wed, 30 Aug 2023 14:03:29 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1693429409; x=1724965409;
  h=message-id:date:subject:to:cc:references:from:
   in-reply-to:content-transfer-encoding:mime-version;
  bh=7gYciZ+Y0R3qCoFLLW1Lh4CIFCKOrZtZMtaCmKI6wt8=;
  b=nrFfTGcqAeqXEi1xRqxBEupJ9uy6UTRvH7ku51oGf15WKqpvY+xwZYOc
   kOVwqGLFhCBedElO+b3+r8ogi68l0izxerwzdIbFqXTcTCnxsDy+NT+lS
   ujPO/rUz44CY1XfgE26+ME8CnIVOgHbAVKEXh6pLKaHS5yVn19W75BbP+
   IJmQcAwy+D+9cgDaNtZCqUnIx2sXJFLG72SIaqRYXEfYjt4kWl86R2NSB
   x3veEAheDWrqZDOduuPZIQFyS42BKbGUUIjPcP6aANI5+OTNZ4zSM6zTf
   l+2qkPgIbq8BFPB+6CsWIsZUEhxOg8EzLIzh2dNNfYbONS/7cLACKkl8s
   g==;
X-IronPort-AV: E=McAfee;i="6600,9927,10818"; a="439698948"
X-IronPort-AV: E=Sophos;i="6.02,214,1688454000"; 
   d="scan'208";a="439698948"
Received: from fmsmga005.fm.intel.com ([10.253.24.32])
  by orsmga104.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 30 Aug 2023 14:02:00 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10818"; a="1069964240"
X-IronPort-AV: E=Sophos;i="6.02,214,1688454000"; 
   d="scan'208";a="1069964240"
Received: from fmsmsx601.amr.corp.intel.com ([10.18.126.81])
  by fmsmga005.fm.intel.com with ESMTP; 30 Aug 2023 14:01:57 -0700
Received: from fmsmsx610.amr.corp.intel.com (10.18.126.90) by
 fmsmsx601.amr.corp.intel.com (10.18.126.81) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27; Wed, 30 Aug 2023 14:01:57 -0700
Received: from fmsedg602.ED.cps.intel.com (10.1.192.136) by
 fmsmsx610.amr.corp.intel.com (10.18.126.90) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27 via Frontend Transport; Wed, 30 Aug 2023 14:01:57 -0700
Received: from NAM11-BN8-obe.outbound.protection.outlook.com (104.47.58.168)
 by edgegateway.intel.com (192.55.55.71) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.27; Wed, 30 Aug 2023 14:01:57 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=La18u/kTPFzc7ptlCN7ppjtQceumUogTttl7YlEYpzOCqId9usFqjJ+nBfOEEl+wdfCcMw3NZajiaZFCzm0t/7eKHcIyfWKKoG4W+DrpIJZBgpLWzUvWxZd3jxgn1tI07lsTvo5cdatLHjM4pKjSJK8TSg6FU03Hqdewkyxbj262zOsZkVjmeSmM99qQzdknpa1RfvKUKxI9pzhsL4ZCPbFmkxMPWhWkECJxT+BIH6ar9cpbdlBd5T2qbxIgw/KcuF4tJQNBznGNHSa8kHSimzJAdmUSYxFphCO3s5DDvPg3wCrX9oVd8Au6FDH1+ez4ig9t4rvKpXGVPNfMa8EMMA==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=bbL2FIQU4DDFRabiYrEf+T5frd+F9XRoeRaZuNGVeZs=;
 b=Gc/UdgFnPFno+uKmtgaIraBuhNgENF0U8lI6tzf3AEX5OCUcKRyj+Vzl4Dn/0ieZ8l64ASOPn7bgkDWGUVHGfmFUWAtNUKFVT8Sz5F7GSnGmVF0zgbRTh386810BuMgV6zqoVpvvIYI2cQ8jGHxQEOF5QtdJ6lX11i4yHhCQRtXnDHo3X6GENh7ttmQdc1MCPePF5z1tZUjOYTI79aRbBroYFykU49KiHYuQvh7BYTeQcoquSL7EH/+9wLw6aWPQ3bGPTj7FoNNe/fH9DPmyZJs+DKMH+vSu/Ft4jl5r+uG9NF0qiUvaIQY/UAONTD4QSbnzwg+YWMeEQpgbXWCj3g==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from PH7PR11MB5984.namprd11.prod.outlook.com (2603:10b6:510:1e3::15)
 by MW4PR11MB5799.namprd11.prod.outlook.com (2603:10b6:303:181::17) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.6699.35; Wed, 30 Aug
 2023 21:01:51 +0000
Received: from PH7PR11MB5984.namprd11.prod.outlook.com
 ([fe80::9563:9642:bbde:293f]) by PH7PR11MB5984.namprd11.prod.outlook.com
 ([fe80::9563:9642:bbde:293f%7]) with mapi id 15.20.6699.034; Wed, 30 Aug 2023
 21:01:51 +0000
Message-ID: <db3bd5d0-640a-b121-f3e7-cfb73dc6c9ff@intel.com>
Date: Wed, 30 Aug 2023 14:01:47 -0700
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101
 Betterbird/102.13.0
Subject: Re: [PATCH RFC v2 03/18] cxl/mem: Read Dynamic capacity configuration
 from the device
To: <ira.weiny@intel.com>, Dan Williams <dan.j.williams@intel.com>
CC: Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Alison Schofield <alison.schofield@intel.com>,
        "Vishal Verma" <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
 <20230604-dcd-type2-upstream-v2-3-f740c47e7916@intel.com>
Content-Language: en-US
From: Dave Jiang <dave.jiang@intel.com>
In-Reply-To: <20230604-dcd-type2-upstream-v2-3-f740c47e7916@intel.com>
Content-Type: text/plain; charset="UTF-8"; format=flowed
Content-Transfer-Encoding: 7bit
X-ClientProxiedBy: SJ0PR03CA0292.namprd03.prod.outlook.com
 (2603:10b6:a03:39e::27) To PH7PR11MB5984.namprd11.prod.outlook.com
 (2603:10b6:510:1e3::15)
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: PH7PR11MB5984:EE_|MW4PR11MB5799:EE_
X-MS-Office365-Filtering-Correlation-Id: b3bfece0-6c42-4493-bf08-08dba99c5546
X-LD-Processed: 46c98d88-e344-4ed4-8496-4ed7712e255d,ExtAddr
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;
X-Microsoft-Antispam-Message-Info: 43s1gX6X3AC/2a0GQKoCI1NJP+VNIKDvjQjQLO+XhW74SHYP/4nsoQ45wJ0JNtyQSYCumuwtlAo/Iw0fpD4BzBIHqe9HxM4TlJfWwxUZ0bIl1x2z0EBL9J5h06AZXfU18nY78aUpbDAk9W5MbQnDQO+AiL2QaU0GJ8MA/I2p+SXXI35Oy3sdG4jknSQd0Q8CZysxgIMg7dlOKJpsBgCHT/szWX1Hk7FVuiIkNA4mA4xLrwpPu9svHoVFSUZzoARYK0Zdhhgs9ym9CNg5xl507WXpmoFVROW+mpPfOZmFCCEDojB7aL2xVuWgqQyysmIy7xxPpqt7mKUGqT3d0Tbp/RUggHLJTmQes8Gdv0oyvpmnaYOShAlvqSRLz9vsczn6dji58V5r72XtdKB7bSlYp5VdnnFVaiQZIk7XH/UzpOOHKc8lvvrRwx90bXkLvEKlpvvv9d0fgMIGNPYySauvc6QH1QO6pe9Hv0Ol/yu4FY0BfkVl/f29Weg4hdLRh7tp5z9Z+QmYgjDgppeFPXXpwpiE8KCsDBFYqOVBmtfAL8pRNXfPcFcMdGWX/32rsx3LN4heABahTqoucOumhZSfGxNCpfCoVa84nK83Kgwau6FUOLKqz3kg1Q9AflWI0nkTuTxjhb5PtHTqEgaSHOQlspDHt/xZmahjPSgomnTkBm5VWao1Nq1+aLLROuRJoNfg
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:PH7PR11MB5984.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230031)(376002)(136003)(346002)(39860400002)(396003)(366004)(1800799009)(451199024)(186009)(31686004)(6512007)(6666004)(6486002)(6506007)(86362001)(36756003)(38100700002)(31696002)(82960400001)(2616005)(478600001)(30864003)(83380400001)(53546011)(26005)(4326008)(8936002)(54906003)(5660300002)(66476007)(66946007)(44832011)(2906002)(6862004)(6636002)(41300700001)(37006003)(66556008)(8676002)(316002)(461764006)(43740500002)(45980500001);DIR:OUT;SFP:1102;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?utf-8?B?dU8wQ2prZzllTXozL1REaVd1S0N1WjBUSVlxV252REk5SXRTVmpCMGtXTUJ6?=
 =?utf-8?B?azZXMWtYSGozVzVKVmZVbVpzbmxXVnlOdk1aSkRqUTkzZHdmYlNwL1dBbWN4?=
 =?utf-8?B?YXFSMG8wNlY5SjJZSjBoZm9jL0Y0TWNaQm16ZEtTcGc4SkRlcVc2Y0dEejRp?=
 =?utf-8?B?SEZMVGhNeTBIZWZtSVpBcE9hZ29MSlgxT0JCaWpkWHZLMUhvRXg0RXR3b1Bx?=
 =?utf-8?B?Snk0NmFDL2w4VGgvSmJXazQyN2tnM3NGQXlVT1Zuek9nMGc3OUVDTDZtd1pM?=
 =?utf-8?B?RFlYSTZoZWlJeGRmWWxZQzhidm9JemN1aVE1OFoxVjBiQnpSRHN2V3BTWmJp?=
 =?utf-8?B?d1FJYmVHaisrMW1pWk90S21FUG9MTnNlRUtjellxcGN3WWhaQitvWHZrNC9t?=
 =?utf-8?B?aXpRbmpqSmJFbkFLMGc0SjdudWNka203NUNoRURyS2lKRXRsZEcxSHZTMGoz?=
 =?utf-8?B?Y3VSZHVxbXFlWG1DdmJhbjBkYkVta3dTSUZJTFdxbmhYcmoyOGdkZE9RRytE?=
 =?utf-8?B?ajZuc3E5YVQ1Sm1obkdsdWxackM4SkNkYjRSWmRreHlMaVFNZHA3Z2FyeUp5?=
 =?utf-8?B?L1FYR0VKblMzbzlwanIrWURUMFF0Nmg5eXRTYnA5NzF5RjA0WGp0UUFWaTU3?=
 =?utf-8?B?cmZwMHBmSTVmTU9SUUh1aDQxVWdlNnlBU3BuYVVQNlFxYmF4Q2dmVEJUZXhL?=
 =?utf-8?B?NDVmZXNEWmExY05PUmFEVnA0dFM4SWgyM1o0YUtsZkhGNmFmeFd5SFBPdHIv?=
 =?utf-8?B?Q29GZi93ZHVuYTNpL2N6d0JHck9JS2RFbyszc3d5cU9oM3RIR0RsNUduSThX?=
 =?utf-8?B?ejBmOURyWmtWd0o1SEZqWTdUM0lFSkQ1YUtGN3FtVVN2ejNMZGgzcVlBUFp4?=
 =?utf-8?B?VjhZTG9TQkY1M3BxdEhjVWUwUkUrN3pFNGxjV092TkJGRS9jV3hNWnRldTRo?=
 =?utf-8?B?a2FyK0hIUWQwMkZmdDJrUzcwY1c0MjNsVmpvTTZxRG5ONVFIWDB4eHA1VjIw?=
 =?utf-8?B?cGdyWTY5QWxacXNnOHk0dkZsaXNxSlZRNDY5ZTlTTkpjdTlnOGhOUENaNysv?=
 =?utf-8?B?QXd5cGFmUmp1eFJnNExIK0FJckZEejdodm5hQy8zbGNLYVlHcm9ySnJIemxn?=
 =?utf-8?B?clZlNUZQY3pVOVdXU0ZhL3FSOUZUMEo0Tm95U0MwV0ZjT1NHbTJlMllvQ1NE?=
 =?utf-8?B?ZVpRSXVQZ3RPVlY4M1NwTDRpbmk2Z1Z1WlVVMm5RRG56VHN4UG9Ocmw5OHY4?=
 =?utf-8?B?VW9LdC81OFE1TUtMNzVEdHVvVTZua28rNUVuVThBQzAzaGI1eHhGM3Z4MkFq?=
 =?utf-8?B?WlQ2SlVURUZuMWM3R1FKTzRBeVQvSGNYMm9PM0dFOWFvUnZsN2t3NmoxeDlH?=
 =?utf-8?B?MFRnSHB0bEpLQnprMUYxY1RCdUFReVVPZlFEczNNY3VScFg2YkpPS0VBVXBT?=
 =?utf-8?B?RlV6OGxKemY2T0lENlRCL2VMNnhHNVpmYko1d1hPTjJOb3p4M3dScWUySExE?=
 =?utf-8?B?Vm5KVFJvMzJzcDYrSVZPa3UweWFoZ25mSWJiZE8rVC96a0R1VHlrc3c4djVa?=
 =?utf-8?B?WnZQWGNKeWlLQ1JzL0VBQmpuSnBWU01wbFU4RmpkdzN2MFdhcGNuWWlpR2x3?=
 =?utf-8?B?UlE5dFZrM2NwNStDMXhkN1F1M2ZCMWJJK3FPaG5ySnFzYk5nMEp6U0hGVFd3?=
 =?utf-8?B?YzRKajRHYlcybmhNYXVHcysraDRkWERCaVkwVWFjNFZrOXpnRUxGRUJtUjgw?=
 =?utf-8?B?MXdHcjFzdXBCZjZ6bGZsLzhZeDhFbnBCWVpqZjl4cm93a3V1Y2NUMGpGMFVu?=
 =?utf-8?B?YWxIVkYySnorZEtmMjRuVmxFSDFEREJLR1R2VzFoRUR2TE8rbS9taVhBd2hV?=
 =?utf-8?B?SkNLNW1xVHYveXVHb1pOWG5XaEtIRUttc3l0bnAzQkl0NEJSSU93TEM2aGha?=
 =?utf-8?B?eTFhdjRGUGR2VkxSb3VudUNndGZ4a0NxQnBjUEtMSW5vUkRMVCt2c0F6VEJw?=
 =?utf-8?B?K21xTVNQenF5OGlvdnVDaWJ6aVNDTEZ3R3JMZS9ZTFBZbFo3YUE1cFpKbjRT?=
 =?utf-8?B?VHlNRi94dVN2VThaOHM5ZDE2NysxcnljKzVuN2x5Mkt5UnBLQ2RBVlZUMjhS?=
 =?utf-8?B?alA5bnVlTXcyUzgrMVdRQTBQclQzUUZESEtwU1oySXNjQ2NZdjExZm1ocWFy?=
 =?utf-8?B?WUE9PQ==?=
X-MS-Exchange-CrossTenant-Network-Message-Id: b3bfece0-6c42-4493-bf08-08dba99c5546
X-MS-Exchange-CrossTenant-AuthSource: PH7PR11MB5984.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 30 Aug 2023 21:01:51.5437
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: UFneUot/6Mr6uDFv3YEIkg7ZH8ZDDpekL+sl3KlJaIm29S0uJSLg4DPnnlXP79E9l0ECJ7EwalEaOAmpaqU14A==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: MW4PR11MB5799
X-OriginatorOrg: intel.com
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org



On 8/28/23 22:20, ira.weiny@intel.com wrote:
> From: Navneet Singh <navneet.singh@intel.com>
> 
> Devices can optionally support Dynamic Capacity (DC).  These devices are
> known as Dynamic Capacity Devices (DCD).
> 
> Implement the DC (opcode 48XXh) mailbox commands as specified in CXL 3.0
> section 8.2.9.8.9.  Read the DC configuration and store the DC region
> information in the device state.
> 
> Co-developed-by: Navneet Singh <navneet.singh@intel.com>
> Signed-off-by: Navneet Singh <navneet.singh@intel.com>
> Signed-off-by: Ira Weiny <ira.weiny@intel.com>

Uncapitalize Dynamic in subject

Also, maybe split out the REGION vs DECODER as a prep patch.

DJ

> 
> ---
> Changes for v2
> [iweiny: Rebased to latest master type2 work]
> [jonathan: s/dc/dc_resp/]
> [iweiny: Clean up commit message]
> [iweiny: Clean kernel docs]
> [djiang: Fix up cxl_is_dcd_command]
> [djiang: extra blank line]
> [alison: s/total_capacity/cap/ etc...]
> [alison: keep partition flag with partition structures]
> [alison: reformat untenanted_mem declaration]
> [alison: move 'cmd' definition back]
> [alison: fix comment line length]
> [alison: reverse x-tree]
> [jonathan: fix and adjust CXL_DC_REGION_STRLEN]
> [Jonathan/iweiny: Factor out storing each DC region read from the device]
> [Jonathan: place all dcr initializers together]
> [Jonathan/iweiny: flip around the region DPA order check]
> [jonathan: Account for short read of mailbox command]
> [iweiny: use snprintf for region name]
> [iweiny: use '<nil>' for missing region names]
> [iweiny: factor out struct cxl_dc_region_info]
> [iweiny: Split out reading CEL]
> ---
>   drivers/cxl/core/mbox.c   | 179 +++++++++++++++++++++++++++++++++++++++++++++-
>   drivers/cxl/core/region.c |  75 +++++++++++++------
>   drivers/cxl/cxl.h         |  27 ++++++-
>   drivers/cxl/cxlmem.h      |  55 +++++++++++++-
>   drivers/cxl/pci.c         |   4 ++
>   5 files changed, 314 insertions(+), 26 deletions(-)
> 
> diff --git a/drivers/cxl/core/mbox.c b/drivers/cxl/core/mbox.c
> index 554ec97a7c39..d769814f80e2 100644
> --- a/drivers/cxl/core/mbox.c
> +++ b/drivers/cxl/core/mbox.c
> @@ -1096,7 +1096,7 @@ int cxl_dev_state_identify(struct cxl_memdev_state *mds)
>   	if (rc < 0)
>   		return rc;
>   
> -	mds->total_bytes =
> +	mds->static_cap =
>   		le64_to_cpu(id.total_capacity) * CXL_CAPACITY_MULTIPLIER;
>   	mds->volatile_only_bytes =
>   		le64_to_cpu(id.volatile_capacity) * CXL_CAPACITY_MULTIPLIER;
> @@ -1114,6 +1114,8 @@ int cxl_dev_state_identify(struct cxl_memdev_state *mds)
>   		mds->poison.max_errors = min_t(u32, val, CXL_POISON_LIST_MAX);
>   	}
>   
> +	mds->dc_event_log_size = le16_to_cpu(id.dc_event_log_size);
> +
>   	return 0;
>   }
>   EXPORT_SYMBOL_NS_GPL(cxl_dev_state_identify, CXL);
> @@ -1178,6 +1180,165 @@ int cxl_mem_sanitize(struct cxl_memdev_state *mds, u16 cmd)
>   }
>   EXPORT_SYMBOL_NS_GPL(cxl_mem_sanitize, CXL);
>   
> +static int cxl_dc_save_region_info(struct cxl_memdev_state *mds, int index,
> +				   struct cxl_dc_region_config *region_config)
> +{
> +	struct cxl_dc_region_info *dcr = &mds->dc_region[index];
> +	struct device *dev = mds->cxlds.dev;
> +
> +	dcr->base = le64_to_cpu(region_config->region_base);
> +	dcr->decode_len = le64_to_cpu(region_config->region_decode_length);
> +	dcr->decode_len *= CXL_CAPACITY_MULTIPLIER;
> +	dcr->len = le64_to_cpu(region_config->region_length);
> +	dcr->blk_size = le64_to_cpu(region_config->region_block_size);
> +	dcr->dsmad_handle = le32_to_cpu(region_config->region_dsmad_handle);
> +	dcr->flags = region_config->flags;
> +	snprintf(dcr->name, CXL_DC_REGION_STRLEN, "dc%d", index);
> +
> +	/* Check regions are in increasing DPA order */
> +	if (index > 0) {
> +		struct cxl_dc_region_info *prev_dcr = &mds->dc_region[index - 1];
> +
> +		if ((prev_dcr->base + prev_dcr->decode_len) > dcr->base) {
> +			dev_err(dev,
> +				"DPA ordering violation for DC region %d and %d\n",
> +				index - 1, index);
> +			return -EINVAL;
> +		}
> +	}
> +
> +	/* Check the region is 256 MB aligned */
> +	if (!IS_ALIGNED(dcr->base, SZ_256M)) {
> +		dev_err(dev, "DC region %d not aligned to 256MB: %#llx\n",
> +			index, dcr->base);
> +		return -EINVAL;
> +	}
> +
> +	/* Check Region base and length are aligned to block size */
> +	if (!IS_ALIGNED(dcr->base, dcr->blk_size) ||
> +	    !IS_ALIGNED(dcr->len, dcr->blk_size)) {
> +		dev_err(dev, "DC region %d not aligned to %#llx\n", index,
> +			dcr->blk_size);
> +		return -EINVAL;
> +	}
> +
> +	dev_dbg(dev,
> +		"DC region %s DPA: %#llx LEN: %#llx BLKSZ: %#llx\n",
> +		dcr->name, dcr->base, dcr->decode_len, dcr->blk_size);
> +
> +	return 0;
> +}
> +
> +/* Returns the number of regions in dc_resp or -ERRNO */
> +static int cxl_get_dc_id(struct cxl_memdev_state *mds, u8 start_region,
> +			 struct cxl_mbox_dynamic_capacity *dc_resp,
> +			 size_t dc_resp_size)
> +{
> +	struct cxl_mbox_get_dc_config get_dc = (struct cxl_mbox_get_dc_config) {
> +		.region_count = CXL_MAX_DC_REGION,
> +		.start_region_index = start_region,
> +	};
> +	struct cxl_mbox_cmd mbox_cmd = (struct cxl_mbox_cmd) {
> +		.opcode = CXL_MBOX_OP_GET_DC_CONFIG,
> +		.payload_in = &get_dc,
> +		.size_in = sizeof(get_dc),
> +		.size_out = dc_resp_size,
> +		.payload_out = dc_resp,
> +		.min_out = 1,
> +	};
> +	struct device *dev = mds->cxlds.dev;
> +	int rc;
> +
> +	rc = cxl_internal_send_cmd(mds, &mbox_cmd);
> +	if (rc < 0)
> +		return rc;
> +
> +	rc = dc_resp->avail_region_count - start_region;
> +
> +	/*
> +	 * The number of regions in the payload may have been truncated due to
> +	 * payload_size limits; if so adjust the count in this query.
> +	 */
> +	if (mbox_cmd.size_out < sizeof(*dc_resp))
> +		rc = CXL_REGIONS_RETURNED(mbox_cmd.size_out);
> +
> +	dev_dbg(dev, "Read %d/%d DC regions\n", rc, dc_resp->avail_region_count);
> +
> +	return rc;
> +}
> +
> +/**
> + * cxl_dev_dynamic_capacity_identify() - Reads the dynamic capacity
> + *					 information from the device.
> + * @mds: The memory device state
> + *
> + * This will dispatch the get_dynamic_capacity command to the device
> + * and on success populate structures to be exported to sysfs.
> + *
> + * Return: 0 if identify was executed successfully, -ERRNO on error.
> + */
> +int cxl_dev_dynamic_capacity_identify(struct cxl_memdev_state *mds)
> +{
> +	struct cxl_mbox_dynamic_capacity *dc_resp;
> +	struct device *dev = mds->cxlds.dev;
> +	size_t dc_resp_size = mds->payload_size;
> +	u8 start_region;
> +	int i, rc = 0;
> +
> +	for (i = 0; i < CXL_MAX_DC_REGION; i++)
> +		snprintf(mds->dc_region[i].name, CXL_DC_REGION_STRLEN, "<nil>");
> +
> +	/* Check GET_DC_CONFIG is supported by device */
> +	if (!test_bit(CXL_DCD_ENABLED_GET_CONFIG, mds->dcd_cmds)) {
> +		dev_dbg(dev, "unsupported cmd: get_dynamic_capacity_config\n");
> +		return 0;
> +	}
> +
> +	dc_resp = kvmalloc(dc_resp_size, GFP_KERNEL);
> +	if (!dc_resp)
> +		return -ENOMEM;
> +
> +	start_region = 0;
> +	do {
> +		int j;
> +
> +		rc = cxl_get_dc_id(mds, start_region, dc_resp, dc_resp_size);
> +		if (rc < 0)
> +			goto free_resp;
> +
> +		mds->nr_dc_region += rc;
> +
> +		if (mds->nr_dc_region < 1 || mds->nr_dc_region > CXL_MAX_DC_REGION) {
> +			dev_err(dev, "Invalid num of dynamic capacity regions %d\n",
> +				mds->nr_dc_region);
> +			rc = -EINVAL;
> +			goto free_resp;
> +		}
> +
> +		for (i = start_region, j = 0; i < mds->nr_dc_region; i++, j++) {
> +			rc = cxl_dc_save_region_info(mds, i, &dc_resp->region[j]);
> +			if (rc)
> +				goto free_resp;
> +		}
> +
> +		start_region = mds->nr_dc_region;
> +
> +	} while (mds->nr_dc_region < dc_resp->avail_region_count);
> +
> +	mds->dynamic_cap =
> +		mds->dc_region[mds->nr_dc_region - 1].base +
> +		mds->dc_region[mds->nr_dc_region - 1].decode_len -
> +		mds->dc_region[0].base;
> +	dev_dbg(dev, "Total dynamic capacity: %#llx\n", mds->dynamic_cap);
> +
> +free_resp:
> +	kfree(dc_resp);
> +	if (rc)
> +		dev_err(dev, "Failed to get DC info: %d\n", rc);
> +	return rc;
> +}
> +EXPORT_SYMBOL_NS_GPL(cxl_dev_dynamic_capacity_identify, CXL);
> +
>   static int add_dpa_res(struct device *dev, struct resource *parent,
>   		       struct resource *res, resource_size_t start,
>   		       resource_size_t size, const char *type)
> @@ -1208,8 +1369,12 @@ int cxl_mem_create_range_info(struct cxl_memdev_state *mds)
>   {
>   	struct cxl_dev_state *cxlds = &mds->cxlds;
>   	struct device *dev = cxlds->dev;
> +	size_t untenanted_mem;
>   	int rc;
>   
> +	untenanted_mem = mds->dc_region[0].base - mds->static_cap;
> +	mds->total_bytes = mds->static_cap + untenanted_mem + mds->dynamic_cap;
> +
>   	if (!cxlds->media_ready) {
>   		cxlds->dpa_res = DEFINE_RES_MEM(0, 0);
>   		cxlds->ram_res = DEFINE_RES_MEM(0, 0);
> @@ -1217,8 +1382,16 @@ int cxl_mem_create_range_info(struct cxl_memdev_state *mds)
>   		return 0;
>   	}
>   
> -	cxlds->dpa_res =
> -		(struct resource)DEFINE_RES_MEM(0, mds->total_bytes);
> +	cxlds->dpa_res = (struct resource)DEFINE_RES_MEM(0, mds->total_bytes);
> +
> +	for (int i = 0; i < mds->nr_dc_region; i++) {
> +		struct cxl_dc_region_info *dcr = &mds->dc_region[i];
> +
> +		rc = add_dpa_res(dev, &cxlds->dpa_res, &cxlds->dc_res[i],
> +				 dcr->base, dcr->decode_len, dcr->name);
> +		if (rc)
> +			return rc;
> +	}
>   
>   	if (mds->partition_align_bytes == 0) {
>   		rc = add_dpa_res(dev, &cxlds->dpa_res, &cxlds->ram_res, 0,
> diff --git a/drivers/cxl/core/region.c b/drivers/cxl/core/region.c
> index 252bc8e1f103..75041903b72c 100644
> --- a/drivers/cxl/core/region.c
> +++ b/drivers/cxl/core/region.c
> @@ -46,7 +46,7 @@ static ssize_t uuid_show(struct device *dev, struct device_attribute *attr,
>   	rc = down_read_interruptible(&cxl_region_rwsem);
>   	if (rc)
>   		return rc;
> -	if (cxlr->mode != CXL_DECODER_PMEM)
> +	if (cxlr->mode != CXL_REGION_PMEM)
>   		rc = sysfs_emit(buf, "\n");
>   	else
>   		rc = sysfs_emit(buf, "%pUb\n", &p->uuid);
> @@ -359,7 +359,7 @@ static umode_t cxl_region_visible(struct kobject *kobj, struct attribute *a,
>   	 * Support tooling that expects to find a 'uuid' attribute for all
>   	 * regions regardless of mode.
>   	 */
> -	if (a == &dev_attr_uuid.attr && cxlr->mode != CXL_DECODER_PMEM)
> +	if (a == &dev_attr_uuid.attr && cxlr->mode != CXL_REGION_PMEM)
>   		return 0444;
>   	return a->mode;
>   }
> @@ -537,7 +537,7 @@ static ssize_t mode_show(struct device *dev, struct device_attribute *attr,
>   {
>   	struct cxl_region *cxlr = to_cxl_region(dev);
>   
> -	return sysfs_emit(buf, "%s\n", cxl_decoder_mode_name(cxlr->mode));
> +	return sysfs_emit(buf, "%s\n", cxl_region_mode_name(cxlr->mode));
>   }
>   static DEVICE_ATTR_RO(mode);
>   
> @@ -563,7 +563,7 @@ static int alloc_hpa(struct cxl_region *cxlr, resource_size_t size)
>   
>   	/* ways, granularity and uuid (if PMEM) need to be set before HPA */
>   	if (!p->interleave_ways || !p->interleave_granularity ||
> -	    (cxlr->mode == CXL_DECODER_PMEM && uuid_is_null(&p->uuid)))
> +	    (cxlr->mode == CXL_REGION_PMEM && uuid_is_null(&p->uuid)))
>   		return -ENXIO;
>   
>   	div_u64_rem(size, SZ_256M * p->interleave_ways, &remainder);
> @@ -1765,6 +1765,17 @@ static int cxl_region_sort_targets(struct cxl_region *cxlr)
>   	return rc;
>   }
>   
> +static bool cxl_modes_compatible(enum cxl_region_mode rmode,
> +				 enum cxl_decoder_mode dmode)
> +{
> +	if (rmode == CXL_REGION_RAM && dmode == CXL_DECODER_RAM)
> +		return true;
> +	if (rmode == CXL_REGION_PMEM && dmode == CXL_DECODER_PMEM)
> +		return true;
> +
> +	return false;
> +}
> +
>   static int cxl_region_attach(struct cxl_region *cxlr,
>   			     struct cxl_endpoint_decoder *cxled, int pos)
>   {
> @@ -1778,9 +1789,11 @@ static int cxl_region_attach(struct cxl_region *cxlr,
>   	lockdep_assert_held_write(&cxl_region_rwsem);
>   	lockdep_assert_held_read(&cxl_dpa_rwsem);
>   
> -	if (cxled->mode != cxlr->mode) {
> -		dev_dbg(&cxlr->dev, "%s region mode: %d mismatch: %d\n",
> -			dev_name(&cxled->cxld.dev), cxlr->mode, cxled->mode);
> +	if (!cxl_modes_compatible(cxlr->mode, cxled->mode)) {
> +		dev_dbg(&cxlr->dev, "%s region mode: %s mismatch decoder: %s\n",
> +			dev_name(&cxled->cxld.dev),
> +			cxl_region_mode_name(cxlr->mode),
> +			cxl_decoder_mode_name(cxled->mode));
>   		return -EINVAL;
>   	}
>   
> @@ -2234,7 +2247,7 @@ static struct cxl_region *cxl_region_alloc(struct cxl_root_decoder *cxlrd, int i
>    * devm_cxl_add_region - Adds a region to a decoder
>    * @cxlrd: root decoder
>    * @id: memregion id to create, or memregion_free() on failure
> - * @mode: mode for the endpoint decoders of this region
> + * @mode: mode of this region
>    * @type: select whether this is an expander or accelerator (type-2 or type-3)
>    *
>    * This is the second step of region initialization. Regions exist within an
> @@ -2245,7 +2258,7 @@ static struct cxl_region *cxl_region_alloc(struct cxl_root_decoder *cxlrd, int i
>    */
>   static struct cxl_region *devm_cxl_add_region(struct cxl_root_decoder *cxlrd,
>   					      int id,
> -					      enum cxl_decoder_mode mode,
> +					      enum cxl_region_mode mode,
>   					      enum cxl_decoder_type type)
>   {
>   	struct cxl_port *port = to_cxl_port(cxlrd->cxlsd.cxld.dev.parent);
> @@ -2254,11 +2267,12 @@ static struct cxl_region *devm_cxl_add_region(struct cxl_root_decoder *cxlrd,
>   	int rc;
>   
>   	switch (mode) {
> -	case CXL_DECODER_RAM:
> -	case CXL_DECODER_PMEM:
> +	case CXL_REGION_RAM:
> +	case CXL_REGION_PMEM:
>   		break;
>   	default:
> -		dev_err(&cxlrd->cxlsd.cxld.dev, "unsupported mode %d\n", mode);
> +		dev_err(&cxlrd->cxlsd.cxld.dev, "unsupported mode %s\n",
> +			cxl_region_mode_name(mode));
>   		return ERR_PTR(-EINVAL);
>   	}
>   
> @@ -2308,7 +2322,7 @@ static ssize_t create_ram_region_show(struct device *dev,
>   }
>   
>   static struct cxl_region *__create_region(struct cxl_root_decoder *cxlrd,
> -					  int id, enum cxl_decoder_mode mode,
> +					  int id, enum cxl_region_mode mode,
>   					  enum cxl_decoder_type type)
>   {
>   	int rc;
> @@ -2337,7 +2351,7 @@ static ssize_t create_pmem_region_store(struct device *dev,
>   	if (rc != 1)
>   		return -EINVAL;
>   
> -	cxlr = __create_region(cxlrd, id, CXL_DECODER_PMEM,
> +	cxlr = __create_region(cxlrd, id, CXL_REGION_PMEM,
>   			       CXL_DECODER_HOSTONLYMEM);
>   	if (IS_ERR(cxlr))
>   		return PTR_ERR(cxlr);
> @@ -2358,7 +2372,7 @@ static ssize_t create_ram_region_store(struct device *dev,
>   	if (rc != 1)
>   		return -EINVAL;
>   
> -	cxlr = __create_region(cxlrd, id, CXL_DECODER_RAM,
> +	cxlr = __create_region(cxlrd, id, CXL_REGION_RAM,
>   			       CXL_DECODER_HOSTONLYMEM);
>   	if (IS_ERR(cxlr))
>   		return PTR_ERR(cxlr);
> @@ -2886,10 +2900,31 @@ static void construct_region_end(void)
>   	up_write(&cxl_region_rwsem);
>   }
>   
> +static enum cxl_region_mode
> +cxl_decoder_to_region_mode(enum cxl_decoder_mode mode)
> +{
> +	switch (mode) {
> +	case CXL_DECODER_NONE:
> +		return CXL_REGION_NONE;
> +	case CXL_DECODER_RAM:
> +		return CXL_REGION_RAM;
> +	case CXL_DECODER_PMEM:
> +		return CXL_REGION_PMEM;
> +	case CXL_DECODER_DEAD:
> +		return CXL_REGION_DEAD;
> +	case CXL_DECODER_MIXED:
> +	default:
> +		return CXL_REGION_MIXED;
> +	}
> +
> +	return CXL_REGION_MIXED;
> +}
> +
>   static struct cxl_region *
>   construct_region_begin(struct cxl_root_decoder *cxlrd,
>   		       struct cxl_endpoint_decoder *cxled)
>   {
> +	enum cxl_region_mode mode = cxl_decoder_to_region_mode(cxled->mode);
>   	struct cxl_memdev *cxlmd = cxled_to_memdev(cxled);
>   	struct cxl_region_params *p;
>   	struct cxl_region *cxlr;
> @@ -2897,7 +2932,7 @@ construct_region_begin(struct cxl_root_decoder *cxlrd,
>   
>   	do {
>   		cxlr = __create_region(cxlrd, atomic_read(&cxlrd->region_id),
> -				       cxled->mode, cxled->cxld.target_type);
> +				       mode, cxled->cxld.target_type);
>   	} while (IS_ERR(cxlr) && PTR_ERR(cxlr) == -EBUSY);
>   
>   	if (IS_ERR(cxlr)) {
> @@ -3200,9 +3235,9 @@ static int cxl_region_probe(struct device *dev)
>   		return rc;
>   
>   	switch (cxlr->mode) {
> -	case CXL_DECODER_PMEM:
> +	case CXL_REGION_PMEM:
>   		return devm_cxl_add_pmem_region(cxlr);
> -	case CXL_DECODER_RAM:
> +	case CXL_REGION_RAM:
>   		/*
>   		 * The region can not be manged by CXL if any portion of
>   		 * it is already online as 'System RAM'
> @@ -3223,8 +3258,8 @@ static int cxl_region_probe(struct device *dev)
>   		/* HDM-H routes to device-dax */
>   		return devm_cxl_add_dax_region(cxlr);
>   	default:
> -		dev_dbg(&cxlr->dev, "unsupported region mode: %d\n",
> -			cxlr->mode);
> +		dev_dbg(&cxlr->dev, "unsupported region mode: %s\n",
> +			cxl_region_mode_name(cxlr->mode));
>   		return -ENXIO;
>   	}
>   }
> diff --git a/drivers/cxl/cxl.h b/drivers/cxl/cxl.h
> index cd4a9ffdacc7..ed282dcd5cf5 100644
> --- a/drivers/cxl/cxl.h
> +++ b/drivers/cxl/cxl.h
> @@ -374,6 +374,28 @@ static inline const char *cxl_decoder_mode_name(enum cxl_decoder_mode mode)
>   	return "mixed";
>   }
>   
> +enum cxl_region_mode {
> +	CXL_REGION_NONE,
> +	CXL_REGION_RAM,
> +	CXL_REGION_PMEM,
> +	CXL_REGION_MIXED,
> +	CXL_REGION_DEAD,
> +};
> +
> +static inline const char *cxl_region_mode_name(enum cxl_region_mode mode)
> +{
> +	static const char * const names[] = {
> +		[CXL_REGION_NONE] = "none",
> +		[CXL_REGION_RAM] = "ram",
> +		[CXL_REGION_PMEM] = "pmem",
> +		[CXL_REGION_MIXED] = "mixed",
> +	};
> +
> +	if (mode >= CXL_REGION_NONE && mode <= CXL_REGION_MIXED)
> +		return names[mode];
> +	return "mixed";
> +}
> +
>   /*
>    * Track whether this decoder is reserved for region autodiscovery, or
>    * free for userspace provisioning.
> @@ -502,7 +524,8 @@ struct cxl_region_params {
>    * struct cxl_region - CXL region
>    * @dev: This region's device
>    * @id: This region's id. Id is globally unique across all regions
> - * @mode: Endpoint decoder allocation / access mode
> + * @mode: Region mode which defines which endpoint decoder mode the region is
> + *        compatible with
>    * @type: Endpoint decoder target type
>    * @cxl_nvb: nvdimm bridge for coordinating @cxlr_pmem setup / shutdown
>    * @cxlr_pmem: (for pmem regions) cached copy of the nvdimm bridge
> @@ -512,7 +535,7 @@ struct cxl_region_params {
>   struct cxl_region {
>   	struct device dev;
>   	int id;
> -	enum cxl_decoder_mode mode;
> +	enum cxl_region_mode mode;
>   	enum cxl_decoder_type type;
>   	struct cxl_nvdimm_bridge *cxl_nvb;
>   	struct cxl_pmem_region *cxlr_pmem;
> diff --git a/drivers/cxl/cxlmem.h b/drivers/cxl/cxlmem.h
> index 5f2e65204bf9..8c8f47b397ab 100644
> --- a/drivers/cxl/cxlmem.h
> +++ b/drivers/cxl/cxlmem.h
> @@ -396,6 +396,7 @@ enum cxl_devtype {
>   	CXL_DEVTYPE_CLASSMEM,
>   };
>   
> +#define CXL_MAX_DC_REGION 8
>   /**
>    * struct cxl_dev_state - The driver device state
>    *
> @@ -412,6 +413,8 @@ enum cxl_devtype {
>    * @dpa_res: Overall DPA resource tree for the device
>    * @pmem_res: Active Persistent memory capacity configuration
>    * @ram_res: Active Volatile memory capacity configuration
> + * @dc_res: Active Dynamic Capacity memory configuration for each possible
> + *          region
>    * @component_reg_phys: register base of component registers
>    * @serial: PCIe Device Serial Number
>    * @type: Generic Memory Class device or Vendor Specific Memory device
> @@ -426,11 +429,23 @@ struct cxl_dev_state {
>   	struct resource dpa_res;
>   	struct resource pmem_res;
>   	struct resource ram_res;
> +	struct resource dc_res[CXL_MAX_DC_REGION];
>   	resource_size_t component_reg_phys;
>   	u64 serial;
>   	enum cxl_devtype type;
>   };
>   
> +#define CXL_DC_REGION_STRLEN 7
> +struct cxl_dc_region_info {
> +	u64 base;
> +	u64 decode_len;
> +	u64 len;
> +	u64 blk_size;
> +	u32 dsmad_handle;
> +	u8 flags;
> +	u8 name[CXL_DC_REGION_STRLEN];
> +};
> +
>   /**
>    * struct cxl_memdev_state - Generic Type-3 Memory Device Class driver data
>    *
> @@ -449,6 +464,8 @@ struct cxl_dev_state {
>    * @enabled_cmds: Hardware commands found enabled in CEL.
>    * @exclusive_cmds: Commands that are kernel-internal only
>    * @total_bytes: sum of all possible capacities
> + * @static_cap: Sum of RAM and PMEM capacities
> + * @dynamic_cap: Complete DPA range occupied by DC regions
>    * @volatile_only_bytes: hard volatile capacity
>    * @persistent_only_bytes: hard persistent capacity
>    * @partition_align_bytes: alignment size for partition-able capacity
> @@ -456,6 +473,10 @@ struct cxl_dev_state {
>    * @active_persistent_bytes: sum of hard + soft persistent
>    * @next_volatile_bytes: volatile capacity change pending device reset
>    * @next_persistent_bytes: persistent capacity change pending device reset
> + * @nr_dc_region: number of DC regions implemented in the memory device
> + * @dc_region: array containing info about the DC regions
> + * @dc_event_log_size: The number of events the device can store in the
> + * Dynamic Capacity Event Log before it overflows
>    * @event: event log driver state
>    * @poison: poison driver state info
>    * @fw: firmware upload / activation state
> @@ -473,7 +494,10 @@ struct cxl_memdev_state {
>   	DECLARE_BITMAP(dcd_cmds, CXL_DCD_ENABLED_MAX);
>   	DECLARE_BITMAP(enabled_cmds, CXL_MEM_COMMAND_ID_MAX);
>   	DECLARE_BITMAP(exclusive_cmds, CXL_MEM_COMMAND_ID_MAX);
> +
>   	u64 total_bytes;
> +	u64 static_cap;
> +	u64 dynamic_cap;
>   	u64 volatile_only_bytes;
>   	u64 persistent_only_bytes;
>   	u64 partition_align_bytes;
> @@ -481,6 +505,11 @@ struct cxl_memdev_state {
>   	u64 active_persistent_bytes;
>   	u64 next_volatile_bytes;
>   	u64 next_persistent_bytes;
> +
> +	u8 nr_dc_region;
> +	struct cxl_dc_region_info dc_region[CXL_MAX_DC_REGION];
> +	size_t dc_event_log_size;
> +
>   	struct cxl_event_state event;
>   	struct cxl_poison_state poison;
>   	struct cxl_security_state security;
> @@ -587,6 +616,7 @@ struct cxl_mbox_identify {
>   	__le16 inject_poison_limit;
>   	u8 poison_caps;
>   	u8 qos_telemetry_caps;
> +	__le16 dc_event_log_size;
>   } __packed;
>   
>   /*
> @@ -741,9 +771,31 @@ struct cxl_mbox_set_partition_info {
>   	__le64 volatile_capacity;
>   	u8 flags;
>   } __packed;
> -
>   #define  CXL_SET_PARTITION_IMMEDIATE_FLAG	BIT(0)
>   
> +struct cxl_mbox_get_dc_config {
> +	u8 region_count;
> +	u8 start_region_index;
> +} __packed;
> +
> +/* See CXL 3.0 Table 125 get dynamic capacity config Output Payload */
> +struct cxl_mbox_dynamic_capacity {
> +	u8 avail_region_count;
> +	u8 rsvd[7];
> +	struct cxl_dc_region_config {
> +		__le64 region_base;
> +		__le64 region_decode_length;
> +		__le64 region_length;
> +		__le64 region_block_size;
> +		__le32 region_dsmad_handle;
> +		u8 flags;
> +		u8 rsvd[3];
> +	} __packed region[];
> +} __packed;
> +#define CXL_DYNAMIC_CAPACITY_SANITIZE_ON_RELEASE_FLAG BIT(0)
> +#define CXL_REGIONS_RETURNED(size_out) \
> +	((size_out - 8) / sizeof(struct cxl_dc_region_config))
> +
>   /* Set Timestamp CXL 3.0 Spec 8.2.9.4.2 */
>   struct cxl_mbox_set_timestamp_in {
>   	__le64 timestamp;
> @@ -867,6 +919,7 @@ enum {
>   int cxl_internal_send_cmd(struct cxl_memdev_state *mds,
>   			  struct cxl_mbox_cmd *cmd);
>   int cxl_dev_state_identify(struct cxl_memdev_state *mds);
> +int cxl_dev_dynamic_capacity_identify(struct cxl_memdev_state *mds);
>   int cxl_await_media_ready(struct cxl_dev_state *cxlds);
>   int cxl_enumerate_cmds(struct cxl_memdev_state *mds);
>   int cxl_mem_create_range_info(struct cxl_memdev_state *mds);
> diff --git a/drivers/cxl/pci.c b/drivers/cxl/pci.c
> index 5242dbf0044d..a9b110ff1176 100644
> --- a/drivers/cxl/pci.c
> +++ b/drivers/cxl/pci.c
> @@ -879,6 +879,10 @@ static int cxl_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)
>   	if (rc)
>   		return rc;
>   
> +	rc = cxl_dev_dynamic_capacity_identify(mds);
> +	if (rc)
> +		return rc;
> +
>   	rc = cxl_mem_create_range_info(mds);
>   	if (rc)
>   		return rc;
> 

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id A8AE5C83F01
	for <linux-cxl@archiver.kernel.org>; Wed, 30 Aug 2023 20:33:38 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S237957AbjH3Udj (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Wed, 30 Aug 2023 16:33:39 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:37666 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S235304AbjH3Udj (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Wed, 30 Aug 2023 16:33:39 -0400
Received: from mgamail.intel.com (mgamail.intel.com [134.134.136.65])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 89DAB4B23;
        Wed, 30 Aug 2023 13:33:05 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1693427586; x=1724963586;
  h=message-id:date:subject:to:cc:references:from:
   in-reply-to:content-transfer-encoding:mime-version;
  bh=V/ktCVoY24ZA1fxtPqnDfXW5T1BU4M93WcII81NJuew=;
  b=HUlAv7F42N0Ye2FCa20/BTNYVNJ6NUDUFXtul7Xlm7lz7FSvjrHqV9/p
   frzxe0RmSJD9ofU2S2/gmHsRuvPxEbMK6a/33RR8W5ApTfYKJwz2FFPKf
   ymxnB28fF12alhPJ4nmTZx5Y2GCKLXycX/PHc/ZAnHrsFVCvgWWzzKHqj
   EsRGXGYfXDtTcBCtFgylHmGVXJ63sNc50LJnZKMR0ZM1GKpKeWSU7KC2x
   0xSaVvy2Q71OrePgT7jaXq7d3Lkh8stvyA9e8k9Gsw7dxOU/GdwxxNdlC
   3aK03nKb7TQGAGvH1f/LQ97f8a3DDVwlmRd40nZZDKaXkrn9xLPuS+keG
   w==;
X-IronPort-AV: E=McAfee;i="6600,9927,10818"; a="379495599"
X-IronPort-AV: E=Sophos;i="6.02,214,1688454000"; 
   d="scan'208";a="379495599"
Received: from orsmga008.jf.intel.com ([10.7.209.65])
  by orsmga103.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 30 Aug 2023 13:33:04 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10818"; a="768533125"
X-IronPort-AV: E=Sophos;i="6.02,214,1688454000"; 
   d="scan'208";a="768533125"
Received: from orsmsx601.amr.corp.intel.com ([10.22.229.14])
  by orsmga008.jf.intel.com with ESMTP; 30 Aug 2023 13:33:03 -0700
Received: from orsmsx611.amr.corp.intel.com (10.22.229.24) by
 ORSMSX601.amr.corp.intel.com (10.22.229.14) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27; Wed, 30 Aug 2023 13:33:02 -0700
Received: from orsmsx602.amr.corp.intel.com (10.22.229.15) by
 ORSMSX611.amr.corp.intel.com (10.22.229.24) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27; Wed, 30 Aug 2023 13:33:02 -0700
Received: from ORSEDG601.ED.cps.intel.com (10.7.248.6) by
 orsmsx602.amr.corp.intel.com (10.22.229.15) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27 via Frontend Transport; Wed, 30 Aug 2023 13:33:02 -0700
Received: from NAM10-MW2-obe.outbound.protection.outlook.com (104.47.55.108)
 by edgegateway.intel.com (134.134.137.102) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.27; Wed, 30 Aug 2023 13:33:02 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=B5HHVUnfuaJVoUGMFicDu9YjNyIBM85FYI/K3w4JdbNL7jkqYcKTWJ+4oLeh+SrIciMSFQyxmc0eaaSm1UFao+6BJMda/mkZ93htr84T7pIzwWzKsGxV9hwk4Olw9IdwRobySl80F2MkvkNJbUKZbn+rBIDD75fLxV4Ln9xPUdvAeeHQyTP4uNuqGBF9GAbGzM4e7/BIn21/xDRrNP7o/w3wTaPceYUrBYJVrUQMNpC0adX0A7XxynzAhdoktyA9BHTM/0NKEyv7S/LXCDMa296IxClpe7ZvzmQUn7pSAH269eTUFuoPmoK7osgYvmT+nJvVtXgCbbXTNDOUqWahCg==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=2sP2YgWLcrTQLQbf2Dw1IxCm11sq7Yb5BU/zr2vLlz8=;
 b=LpmUzMv3DssXn9jkHTqhYcsi9jWbqMrgUvMg+dUDyDuRAKugjPqZlw58/TtbQnJVeCaFJPrgAAmY76msGbtTizqC3fBE6D4MKpeNlYugaBjxqCnpioTJOfylGsohiHdUaLu29v034mOWtCUS8nLKrPiE88makFxLcTUEtgWOg06DejEqytEtoRPFjlfK3WsBp880iXZZJw5Us4c5BKRYAWjTaRjWAbjOphBwbB94+D55lns56h069c/YOp8m+jJvDugNZT0k/szCo1i9dgLS8MK3TYGv9iPxwflud2x5ucSp29BA+KBtK/o+otBoVugzk16BLxz7l/AADPuddp11zQ==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from PH7PR11MB5984.namprd11.prod.outlook.com (2603:10b6:510:1e3::15)
 by PH8PR11MB8015.namprd11.prod.outlook.com (2603:10b6:510:23b::18) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.6699.30; Wed, 30 Aug
 2023 20:33:00 +0000
Received: from PH7PR11MB5984.namprd11.prod.outlook.com
 ([fe80::9563:9642:bbde:293f]) by PH7PR11MB5984.namprd11.prod.outlook.com
 ([fe80::9563:9642:bbde:293f%7]) with mapi id 15.20.6699.034; Wed, 30 Aug 2023
 20:33:00 +0000
Message-ID: <4a7c4345-a35a-4b41-9d51-fe98e36a3bbc@intel.com>
Date: Wed, 30 Aug 2023 13:32:56 -0700
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101
 Betterbird/102.13.0
Subject: Re: [PATCH RFC v2 01/18] cxl/hdm: Debug, use decoder name function
To: Ira Weiny <ira.weiny@intel.com>,
        Dan Williams <dan.j.williams@intel.com>
CC: Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Alison Schofield <alison.schofield@intel.com>,
        "Vishal Verma" <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
 <20230604-dcd-type2-upstream-v2-1-f740c47e7916@intel.com>
Content-Language: en-US
From: Dave Jiang <dave.jiang@intel.com>
In-Reply-To: <20230604-dcd-type2-upstream-v2-1-f740c47e7916@intel.com>
Content-Type: text/plain; charset="UTF-8"; format=flowed
Content-Transfer-Encoding: 7bit
X-ClientProxiedBy: SJ0PR03CA0042.namprd03.prod.outlook.com
 (2603:10b6:a03:33e::17) To PH7PR11MB5984.namprd11.prod.outlook.com
 (2603:10b6:510:1e3::15)
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: PH7PR11MB5984:EE_|PH8PR11MB8015:EE_
X-MS-Office365-Filtering-Correlation-Id: 54fb032b-fcb6-4db6-63b4-08dba9984d6c
X-LD-Processed: 46c98d88-e344-4ed4-8496-4ed7712e255d,ExtAddr
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;
X-Microsoft-Antispam-Message-Info: JzznsR7r+wOkwqTB4CFlEjWqHc7Ninsh4jgsFyAXPk/y96Ub8JVXZZAO4hAarLyxlrDECbXdI/LwTgaRFs24reRiQIjRaX76SEKh4pt4mKZ0foJdbtTjbFixVf19xNXKUKl0ECBlP/QSAViYTT25ad4gyoQdq4S2akVD2F6cUQXUKEJs2KoJ9pBDQxOZuup1dkhVNtkHaWHdxOKGcLvOmDIsX6LVvQanw/BhFsvlw/iftDmsgE0do3ZvK7VTsaiNSy9v8W8D8LeTPhLg7GxpvO29Qfgk9CzlBKcIGBiVRmcXphBVWl3A+MRsOacGX0lyuuSzaKAh/MrEj3nSgdk0mMHiQy8PS1fDKMTLSgN6V+5DGjoLu7MscKZUDaFd1eR1YYLEegzRdlbsnUEXIVGijq1ma+scBRZ2HLJoDVtrrmCo2aYW5Xasoh0IEkgJLZU5GBF0iWLE2NQEzYuAMv9wcifnc8mN3cxJWnF81UTdU421JZk8Sjfei1r+pIzAMeY9m0WsX89ZO4WwqW5M8t3hHLdCwYNMC8kK+WJeV9KCQojpqEXYB63P0D50gmYYZWcCrpf8JXAzrzQ7o8FyVOOXdviArAbbzQyW2Nf8knSkmhdKSNhrvCN6nG8A+cXausV73W+41FcLCoPIvVBD3ZCJ+w==
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:PH7PR11MB5984.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230031)(376002)(366004)(396003)(346002)(136003)(39860400002)(186009)(1800799009)(451199024)(8936002)(6666004)(66946007)(31686004)(478600001)(110136005)(53546011)(66476007)(6506007)(54906003)(66556008)(6486002)(6636002)(38100700002)(316002)(82960400001)(41300700001)(6512007)(26005)(44832011)(5660300002)(36756003)(2616005)(8676002)(31696002)(2906002)(86362001)(83380400001)(4326008)(45980500001)(43740500002);DIR:OUT;SFP:1102;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?utf-8?B?dVR3emhaRTlod1UydEFiUzRML3JhT2Y4eDZzYTBVbVZ1Q0FOOTYwTEVCaGI4?=
 =?utf-8?B?SklkdmVJK0Fld25HUUM3bEs5akVrNWFzYlh3ZWFoT2lrbk9FNDlnYnNxV0FE?=
 =?utf-8?B?cFhlaWZsTDZsL09zQmNtYnphSlp0bkU3UWIwOWtCTFA0SGtnbWkwaklaZFFq?=
 =?utf-8?B?TStQcFp0MjF5ZithQjlibW53T1JFNXlCejF5WGFlVFB3TnpGUk9VdnA2OEFQ?=
 =?utf-8?B?d2FrY2ZYczlZTnB5Ym1xY1RGU0pPQVdGaDFUU1JHVzFVWDhMYyszN0x0WENq?=
 =?utf-8?B?Skd6YWZrZmZpbzZSZDJsSXJ3Y0xZRTI1Q1ZSWlpKQkoyQ1J6amVYWThTZWlt?=
 =?utf-8?B?L2VkU201a2c0QWU4VS80Z1V2R2dxcWZTZGRXMldqdjdsNHRBaXl2V3RGNnAx?=
 =?utf-8?B?cWdNMVBHeVBtbjBJMGlWOHptSlAvS0VjMWhnL2t1WGxsSVErd0MwaGhDb3lm?=
 =?utf-8?B?OERaaUl0Zy93bUovZWRQeHRKMGpORnVFb3pVMmdON2Y2OUpkVG5CUTAwcVFt?=
 =?utf-8?B?M2duazBGNUJFQVpFNHB0S3E3YjJoaU9NYzJOd084eVpvYmpGQ01WYlMyd2Jy?=
 =?utf-8?B?OEJhM3BOOFY4ZW9BVkFES2pjZk9ha2o5Vno2cHdtM29VaDRSdFlDYkI3TXdx?=
 =?utf-8?B?bU9SRUNYcVJxRTdYSSthMFA0T2xLYm42eHgxL1dubFNHSnB6QWdmV1B5bjVM?=
 =?utf-8?B?M0hLVDBuUVE0bTlLSFRGdi84di9yZ1liaWhOeE1qdmlMajFjcjRwd09ZVitI?=
 =?utf-8?B?aVlGVENsaHdEb25CWm1jS1dHY2p5aU0wZC9iSFFNd0VlcHVNVDl0SFU2SlBw?=
 =?utf-8?B?QjExVWcxZ2pzMXkwRGJnK2U0RzdZYi9aRENEQVd2cWxCVUM2NHg5b3JabFJH?=
 =?utf-8?B?WmhuZSt6cnhpVUc5Mkk1MU1BN2VWZGg2a1pMa3Npc2pDeE5ycGlVaHNuWUZD?=
 =?utf-8?B?WXRqOVBEM3NRTk5xei9LOXAzTEFaTUtwWVVWVnFTOC9QcjVzYnAyMndBMHJp?=
 =?utf-8?B?QnZlSDU5dFVJWlJCajRvOWEra0M3TUQ4cGZkMmYySE9raTVrdXQ1ODFZb0FI?=
 =?utf-8?B?K0VaMUljcVJrcFg4YURFZFZYY1o4QVlIbnZNOU5NdEZibUxENXVHRHlibHV5?=
 =?utf-8?B?eHpyNUJsNnJOOW00VVU1UWlId1pGbDNqeFFrS0I2NjNTb3lDbjZZK0RtcVp5?=
 =?utf-8?B?L1BUMDI4YjJjeWFnSjdQaHo2b3d5TGpEYWEwQlJLOU9xcEVDeGgvTnRTaDJ2?=
 =?utf-8?B?VnBMYXZaVkpUejhhS0lwYjJsVXJyNXdXOXZRb3lKcDdXY0IwZ3hYTmoreE85?=
 =?utf-8?B?bXZqVTVxUUI2Q1BUS05xRllHVDA4MTR3UmZOcUZoYzVMMGRLTENCU0lHODFW?=
 =?utf-8?B?Kzd4TWd0ZVBoSi9WOVhrT1ZiaW5zS2NhcHBzeklpRDBjTThmeW9nUkhQSEhw?=
 =?utf-8?B?NUdUWi9zVWl0QjRvRzdEdTNwSlIrWmRBZFMwNlE1VlpxaW1tYmFLMDV6bGVu?=
 =?utf-8?B?Rm5iN3N2dTZBei9UaGFsTFZOYms4QStCQWQyQlVJVU1mWU1pd2RoSnYrVUh3?=
 =?utf-8?B?NFV3ZjJITzNpRTFpRUlVOUFOOVFHK3g0R1ZHLzBnRHV4QU04eFVEWDRlQlp2?=
 =?utf-8?B?NWhrQ3F5NnFZS1g3YW5zWmc2K2ZERElmeWd2RWE1V3A1QlByNDR0T0hpenlv?=
 =?utf-8?B?TnZweGZEZnJaWTIvNU1qOUJaMTluM2RJdzlRSit4NVpmV01YU2FYRDgzSGt1?=
 =?utf-8?B?Vm04cXBRNVhFQmxrKzFCQUR5ZzY2dHlHZEVTRDhiTURSS2JNdlJHL3RSbmVv?=
 =?utf-8?B?VTMydG5LdmRROFV3UjJSYmU5SXlvMWpnOHBXTXpxUGh0YWRsSU5yN1NzNTVT?=
 =?utf-8?B?RlBsRzdjbExQaXZBakRJa0xYbC9Jajc4Ymp0elBqNHp5VUtpL2M0Vk1zcHdj?=
 =?utf-8?B?U1JPdHl0QVBLV25uSi8zb2ZFQnRjVE1yZlhBYUpyTG8rMHd1QWpsNys5cGJJ?=
 =?utf-8?B?M2FLWERRanRtenhIQ3VLd0w5TmltQWYvYjExSzR5aWNnM25HejEyYWYyNXg0?=
 =?utf-8?B?LytyR3JGY3d2UzNVNnQxZWFpRThVdnhoR3VZS3EzeENEY0h4bGFMcFFnRHJj?=
 =?utf-8?B?Q3ozK0pCaXZSMjNVNWRmazM3a3ovQzhTUjQyNE5UbkNBMytwWjJ5TnBxS1ZG?=
 =?utf-8?B?N2c9PQ==?=
X-MS-Exchange-CrossTenant-Network-Message-Id: 54fb032b-fcb6-4db6-63b4-08dba9984d6c
X-MS-Exchange-CrossTenant-AuthSource: PH7PR11MB5984.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 30 Aug 2023 20:33:00.4423
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: ID7PbUj5nPILIgKPa8UWMyABAtpLXaICH/u13c1BRQWQkkZ/pHc+syrokBwaVnbljk6hhjAm6hp9Qxy5VSHzXw==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: PH8PR11MB8015
X-OriginatorOrg: intel.com
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org



On 8/28/23 22:20, Ira Weiny wrote:
> The decoder enum has a name conversion function defined now.
> 
> Use that instead of open coding.
> 
> Suggested-by: Navneet Singh <navneet.singh@intel.com>
> Signed-off-by: Ira Weiny <ira.weiny@intel.com>

As others said, send this upstream outside of the series.

Reviewed-by: Dave Jiang <dave.jiang@intel.com>
> 
> ---
> Changes for v2:
> [iweiny: new patch, split out]
> ---
>   drivers/cxl/core/hdm.c | 3 +--
>   1 file changed, 1 insertion(+), 2 deletions(-)
> 
> diff --git a/drivers/cxl/core/hdm.c b/drivers/cxl/core/hdm.c
> index b01a77b67511..a254f79dd4e8 100644
> --- a/drivers/cxl/core/hdm.c
> +++ b/drivers/cxl/core/hdm.c
> @@ -550,8 +550,7 @@ int cxl_dpa_alloc(struct cxl_endpoint_decoder *cxled, unsigned long long size)
>   
>   	if (size > avail) {
>   		dev_dbg(dev, "%pa exceeds available %s capacity: %pa\n", &size,
> -			cxled->mode == CXL_DECODER_RAM ? "ram" : "pmem",
> -			&avail);
> +			cxl_decoder_mode_name(cxled->mode), &avail);
>   		rc = -ENOSPC;
>   		goto out;
>   	}
> 

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 8615EC83F1D
	for <linux-cxl@archiver.kernel.org>; Wed, 30 Aug 2023 18:54:18 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S245546AbjH3SxP (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Wed, 30 Aug 2023 14:53:15 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:36844 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S244048AbjH3MXn (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Wed, 30 Aug 2023 08:23:43 -0400
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 3C0D5CC5;
        Wed, 30 Aug 2023 05:23:40 -0700 (PDT)
Received: from lhrpeml500005.china.huawei.com (unknown [172.18.147.206])
        by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4RbNj61Wk1z6HJcm;
        Wed, 30 Aug 2023 20:22:34 +0800 (CST)
Received: from localhost (10.202.227.76) by lhrpeml500005.china.huawei.com
 (7.191.163.240) with Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id 15.1.2507.31; Wed, 30 Aug
 2023 13:23:36 +0100
Date: Wed, 30 Aug 2023 13:23:35 +0100
From: Jonathan Cameron <Jonathan.Cameron@Huawei.com>
To: Ira Weiny <ira.weiny@intel.com>
CC: Dan Williams <dan.j.williams@intel.com>,
        Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
Subject: Re: [PATCH RFC v2 18/18] tools/testing/cxl: Add Dynamic Capacity
 events
Message-ID: <20230830132335.0000162e@Huawei.com>
In-Reply-To: <20230604-dcd-type2-upstream-v2-18-f740c47e7916@intel.com>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
        <20230604-dcd-type2-upstream-v2-18-f740c47e7916@intel.com>
Organization: Huawei Technologies Research and Development (UK) Ltd.
X-Mailer: Claws Mail 4.1.0 (GTK 3.24.33; x86_64-w64-mingw32)
MIME-Version: 1.0
Content-Type: text/plain; charset="US-ASCII"
Content-Transfer-Encoding: 7bit
X-Originating-IP: [10.202.227.76]
X-ClientProxiedBy: lhrpeml100006.china.huawei.com (7.191.160.224) To
 lhrpeml500005.china.huawei.com (7.191.163.240)
X-CFilter-Loop: Reflected
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

On Mon, 28 Aug 2023 22:21:09 -0700
Ira Weiny <ira.weiny@intel.com> wrote:

> OS software needs to be alerted when new extents arrive on a Dynamic
> Capacity Device (DCD).  On test DCDs extents are added through sysfs.
> 
> Add events on DCD extent injection.  Directly call the event irq
> callback to simulate irqs to process the test extents.
> 
> Signed-off-by: Ira Weiny <ira.weiny@intel.com>
Trivial comments inline.

Reviewed-by: Jonathan.Cameron@huawei.com>

> ---
>  tools/testing/cxl/test/mem.c | 57 ++++++++++++++++++++++++++++++++++++++++++++
>  1 file changed, 57 insertions(+)
> 
> diff --git a/tools/testing/cxl/test/mem.c b/tools/testing/cxl/test/mem.c
> index d6041a2145c5..20364fee9df9 100644
> --- a/tools/testing/cxl/test/mem.c
> +++ b/tools/testing/cxl/test/mem.c
> @@ -2008,6 +2008,41 @@ static bool new_extent_valid(struct device *dev, size_t new_start,
>  	return false;
>  }
>  
> +struct dcd_event_dyn_cap dcd_event_rec_template = {
> +	.hdr = {
> +		.id = UUID_INIT(0xca95afa7, 0xf183, 0x4018,
> +				0x8c, 0x2f, 0x95, 0x26, 0x8e, 0x10, 0x1a, 0x2a),
> +		.length = sizeof(struct dcd_event_dyn_cap),
> +	},
> +};
> +
> +static int send_dc_event(struct mock_event_store *mes, enum dc_event type,
> +			 u64 start, u64 length, const char *tag_str)

Arguably it's not sending the event, but rather adding it to the event log and
flicking the irq. So maybe naming needs some thought?

> +{
> +	struct device *dev = mes->mds->cxlds.dev;
> +	struct dcd_event_dyn_cap *dcd_event_rec;
> +
> +	dcd_event_rec = devm_kzalloc(dev, sizeof(*dcd_event_rec), GFP_KERNEL);
> +	if (!dcd_event_rec)
> +		return -ENOMEM;
> +
> +	memcpy(dcd_event_rec, &dcd_event_rec_template, sizeof(*dcd_event_rec));

devm_kmemdup?

> +	dcd_event_rec->data.event_type = type;
> +	dcd_event_rec->data.extent.start_dpa = cpu_to_le64(start);
> +	dcd_event_rec->data.extent.length = cpu_to_le64(length);
> +	memcpy(dcd_event_rec->data.extent.tag, tag_str,
> +	       min(sizeof(dcd_event_rec->data.extent.tag),
> +		   strlen(tag_str)));
> +
> +	mes_add_event(mes, CXL_EVENT_TYPE_DCD,
> +		      (struct cxl_event_record_raw *)dcd_event_rec);
> +
> +	/* Fake the irq */
> +	cxl_mem_get_event_records(mes->mds, CXLDEV_EVENT_STATUS_DCD);
> +
> +	return 0;
> +}
> +



From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 9E69AC83F17
	for <linux-cxl@archiver.kernel.org>; Wed, 30 Aug 2023 18:54:15 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S243680AbjH3SxE (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Wed, 30 Aug 2023 14:53:04 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:54702 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S244044AbjH3MUn (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Wed, 30 Aug 2023 08:20:43 -0400
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id CE489CC5;
        Wed, 30 Aug 2023 05:20:40 -0700 (PDT)
Received: from lhrpeml500005.china.huawei.com (unknown [172.18.147.226])
        by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4RbNdg5rsbz6HJdJ;
        Wed, 30 Aug 2023 20:19:35 +0800 (CST)
Received: from localhost (10.202.227.76) by lhrpeml500005.china.huawei.com
 (7.191.163.240) with Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id 15.1.2507.31; Wed, 30 Aug
 2023 13:20:38 +0100
Date: Wed, 30 Aug 2023 13:20:37 +0100
From: Jonathan Cameron <Jonathan.Cameron@Huawei.com>
To: Ira Weiny <ira.weiny@intel.com>
CC: Dan Williams <dan.j.williams@intel.com>,
        Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
Subject: Re: [PATCH RFC v2 17/18] tools/testing/cxl: Add DC Regions to mock
 mem data
Message-ID: <20230830132037.00005348@Huawei.com>
In-Reply-To: <20230604-dcd-type2-upstream-v2-17-f740c47e7916@intel.com>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
        <20230604-dcd-type2-upstream-v2-17-f740c47e7916@intel.com>
Organization: Huawei Technologies Research and Development (UK) Ltd.
X-Mailer: Claws Mail 4.1.0 (GTK 3.24.33; x86_64-w64-mingw32)
MIME-Version: 1.0
Content-Type: text/plain; charset="US-ASCII"
Content-Transfer-Encoding: 7bit
X-Originating-IP: [10.202.227.76]
X-ClientProxiedBy: lhrpeml100006.china.huawei.com (7.191.160.224) To
 lhrpeml500005.china.huawei.com (7.191.163.240)
X-CFilter-Loop: Reflected
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

On Mon, 28 Aug 2023 22:21:08 -0700
Ira Weiny <ira.weiny@intel.com> wrote:

> To test DC regions the mock memory devices will need to store
> information about the regions and manage fake extent data.
> 
> Define mock_dc_region information within the mock memory data.  Add
> sysfs entries on the mock device to inject and delete extents.
> 
> The inject format is <start>:<length>:<tag>
> The delete format is <start>
> 
> Add DC mailbox commands to the CEL and implement those commands.
> 
> Signed-off-by: Ira Weiny <ira.weiny@intel.com>

Looks fine to me.  Totally trivial comment inline.

FWIW
Reviewed-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>


> +
>  static int mock_gsl(struct cxl_mbox_cmd *cmd)
>  {
>  	if (cmd->size_out < sizeof(mock_gsl_payload))
> @@ -1315,6 +1429,148 @@ static int mock_activate_fw(struct cxl_mockmem_data *mdata,
>  	return -EINVAL;
>  }
>  

Bit inconsistent on whether there are one or two blank lines between functions.

> +static int mock_get_dc_config(struct device *dev,
> +			      struct cxl_mbox_cmd *cmd)
> +{
> +	struct cxl_mbox_get_dc_config *dc_config = cmd->payload_in;
> +	struct cxl_mockmem_data *mdata = dev_get_drvdata(dev);
> +	u8 region_requested, region_start_idx, region_ret_cnt;
> +	struct cxl_mbox_dynamic_capacity *resp;
> +
> +	region_requested = dc_config->region_count;
> +	if (NUM_MOCK_DC_REGIONS < region_requested)
> +		region_requested = NUM_MOCK_DC_REGIONS;
> +
> +	if (cmd->size_out < struct_size(resp, region, region_requested))
> +		return -EINVAL;
> +
> +	memset(cmd->payload_out, 0, cmd->size_out);
> +	resp = cmd->payload_out;
> +
> +	region_start_idx = dc_config->start_region_index;
> +	region_ret_cnt = 0;
> +	for (int i = 0; i < NUM_MOCK_DC_REGIONS; i++) {
> +		if (i >= region_start_idx) {
> +			memcpy(&resp->region[region_ret_cnt],
> +				&mdata->dc_regions[i],
> +				sizeof(resp->region[region_ret_cnt]));
> +			region_ret_cnt++;
> +		}
> +	}
> +	resp->avail_region_count = region_ret_cnt;
> +
> +	dev_dbg(dev, "Returning %d dc regions\n", region_ret_cnt);
> +	return 0;
> +}



From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 58796C83F1C
	for <linux-cxl@archiver.kernel.org>; Wed, 30 Aug 2023 18:54:14 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S237423AbjH3SxC (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Wed, 30 Aug 2023 14:53:02 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:53482 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S243680AbjH3L1s (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Wed, 30 Aug 2023 07:27:48 -0400
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 0BD3C1B0;
        Wed, 30 Aug 2023 04:27:45 -0700 (PDT)
Received: from lhrpeml500005.china.huawei.com (unknown [172.18.147.201])
        by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4RbMNG5m90z6K6J8;
        Wed, 30 Aug 2023 19:22:54 +0800 (CST)
Received: from localhost (10.202.227.76) by lhrpeml500005.china.huawei.com
 (7.191.163.240) with Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id 15.1.2507.31; Wed, 30 Aug
 2023 12:27:42 +0100
Date: Wed, 30 Aug 2023 12:27:41 +0100
From: Jonathan Cameron <Jonathan.Cameron@Huawei.com>
To: Ira Weiny <ira.weiny@intel.com>
CC: Dan Williams <dan.j.williams@intel.com>,
        Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
Subject: Re: [PATCH RFC v2 13/18] dax/bus: Factor out dev dax resize logic
Message-ID: <20230830122741.00007628@Huawei.com>
In-Reply-To: <20230604-dcd-type2-upstream-v2-13-f740c47e7916@intel.com>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
        <20230604-dcd-type2-upstream-v2-13-f740c47e7916@intel.com>
Organization: Huawei Technologies Research and Development (UK) Ltd.
X-Mailer: Claws Mail 4.1.0 (GTK 3.24.33; x86_64-w64-mingw32)
MIME-Version: 1.0
Content-Type: text/plain; charset="US-ASCII"
Content-Transfer-Encoding: 7bit
X-Originating-IP: [10.202.227.76]
X-ClientProxiedBy: lhrpeml500002.china.huawei.com (7.191.160.78) To
 lhrpeml500005.china.huawei.com (7.191.163.240)
X-CFilter-Loop: Reflected
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

On Mon, 28 Aug 2023 22:21:04 -0700
Ira Weiny <ira.weiny@intel.com> wrote:

> Dynamic Capacity regions must limit dev dax resources to those areas
> which have extents backing real memory.  Four alternatives were
> considered to manage the intersection of region space and extents:
> 
> 1) Create a single region resource child on region creation which
>    reserves the entire region.  Then as extents are added punch holes in
>    this reservation.  This requires new resource manipulation to punch
>    the holes and still requires an additional iteration over the extent
>    areas which may already have existing dev dax resources used.
> 
> 2) Maintain an ordered xarray of extents which can be queried while
>    processing the resize logic.  The issue is that existing region->res
>    children may artificially limit the allocation size sent to
>    alloc_dev_dax_range().  IE the resource children can't be directly
>    used in the resize logic to find where space in the region is.
> 
> 3) Maintain a separate resource tree with extents.  This option is the
>    same as 2) but with a different data structure.  Most ideally we have
>    some unified representation of the resource tree.
> 
> 4) Create region resource children for each extent.  Manage the dax dev
>    resize logic in the same way as before but use a region child
>    (extent) resource as the parents to find space within each extent.
> 
> Option 4 can leverage the existing resize algorithm to find space within
> the extents.
> 
> In preparation for this change, factor out the dev_dax_resize logic.
> For static regions use dax_region->res as the parent to find space for
> the dax ranges.  Future patches will use the same algorithm with
> individual extent resources as the parent.
> 
> Signed-off-by: Ira Weiny <ira.weiny@intel.com>
Hi Ira,

Some trivial comments on comments, but in general this indeed seems to be doing what you
say and factoring out the static allocation part.

Reviewed-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>


> ---
>  drivers/dax/bus.c | 128 +++++++++++++++++++++++++++++++++---------------------
>  1 file changed, 79 insertions(+), 49 deletions(-)
> 
> diff --git a/drivers/dax/bus.c b/drivers/dax/bus.c
> index b76e49813a39..ea7ae82b4687 100644
> --- a/drivers/dax/bus.c
> +++ b/drivers/dax/bus.c
> @@ -817,11 +817,10 @@ static int devm_register_dax_mapping(struct dev_dax *dev_dax, int range_id)
>  	return 0;
>  }
>  

> -static ssize_t dev_dax_resize(struct dax_region *dax_region,
> -		struct dev_dax *dev_dax, resource_size_t size)
> +/*

/**

Suitable builds will then check this doc matches the function etc
even if this is never included into any of the docs build.

> + * dev_dax_resize_static - Expand the device into the unused portion of the
> + * region. This may involve adjusting the end of an existing resource, or
> + * allocating a new resource.
> + *
> + * @parent: parent resource to allocate this range in.
> + * @dev_dax: DAX device we are creating this range for

Trivial: Doesn't seem to be consistent on . or not

> + * @to_alloc: amount of space to alloc; must be <= space available in @parent
> + *
> + * Return the amount of space allocated or -ERRNO on failure
> + */
> +static ssize_t dev_dax_resize_static(struct resource *parent,
> +				     struct dev_dax *dev_dax,
> +				     resource_size_t to_alloc)


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 71D0EC83F19
	for <linux-cxl@archiver.kernel.org>; Wed, 30 Aug 2023 18:54:11 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S244180AbjH3Sww (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Wed, 30 Aug 2023 14:52:52 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:53044 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S243904AbjH3MMF (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Wed, 30 Aug 2023 08:12:05 -0400
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 7F2F31B0;
        Wed, 30 Aug 2023 05:12:00 -0700 (PDT)
Received: from lhrpeml500005.china.huawei.com (unknown [172.18.147.226])
        by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4RbNMs5Hhtz6J7YY;
        Wed, 30 Aug 2023 20:07:37 +0800 (CST)
Received: from localhost (10.202.227.76) by lhrpeml500005.china.huawei.com
 (7.191.163.240) with Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id 15.1.2507.31; Wed, 30 Aug
 2023 13:11:48 +0100
Date: Wed, 30 Aug 2023 13:11:47 +0100
From: Jonathan Cameron <Jonathan.Cameron@Huawei.com>
To: Ira Weiny <ira.weiny@intel.com>
CC: Dan Williams <dan.j.williams@intel.com>,
        Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
Subject: Re: [PATCH RFC v2 16/18] tools/testing/cxl: Make event logs dynamic
Message-ID: <20230830131147.000034bc@Huawei.com>
In-Reply-To: <20230604-dcd-type2-upstream-v2-16-f740c47e7916@intel.com>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
        <20230604-dcd-type2-upstream-v2-16-f740c47e7916@intel.com>
Organization: Huawei Technologies Research and Development (UK) Ltd.
X-Mailer: Claws Mail 4.1.0 (GTK 3.24.33; x86_64-w64-mingw32)
MIME-Version: 1.0
Content-Type: text/plain; charset="US-ASCII"
Content-Transfer-Encoding: 7bit
X-Originating-IP: [10.202.227.76]
X-ClientProxiedBy: lhrpeml100006.china.huawei.com (7.191.160.224) To
 lhrpeml500005.china.huawei.com (7.191.163.240)
X-CFilter-Loop: Reflected
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

On Mon, 28 Aug 2023 22:21:07 -0700
Ira Weiny <ira.weiny@intel.com> wrote:

> The test event logs were created as static arrays as an easy way to mock
> events.  Dynamic Capacity Device (DCD) test support requires events be
> created dynamically when extents are created/destroyed.
> 
> Modify the event log storage to be dynamically allocated.  Thus they can
> accommodate the dynamic events required by DCD.  Reuse the static event
> data to create the dynamic events in the new logs without inventing
> complex event injection through the test sysfs.  Simplify the processing
> of the logs by using the event log array index as the handle.  Add a
> lock to manage concurrency to come with DCD extent testing.
> 
> Signed-off-by: Ira Weiny <ira.weiny@intel.com>
Diff did a horrible job on readability of this patch.

Ah well. Comments superficial only.

Jonathan

> ---
>  tools/testing/cxl/test/mem.c | 276 ++++++++++++++++++++++++++-----------------
>  1 file changed, 170 insertions(+), 106 deletions(-)
> 
> diff --git a/tools/testing/cxl/test/mem.c b/tools/testing/cxl/test/mem.c
> index 51be202fabd0..6a036c8d215d 100644
> --- a/tools/testing/cxl/test/mem.c
> +++ b/tools/testing/cxl/test/mem.c
> @@ -118,18 +118,27 @@ static struct {
>  
>  #define PASS_TRY_LIMIT 3
>  
> -#define CXL_TEST_EVENT_CNT_MAX 15
> +#define CXL_TEST_EVENT_CNT_MAX 17
>  
>  /* Set a number of events to return at a time for simulation.  */
>  #define CXL_TEST_EVENT_CNT 3
>  
> +/*
> + * @next_handle: next handle (index) to be stored to
> + * @cur_handle: current handle (index) to be returned to the user on get_event
> + * @nr_events: total events in this log
> + * @nr_overflow: number of events added past the log size
> + * @lock: protect these state variables
> + * @events: array of pending events to be returned.
> + */
>  struct mock_event_log {
> -	u16 clear_idx;
> -	u16 cur_idx;
> +	u16 next_handle;
> +	u16 cur_handle;
>  	u16 nr_events;
>  	u16 nr_overflow;
> -	u16 overflow_reset;
> -	struct cxl_event_record_raw *events[CXL_TEST_EVENT_CNT_MAX];
> +	rwlock_t lock;
> +	/* 1 extra slot to accommodate that handles can't be 0 */
> +	struct cxl_event_record_raw *events[CXL_TEST_EVENT_CNT_MAX+1];

Spaces around +

>  };
>  

...


>  
> -static void cxl_mock_add_event_logs(struct mock_event_store *mes)
> +/* Create a dynamically allocated event out of a statically defined event. */
> +static void add_event_from_static(struct mock_event_store *mes,
> +				  enum cxl_event_log_type log_type,
> +				  struct cxl_event_record_raw *raw)
> +{
> +	struct device *dev = mes->mds->cxlds.dev;
> +	struct cxl_event_record_raw *rec;
> +
> +	rec = devm_kzalloc(dev, sizeof(*rec), GFP_KERNEL);
> +	if (!rec) {
> +		dev_err(dev, "Failed to alloc event for log\n");
> +		return;
> +	}
> +
> +	memcpy(rec, raw, sizeof(*rec));

devm_kmemdup()?


> +	mes_add_event(mes, log_type, rec);
> +}
> +
> +static void cxl_mock_add_event_logs(struct cxl_mockmem_data *mdata)
>  {
> +	struct mock_event_store *mes = &mdata->mes;
> +	struct device *dev = mes->mds->cxlds.dev;
> +
>  	put_unaligned_le16(CXL_GMER_VALID_CHANNEL | CXL_GMER_VALID_RANK,
>  			   &gen_media.validity_flags);
>  
> @@ -438,43 +475,60 @@ static void cxl_mock_add_event_logs(struct mock_event_store *mes)
>  			   CXL_DER_VALID_BANK | CXL_DER_VALID_COLUMN,
>  			   &dram.validity_flags);
>  
> -	mes_add_event(mes, CXL_EVENT_TYPE_INFO, &maint_needed);
> -	mes_add_event(mes, CXL_EVENT_TYPE_INFO,
> +	dev_dbg(dev, "Generating fake event logs %d\n",
> +		CXL_EVENT_TYPE_INFO);
> +	add_event_from_static(mes, CXL_EVENT_TYPE_INFO, &maint_needed);
> +	add_event_from_static(mes, CXL_EVENT_TYPE_INFO,
>  		      (struct cxl_event_record_raw *)&gen_media);
> -	mes_add_event(mes, CXL_EVENT_TYPE_INFO,
> +	add_event_from_static(mes, CXL_EVENT_TYPE_INFO,
>  		      (struct cxl_event_record_raw *)&mem_module);
>  	mes->ev_status |= CXLDEV_EVENT_STATUS_INFO;
>  
> -	mes_add_event(mes, CXL_EVENT_TYPE_FAIL, &maint_needed);
> -	mes_add_event(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
> -	mes_add_event(mes, CXL_EVENT_TYPE_FAIL,
> +	dev_dbg(dev, "Generating fake event logs %d\n",
> +		CXL_EVENT_TYPE_FAIL);
> +	add_event_from_static(mes, CXL_EVENT_TYPE_FAIL, &maint_needed);
> +	add_event_from_static(mes, CXL_EVENT_TYPE_FAIL,
> +		      (struct cxl_event_record_raw *)&mem_module);
> +	add_event_from_static(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
> +	add_event_from_static(mes, CXL_EVENT_TYPE_FAIL,
>  		      (struct cxl_event_record_raw *)&dram);
> -	mes_add_event(mes, CXL_EVENT_TYPE_FAIL,
> +	add_event_from_static(mes, CXL_EVENT_TYPE_FAIL,
>  		      (struct cxl_event_record_raw *)&gen_media);
> -	mes_add_event(mes, CXL_EVENT_TYPE_FAIL,
> +	add_event_from_static(mes, CXL_EVENT_TYPE_FAIL,
>  		      (struct cxl_event_record_raw *)&mem_module);
> -	mes_add_event(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
> -	mes_add_event(mes, CXL_EVENT_TYPE_FAIL,
> +	add_event_from_static(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
> +	add_event_from_static(mes, CXL_EVENT_TYPE_FAIL,
>  		      (struct cxl_event_record_raw *)&dram);
>  	/* Overflow this log */
> -	mes_add_event(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
> -	mes_add_event(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
> -	mes_add_event(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
> -	mes_add_event(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
> -	mes_add_event(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
> -	mes_add_event(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
> -	mes_add_event(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
> -	mes_add_event(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
> -	mes_add_event(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
> -	mes_add_event(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
> +	add_event_from_static(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
> +	add_event_from_static(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
> +	add_event_from_static(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
> +	add_event_from_static(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
> +	add_event_from_static(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
> +	add_event_from_static(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
> +	add_event_from_static(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
> +	add_event_from_static(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
> +	add_event_from_static(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
> +	add_event_from_static(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
>  	mes->ev_status |= CXLDEV_EVENT_STATUS_FAIL;
>  
> -	mes_add_event(mes, CXL_EVENT_TYPE_FATAL, &hardware_replace);
> -	mes_add_event(mes, CXL_EVENT_TYPE_FATAL,
> +	dev_dbg(dev, "Generating fake event logs %d\n",
> +		CXL_EVENT_TYPE_FATAL);
> +	add_event_from_static(mes, CXL_EVENT_TYPE_FATAL, &hardware_replace);
> +	add_event_from_static(mes, CXL_EVENT_TYPE_FATAL,
>  		      (struct cxl_event_record_raw *)&dram);
>  	mes->ev_status |= CXLDEV_EVENT_STATUS_FATAL;
>  }
>  
> +static void cxl_mock_event_trigger(struct device *dev)
> +{
> +	struct cxl_mockmem_data *mdata = dev_get_drvdata(dev);
> +	struct mock_event_store *mes = &mdata->mes;
> +
> +	cxl_mock_add_event_logs(mdata);
> +	cxl_mem_get_event_records(mes->mds, mes->ev_status);
> +}


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id EDFA4C83F19
	for <linux-cxl@archiver.kernel.org>; Wed, 30 Aug 2023 18:54:04 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S243426AbjH3Swm (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Wed, 30 Aug 2023 14:52:42 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:51014 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S243828AbjH3Luc (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Wed, 30 Aug 2023 07:50:32 -0400
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 983E71B0;
        Wed, 30 Aug 2023 04:50:28 -0700 (PDT)
Received: from lhrpeml500005.china.huawei.com (unknown [172.18.147.226])
        by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4RbMyq6GGTz6HJcW;
        Wed, 30 Aug 2023 19:49:23 +0800 (CST)
Received: from localhost (10.202.227.76) by lhrpeml500005.china.huawei.com
 (7.191.163.240) with Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id 15.1.2507.31; Wed, 30 Aug
 2023 12:50:26 +0100
Date: Wed, 30 Aug 2023 12:50:25 +0100
From: Jonathan Cameron <Jonathan.Cameron@Huawei.com>
To: Ira Weiny <ira.weiny@intel.com>
CC: Dan Williams <dan.j.williams@intel.com>,
        Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
Subject: Re: [PATCH RFC v2 14/18] dax/region: Support DAX device creation on
 dynamic DAX regions
Message-ID: <20230830125025.00000fea@Huawei.com>
In-Reply-To: <20230604-dcd-type2-upstream-v2-14-f740c47e7916@intel.com>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
        <20230604-dcd-type2-upstream-v2-14-f740c47e7916@intel.com>
Organization: Huawei Technologies Research and Development (UK) Ltd.
X-Mailer: Claws Mail 4.1.0 (GTK 3.24.33; x86_64-w64-mingw32)
MIME-Version: 1.0
Content-Type: text/plain; charset="US-ASCII"
Content-Transfer-Encoding: 7bit
X-Originating-IP: [10.202.227.76]
X-ClientProxiedBy: lhrpeml100004.china.huawei.com (7.191.162.219) To
 lhrpeml500005.china.huawei.com (7.191.163.240)
X-CFilter-Loop: Reflected
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

On Mon, 28 Aug 2023 22:21:05 -0700
Ira Weiny <ira.weiny@intel.com> wrote:

> Dynamic Capacity (DC) DAX regions have a list of extents which define
> the memory of the region which is available.
> 
> Now that DAX region extents are fully realized support DAX device
> creation on dynamic regions by adjusting the allocation algorithms
> to account for the extents.  Remember also references must be held on
> the extents until the DAX devices are done with the memory.
> 
> Redefine the region available size to include only extent space.  Reuse
> the size allocation algorithm by defining sub-resources for each extent
> and limiting range allocation to those extents which have space.  Do not
> support direct mapping of DAX devices on dynamic devices.
> 
> Enhance DAX device range objects to hold references on the extents until
> the DAX device is destroyed.
> 
> NOTE: At this time all extents within a region are created equally.
> However, labels are associated with extents which can be used with
> future DAX device labels to group which extents are used.

This sound like a bad place to start to me as we are enabling something
that is probably 'wrong' in the long term as opposed to just not enabling it
until we have appropriate support.
I'd argue better to just reject any extents with different labels for now.

As this is an RFC meh ;)

Whilst this looks fine to me, I'm rather out of my depth wrt to the DAX
side of things so take that with a pinch of salt.

Jonathan


> 
> Signed-off-by: Ira Weiny <ira.weiny@intel.com>
> ---
>  drivers/dax/bus.c         | 157 +++++++++++++++++++++++++++++++++++++++-------
>  drivers/dax/cxl.c         |  44 +++++++++++++
>  drivers/dax/dax-private.h |   5 ++
>  3 files changed, 182 insertions(+), 24 deletions(-)
> 
> diff --git a/drivers/dax/bus.c b/drivers/dax/bus.c
> index ea7ae82b4687..a9ea6a706702 100644
> --- a/drivers/dax/bus.c
> +++ b/drivers/dax/bus.c

...


> @@ -1183,7 +1290,7 @@ static ssize_t mapping_store(struct device *dev, struct device_attribute *attr,
>  	to_alloc = range_len(&r);
>  	if (alloc_is_aligned(dev_dax, to_alloc))
>  		rc = alloc_dev_dax_range(&dax_region->res, dev_dax, r.start,
> -					 to_alloc);
> +					 to_alloc, NULL);
>  	device_unlock(dev);
>  	device_unlock(dax_region->dev);
>  
> @@ -1400,8 +1507,10 @@ struct dev_dax *devm_create_dev_dax(struct dev_dax_data *data)
>  	device_initialize(dev);
>  	dev_set_name(dev, "dax%d.%d", dax_region->id, dev_dax->id);
>  
> +	dev_WARN_ONCE(parent, is_dynamic(dax_region) && data->size,
> +		      "Dynamic DAX devices are created initially with 0 size");

dev_info() maybe more appropriate?   Is this common enough that we need the
_ONCE?


>  	rc = alloc_dev_dax_range(&dax_region->res, dev_dax, dax_region->res.start,
> -				 data->size);
> +				 data->size, NULL);
>  	if (rc)
>  		goto err_range;
>  
> diff --git a/drivers/dax/cxl.c b/drivers/dax/cxl.c
> index 44cbd28668f1..6394a3531e25 100644
> --- a/drivers/dax/cxl.c
> +++ b/drivers/dax/cxl.c
...


>  static int cxl_dax_region_create_extent(struct dax_region *dax_region,
>  					struct cxl_dr_extent *cxl_dr_ext)
>  {
> @@ -45,11 +80,20 @@ static int cxl_dax_region_create_extent(struct dax_region *dax_region,
>  	/* device manages the dr_extent on success */
>  	kref_init(&dr_extent->ref);
>  
> +	rc = dax_region_add_resource(dax_region, dr_extent,
> +				     cxl_dr_ext->hpa_offset,
> +				     cxl_dr_ext->hpa_length);
> +	if (rc) {
> +		kfree(dr_extent);

goto for these and single unwinding block?

> +		return rc;
> +	}
> +
>  	rc = dax_region_ext_create_dev(dax_region, dr_extent,
>  				       cxl_dr_ext->hpa_offset,
>  				       cxl_dr_ext->hpa_length,
>  				       cxl_dr_ext->label);
>  	if (rc) {
> +		dax_region_rm_resource(dr_extent);
>  		kfree(dr_extent);
as above.

>  		return rc;
>  	}
> diff --git a/drivers/dax/dax-private.h b/drivers/dax/dax-private.h
> index 250babd6e470..ad73b53aa802 100644
> --- a/drivers/dax/dax-private.h
> +++ b/drivers/dax/dax-private.h
> @@ -44,12 +44,16 @@ struct dax_region {
>  /*
>   * struct dax_region_extent - extent data defined by the low level region
>   * driver.
> + * @region: cache of dax_region
> + * @res: cache of resource tree for this extent
>   * @private_data: lower level region driver data

Not sure 'lower level' is well defined here. Is "region driver data"
not enough?

>   * @ref: track number of dax devices which are using this extent
>   * @get: get reference to low level data
>   * @put: put reference to low level data
>   */
>  struct dax_region_extent {
> +	struct dax_region *region;
> +	struct resource *res;
>  	void *private_data;
>  	struct kref ref;
>  	void (*get)(struct dax_region_extent *dr_extent);
> @@ -131,6 +135,7 @@ struct dev_dax {
>  		unsigned long pgoff;
>  		struct range range;
>  		struct dax_mapping *mapping;
> +		struct dax_region_extent *dr_extent;

Huh. Seems that ranges is in the kernel doc but not the
bits that make that up.  Maybe good to add the docs
whilst here?

>  	} *ranges;
>  };
>  
> 


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id BE9FCC83F12
	for <linux-cxl@archiver.kernel.org>; Wed, 30 Aug 2023 00:18:13 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S233660AbjH3ARn (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 29 Aug 2023 20:17:43 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:33702 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S232960AbjH3ARP (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 29 Aug 2023 20:17:15 -0400
Received: from mgamail.intel.com (mgamail.intel.com [192.55.52.93])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 6479ED7;
        Tue, 29 Aug 2023 17:17:13 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1693354633; x=1724890633;
  h=date:from:to:cc:subject:message-id:references:
   in-reply-to:mime-version;
  bh=ZVvr60VjQCSMZ2ACnGKrWXHbv4Z0dd9UlPQInAm3oUQ=;
  b=jQ7UED3Gi7nXY+6KDNcHwzJVJFXxxJ7jiOWyRdTj+YbTrtD+0sl6gMnc
   ig87QX5HjIISsY9WPS6Eo0oJRyx9dcCW0iBFYL6eKhoRajCzm45uQEa2i
   2//jQVArgZx5Ui4LJq6RwCFq5Ik8bFTVfh0t+IGsxIxT3b1xoyT3A1bkS
   sgg3M+InuqWh7xhxqCFF8AVfmpnwuKmEfZqOVZIejaEIi44TzK1OKirG4
   hF46d8hoHPCib5ukCQ/p0z41Nfqq5nnqJLoB9dDmJEpiVm3vUuwsRnkC7
   cOmKNBOf9dYK7XaCSQ+GjWrcdvfL9yxi0HuqCuvFnzhzQPAS/TjipXEc/
   w==;
X-IronPort-AV: E=McAfee;i="6600,9927,10817"; a="372923323"
X-IronPort-AV: E=Sophos;i="6.02,211,1688454000"; 
   d="scan'208";a="372923323"
Received: from fmsmga008.fm.intel.com ([10.253.24.58])
  by fmsmga102.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 29 Aug 2023 17:17:13 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10817"; a="804314580"
X-IronPort-AV: E=Sophos;i="6.02,211,1688454000"; 
   d="scan'208";a="804314580"
Received: from fmsmsx603.amr.corp.intel.com ([10.18.126.83])
  by fmsmga008.fm.intel.com with ESMTP; 29 Aug 2023 17:17:12 -0700
Received: from fmsmsx612.amr.corp.intel.com (10.18.126.92) by
 fmsmsx603.amr.corp.intel.com (10.18.126.83) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27; Tue, 29 Aug 2023 17:17:12 -0700
Received: from fmsmsx603.amr.corp.intel.com (10.18.126.83) by
 fmsmsx612.amr.corp.intel.com (10.18.126.92) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27; Tue, 29 Aug 2023 17:17:12 -0700
Received: from fmsedg601.ED.cps.intel.com (10.1.192.135) by
 fmsmsx603.amr.corp.intel.com (10.18.126.83) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.27 via Frontend Transport; Tue, 29 Aug 2023 17:17:12 -0700
Received: from NAM11-DM6-obe.outbound.protection.outlook.com (104.47.57.171)
 by edgegateway.intel.com (192.55.55.70) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.27; Tue, 29 Aug 2023 17:17:11 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=TLpNBk7FP3IwykgwiVIMxQnyLVp/UWfSSD/KP0APhdQyPz0Vm2zm2E/savAVJtge6Ex7Uro7wnZ8mPdC7VUNE8aWhfKMBV0eyMtC3WEi84XKHjohAvEy+B+cxeGtQUjOHmxog8jxeE5MhviKXFW9Ht3/Igaq/SMVLDn2NM7Ct5xtMB8aj5kuHzvIReEq7y3SXkiUlUdc00JBXUzqR1fimV8/o0mEnH8dMnFOMEWBSnZBe8ht+SXghRW18rZK3XOlA1lGxK8C6aL9t9aG+kbtTc2f3pqVXH5Q4ibVyK01y1CFaBK60szOhZgyh3tzvvPLXjZRCp7zMQLNMZSl8l4XAw==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=o90nXvxfYJHAygPRAGF3f9Ao6JkNPRFwbhtnjH+OeRY=;
 b=UvxiWQ8Q1dmEr5z0OvUhy/i/3sM3yw53n6usJSfzHlHIRlnggihqOFDa+XeKM6HyyFnBdGxiF0fYeULvLKRiZLhEuuqDNn16RP8jPqpndSDMfBQkuVIylYaNxECrDrL8q7GjuhTeTzkNxwAf0bwyYyj+0n08D4J4KBDOk8YgLn77kQSIjNQQcYdA/Ny3Qh46MwNexpOyOphn1ZYRVzM+MbhEB0Zb1mV2IuVVn2iOHcY1GqgOf/CY0vy1Uu20ar5+nA6BLfQYaL7/8bsCx0k6LmFz5l2y9h1x4+iBl0dzxfkczS02vEZyHbTfRKouAn6vqkrWKPxKfNfo+e6kUIVMOg==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from SA1PR11MB6733.namprd11.prod.outlook.com (2603:10b6:806:25c::17)
 by CY8PR11MB7396.namprd11.prod.outlook.com (2603:10b6:930:87::11) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.6699.35; Wed, 30 Aug
 2023 00:17:04 +0000
Received: from SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938]) by SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938%6]) with mapi id 15.20.6699.034; Wed, 30 Aug 2023
 00:17:04 +0000
Date: Tue, 29 Aug 2023 17:16:59 -0700
From: Ira Weiny <ira.weiny@intel.com>
To: Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Ira Weiny <ira.weiny@intel.com>
CC: Dan Williams <dan.j.williams@intel.com>,
        Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
Subject: Re: [PATCH RFC v2 09/18] cxl/mem: Read extents on memory device
 discovery
Message-ID: <64ee8a7b2c69a_18d28a294ad@iweiny-mobl.notmuch>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
 <20230604-dcd-type2-upstream-v2-9-f740c47e7916@intel.com>
 <20230829162600.00004ac2@Huawei.com>
Content-Type: text/plain; charset="us-ascii"
Content-Disposition: inline
In-Reply-To: <20230829162600.00004ac2@Huawei.com>
X-ClientProxiedBy: SJ0PR03CA0146.namprd03.prod.outlook.com
 (2603:10b6:a03:33c::31) To SA1PR11MB6733.namprd11.prod.outlook.com
 (2603:10b6:806:25c::17)
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: SA1PR11MB6733:EE_|CY8PR11MB7396:EE_
X-MS-Office365-Filtering-Correlation-Id: dfa8b969-7d68-4edc-d517-08dba8ee7020
X-LD-Processed: 46c98d88-e344-4ed4-8496-4ed7712e255d,ExtAddr
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;
X-Microsoft-Antispam-Message-Info: LeNRRJRfQ2F8eZa0+1bGng4iBa1DmuTCpEeC7vHdgnuJl2NnlPYudaELHzOlM/4NntC8AkOJLKpfN3wg3ltbk0mDTGWMEu90JRj4JwRwTCdiZ3gG/D5SG71JJzyynONTaMJH4P0miaEij/VvqoM1sYFtpBYkR+SLTbraDDLcse3WDfam3UABDnv+9TDAxgOhsyi8LBemZyrR0ArXB9EpiaqEZ79E2nAa43oqdau7/He1qZPAFSHequU5rwv8RJkpfjMs0waiDaHLQWh98ahHMZM5pME/UPwyJSTtxQ5rBgirvlLCIdbTwLhzfLyih/UlkvUzD5UeRN8WuCOhtyo4xxwXV09X+EH4e0eioiBwIdF5ZjkwJSDhvzQSVRi+IQ3AdQ4TqZcRBqKfMap3I2R96I4LLBZ6JZYOHNEvoG5fxn1CwowotiDsLkEMJE9Pahs5/9fA2IdsXAgihGM2S0z919snQ7mS7i4EButi9zfQXoQHWL3eEy6xfNww0AMKmczddu3q5JsAj48UAsPRLQk4y+tIJ9NXXJGx9p3iopHoRPkk2nwdqzC17Q4uBRsQiUba
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:SA1PR11MB6733.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230031)(396003)(346002)(136003)(376002)(366004)(39860400002)(1800799009)(186009)(451199024)(8936002)(6666004)(110136005)(478600001)(6506007)(66556008)(66946007)(66476007)(54906003)(6486002)(316002)(38100700002)(41300700001)(82960400001)(9686003)(6512007)(26005)(44832011)(8676002)(5660300002)(2906002)(86362001)(4326008);DIR:OUT;SFP:1102;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?us-ascii?Q?vpSg/NQiRYZaTLPDrGBRLrjJYuvr4QoZIzm27U9Z/ot20Zn9QHVF/Hm/YxrI?=
 =?us-ascii?Q?jvMb535B+0zlgKya8yZ4wfrMTl0KXP/KbspttW2vta0/VkDZFdjtzmQWdZrX?=
 =?us-ascii?Q?V2vgWm6HX6jMz+8Lt4ZqoA1MrbZm8WlsNzgEkZpPDYSvjBmAYOYu25ivOySa?=
 =?us-ascii?Q?q8kJwi0PEm54m/nD00XtMugVO52DuQgL5Vr67KRLoZV/uCweVzSFDPE1ZNXS?=
 =?us-ascii?Q?t26OYHFX4YzYuBGozCX3it9aWPfS4PkCODEOvF8+m079x2WAKHbT2kIiuaf1?=
 =?us-ascii?Q?K2pSpBbp8FGd5trY4cX+RqaQRqtH+imX/+u1ttFhe7Ghr1EUL3ck/2bfMOWz?=
 =?us-ascii?Q?GV3raHs6rhvCxpIFMDq5btIQBrkNgVeZFpzj9GrUKjmyae+aefpGWE0f6SLL?=
 =?us-ascii?Q?nxF/3Ze6wDgEgVEGvNAG2F0LQTkuwX0esbh1NfG1QGXX3bj5y/u0Gn1FJMFj?=
 =?us-ascii?Q?LZeDuE1EcVNvkHECPP6oESXGN+xYcXhL30eFgLnqBBcwulst3E88e9ESDV4i?=
 =?us-ascii?Q?lTABJzzo1lcimhO41QODN3tDRJxmDL8R7+mMUrOZzufA/qVk0WFKxqOWJOZO?=
 =?us-ascii?Q?4jZYrPNY2hIEI7NDQPLJid1kJu1qmMvsLzeKVSJ/mnLIqi0msDsgB12jTx3H?=
 =?us-ascii?Q?kKChYzq/H81bb2SYjE0JO56CWI5kdnean69vvLUXRGNi73vfaU4t4gmqn59q?=
 =?us-ascii?Q?zYg5q+WKyTEK4tZxymhcV1VacBuAm5bpPxqtORJ9mVoHsLTL4E8esrIKeSIN?=
 =?us-ascii?Q?1hjtiYc3xVqxpnBMrQ65DZIJC6rBRfkob8A00QtGCBcFvsOdfvGhJCsmoSzQ?=
 =?us-ascii?Q?zIzFf+4lvpyJdhlzv+KgNPn5oA8BBWvFKXwi0ZU96trMmSmAkOdJ+s6kjoM7?=
 =?us-ascii?Q?qX/6KygPeBZTKpjahruWIOfqF27JIhe82JqavWjsIO4lNSdi23m7SKTWP80o?=
 =?us-ascii?Q?mIPUQhDE1WvhfppvPivO1CgP5LzMDe6JGp/3s8oLfJy1nFRoompIAA+dZNyw?=
 =?us-ascii?Q?MNzbxwrQTIRjv/aFBEnw8U7egVvoXYqaIsKmUdWVK/oAYcWXXwhYlq95LRmg?=
 =?us-ascii?Q?/ui23v2sVr3pAKpVByEPxwTeKq7HYQIH32tdtxFlEQTZsYNZYmNZ9IJI/vap?=
 =?us-ascii?Q?+2bepj05y8/5rHuOUeEahre7NqwHffKl/riRUeUhxqQ0FYNn31M4qjOwf3AB?=
 =?us-ascii?Q?1BWdXl1Gbgn8vk4jFXp5qqRfFcMxGIyUF8M7T1/n1tfH/jn1OX1QswP3V5BD?=
 =?us-ascii?Q?KMVxzjematYYvICipD14yVNRWS4TaCVnyeEdCBkEseRIvuj+QLMV2feBFkIr?=
 =?us-ascii?Q?ojL9+itqki44qzK91DLzcA+R+esIUQsdl1hRCwoypENs/aBsveIf0iBWjI3g?=
 =?us-ascii?Q?8+8BKURQrvTdGQ/SNrcaKD0xmCEL1zIEM3yuJGW9A80REQgb1abMArJ+W3o1?=
 =?us-ascii?Q?9mSgRr48nDnP36WP3Q8H+uGvWELAeTZOR86cMPGNOxQb4lr+C7aHuPxLV+Qg?=
 =?us-ascii?Q?ByjR3c1oaAv3xSms8bbED5y4+IOpeZWc3Y0P7vylI1DRip81Sgv1wwfojbsi?=
 =?us-ascii?Q?RDKuJ1T8ImP8KKRJV3ThXdefsmoxTash9oTBVu+w?=
X-MS-Exchange-CrossTenant-Network-Message-Id: dfa8b969-7d68-4edc-d517-08dba8ee7020
X-MS-Exchange-CrossTenant-AuthSource: SA1PR11MB6733.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 30 Aug 2023 00:17:04.2805
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: UrZU8lQxHWuL/NA8H9P5cYu/bw3lXntr9HtYWDARhU0AKt/mGOl5zIzIwyNkwLs5DmYTuNL1oQwMQaJNN1fbUA==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: CY8PR11MB7396
X-OriginatorOrg: intel.com
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

Jonathan Cameron wrote:
> On Mon, 28 Aug 2023 22:21:00 -0700
> Ira Weiny <ira.weiny@intel.com> wrote:
> 

[snip]

I'll go through each review but I had to respond to this one...

> 
> > +		.payload_out = &dc_extents,
> > +		.min_out = 1,
> > +	};
> > +
> > +	rc = cxl_internal_send_cmd(mds, &mbox_cmd);
> > +	if (rc < 0)
> > +		return rc;
> > +
> > +	count = le32_to_cpu(dc_extents.total_extent_cnt);
> > +	*extent_gen_num = le32_to_cpu(dc_extents.extent_list_num);
> > +
> > +	return count;
> > +}
> > +
> > +static int cxl_dev_get_dc_extents(struct cxl_memdev_state *mds,
> > +				  unsigned int start_gen_num,
> > +				  unsigned int exp_cnt)
> > +{
> > +	struct cxl_mbox_dc_extents *dc_extents;
> > +	unsigned int start_index, total_read;
> > +	struct device *dev = mds->cxlds.dev;
> > +	struct cxl_mbox_cmd mbox_cmd;
> > +	int retry = 3;
> 
> Why 3?
> 

Then shall thou count to 3, no more, no less...
4 shall thou not count...
5 is right out...

;-)

Seriously, it seemed like a decent number to try.  I would hope that the
extents are not changing much as the host is booting or the device drivers
are loading.  But since the generation number is there I figured it was
fine to try again.

However, its been a while since I focused on this patch and as I look at
it now I realize that retrying is going to be a problem anyway.  Some of
the old extents from the previous generation may have been stored and the
new list is likely to have the same extents.  Which would result in errors
later.

I think it is best to remove the retry and just throw an error.

Thanks for catching,
Ira

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 80C49C71153
	for <linux-cxl@archiver.kernel.org>; Tue, 29 Aug 2023 21:51:00 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S233744AbjH2Vub (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 29 Aug 2023 17:50:31 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:52794 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S238511AbjH2VuT (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 29 Aug 2023 17:50:19 -0400
Received: from mout.gmx.net (mout.gmx.net [212.227.15.19])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 9452ECC0;
        Tue, 29 Aug 2023 14:50:16 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=gmx.us;
 s=s31663417; t=1693345763; x=1693950563; i=fan.ni@gmx.us;
 bh=E0d/5x/RmE517ERqUPY+Iqcr/9gBktMSOn8LBSbCfQ0=;
 h=X-UI-Sender-Class:Date:From:To:Cc:Subject:References:In-Reply-To;
 b=kcu/RKady7pp/Ab23TjYDeKiABljeNbqjppR3ccdpEDoIqVJxdUcNBi7kknmMoydzLuPoHr
 OvRStfbqIhGu3WKQxAbOm/QO84aMs9CK3VjTjxdbUvv0DeiuM+O8gP/+yqzT0gGBYeWxkp9dn
 GymfXUDJU8eGq3cR+DGjGwIG0UzBggZd197EBsHgPzvPy+iV4sSBdpw9MTxzjBIQO/m28sKDX
 roNd9rsVddCuXtqjXzuPyNf3/plMkGPt5cgtDZl0FTO0AaZJamY9EUzxZ63aV8mL9LIOoWVmJ
 vzh64nGbugRTJF+ENiUYLN2Gf9DOkIDOSwNIU9A/wi4y1Kue045Q==
X-UI-Sender-Class: 724b4f7f-cbec-4199-ad4e-598c01a50d3a
Received: from debian ([50.205.20.42]) by mail.gmx.net (mrgmx005
 [212.227.17.184]) with ESMTPSA (Nemesis) id 1MHGCo-1qWgja0xLk-00DJwF; Tue, 29
 Aug 2023 23:49:22 +0200
Date: Tue, 29 Aug 2023 14:49:15 -0700
From: Fan Ni <fan.ni@gmx.us>
To: Ira Weiny <ira.weiny@intel.com>
Cc: Dan Williams <dan.j.williams@intel.com>,
        Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        linux-cxl@vger.kernel.org, linux-kernel@vger.kernel.org
Subject: Re: [PATCH RFC v2 02/18] cxl/mbox: Flag support for Dynamic Capacity
 Devices (DCD)
Message-ID: <ZO5n2+Kc+VpWXMlk@debian>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
 <20230604-dcd-type2-upstream-v2-2-f740c47e7916@intel.com>
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: <20230604-dcd-type2-upstream-v2-2-f740c47e7916@intel.com>
X-Provags-ID: V03:K1:YoAvlo2RfG5dULrcWzNlH9zDToUU3T+J3eqxkZ+OpHaXLoqMusA
 k5RlOuADzCm6OTy4FtcwJ2b4sVBsfToNqwo4FKlr65PfZu897/qJbw8wTm5TJede4RohCcj
 eu53KYERdmnMvwUyoF2GwQS9lRfwBh1Y7/0Q+dA/n2b2ZGA2BMAKKF9NRLeHYT4x4SGnQlM
 KdLjMPT3zj7WHyjqzROtA==
UI-OutboundReport: notjunk:1;M01:P0:mJ87uB9AMqY=;lwrlQ/ra4pPz5PMy/Nt8klMyHm9
 qsaKkxKmKSsNbWzaQZqQGPiXPkjS89BUkxSPLp5PGNuOCdVWAw9gWc5RQJREKDBEWeHOqs8Pc
 uh4wotJbjNMa0w96xlHuV/qoFhU2A8X6Ux0SHmdyTCIVO8NNZVwq/6y+yZpGi3lUKuarm76OF
 oyEzPrtXMCSR8UfvaXRV2TSG3t9cal4Q+1M9t5bQ0bo8WsHV6mD2PuWeKKRFvEGfpq7sDufPQ
 Y2lOucS0S1VnYlgN0lSmlsFwIxY1jQ1dxHEqPcYLrBnl/psFpvMYmwou2VCJF2NCydVleF6WF
 rGnNQ9JIHG8u4jl/hufh4Aia0ymxvOvmT8q2WFPv+TaoA8XgQ9qmHWx9pMe/t92wN5kWmHVZ2
 opiIAr6rBJ+7VVwbmUWXhE5JQ/KZ4uifch49aLZm/39cJKVqr6d7hTFaByF0ne5rvjwv8WaHn
 yLkTl+E8nmDpnY0rUoYC2X/WhUTbJUs5lx/b7N36l/etMat3hBrI4Wqgh3Yb7KVYE6qU7tAzO
 m/+qPdLxVkXWfvIL7CVepau6rUP0WGRl7+PVbMKASyHuL46inPbyrxl8P/TAx/U0WKjv/uMwJ
 IGZnU6RDZduXtUZsHZzvEjFEvbpIbvrvxoFi5fxiB2bw63nVBdbXLKHptEfuRQrX6Q9K1p0O9
 xnFNV+yUznu5k/yLBa3inCtZdB2rl9A1BWHuKYTDEm3tyrSyo9+Y9JsAvN2v9m7l771EE0vP7
 BQkNQjcp6Hi4/BwJPnieGKPwmbPYVzTLEo7oF3ZAfe04CNgvywfaIG/dOAKvpfHoAkNsJZN6q
 cxlGXwG+p7ooypyEZ7OmP+aAIFw+SoXqdNk46094ZHXP56o4uSCBAL8FngYpWzh8n5WZmD5/W
 FVv2F15e50IYwRybTr42zFsf6/UEXfiTl0cWt99f2ZV3c3Xb832rZGYfXMxTFF2G66z9TSAON
 e/Kp75DBbiUfPEJP9jEw9hEALDA=
Content-Transfer-Encoding: quoted-printable
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

On Mon, Aug 28, 2023 at 10:20:53PM -0700, Ira Weiny wrote:
> Per the CXL 3.0 specification software must check the Command Effects
> Log (CEL) to know if a device supports DC.  If the device does support
> DC the specifics of the DC Regions (0-7) are read through the mailbox.
>
> Flag DC Device (DCD) commands in a device if they are supported.
> Subsequent patches will key off these bits to configure a DCD.
>
> Co-developed-by: Navneet Singh <navneet.singh@intel.com>
> Signed-off-by: Navneet Singh <navneet.singh@intel.com>
> Signed-off-by: Ira Weiny <ira.weiny@intel.com>
>

Reviewed-by: Fan Ni <fan.ni@samsung.com>

> ---
> Changes for v2
> [iweiny: new patch]
> ---
>  drivers/cxl/core/mbox.c | 38 +++++++++++++++++++++++++++++++++++---
>  drivers/cxl/cxlmem.h    | 15 +++++++++++++++
>  2 files changed, 50 insertions(+), 3 deletions(-)
>
> diff --git a/drivers/cxl/core/mbox.c b/drivers/cxl/core/mbox.c
> index f052d5f174ee..554ec97a7c39 100644
> --- a/drivers/cxl/core/mbox.c
> +++ b/drivers/cxl/core/mbox.c
> @@ -111,6 +111,34 @@ static u8 security_command_sets[] =3D {
>  	0x46, /* Security Passthrough */
>  };
>
> +static bool cxl_is_dcd_command(u16 opcode)
> +{
> +#define CXL_MBOX_OP_DCD_CMDS 0x48
> +
> +	return (opcode >> 8) =3D=3D CXL_MBOX_OP_DCD_CMDS;
> +}
> +
> +static void cxl_set_dcd_cmd_enabled(struct cxl_memdev_state *mds,
> +					u16 opcode)
> +{
> +	switch (opcode) {
> +	case CXL_MBOX_OP_GET_DC_CONFIG:
> +		set_bit(CXL_DCD_ENABLED_GET_CONFIG, mds->dcd_cmds);
> +		break;
> +	case CXL_MBOX_OP_GET_DC_EXTENT_LIST:
> +		set_bit(CXL_DCD_ENABLED_GET_EXTENT_LIST, mds->dcd_cmds);
> +		break;
> +	case CXL_MBOX_OP_ADD_DC_RESPONSE:
> +		set_bit(CXL_DCD_ENABLED_ADD_RESPONSE, mds->dcd_cmds);
> +		break;
> +	case CXL_MBOX_OP_RELEASE_DC:
> +		set_bit(CXL_DCD_ENABLED_RELEASE, mds->dcd_cmds);
> +		break;
> +	default:
> +		break;
> +	}
> +}
> +
>  static bool cxl_is_security_command(u16 opcode)
>  {
>  	int i;
> @@ -677,9 +705,10 @@ static void cxl_walk_cel(struct cxl_memdev_state *m=
ds, size_t size, u8 *cel)
>  		u16 opcode =3D le16_to_cpu(cel_entry[i].opcode);
>  		struct cxl_mem_command *cmd =3D cxl_mem_find_command(opcode);
>
> -		if (!cmd && !cxl_is_poison_command(opcode)) {
> -			dev_dbg(dev,
> -				"Opcode 0x%04x unsupported by driver\n", opcode);
> +		if (!cmd && !cxl_is_poison_command(opcode) &&
> +		    !cxl_is_dcd_command(opcode)) {
> +			dev_dbg(dev, "Opcode 0x%04x unsupported by driver\n",
> +				opcode);
>  			continue;
>  		}
>
> @@ -689,6 +718,9 @@ static void cxl_walk_cel(struct cxl_memdev_state *md=
s, size_t size, u8 *cel)
>  		if (cxl_is_poison_command(opcode))
>  			cxl_set_poison_cmd_enabled(&mds->poison, opcode);
>
> +		if (cxl_is_dcd_command(opcode))
> +			cxl_set_dcd_cmd_enabled(mds, opcode);
> +
>  		dev_dbg(dev, "Opcode 0x%04x enabled\n", opcode);
>  	}
>  }
> diff --git a/drivers/cxl/cxlmem.h b/drivers/cxl/cxlmem.h
> index adfba72445fc..5f2e65204bf9 100644
> --- a/drivers/cxl/cxlmem.h
> +++ b/drivers/cxl/cxlmem.h
> @@ -247,6 +247,15 @@ struct cxl_event_state {
>  	struct mutex log_lock;
>  };
>
> +/* Device enabled DCD commands */
> +enum dcd_cmd_enabled_bits {
> +	CXL_DCD_ENABLED_GET_CONFIG,
> +	CXL_DCD_ENABLED_GET_EXTENT_LIST,
> +	CXL_DCD_ENABLED_ADD_RESPONSE,
> +	CXL_DCD_ENABLED_RELEASE,
> +	CXL_DCD_ENABLED_MAX
> +};
> +
>  /* Device enabled poison commands */
>  enum poison_cmd_enabled_bits {
>  	CXL_POISON_ENABLED_LIST,
> @@ -436,6 +445,7 @@ struct cxl_dev_state {
>   *                (CXL 2.0 8.2.9.5.1.1 Identify Memory Device)
>   * @mbox_mutex: Mutex to synchronize mailbox access.
>   * @firmware_version: Firmware version for the memory device.
> + * @dcd_cmds: List of DCD commands implemented by memory device
>   * @enabled_cmds: Hardware commands found enabled in CEL.
>   * @exclusive_cmds: Commands that are kernel-internal only
>   * @total_bytes: sum of all possible capacities
> @@ -460,6 +470,7 @@ struct cxl_memdev_state {
>  	size_t lsa_size;
>  	struct mutex mbox_mutex; /* Protects device mailbox and firmware */
>  	char firmware_version[0x10];
> +	DECLARE_BITMAP(dcd_cmds, CXL_DCD_ENABLED_MAX);
>  	DECLARE_BITMAP(enabled_cmds, CXL_MEM_COMMAND_ID_MAX);
>  	DECLARE_BITMAP(exclusive_cmds, CXL_MEM_COMMAND_ID_MAX);
>  	u64 total_bytes;
> @@ -525,6 +536,10 @@ enum cxl_opcode {
>  	CXL_MBOX_OP_UNLOCK		=3D 0x4503,
>  	CXL_MBOX_OP_FREEZE_SECURITY	=3D 0x4504,
>  	CXL_MBOX_OP_PASSPHRASE_SECURE_ERASE	=3D 0x4505,
> +	CXL_MBOX_OP_GET_DC_CONFIG	=3D 0x4800,
> +	CXL_MBOX_OP_GET_DC_EXTENT_LIST	=3D 0x4801,
> +	CXL_MBOX_OP_ADD_DC_RESPONSE	=3D 0x4802,
> +	CXL_MBOX_OP_RELEASE_DC		=3D 0x4803,
>  	CXL_MBOX_OP_MAX			=3D 0x10000
>  };
>
>
> --
> 2.41.0
>

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id A4DF0C71153
	for <linux-cxl@archiver.kernel.org>; Tue, 29 Aug 2023 21:49:56 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S231250AbjH2Vt0 (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 29 Aug 2023 17:49:26 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:43440 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S237237AbjH2VtJ (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 29 Aug 2023 17:49:09 -0400
Received: from mout.gmx.net (mout.gmx.net [212.227.15.18])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id D914ACC3;
        Tue, 29 Aug 2023 14:49:04 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=gmx.us;
 s=s31663417; t=1693345720; x=1693950520; i=fan.ni@gmx.us;
 bh=a9Wnn2WFAKosOzabvPuR9+jFl4rAp8iJnreXsjbwH0Q=;
 h=X-UI-Sender-Class:Date:From:To:Cc:Subject:References:In-Reply-To;
 b=Q2Z27HapZN0BavqN1ThoOPaAeM9dDonJ5ssWsvbCt/tKqCaRa866100nQaG5+7ZxUj5KCGo
 37u+RZc3sLxfhnVvEqh3IdRYXvqvgUAQ/o2gQtS9W6QXxTZgYTX3tMofPNG7pYY+dyc/0ZSbC
 8tr7/bRPxLpVW9h4Gud99qpl6n1Z5d6AEWKdui2CTtq6E3mwiwpw6VAR9YDG8BJ1Qjk3g7dtV
 ybIeOE+TLMtvUGvCUiHXg1FDZysIDdx5gieBSPaIHoTfA2DMTKTCRcEZ6t9srdPzI1m5iWfc5
 vuIVrYJsxwfxPxE4qk4qtnKCIUyuuygYY+Dp3qC4o55+ujlGD73A==
X-UI-Sender-Class: 724b4f7f-cbec-4199-ad4e-598c01a50d3a
Received: from debian ([50.205.20.42]) by mail.gmx.net (mrgmx004
 [212.227.17.184]) with ESMTPSA (Nemesis) id 1MryXH-1pwnSs2d8v-00nylh; Tue, 29
 Aug 2023 23:48:40 +0200
Date: Tue, 29 Aug 2023 14:48:28 -0700
From: Fan Ni <fan.ni@gmx.us>
To: Jonathan Cameron <Jonathan.Cameron@huawei.com>
Cc: Ira Weiny <ira.weiny@intel.com>,
        Dan Williams <dan.j.williams@intel.com>,
        Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        linux-cxl@vger.kernel.org, linux-kernel@vger.kernel.org
Subject: Re: [PATCH RFC v2 01/18] cxl/hdm: Debug, use decoder name function
Message-ID: <ZO5nrKyE/snTdE9D@debian>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
 <20230604-dcd-type2-upstream-v2-1-f740c47e7916@intel.com>
 <20230829150320.00007f08@Huawei.com>
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: <20230829150320.00007f08@Huawei.com>
X-Provags-ID: V03:K1:NHousnP49LQdt2FZt+BuG85wA2deMqMCR17CP+ov3XNePx0V9t9
 khkmI1CQj09ejvZB5jI4lHuZmwkf8y5MlnOlnzVXxo39oUhLEu8d05qGEJ3nZ+LKCu80rJ8
 oCbzOtkAa2/mK3NYIcmuRcSM4s7aMgOEH2YV85ZV6hPsAIyHnCtFTnlaT6rjOdSpjRjPlZq
 lHlc9XN6whtMGiryLt+rg==
UI-OutboundReport: notjunk:1;M01:P0:UbirIdvpEZQ=;83OU6fRnDwzmVaJV+wlbK60rZd5
 117TRmSHk4n+1HFQGiNhVuGwWdRfdCmPSCmtOgErCymN7CR2KUDXhbL80+JQmEYFmCQy5gUuE
 /EleYr9WRqJ/SW22jvhp5guDV6SDfsq0kJSfv442/l9y1KJ0qjbng0NDyDsNNkmKABQVG5c3w
 NXt+G7tk1ulcBngi+h7mYjXsZNQYTRCkjZ0B5TVgwjBnrZnqpvO94zoCRWDsVcPUqxVzkJrmH
 BFwiDdsLicuZ37+Eoc1l1LCKFBm7dIKUwyhnqGhe/2xgGsJpgLpWRYXpuwhkUc201ZSOU5b3u
 5Y2T+jrY7SY3H57NAXTeRUxSeLaOEWR5YmkfJcXwjGSrUwvtADceirgCpuEfMk968S7C0q4BI
 8iG9WMcA0KiOGY+ImvA4wwMPAkH/3Gbw/Xn90iOVL93ETL+POPju537C+ojSjpUsAhnQyndfX
 nqULu8w0QynHAiwneu9OWmACSGyjPCIV1f94kQCaT64VfuWRwMZ2jnFkXbm+VBC4/Rs+d3in6
 57eAXDClJ0IFkoPq4vDFv2yxlfzb1T64HlnOwetwGoHDyTP0bnRA0QnH9nnZO3EXL6NRk8fL4
 A9EHTYunZ3/QszrofB5QhNHOvPehyCN+YhED9+F15BtQHxsff/mwA+S/fVOw1hg6AagcO9557
 03nDeNxJ522kqmXif+JPgV1lH4RzS5/dbEWdWzhH1NfbMBu8mOzv9n+DLq6v3kiRMleZDKSoi
 6ZWKAgu5YerHMZLnsl9ONIrAdXRHEZaHCT5DcY7Doo4sd8XtmQMDot2946XWYXc5wZK4LQ0i6
 xDngN1Q01A1wu0dsVZUFUeF2bZoI2Q3uhkcrwREQw8o1bjTobsD4MvIO7jb9ElvCbGlyd+roK
 fNdUdv0FRXcKI67TQdQl45C39t7Sse2/dosznCtseU7Wkgjp1Sa3Av/zV+BXvtnPDYXHC8O6c
 p8Qjxg+xJw63eiLAk6Yct+7MSG0=
Content-Transfer-Encoding: quoted-printable
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

On Tue, Aug 29, 2023 at 03:03:20PM +0100, Jonathan Cameron wrote:
> On Mon, 28 Aug 2023 22:20:52 -0700
> Ira Weiny <ira.weiny@intel.com> wrote:
>
> > The decoder enum has a name conversion function defined now.
> >
> > Use that instead of open coding.
> >
> > Suggested-by: Navneet Singh <navneet.singh@intel.com>
> > Signed-off-by: Ira Weiny <ira.weiny@intel.com>
> >
>
> Perhaps pull this one out so it can go upstream before the rest are read=
y,
> or could be picked up from here.
>
> Whilst we probably won't see the other decoder modes in here, there
> is no reason why anyone reading the code should have to figure that out.
> As such much better to use the more generic function.
>
> Reviewed-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
>

Agreed. This patch can be pulled out and picked up before the rest.


Reviewed-by: Fan Ni <fan.ni@samsung.com>


> > ---
> > Changes for v2:
> > [iweiny: new patch, split out]
> > ---
> >  drivers/cxl/core/hdm.c | 3 +--
> >  1 file changed, 1 insertion(+), 2 deletions(-)
> >
> > diff --git a/drivers/cxl/core/hdm.c b/drivers/cxl/core/hdm.c
> > index b01a77b67511..a254f79dd4e8 100644
> > --- a/drivers/cxl/core/hdm.c
> > +++ b/drivers/cxl/core/hdm.c
> > @@ -550,8 +550,7 @@ int cxl_dpa_alloc(struct cxl_endpoint_decoder *cxl=
ed, unsigned long long size)
> >
> >  	if (size > avail) {
> >  		dev_dbg(dev, "%pa exceeds available %s capacity: %pa\n", &size,
> > -			cxled->mode =3D=3D CXL_DECODER_RAM ? "ram" : "pmem",
> > -			&avail);
> > +			cxl_decoder_mode_name(cxled->mode), &avail);
> >  		rc =3D -ENOSPC;
> >  		goto out;
> >  	}
> >
>

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 6D5FFC83F14
	for <linux-cxl@archiver.kernel.org>; Tue, 29 Aug 2023 16:47:20 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S237521AbjH2Qqt (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 29 Aug 2023 12:46:49 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:41804 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S237537AbjH2Qql (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 29 Aug 2023 12:46:41 -0400
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 209601A1;
        Tue, 29 Aug 2023 09:46:39 -0700 (PDT)
Received: from lhrpeml500005.china.huawei.com (unknown [172.18.147.226])
        by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4RZtWG5Wlyz67PFb;
        Wed, 30 Aug 2023 00:42:18 +0800 (CST)
Received: from localhost (10.202.227.76) by lhrpeml500005.china.huawei.com
 (7.191.163.240) with Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id 15.1.2507.31; Tue, 29 Aug
 2023 17:46:36 +0100
Date: Tue, 29 Aug 2023 17:46:35 +0100
From: Jonathan Cameron <Jonathan.Cameron@Huawei.com>
To: <ira.weiny@intel.com>
CC: Dan Williams <dan.j.williams@intel.com>,
        Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
Subject: Re: [PATCH RFC v2 15/18] cxl/mem: Trace Dynamic capacity Event
 Record
Message-ID: <20230829174635.00004371@Huawei.com>
In-Reply-To: <20230604-dcd-type2-upstream-v2-15-f740c47e7916@intel.com>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
        <20230604-dcd-type2-upstream-v2-15-f740c47e7916@intel.com>
Organization: Huawei Technologies Research and Development (UK) Ltd.
X-Mailer: Claws Mail 4.1.0 (GTK 3.24.33; x86_64-w64-mingw32)
MIME-Version: 1.0
Content-Type: text/plain; charset="US-ASCII"
Content-Transfer-Encoding: 7bit
X-Originating-IP: [10.202.227.76]
X-ClientProxiedBy: lhrpeml100003.china.huawei.com (7.191.160.210) To
 lhrpeml500005.china.huawei.com (7.191.163.240)
X-CFilter-Loop: Reflected
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

On Mon, 28 Aug 2023 22:21:06 -0700
ira.weiny@intel.com wrote:

> From: Navneet Singh <navneet.singh@intel.com>
> 
> CXL rev 3.0 section 8.2.9.2.1.5 defines the Dynamic Capacity Event Record
> Determine if the event read is a Dynamic capacity event record and
> if so trace the record for the debug purpose.
> 
> Add DC trace points to the trace log.

Probably should say why these might be useful...


> 
> Signed-off-by: Navneet Singh <navneet.singh@intel.com>
> Signed-off-by: Ira Weiny <ira.weiny@intel.com>
> 
> ---
> [iweiny: fixups]
> ---
>  drivers/cxl/core/mbox.c  |  5 ++++
>  drivers/cxl/core/trace.h | 65 ++++++++++++++++++++++++++++++++++++++++++++++++
>  2 files changed, 70 insertions(+)
> 
> diff --git a/drivers/cxl/core/mbox.c b/drivers/cxl/core/mbox.c
> index 9d9c13e13ecf..9462c34aa1dc 100644
> --- a/drivers/cxl/core/mbox.c
> +++ b/drivers/cxl/core/mbox.c
> @@ -939,6 +939,11 @@ static void cxl_event_trace_record(const struct cxl_memdev *cxlmd,
>  				(struct cxl_event_mem_module *)record;
>  
>  		trace_cxl_memory_module(cxlmd, type, rec);
> +	} else if (uuid_equal(id, &dc_event_uuid)) {
> +		struct dcd_event_dyn_cap *rec =
> +				(struct dcd_event_dyn_cap *)record;
> +
> +		trace_cxl_dynamic_capacity(cxlmd, type, rec);
>  	} else {
>  		/* For unknown record types print just the header */
>  		trace_cxl_generic_event(cxlmd, type, record);
> diff --git a/drivers/cxl/core/trace.h b/drivers/cxl/core/trace.h
> index a0b5819bc70b..1899c5cc96b9 100644
> --- a/drivers/cxl/core/trace.h
> +++ b/drivers/cxl/core/trace.h
> @@ -703,6 +703,71 @@ TRACE_EVENT(cxl_poison,
>  	)
>  );
>  
> +/*
> + * DYNAMIC CAPACITY Event Record - DER
> + *
> + * CXL rev 3.0 section 8.2.9.2.1.5 Table 8-47
> + */
> +
> +#define CXL_DC_ADD_CAPACITY			0x00
> +#define CXL_DC_REL_CAPACITY			0x01
> +#define CXL_DC_FORCED_REL_CAPACITY		0x02
> +#define CXL_DC_REG_CONF_UPDATED			0x03
> +#define show_dc_evt_type(type)	__print_symbolic(type,		\
> +	{ CXL_DC_ADD_CAPACITY,	"Add capacity"},		\
> +	{ CXL_DC_REL_CAPACITY,	"Release capacity"},		\
> +	{ CXL_DC_FORCED_REL_CAPACITY,	"Forced capacity release"},	\
> +	{ CXL_DC_REG_CONF_UPDATED,	"Region Configuration Updated"	} \
> +)
> +
> +TRACE_EVENT(cxl_dynamic_capacity,
> +
> +	TP_PROTO(const struct cxl_memdev *cxlmd, enum cxl_event_log_type log,
> +		 struct dcd_event_dyn_cap  *rec),
> +
> +	TP_ARGS(cxlmd, log, rec),
> +
> +	TP_STRUCT__entry(
> +		CXL_EVT_TP_entry
> +
> +		/* Dynamic capacity Event */
> +		__field(u8, event_type)
> +		__field(u16, hostid)
> +		__field(u8, region_id)
> +		__field(u64, dpa_start)
> +		__field(u64, length)
> +		__array(u8, tag, CXL_DC_EXTENT_TAG_LEN)
> +		__field(u16, sh_extent_seq)
> +	),
> +
> +	TP_fast_assign(
> +		CXL_EVT_TP_fast_assign(cxlmd, log, rec->hdr);
> +
> +		/* Dynamic_capacity Event */
> +		__entry->event_type = rec->data.event_type;
> +
> +		/* DCD event record data */
> +		__entry->hostid = le16_to_cpu(rec->data.host_id);
> +		__entry->region_id = rec->data.region_index;
> +		__entry->dpa_start = le64_to_cpu(rec->data.extent.start_dpa);
> +		__entry->length = le64_to_cpu(rec->data.extent.length);
> +		memcpy(__entry->tag, &rec->data.extent.tag, CXL_DC_EXTENT_TAG_LEN);
> +		__entry->sh_extent_seq = le16_to_cpu(rec->data.extent.shared_extn_seq);
> +	),
> +
> +	CXL_EVT_TP_printk("event_type='%s' host_id='%d' region_id='%d' " \
> +		"starting_dpa=%llx length=%llx tag=%s " \
> +		"shared_extent_sequence=%d",
> +		show_dc_evt_type(__entry->event_type),
> +		__entry->hostid,
> +		__entry->region_id,
> +		__entry->dpa_start,
> +		__entry->length,
> +		__print_hex(__entry->tag, CXL_DC_EXTENT_TAG_LEN),
> +		__entry->sh_extent_seq
> +	)
> +);
> +
>  #endif /* _CXL_EVENTS_H */
>  
>  #define TRACE_INCLUDE_FILE trace
> 


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 94728C71153
	for <linux-cxl@archiver.kernel.org>; Tue, 29 Aug 2023 16:41:55 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S230217AbjH2QlY (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 29 Aug 2023 12:41:24 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:35518 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S236025AbjH2QlE (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 29 Aug 2023 12:41:04 -0400
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 59C8D198;
        Tue, 29 Aug 2023 09:40:57 -0700 (PDT)
Received: from lhrpeml500005.china.huawei.com (unknown [172.18.147.201])
        by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4RZtNh3fGbz67ZCK;
        Wed, 30 Aug 2023 00:36:36 +0800 (CST)
Received: from localhost (10.202.227.76) by lhrpeml500005.china.huawei.com
 (7.191.163.240) with Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id 15.1.2507.31; Tue, 29 Aug
 2023 17:40:54 +0100
Date: Tue, 29 Aug 2023 17:40:53 +0100
From: Jonathan Cameron <Jonathan.Cameron@Huawei.com>
To: Ira Weiny <ira.weiny@intel.com>
CC: Dan Williams <dan.j.williams@intel.com>,
        Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
Subject: Re: [PATCH RFC v2 12/18] cxl/region: Notify regions of DC changes
Message-ID: <20230829174053.000008a1@Huawei.com>
In-Reply-To: <20230604-dcd-type2-upstream-v2-12-f740c47e7916@intel.com>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
        <20230604-dcd-type2-upstream-v2-12-f740c47e7916@intel.com>
Organization: Huawei Technologies Research and Development (UK) Ltd.
X-Mailer: Claws Mail 4.1.0 (GTK 3.24.33; x86_64-w64-mingw32)
MIME-Version: 1.0
Content-Type: text/plain; charset="US-ASCII"
Content-Transfer-Encoding: 7bit
X-Originating-IP: [10.202.227.76]
X-ClientProxiedBy: lhrpeml100003.china.huawei.com (7.191.160.210) To
 lhrpeml500005.china.huawei.com (7.191.163.240)
X-CFilter-Loop: Reflected
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

On Mon, 28 Aug 2023 22:21:03 -0700
Ira Weiny <ira.weiny@intel.com> wrote:

> In order for a user to use dynamic capacity effectively they need to
> know when dynamic capacity is available.  Thus when Dynamic Capacity
> (DC) extents are added or removed by a DC device the regions affected
> need to be notified.  Ultimately the DAX region uses the memory
> associated with DC extents.  However, remember that CXL DAX regions
> maintain any interleave details between devices.
> 
> When a DCD event occurs, iterate all CXL endpoint decoders and notify
> regions which contain the endpoints affected by the event.  In turn
> notify the DAX regions of the changes to the DAX region extents.
> 
> For now interleave is handled by creating simple 1:1 mappings between
> the CXL DAX region and DAX region layers.  Future implementations will
> need to resolve when to actually surface a DAX region extent and pass
> the notification along.
> 
> Remember that adding capacity is safe because there is no chance of the
> memory being in use.  Also remember at this point releasing capacity is
> straight forward because DAX devices do not yet have references to the
> extents.  Future patches will handle that complication.
> 
> Signed-off-by: Ira Weiny <ira.weiny@intel.com>
> 

A few trivial comments on this.  Lot here so I'll take a closer look
at some point after doing a light pass over the rest of the series.





> diff --git a/drivers/cxl/mem.c b/drivers/cxl/mem.c
> index 80cffa40e91a..d3c4c9c87392 100644
> --- a/drivers/cxl/mem.c
> +++ b/drivers/cxl/mem.c
> @@ -104,6 +104,55 @@ static int cxl_debugfs_poison_clear(void *data, u64 dpa)
>  DEFINE_DEBUGFS_ATTRIBUTE(cxl_poison_clear_fops, NULL,
>  			 cxl_debugfs_poison_clear, "%llx\n");
>  
> +static int match_ep_decoder_by_range(struct device *dev, void *data)
> +{
> +	struct cxl_dc_extent_data *extent = data;
> +	struct cxl_endpoint_decoder *cxled;
> +
> +	if (!is_endpoint_decoder(dev))
> +		return 0;

blank line

> +	cxled = to_cxl_endpoint_decoder(dev);
> +	return cxl_dc_extent_in_ed(cxled, extent);
> +}
> +
> +static struct cxl_endpoint_decoder *cxl_find_ed(struct cxl_memdev_state *mds,
> +						struct cxl_dc_extent_data *extent)
> +{
> +	struct cxl_memdev *cxlmd = mds->cxlds.cxlmd;
> +	struct cxl_port *endpoint = cxlmd->endpoint;
> +	struct device *dev;
> +
> +	dev = device_find_child(&endpoint->dev, extent,
> +				match_ep_decoder_by_range);
> +	if (!dev) {
> +		dev_dbg(mds->cxlds.dev, "Extent DPA:%llx LEN:%llx not mapped\n",
> +			extent->dpa_start, extent->length);
> +		return NULL;
> +	}
> +
> +	return to_cxl_endpoint_decoder(dev);
> +}
> +
> +static int cxl_mem_notify(struct device *dev, struct cxl_drv_nd *nd)
> +{
> +	struct cxl_memdev *cxlmd = to_cxl_memdev(dev);
> +	struct cxl_memdev_state *mds = to_cxl_memdev_state(cxlmd->cxlds);
> +	struct cxl_endpoint_decoder *cxled;
> +	struct cxl_dc_extent_data *extent;
> +	int rc = 0;
> +
> +	extent = nd->extent;
> +	dev_dbg(dev, "notify DC action %d DPA:%llx LEN:%llx\n",
> +		nd->event, extent->dpa_start, extent->length);
> +
> +	cxled = cxl_find_ed(mds, extent);
> +	if (!cxled)
> +		return 0;
Blank line.

> +	rc = cxl_ed_notify_extent(cxled, nd);
> +	put_device(&cxled->cxld.dev);
> +	return rc;
> +}
> +
>  static int cxl_mem_probe(struct device *dev)
>  {
>  	struct cxl_memdev *cxlmd = to_cxl_memdev(dev);
> @@ -247,6 +296,7 @@ __ATTRIBUTE_GROUPS(cxl_mem);
>  static struct cxl_driver cxl_mem_driver = {
>  	.name = "cxl_mem",
>  	.probe = cxl_mem_probe,
> +	.notify = cxl_mem_notify,
>  	.id = CXL_DEVICE_MEMORY_EXPANDER,
>  	.drv = {
>  		.dev_groups = cxl_mem_groups,
> diff --git a/drivers/dax/cxl.c b/drivers/dax/cxl.c
> index 057b00b1d914..44cbd28668f1 100644
> --- a/drivers/dax/cxl.c
> +++ b/drivers/dax/cxl.c
> @@ -59,6 +59,29 @@ static int cxl_dax_region_create_extent(struct dax_region *dax_region,
>  	return 0;
>  }
>  
> +static int cxl_dax_region_add_extent(struct cxl_dax_region *cxlr_dax,
> +				     struct cxl_dr_extent *cxl_dr_ext)
> +{

Why not have this helper in the earlier patch that introduced the code
this is factoring out?  Will reduce churn in the set whilst not much hurting
readability of that patch.

> +	/*
> +	 * get not zero is important because this is racing with the
> +	 * region driver which is racing with the memory device which
> +	 * could be removing the extent at the same time.
> +	 */
> +	if (cxl_dr_extent_get_not_zero(cxl_dr_ext)) {
> +		struct dax_region *dax_region;
> +		int rc;
> +
> +		dax_region = dev_get_drvdata(&cxlr_dax->dev);
> +		dev_dbg(&cxlr_dax->dev, "Creating HPA:%llx LEN:%llx\n",
> +			cxl_dr_ext->hpa_offset, cxl_dr_ext->hpa_length);
> +		rc = cxl_dax_region_create_extent(dax_region, cxl_dr_ext);
> +		cxl_dr_extent_put(cxl_dr_ext);
> +		if (rc)
> +			return rc;
> +	}
> +	return 0;
Perhaps flip logic
	if (!cxl_dr_extent_get_not_zero())
		return 0;

etc to reduce the code indent.
> +}
> +
>  static int cxl_dax_region_create_extents(struct cxl_dax_region *cxlr_dax)
>  {
>  	struct cxl_dr_extent *cxl_dr_ext;
> @@ -66,27 +89,68 @@ static int cxl_dax_region_create_extents(struct cxl_dax_region *cxlr_dax)
>  
>  	dev_dbg(&cxlr_dax->dev, "Adding extents\n");
>  	xa_for_each(&cxlr_dax->extents, index, cxl_dr_ext) {
> -		/*
> -		 * get not zero is important because this is racing with the
> -		 * region driver which is racing with the memory device which
> -		 * could be removing the extent at the same time.
> -		 */
> -		if (cxl_dr_extent_get_not_zero(cxl_dr_ext)) {
> -			struct dax_region *dax_region;
> -			int rc;
> -
> -			dax_region = dev_get_drvdata(&cxlr_dax->dev);
> -			dev_dbg(&cxlr_dax->dev, "Found OFF:%llx LEN:%llx\n",
> -				cxl_dr_ext->hpa_offset, cxl_dr_ext->hpa_length);
> -			rc = cxl_dax_region_create_extent(dax_region, cxl_dr_ext);
> -			cxl_dr_extent_put(cxl_dr_ext);
> -			if (rc)
> -				return rc;
> -		}
> +		int rc;
> +
> +		rc = cxl_dax_region_add_extent(cxlr_dax, cxl_dr_ext);
> +		if (rc)
> +			return rc;
>  	}
>  	return 0;
>  }
>  
> +static int match_cxl_dr_extent(struct device *dev, void *data)
> +{
> +	struct dax_reg_ext_dev *dr_reg_ext_dev;
> +	struct dax_region_extent *dr_extent;
> +
> +	if (!is_dr_ext_dev(dev))
> +		return 0;
> +
> +	dr_reg_ext_dev = to_dr_ext_dev(dev);
> +	dr_extent = dr_reg_ext_dev->dr_extent;
> +	return data == dr_extent->private_data;
> +}
> +
> +static int cxl_dax_region_rm_extent(struct cxl_dax_region *cxlr_dax,
> +				    struct cxl_dr_extent *cxl_dr_ext)
> +{
> +	struct dax_reg_ext_dev *dr_reg_ext_dev;
> +	struct dax_region *dax_region;
> +	struct device *dev;
> +
> +	dev = device_find_child(&cxlr_dax->dev, cxl_dr_ext,
> +				match_cxl_dr_extent);
> +	if (!dev)
> +		return -EINVAL;

blank line.

> +	dr_reg_ext_dev = to_dr_ext_dev(dev);
> +	put_device(dev);
> +	dax_region = dev_get_drvdata(&cxlr_dax->dev);
> +	dax_region_ext_del_dev(dax_region, dr_reg_ext_dev);
blank line

> +	return 0;
> +}
> +
> +static int cxl_dax_region_notify(struct device *dev,
> +				 struct cxl_drv_nd *nd)
> +{
> +	struct cxl_dax_region *cxlr_dax = to_cxl_dax_region(dev);
> +	struct cxl_dr_extent *cxl_dr_ext = nd->cxl_dr_ext;
> +	int rc = 0;
> +
> +	switch (nd->event) {
> +	case DCD_ADD_CAPACITY:
> +		rc = cxl_dax_region_add_extent(cxlr_dax, cxl_dr_ext);
> +		break;

Early returns in here will perhaps make this more readable and definitely
make it more compact.

> +	case DCD_RELEASE_CAPACITY:
> +	case DCD_FORCED_CAPACITY_RELEASE:
> +		rc = cxl_dax_region_rm_extent(cxlr_dax, cxl_dr_ext);
> +		break;
> +	default:
> +		dev_err(&cxlr_dax->dev, "Unknown DC event %d\n", nd->event);
> +		break;
> +	}
> +	return rc;
> +}
> +
>  static int cxl_dax_region_probe(struct device *dev)
>  {
>  	struct cxl_dax_region *cxlr_dax = to_cxl_dax_region(dev);
> @@ -134,6 +198,7 @@ static int cxl_dax_region_probe(struct device *dev)
>  static struct cxl_driver cxl_dax_region_driver = {
>  	.name = "cxl_dax_region",
>  	.probe = cxl_dax_region_probe,
> +	.notify = cxl_dax_region_notify,
>  	.id = CXL_DEVICE_DAX_REGION,
>  	.drv = {
>  		.suppress_bind_attrs = true,

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id C0FEFC83F12
	for <linux-cxl@archiver.kernel.org>; Tue, 29 Aug 2023 16:21:29 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S234598AbjH2QVA (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 29 Aug 2023 12:21:00 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:59142 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S237460AbjH2QUy (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 29 Aug 2023 12:20:54 -0400
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id DFEC0C9;
        Tue, 29 Aug 2023 09:20:51 -0700 (PDT)
Received: from lhrpeml500005.china.huawei.com (unknown [172.18.147.226])
        by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4RZt1K0Mbsz67VcY;
        Wed, 30 Aug 2023 00:19:49 +0800 (CST)
Received: from localhost (10.202.227.76) by lhrpeml500005.china.huawei.com
 (7.191.163.240) with Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id 15.1.2507.31; Tue, 29 Aug
 2023 17:20:49 +0100
Date: Tue, 29 Aug 2023 17:20:48 +0100
From: Jonathan Cameron <Jonathan.Cameron@Huawei.com>
To: Ira Weiny <ira.weiny@intel.com>
CC: Dan Williams <dan.j.williams@intel.com>,
        Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
Subject: Re: [PATCH RFC v2 11/18] cxl/region: Expose DC extents on region
 driver load
Message-ID: <20230829172048.000006fb@Huawei.com>
In-Reply-To: <20230604-dcd-type2-upstream-v2-11-f740c47e7916@intel.com>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
        <20230604-dcd-type2-upstream-v2-11-f740c47e7916@intel.com>
Organization: Huawei Technologies Research and Development (UK) Ltd.
X-Mailer: Claws Mail 4.1.0 (GTK 3.24.33; x86_64-w64-mingw32)
MIME-Version: 1.0
Content-Type: text/plain; charset="US-ASCII"
Content-Transfer-Encoding: 7bit
X-Originating-IP: [10.202.227.76]
X-ClientProxiedBy: lhrpeml500006.china.huawei.com (7.191.161.198) To
 lhrpeml500005.china.huawei.com (7.191.163.240)
X-CFilter-Loop: Reflected
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

On Mon, 28 Aug 2023 22:21:02 -0700
Ira Weiny <ira.weiny@intel.com> wrote:

> Ultimately user space must associate Dynamic Capacity (DC) extents with
> DAX devices.  Remember also that DCD extents may have been accepted
> previous to regions being created and must have references held until
> all higher level regions and DAX devices are done with the memory.
> 
> On CXL region driver load scan existing device extents and create CXL
> DAX region extents as needed.
> 
> Create abstractions for the extents to be used in DAX region.  This
> includes a generic interface to take proper references on the lower
> level CXL region extents.
> 
> Also maintain separate objects for the DAX region extent device vs the
> DAX region extent.  The DAX region extent device has a shorter life span
> which corresponds to the removal of an extent while a DAX device is
> still using it.  In this case an extent continues to exist whilst the
> ability to create new DAX devices on that extent is prevented.
> 
> NOTE: Without interleaving; the device, CXL region, and DAX region
> extents have a 1:1:1 relationship.  Future support for interleaving will
> maintain a 1:N relationship between CXL region extents and the hardware
> extents.
> 
> While the ability to create DAX devices on an extent exists; expose the
> necessary details of DAX region extents by creating a device with the
> following sysfs entries.
> 
> /sys/bus/cxl/devices/dax_regionX/extentY
> /sys/bus/cxl/devices/dax_regionX/extentY/length
> /sys/bus/cxl/devices/dax_regionX/extentY/label
> 
> Label is a rough analogy to the DC extent tag.  As such the DC extent
> tag is used to initially populate the label.  However, the label is made
> writeable so that it can be adjusted in the future when forming a DAX
> device.
> 
> Signed-off-by: Navneet Singh <navneet.singh@intel.com>
> Co-developed-by: Navneet Singh <navneet.singh@intel.com>
> Signed-off-by: Ira Weiny <ira.weiny@intel.com>
> 

Trivial stuff inline.



> diff --git a/drivers/dax/dax-private.h b/drivers/dax/dax-private.h
> index 27cf2daaaa79..4dab52496c3f 100644
> --- a/drivers/dax/dax-private.h
> +++ b/drivers/dax/dax-private.h
> @@ -5,6 +5,7 @@
>  #ifndef __DAX_PRIVATE_H__
>  #define __DAX_PRIVATE_H__
>  
> +#include <linux/pgtable.h>
>  #include <linux/device.h>
>  #include <linux/cdev.h>
>  #include <linux/idr.h>
> @@ -40,6 +41,58 @@ struct dax_region {
>  	struct device *youngest;
>  };
>  
> +/*
/**

as it's valid kernel doc so no disadvantage really.

> + * struct dax_region_extent - extent data defined by the low level region
> + * driver.
> + * @private_data: lower level region driver data
> + * @ref: track number of dax devices which are using this extent
> + * @get: get reference to low level data
> + * @put: put reference to low level data

I'd like to understand when these are optional - perhaps comment on that?

> + */
> +struct dax_region_extent {
> +	void *private_data;
> +	struct kref ref;
> +	void (*get)(struct dax_region_extent *dr_extent);
> +	void (*put)(struct dax_region_extent *dr_extent);
> +};
> +
> +static inline void dr_extent_get(struct dax_region_extent *dr_extent)
> +{
> +	if (dr_extent->get)
> +		dr_extent->get(dr_extent);
> +}
> +
> +static inline void dr_extent_put(struct dax_region_extent *dr_extent)
> +{
> +	if (dr_extent->put)
> +		dr_extent->put(dr_extent);
> +}
> +
> +#define DAX_EXTENT_LABEL_LEN 64

blank line here.

> +/**
> + * struct dax_reg_ext_dev - Device object to expose extent information
> + * @dev: device representing this extent
> + * @dr_extent: reference back to private extent data
> + * @offset: offset of this extent
> + * @length: size of this extent
> + * @label: identifier to group extents
> + */
> +struct dax_reg_ext_dev {
> +	struct device dev;
> +	struct dax_region_extent *dr_extent;
> +	resource_size_t offset;
> +	resource_size_t length;
> +	char label[DAX_EXTENT_LABEL_LEN];
> +};


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 7FEEDC83F12
	for <linux-cxl@archiver.kernel.org>; Tue, 29 Aug 2023 16:00:34 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S235467AbjH2QAE (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 29 Aug 2023 12:00:04 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:46570 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S237054AbjH2P7i (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 29 Aug 2023 11:59:38 -0400
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 0BFEF12F;
        Tue, 29 Aug 2023 08:59:34 -0700 (PDT)
Received: from lhrpeml500005.china.huawei.com (unknown [172.18.147.200])
        by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4RZsSx1wZJz6J7Xw;
        Tue, 29 Aug 2023 23:55:13 +0800 (CST)
Received: from localhost (10.202.227.76) by lhrpeml500005.china.huawei.com
 (7.191.163.240) with Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id 15.1.2507.31; Tue, 29 Aug
 2023 16:59:31 +0100
Date: Tue, 29 Aug 2023 16:59:30 +0100
From: Jonathan Cameron <Jonathan.Cameron@Huawei.com>
To: Ira Weiny <ira.weiny@intel.com>
CC: Dan Williams <dan.j.williams@intel.com>,
        Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
Subject: Re: [PATCH RFC v2 10/18] cxl/mem: Handle DCD add and release
 capacity events.
Message-ID: <20230829165930.0000208c@Huawei.com>
In-Reply-To: <20230604-dcd-type2-upstream-v2-10-f740c47e7916@intel.com>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
        <20230604-dcd-type2-upstream-v2-10-f740c47e7916@intel.com>
Organization: Huawei Technologies Research and Development (UK) Ltd.
X-Mailer: Claws Mail 4.1.0 (GTK 3.24.33; x86_64-w64-mingw32)
MIME-Version: 1.0
Content-Type: text/plain; charset="US-ASCII"
Content-Transfer-Encoding: 7bit
X-Originating-IP: [10.202.227.76]
X-ClientProxiedBy: lhrpeml500003.china.huawei.com (7.191.162.67) To
 lhrpeml500005.china.huawei.com (7.191.163.240)
X-CFilter-Loop: Reflected
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

On Mon, 28 Aug 2023 22:21:01 -0700
Ira Weiny <ira.weiny@intel.com> wrote:

> A Dynamic Capacity Device (DCD) utilizes events to signal the host about
> the changes to the allocation of Dynamic Capacity (DC) extents. The
> device communicates the state of DC extents through an extent list that
> describes the starting DPA, length, and meta data of the blocks the host
> can access.
> 
> Process the dynamic capacity add and release events.  The addition or
> removal of extents can occur at any time.  Adding asynchronous memory is
> straight forward.  Also remember the host is under no obligation to
> respond to a release event until it is done with the memory.  Introduce
> extent kref's to handle the delay of extent release.
> 
> In the case of a force removal, access to the memory will fail and may
> cause a crash.  However, the extent tracking object is preserved for the
> region to safely tear down as long as the memory is not accessed.
> 
> Signed-off-by: Navneet Singh <navneet.singh@intel.com>
> Co-developed-by: Ira Weiny <ira.weiny@intel.com>
> Signed-off-by: Ira Weiny <ira.weiny@intel.com>
Minor stuff inline.


> +static int cxl_prepare_ext_list(struct cxl_mbox_dc_response **res,
> +				int *n, struct range *extent)
> +{
> +	struct cxl_mbox_dc_response *dc_res;
> +	unsigned int size;
> +
> +	if (!extent)
> +		size = struct_size(dc_res, extent_list, 0);

This is confusing as if you did have *n > 0 I'd kind of expect
this to just not extend the list rather than shortening it.
Now I guess that never happens, but locally it looks odd.

Maybe just handle that case in a separate function as it doesn't
share much code with the case where there is an extent and I would
assume we always know at the caller which one we want.


> +	else
> +		size = struct_size(dc_res, extent_list, *n + 1);

Might be clearer with a local variable for the number of extents.

extents_count = *n;

if (extent)
	extents_count++;

size = struct_size(dc_res, extent_list, extents_count);

Though I'm not sure that really helps.  Maybe this will just need
to be a little confusing :)

> +
> +	dc_res = krealloc(*res, size, GFP_KERNEL);
> +	if (!dc_res)
> +		return -ENOMEM;
> +
> +	if (extent) {
> +		dc_res->extent_list[*n].dpa_start = cpu_to_le64(extent->start);
> +		memset(dc_res->extent_list[*n].reserved, 0, 8);
> +		dc_res->extent_list[*n].length = cpu_to_le64(range_len(extent));
> +		(*n)++;
> +	}
> +
> +	*res = dc_res;
> +	return 0;
> +}

> +
> +/* Returns 0 if the event was handled successfully. */
> +static int cxl_handle_dcd_event_records(struct cxl_memdev_state *mds,
> +					struct cxl_event_record_raw *rec)
> +{
> +	struct dcd_event_dyn_cap *record = (struct dcd_event_dyn_cap *)rec;
> +	uuid_t *id = &rec->hdr.id;
> +	int rc;
> +
> +	if (!uuid_equal(id, &dc_event_uuid))
> +		return -EINVAL;
> +
> +	switch (record->data.event_type) {
> +	case DCD_ADD_CAPACITY:
> +		rc = cxl_handle_dcd_add_event(mds, &record->data.extent);
> +		break;

I guess it might not be consistent with local style...
		return cxl_handle_dcd_add_event()  etc

> +	case DCD_RELEASE_CAPACITY:
> +        case DCD_FORCED_CAPACITY_RELEASE:
> +		rc = cxl_handle_dcd_release_event(mds, &record->data.extent);
> +		break;
> +	default:
> +		return -EINVAL;
> +	}
> +
> +	return rc;
> +}
> +



From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 421ACC6FA8F
	for <linux-cxl@archiver.kernel.org>; Tue, 29 Aug 2023 15:27:22 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S230020AbjH2P0s (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 29 Aug 2023 11:26:48 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:43802 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S237289AbjH2P0j (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 29 Aug 2023 11:26:39 -0400
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 50577CD7;
        Tue, 29 Aug 2023 08:26:04 -0700 (PDT)
Received: from lhrpeml500005.china.huawei.com (unknown [172.18.147.206])
        by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4RZrjn0zZRz686y1;
        Tue, 29 Aug 2023 23:21:17 +0800 (CST)
Received: from localhost (10.202.227.76) by lhrpeml500005.china.huawei.com
 (7.191.163.240) with Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id 15.1.2507.31; Tue, 29 Aug
 2023 16:26:01 +0100
Date: Tue, 29 Aug 2023 16:26:00 +0100
From: Jonathan Cameron <Jonathan.Cameron@Huawei.com>
To: Ira Weiny <ira.weiny@intel.com>
CC: Dan Williams <dan.j.williams@intel.com>,
        Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
Subject: Re: [PATCH RFC v2 09/18] cxl/mem: Read extents on memory device
 discovery
Message-ID: <20230829162600.00004ac2@Huawei.com>
In-Reply-To: <20230604-dcd-type2-upstream-v2-9-f740c47e7916@intel.com>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
        <20230604-dcd-type2-upstream-v2-9-f740c47e7916@intel.com>
Organization: Huawei Technologies Research and Development (UK) Ltd.
X-Mailer: Claws Mail 4.1.0 (GTK 3.24.33; x86_64-w64-mingw32)
MIME-Version: 1.0
Content-Type: text/plain; charset="US-ASCII"
Content-Transfer-Encoding: 7bit
X-Originating-IP: [10.202.227.76]
X-ClientProxiedBy: lhrpeml500004.china.huawei.com (7.191.163.9) To
 lhrpeml500005.china.huawei.com (7.191.163.240)
X-CFilter-Loop: Reflected
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

On Mon, 28 Aug 2023 22:21:00 -0700
Ira Weiny <ira.weiny@intel.com> wrote:

> When a Dynamic Capacity Device (DCD) is realized some extents may
> already be available within the DC Regions.  This can happen if the host
> has accepted extents and been rebooted or any other time the host driver
> software has become out of sync with the device hardware.
> 
> Read the available extents during probe and store them for later
> use.
> 
> Signed-off-by: Navneet Singh <navneet.singh@intel.com>
> Co-developed-by: Navneet Singh <navneet.singh@intel.com>
> Signed-off-by: Ira Weiny <ira.weiny@intel.com>
> 
A few minor comments inline.

Thanks,

Jonathan

> ---
> Change for v2:
> [iweiny: new patch]
> ---
>  drivers/cxl/core/mbox.c | 195 ++++++++++++++++++++++++++++++++++++++++++++++++
>  drivers/cxl/cxlmem.h    |  36 +++++++++
>  drivers/cxl/pci.c       |   4 +
>  3 files changed, 235 insertions(+)
> 
> diff --git a/drivers/cxl/core/mbox.c b/drivers/cxl/core/mbox.c
> index d769814f80e2..9b08c40ef484 100644
> --- a/drivers/cxl/core/mbox.c
> +++ b/drivers/cxl/core/mbox.c
> @@ -824,6 +824,37 @@ int cxl_enumerate_cmds(struct cxl_memdev_state *mds)

...

> +static int cxl_dev_get_dc_extent_cnt(struct cxl_memdev_state *mds,
> +				     unsigned int *extent_gen_num)
> +{
> +	struct cxl_mbox_get_dc_extent get_dc_extent;
> +	struct cxl_mbox_dc_extents dc_extents;
> +	struct device *dev = mds->cxlds.dev;
> +	struct cxl_mbox_cmd mbox_cmd;
> +	unsigned int count;
> +	int rc;
> +
> +	/* Check GET_DC_EXTENT_LIST is supported by device */
> +	if (!test_bit(CXL_DCD_ENABLED_GET_EXTENT_LIST, mds->dcd_cmds)) {
> +		dev_dbg(dev, "unsupported cmd : get dyn cap extent list\n");
> +		return 0;
> +	}
> +
> +	get_dc_extent = (struct cxl_mbox_get_dc_extent) {
> +		.extent_cnt = cpu_to_le32(0),
> +		.start_extent_index = cpu_to_le32(0),
> +	};
> +
> +	mbox_cmd = (struct cxl_mbox_cmd) {
> +		.opcode = CXL_MBOX_OP_GET_DC_EXTENT_LIST,
> +		.payload_in = &get_dc_extent,
> +		.size_in = sizeof(get_dc_extent),
> +		.size_out = mds->payload_size,

If all you are after is the count, then size_out can be a lot smaller than that
I think as we know it can't return any extents.

> +		.payload_out = &dc_extents,
> +		.min_out = 1,
> +	};
> +
> +	rc = cxl_internal_send_cmd(mds, &mbox_cmd);
> +	if (rc < 0)
> +		return rc;
> +
> +	count = le32_to_cpu(dc_extents.total_extent_cnt);
> +	*extent_gen_num = le32_to_cpu(dc_extents.extent_list_num);
> +
> +	return count;
> +}
> +
> +static int cxl_dev_get_dc_extents(struct cxl_memdev_state *mds,
> +				  unsigned int start_gen_num,
> +				  unsigned int exp_cnt)
> +{
> +	struct cxl_mbox_dc_extents *dc_extents;
> +	unsigned int start_index, total_read;
> +	struct device *dev = mds->cxlds.dev;
> +	struct cxl_mbox_cmd mbox_cmd;
> +	int retry = 3;

Why 3?

> +	int rc;
> +
> +	/* Check GET_DC_EXTENT_LIST is supported by device */
> +	if (!test_bit(CXL_DCD_ENABLED_GET_EXTENT_LIST, mds->dcd_cmds)) {
> +		dev_dbg(dev, "unsupported cmd : get dyn cap extent list\n");
> +		return 0;
> +	}
> +
> +	dc_extents = kvmalloc(mds->payload_size, GFP_KERNEL);

Maybe __free magic would simplify this enough to be useful.

> +	if (!dc_extents)
> +		return -ENOMEM;
> +
> +reset:
> +	total_read = 0;
> +	start_index = 0;
> +	do {
> +		unsigned int nr_ext, total_extent_cnt, gen_num;
> +		struct cxl_mbox_get_dc_extent get_dc_extent;
> +
> +		get_dc_extent = (struct cxl_mbox_get_dc_extent) {
> +			.extent_cnt = exp_cnt - start_index,
> +			.start_extent_index = start_index,
> +		};
> +		
> +		mbox_cmd = (struct cxl_mbox_cmd) {
> +			.opcode = CXL_MBOX_OP_GET_DC_EXTENT_LIST,
> +			.payload_in = &get_dc_extent,
> +			.size_in = sizeof(get_dc_extent),
> +			.size_out = mds->payload_size,
> +			.payload_out = dc_extents,
> +			.min_out = 1,
> +		};
> +		
> +		rc = cxl_internal_send_cmd(mds, &mbox_cmd);
> +		if (rc < 0)
> +			goto out;
> +		
> +		nr_ext = le32_to_cpu(dc_extents->ret_extent_cnt);
> +		total_read += nr_ext;
> +		total_extent_cnt = le32_to_cpu(dc_extents->total_extent_cnt);
> +		gen_num = le32_to_cpu(dc_extents->extent_list_num);
> +
> +		dev_dbg(dev, "Get extent list count:%d generation Num:%d\n",
> +			total_extent_cnt, gen_num);
> +
> +		if (gen_num != start_gen_num || exp_cnt != total_extent_cnt) {
> +			dev_err(dev, "Extent list changed while reading; %u != %u : %u != %u\n",
> +				gen_num, start_gen_num, exp_cnt, total_extent_cnt);
> +			if (retry--)
> +				goto reset;
> +			return -EIO;
> +		}
> +		
> +		for (int i = 0; i < nr_ext ; i++) {
> +			dev_dbg(dev, "Storing extent %d/%d\n",
> +				start_index + i, exp_cnt);
> +			rc = cxl_store_dc_extent(mds, &dc_extents->extent[i]);
> +			if (rc)
> +				goto out;
> +		}
> +
> +		start_index += nr_ext;
> +	} while (exp_cnt > total_read);
> +
> +out:
> +	kvfree(dc_extents);
> +	return rc;
> +}



From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id C7613C83F12
	for <linux-cxl@archiver.kernel.org>; Tue, 29 Aug 2023 15:20:54 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S236861AbjH2PUZ (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 29 Aug 2023 11:20:25 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:34970 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S237186AbjH2PTy (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 29 Aug 2023 11:19:54 -0400
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id B131A1AA;
        Tue, 29 Aug 2023 08:19:51 -0700 (PDT)
Received: from lhrpeml500005.china.huawei.com (unknown [172.18.147.207])
        by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4RZrb70mcpz67n0t;
        Tue, 29 Aug 2023 23:15:31 +0800 (CST)
Received: from localhost (10.202.227.76) by lhrpeml500005.china.huawei.com
 (7.191.163.240) with Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id 15.1.2507.31; Tue, 29 Aug
 2023 16:19:49 +0100
Date: Tue, 29 Aug 2023 16:19:48 +0100
From: Jonathan Cameron <Jonathan.Cameron@Huawei.com>
To: Ira Weiny <ira.weiny@intel.com>
CC: Dan Williams <dan.j.williams@intel.com>,
        Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
Subject: Re: [PATCH RFC v2 08/18] cxl/region: Add Dynamic Capacity CXL
 region support
Message-ID: <20230829161948.0000556c@Huawei.com>
In-Reply-To: <20230604-dcd-type2-upstream-v2-8-f740c47e7916@intel.com>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
        <20230604-dcd-type2-upstream-v2-8-f740c47e7916@intel.com>
Organization: Huawei Technologies Research and Development (UK) Ltd.
X-Mailer: Claws Mail 4.1.0 (GTK 3.24.33; x86_64-w64-mingw32)
MIME-Version: 1.0
Content-Type: text/plain; charset="US-ASCII"
Content-Transfer-Encoding: 7bit
X-Originating-IP: [10.202.227.76]
X-ClientProxiedBy: lhrpeml500004.china.huawei.com (7.191.163.9) To
 lhrpeml500005.china.huawei.com (7.191.163.240)
X-CFilter-Loop: Reflected
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

On Mon, 28 Aug 2023 22:20:59 -0700
Ira Weiny <ira.weiny@intel.com> wrote:

> CXL devices optionally support dynamic capacity.  CXL Regions must be
> configured correctly to access this capacity.  Similar to ram and pmem
> partitions, DC Regions represent different partitions of the DPA space.
> 
> Interleaving is deferred due to the complexity of managing extents on
> multiple devices at the same time.  However, there is nothing which
> directly prevents interleave support at this time.  The check allows
> for early rejection.
> 
> To maintain backwards compatibility with older software, CXL regions
> need a default DAX device to hold the reference for the region until it
> is deleted.
> 
> Add create_dc_region sysfs entry to create DC regions.  Share the logic
> of devm_cxl_add_dax_region() and region_is_system_ram().  Special case
> DC capable CXL regions to create a 0 sized seed DAX device until others
> can be created on dynamic space later.
> 
> Flag dax_regions to indicate 0 capacity available until dax_region
> extents are supported by the region.
> 
> Co-developed-by: Navneet Singh <navneet.singh@intel.com>
> Signed-off-by: Navneet Singh <navneet.singh@intel.com>
> Signed-off-by: Ira Weiny <ira.weiny@intel.com>
> 
LGTM
Reviewed-by: Jonathan Cameron <Jonathan.Cameron@Huawei.com>



From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 9B8BAC71153
	for <linux-cxl@archiver.kernel.org>; Tue, 29 Aug 2023 15:15:35 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S232167AbjH2PPE (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 29 Aug 2023 11:15:04 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:57426 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S234923AbjH2POy (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 29 Aug 2023 11:14:54 -0400
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 15233BD;
        Tue, 29 Aug 2023 08:14:52 -0700 (PDT)
Received: from lhrpeml500005.china.huawei.com (unknown [172.18.147.226])
        by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4RZrSr75dqz6K5km;
        Tue, 29 Aug 2023 23:10:04 +0800 (CST)
Received: from localhost (10.202.227.76) by lhrpeml500005.china.huawei.com
 (7.191.163.240) with Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id 15.1.2507.31; Tue, 29 Aug
 2023 16:14:49 +0100
Date: Tue, 29 Aug 2023 16:14:49 +0100
From: Jonathan Cameron <Jonathan.Cameron@Huawei.com>
To: <ira.weiny@intel.com>
CC: Dan Williams <dan.j.williams@intel.com>,
        Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
Subject: Re: [PATCH RFC v2 07/18] cxl/mem: Expose device dynamic capacity
 configuration
Message-ID: <20230829161449.00000c7a@Huawei.com>
In-Reply-To: <20230604-dcd-type2-upstream-v2-7-f740c47e7916@intel.com>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
        <20230604-dcd-type2-upstream-v2-7-f740c47e7916@intel.com>
Organization: Huawei Technologies Research and Development (UK) Ltd.
X-Mailer: Claws Mail 4.1.0 (GTK 3.24.33; x86_64-w64-mingw32)
MIME-Version: 1.0
Content-Type: text/plain; charset="US-ASCII"
Content-Transfer-Encoding: 7bit
X-Originating-IP: [10.202.227.76]
X-ClientProxiedBy: lhrpeml500004.china.huawei.com (7.191.163.9) To
 lhrpeml500005.china.huawei.com (7.191.163.240)
X-CFilter-Loop: Reflected
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

On Mon, 28 Aug 2023 22:20:58 -0700
ira.weiny@intel.com wrote:

> From: Navneet Singh <navneet.singh@intel.com>
> 
> To properly configure CXL regions on Dynamic Capacity Devices (DCD),
> user space will need to know the details of the DC Regions available on
> a device.
> 
> Expose driver dynamic capacity configuration through sysfs
> attributes.
> 
> Co-developed-by: Navneet Singh <navneet.singh@intel.com>
> Signed-off-by: Navneet Singh <navneet.singh@intel.com>
> Signed-off-by: Ira Weiny <ira.weiny@intel.com>
> 
One trivial comment inline.  I wondered a bit if it would
be better to not present dc at all on devices that don't support
dynamic capacity, but for now there isn't an elegant way to do that
(some discussions and patches are flying around however so maybe this
 will be resolved before this series merges giving us that elegant
 option).

With commented code tidied up
Reviewed-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>


> ---
> Changes for v2:
> [iweiny: Rebased on latest master/type2 work]
> [iweiny: add documentation for sysfs entries]
> [iweiny: s/dc_regions_count/region_count/]
> [iweiny: s/dcY_size/regionY_size/]
> [alison: change size format to %#llx]
> [iweiny: change count format to %d]
> [iweiny: Formatting updates]
> [iweiny: Fix crash when device is not a mem device: found with cxl-test]
> ---
>  Documentation/ABI/testing/sysfs-bus-cxl | 17 ++++++++
>  drivers/cxl/core/memdev.c               | 77 +++++++++++++++++++++++++++++++++
>  2 files changed, 94 insertions(+)
> 
> diff --git a/Documentation/ABI/testing/sysfs-bus-cxl b/Documentation/ABI/testing/sysfs-bus-cxl
> index 2268ffcdb604..aa65dc5b4e13 100644
> --- a/Documentation/ABI/testing/sysfs-bus-cxl
> +++ b/Documentation/ABI/testing/sysfs-bus-cxl
> @@ -37,6 +37,23 @@ Description:
>  		identically named field in the Identify Memory Device Output
>  		Payload in the CXL-2.0 specification.
>  
> +What:		/sys/bus/cxl/devices/memX/dc/region_count
> +Date:		July, 2023
> +KernelVersion:	v6.6
> +Contact:	linux-cxl@vger.kernel.org
> +Description:
> +		(RO) Number of Dynamic Capacity (DC) regions supported on the
> +		device.  May be 0 if the device does not support Dynamic
> +		Capacity.
> +
> +What:		/sys/bus/cxl/devices/memX/dc/regionY_size
> +Date:		July, 2023
> +KernelVersion:	v6.6
> +Contact:	linux-cxl@vger.kernel.org
> +Description:
> +		(RO) Size of the Dynamic Capacity (DC) region Y.  Only
> +		available on devices which support DC and only for those
> +		region indexes supported by the device.
>  
>  What:		/sys/bus/cxl/devices/memX/serial
>  Date:		January, 2022
> diff --git a/drivers/cxl/core/memdev.c b/drivers/cxl/core/memdev.c
> index 492486707fd0..397262e0ebd2 100644
> --- a/drivers/cxl/core/memdev.c
> +++ b/drivers/cxl/core/memdev.c
> @@ -101,6 +101,20 @@ static ssize_t pmem_size_show(struct device *dev, struct device_attribute *attr,
>  static struct device_attribute dev_attr_pmem_size =
>  	__ATTR(size, 0444, pmem_size_show, NULL);
>  
> +static ssize_t region_count_show(struct device *dev, struct device_attribute *attr,
> +				 char *buf)
> +{
> +	struct cxl_memdev *cxlmd = to_cxl_memdev(dev);
> +	struct cxl_memdev_state *mds = to_cxl_memdev_state(cxlmd->cxlds);
> +	int len = 0;
> +
> +	len = sysfs_emit(buf, "%d\n", mds->nr_dc_region);
> +	return len;

return sysfs_emit(buf, "...);
	
> +}
> +
> +struct device_attribute dev_attr_region_count =
> +	__ATTR(region_count, 0444, region_count_show, NULL);
> +
>  static ssize_t serial_show(struct device *dev, struct device_attribute *attr,
>  			   char *buf)
>  {
> @@ -454,6 +468,62 @@ static struct attribute *cxl_memdev_security_attributes[] = {
>  	NULL,
>  };
>  
> +static ssize_t show_size_regionN(struct cxl_memdev *cxlmd, char *buf, int pos)
> +{
> +	struct cxl_memdev_state *mds = to_cxl_memdev_state(cxlmd->cxlds);
> +
> +	return sysfs_emit(buf, "%#llx\n", mds->dc_region[pos].decode_len);
> +}
> +
> +#define REGION_SIZE_ATTR_RO(n)						\
> +static ssize_t region##n##_size_show(struct device *dev,		\
> +				     struct device_attribute *attr,	\
> +				     char *buf)				\
> +{									\
> +	return show_size_regionN(to_cxl_memdev(dev), buf, (n));		\
> +}									\
> +static DEVICE_ATTR_RO(region##n##_size)
> +REGION_SIZE_ATTR_RO(0);
> +REGION_SIZE_ATTR_RO(1);
> +REGION_SIZE_ATTR_RO(2);
> +REGION_SIZE_ATTR_RO(3);
> +REGION_SIZE_ATTR_RO(4);
> +REGION_SIZE_ATTR_RO(5);
> +REGION_SIZE_ATTR_RO(6);
> +REGION_SIZE_ATTR_RO(7);
> +
> +static struct attribute *cxl_memdev_dc_attributes[] = {
> +	&dev_attr_region0_size.attr,
> +	&dev_attr_region1_size.attr,
> +	&dev_attr_region2_size.attr,
> +	&dev_attr_region3_size.attr,
> +	&dev_attr_region4_size.attr,
> +	&dev_attr_region5_size.attr,
> +	&dev_attr_region6_size.attr,
> +	&dev_attr_region7_size.attr,
> +	&dev_attr_region_count.attr,
> +	NULL,
> +};
> +
> +static umode_t cxl_dc_visible(struct kobject *kobj, struct attribute *a, int n)
> +{
> +	struct device *dev = kobj_to_dev(kobj);
> +	struct cxl_memdev *cxlmd = to_cxl_memdev(dev);
> +	struct cxl_memdev_state *mds = to_cxl_memdev_state(cxlmd->cxlds);
> +
> +	/* Not a memory device */
> +	if (!mds)
> +		return 0;
> +
> +	if (a == &dev_attr_region_count.attr)
> +		return a->mode;
> +
> +	if (n < mds->nr_dc_region)
> +		return a->mode;
> +
> +	return 0;
> +}
> +
>  static umode_t cxl_memdev_visible(struct kobject *kobj, struct attribute *a,
>  				  int n)
>  {
> @@ -482,11 +552,18 @@ static struct attribute_group cxl_memdev_security_attribute_group = {
>  	.attrs = cxl_memdev_security_attributes,
>  };
>  
> +static struct attribute_group cxl_memdev_dc_attribute_group = {
> +	.name = "dc",
> +	.attrs = cxl_memdev_dc_attributes,
> +	.is_visible = cxl_dc_visible,
> +};
> +
>  static const struct attribute_group *cxl_memdev_attribute_groups[] = {
>  	&cxl_memdev_attribute_group,
>  	&cxl_memdev_ram_attribute_group,
>  	&cxl_memdev_pmem_attribute_group,
>  	&cxl_memdev_security_attribute_group,
> +	&cxl_memdev_dc_attribute_group,
>  	NULL,
>  };
>  
> 


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id D1BE8C83F12
	for <linux-cxl@archiver.kernel.org>; Tue, 29 Aug 2023 15:10:12 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S231527AbjH2PJk (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 29 Aug 2023 11:09:40 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:58160 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S237152AbjH2PJ1 (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 29 Aug 2023 11:09:27 -0400
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 8A481BD;
        Tue, 29 Aug 2023 08:09:23 -0700 (PDT)
Received: from lhrpeml500005.china.huawei.com (unknown [172.18.147.200])
        by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4RZrM245X0z67qpK;
        Tue, 29 Aug 2023 23:05:02 +0800 (CST)
Received: from localhost (10.202.227.76) by lhrpeml500005.china.huawei.com
 (7.191.163.240) with Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id 15.1.2507.31; Tue, 29 Aug
 2023 16:09:20 +0100
Date: Tue, 29 Aug 2023 16:09:19 +0100
From: Jonathan Cameron <Jonathan.Cameron@Huawei.com>
To: Ira Weiny <ira.weiny@intel.com>
CC: Dan Williams <dan.j.williams@intel.com>,
        Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
Subject: Re: [PATCH RFC v2 06/18] cxl/port: Add Dynamic Capacity size
 support to endpoint decoders
Message-ID: <20230829160919.00007f69@Huawei.com>
In-Reply-To: <20230604-dcd-type2-upstream-v2-6-f740c47e7916@intel.com>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
        <20230604-dcd-type2-upstream-v2-6-f740c47e7916@intel.com>
Organization: Huawei Technologies Research and Development (UK) Ltd.
X-Mailer: Claws Mail 4.1.0 (GTK 3.24.33; x86_64-w64-mingw32)
MIME-Version: 1.0
Content-Type: text/plain; charset="US-ASCII"
Content-Transfer-Encoding: 7bit
X-Originating-IP: [10.202.227.76]
X-ClientProxiedBy: lhrpeml500004.china.huawei.com (7.191.163.9) To
 lhrpeml500005.china.huawei.com (7.191.163.240)
X-CFilter-Loop: Reflected
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

On Mon, 28 Aug 2023 22:20:57 -0700
Ira Weiny <ira.weiny@intel.com> wrote:

> To support Dynamic Capacity Devices (DCD) endpoint decoders will need to
> map DC Regions (partitions).  Part of this is assigning the size of the
> DC Region DPA to the decoder in addition to any skip value from the
> previous decoder which exists.  This must be done within a continuous
> DPA space.  Two complications arise with Dynamic Capacity regions which
> did not exist with Ram and PMEM partitions.  First, gaps in the DPA
> space can exist between and around the DC Regions.  Second, the Linux
> resource tree does not allow a resource to be marked across existing
> nodes within a tree.
> 
> For clarity, below is an example of an 60GB device with 10GB of RAM,
> 10GB of PMEM and 10GB for each of 2 DC Regions.  The desired CXL mapping
> is 5GB of RAM, 5GB of PMEM, and all 10GB of DC1.
> 
>      DPA RANGE
>      (dpa_res)
> 0GB        10GB       20GB       30GB       40GB       50GB       60GB
> |----------|----------|----------|----------|----------|----------|
> 
> RAM         PMEM                  DC0                   DC1
>  (ram_res)  (pmem_res)            (dc_res[0])           (dc_res[1])
> |----------|----------|   <gap>  |----------|   <gap>  |----------|
> 
>  RAM        PMEM                                        DC1
> |XXXXX|----|XXXXX|----|----------|----------|----------|XXXXXXXXXX|
> 0GB   5GB  10GB  15GB 20GB       30GB       40GB       50GB       60GB
> 
> The previous skip resource between RAM and PMEM was always a child of
> the RAM resource and fit nicely (see X below).  Because of this
> simplicity this skip resource reference was not stored in any CXL state.
> On release the skip range could be calculated based on the endpoint
> decoders stored values.
> 
> Now when DC1 is being mapped 4 skip resources must be created as
> children.  One of the PMEM resource (A), two of the parent DPA resource
> (B,D), and one more child of the DC0 resource (C).
> 
> 0GB        10GB       20GB       30GB       40GB       50GB       60GB
> |----------|----------|----------|----------|----------|----------|
>                            |                     |
> |----------|----------|    |     |----------|    |     |----------|
>         |          |       |          |          |
>        (X)        (A)     (B)        (C)        (D)
> 	v          v       v          v          v
> |XXXXX|----|XXXXX|----|----------|----------|----------|XXXXXXXXXX|
>        skip       skip  skip        skip      skip
> 
> Expand the calculation of DPA freespace and enhance the logic to support
> mapping/unmapping DC DPA space.  To track the potential of multiple skip
> resources an xarray is attached to the endpoint decoder.  The existing
> algorithm is consolidated with the new one to store a single skip
> resource in the same way as multiple skip resources.
> 
> Co-developed-by: Navneet Singh <navneet.singh@intel.com>
> Signed-off-by: Navneet Singh <navneet.singh@intel.com>
> Signed-off-by: Ira Weiny <ira.weiny@intel.com>

Various minor things noticed inline.

Jonathan

> 
> ---
> An alternative of using reserve_region_with_split() was considered.
> The advantage of that would be keeping all the resource information
> stored solely in the resource tree rather than having separate
> references to them.  However, it would best be implemented with a call
> such as release_split_region() [name TBD?] which could find all the leaf
> resources in the range and release them.  Furthermore, it is not clear
> if reserve_region_with_split() is really intended for anything outside
> of init code.  In the end this algorithm seems straight forward enough.
> 
> Changes for v2:
> [iweiny: write commit message]
> [iweiny: remove unneeded changes]
> [iweiny: split from region creation patch]
> [iweiny: Alter skip algorithm to use 'anonymous regions']
> [iweiny: enhance debug messages]
> [iweiny: consolidate skip resource creation]
> [iweiny: ensure xa_destroy() is called]
> [iweiny: consolidate region requests further]
> [iweiny: ensure resource is released on xa_insert]
> ---
>  drivers/cxl/core/hdm.c  | 188 +++++++++++++++++++++++++++++++++++++++++++-----
>  drivers/cxl/core/port.c |   2 +
>  drivers/cxl/cxl.h       |   2 +
>  3 files changed, 176 insertions(+), 16 deletions(-)
> 
> diff --git a/drivers/cxl/core/hdm.c b/drivers/cxl/core/hdm.c
> index 3f4af1f5fac8..3cd048677816 100644
> --- a/drivers/cxl/core/hdm.c
> +++ b/drivers/cxl/core/hdm.c


> +
> +static int cxl_reserve_dpa_skip(struct cxl_endpoint_decoder *cxled,
> +				resource_size_t base, resource_size_t skipped)
> +{
> +	struct cxl_memdev *cxlmd = cxled_to_memdev(cxled);
> +	struct cxl_port *port = cxled_to_port(cxled);
> +	struct cxl_dev_state *cxlds = cxlmd->cxlds;
> +	resource_size_t skip_base = base - skipped;
> +	resource_size_t size, skip_len = 0;
> +	struct device *dev = &port->dev;
> +	int rc, index;
> +
> +	size = resource_size(&cxlds->ram_res);
> +	if (size && skip_base <= cxlds->ram_res.end) {

This size only used in this if statement I'd just put it inline.
 
> +		skip_len = cxlds->ram_res.end - skip_base + 1;
> +		rc = cxl_request_skip(cxled, skip_base, skip_len);
> +		if (rc)
> +			return rc;
> +		skip_base += skip_len;
> +	}
> +
> +	if (skip_base == base) {
> +		dev_dbg(dev, "skip done!\n");

Not sure that dbg is much help as other places below where skip also done...

> +		return 0;
> +	}
> +
> +	size = resource_size(&cxlds->pmem_res);
> +	if (size && skip_base <= cxlds->pmem_res.end) {

size only used in this if statement. I'd just put
the resource_size() bit inline.

> +		skip_len = cxlds->pmem_res.end - skip_base + 1;
> +		rc = cxl_request_skip(cxled, skip_base, skip_len);
> +		if (rc)
> +			return rc;
> +		skip_base += skip_len;
> +	}
> +
> +	index = dc_mode_to_region_index(cxled->mode);
> +	for (int i = 0; i <= index; i++) {
> +		struct resource *dcr = &cxlds->dc_res[i];
> +
> +		if (skip_base < dcr->start) {
> +			skip_len = dcr->start - skip_base;
> +			rc = cxl_request_skip(cxled, skip_base, skip_len);
> +			if (rc)
> +				return rc;
> +			skip_base += skip_len;
> +		}
> +
> +		if (skip_base == base) {
> +			dev_dbg(dev, "skip done!\n");

As above - perhaps some more info?

> +			break;
> +		}
> +
> +		if (resource_size(dcr) && skip_base <= dcr->end) {
> +			if (skip_base > base)
> +				dev_err(dev, "Skip error\n");

Not return ?  If there is a reason to carry on, I'd like a comment to say what it is.

> +
> +			skip_len = dcr->end - skip_base + 1;
> +			rc = cxl_request_skip(cxled, skip_base, skip_len);
> +			if (rc)
> +				return rc;
> +			skip_base += skip_len;
> +		}
> +	}
> +
> +	return 0;
> +}
> +


> @@ -492,11 +607,13 @@ static resource_size_t cxl_dpa_freespace(struct cxl_endpoint_decoder *cxled,
>  					 resource_size_t *start_out,
>  					 resource_size_t *skip_out)
>  {
> +	resource_size_t free_ram_start, free_pmem_start, free_dc_start;
>  	struct cxl_memdev *cxlmd = cxled_to_memdev(cxled);
> -	resource_size_t free_ram_start, free_pmem_start;
>  	struct cxl_dev_state *cxlds = cxlmd->cxlds;
> +	struct device *dev = &cxled->cxld.dev;

There is one existing (I think) call to dev_dbg(cxled_dev(cxled) ...
in this function.  So both should use that here, and should convert that one
case to using dev.

>  	resource_size_t start, avail, skip;
>  	struct resource *p, *last;
> +	int index;
>  
>  	lockdep_assert_held(&cxl_dpa_rwsem);
>  
> @@ -514,6 +631,20 @@ static resource_size_t cxl_dpa_freespace(struct cxl_endpoint_decoder *cxled,
>  	else
>  		free_pmem_start = cxlds->pmem_res.start;
>  
> +	/*
> +	 * Limit each decoder to a single DC region to map memory with
> +	 * different DSMAS entry.
> +	 */
> +	index = dc_mode_to_region_index(cxled->mode);
> +	if (index >= 0) {
> +		if (cxlds->dc_res[index].child) {
> +			dev_err(dev, "Cannot allocate DPA from DC Region: %d\n",
> +				index);
> +			return -EINVAL;
> +		}
> +		free_dc_start = cxlds->dc_res[index].start;
> +	}
> +
>  	if (cxled->mode == CXL_DECODER_RAM) {
>  		start = free_ram_start;
>  		avail = cxlds->ram_res.end - start + 1;
> @@ -535,6 +666,29 @@ static resource_size_t cxl_dpa_freespace(struct cxl_endpoint_decoder *cxled,
>  		else
>  			skip_end = start - 1;
>  		skip = skip_end - skip_start + 1;
> +	} else if (cxl_decoder_mode_is_dc(cxled->mode)) {
> +		resource_size_t skip_start, skip_end;
> +
> +		start = free_dc_start;
> +		avail = cxlds->dc_res[index].end - start + 1;
> +		if ((resource_size(&cxlds->pmem_res) == 0) || !cxlds->pmem_res.child)

Previous patch used !resource_size()
I prefer compare with 0 like you have here, but which ever is chosen, things should
be consistent.

...


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id BF1E8C6FA8F
	for <linux-cxl@archiver.kernel.org>; Tue, 29 Aug 2023 14:50:24 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S231171AbjH2Oty (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 29 Aug 2023 10:49:54 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:37674 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S230054AbjH2Otw (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 29 Aug 2023 10:49:52 -0400
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 4F8A3194;
        Tue, 29 Aug 2023 07:49:49 -0700 (PDT)
Received: from lhrpeml500005.china.huawei.com (unknown [172.18.147.200])
        by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4RZqvx5ySzz6K63w;
        Tue, 29 Aug 2023 22:45:01 +0800 (CST)
Received: from localhost (10.202.227.76) by lhrpeml500005.china.huawei.com
 (7.191.163.240) with Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id 15.1.2507.31; Tue, 29 Aug
 2023 15:49:46 +0100
Date: Tue, 29 Aug 2023 15:49:45 +0100
From: Jonathan Cameron <Jonathan.Cameron@Huawei.com>
To: Ira Weiny <ira.weiny@intel.com>
CC: Dan Williams <dan.j.williams@intel.com>,
        Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
Subject: Re: [PATCH RFC v2 05/18] cxl/port: Add Dynamic Capacity mode
 support to endpoint decoders
Message-ID: <20230829154945.00002870@Huawei.com>
In-Reply-To: <20230604-dcd-type2-upstream-v2-5-f740c47e7916@intel.com>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
        <20230604-dcd-type2-upstream-v2-5-f740c47e7916@intel.com>
Organization: Huawei Technologies Research and Development (UK) Ltd.
X-Mailer: Claws Mail 4.1.0 (GTK 3.24.33; x86_64-w64-mingw32)
MIME-Version: 1.0
Content-Type: text/plain; charset="US-ASCII"
Content-Transfer-Encoding: 7bit
X-Originating-IP: [10.202.227.76]
X-ClientProxiedBy: lhrpeml500002.china.huawei.com (7.191.160.78) To
 lhrpeml500005.china.huawei.com (7.191.163.240)
X-CFilter-Loop: Reflected
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

On Mon, 28 Aug 2023 22:20:56 -0700
Ira Weiny <ira.weiny@intel.com> wrote:

> Endpoint decoders used to map Dynamic Capacity must be configured to
> point to the correct Dynamic Capacity (DC) Region.  The decoder mode
> currently represents the partition the decoder points to such as ram or
> pmem.
> 
> Expand the mode to include DC Regions.
> 
> Co-developed-by: Navneet Singh <navneet.singh@intel.com>
> Signed-off-by: Navneet Singh <navneet.singh@intel.com>
> Signed-off-by: Ira Weiny <ira.weiny@intel.com>

I'm reading this in a linear fashion for now (and ideally that should
always make sense) so I don't currently see the reason for the loops
in here. If they are needed for a future patch, add something to the
description to indicate that.

> 
> ---
> Changes for v2:
> [iweiny: split from region creation patch]
> ---
>  Documentation/ABI/testing/sysfs-bus-cxl | 19 ++++++++++---------
>  drivers/cxl/core/hdm.c                  | 24 ++++++++++++++++++++++++
>  drivers/cxl/core/port.c                 | 16 ++++++++++++++++
>  3 files changed, 50 insertions(+), 9 deletions(-)
> 
> diff --git a/Documentation/ABI/testing/sysfs-bus-cxl b/Documentation/ABI/testing/sysfs-bus-cxl
> index 6350dd82b9a9..2268ffcdb604 100644
> --- a/Documentation/ABI/testing/sysfs-bus-cxl
> +++ b/Documentation/ABI/testing/sysfs-bus-cxl
> @@ -257,22 +257,23 @@ Description:
>  
>  What:		/sys/bus/cxl/devices/decoderX.Y/mode
>  Date:		May, 2022
> -KernelVersion:	v6.0
> +KernelVersion:	v6.0, v6.6 (dcY)
>  Contact:	linux-cxl@vger.kernel.org
>  Description:
>  		(RW) When a CXL decoder is of devtype "cxl_decoder_endpoint" it
>  		translates from a host physical address range, to a device local
>  		address range. Device-local address ranges are further split
> -		into a 'ram' (volatile memory) range and 'pmem' (persistent
> -		memory) range. The 'mode' attribute emits one of 'ram', 'pmem',
> -		'mixed', or 'none'. The 'mixed' indication is for error cases
> -		when a decoder straddles the volatile/persistent partition
> -		boundary, and 'none' indicates the decoder is not actively
> -		decoding, or no DPA allocation policy has been set.
> +		into a 'ram' (volatile memory) range, 'pmem' (persistent
> +		memory) range, or Dynamic Capacity (DC) range. The 'mode'
> +		attribute emits one of 'ram', 'pmem', 'dcY', 'mixed', or
> +		'none'. The 'mixed' indication is for error cases when a
> +		decoder straddles the volatile/persistent partition boundary,
> +		and 'none' indicates the decoder is not actively decoding, or
> +		no DPA allocation policy has been set.
>  
>  		'mode' can be written, when the decoder is in the 'disabled'
> -		state, with either 'ram' or 'pmem' to set the boundaries for the
> -		next allocation.
> +		state, with 'ram', 'pmem', or 'dcY' to set the boundaries for
> +		the next allocation.
>  
>  
>  What:		/sys/bus/cxl/devices/decoderX.Y/dpa_resource
> diff --git a/drivers/cxl/core/hdm.c b/drivers/cxl/core/hdm.c
> index a254f79dd4e8..3f4af1f5fac8 100644
> --- a/drivers/cxl/core/hdm.c
> +++ b/drivers/cxl/core/hdm.c
> @@ -267,6 +267,19 @@ static void devm_cxl_dpa_release(struct cxl_endpoint_decoder *cxled)
>  	__cxl_dpa_release(cxled);
>  }
>  
> +static int dc_mode_to_region_index(enum cxl_decoder_mode mode)
> +{
> +	int index = 0;
> +
> +	for (int i = CXL_DECODER_DC0; i <= CXL_DECODER_DC7; i++) {
As you are relying on them being in order and adjacent for the loop, why is

	if (mode < CXL_DECODER_DC0 || mode > CXL_DECODER_DC7)
		return -EINVAL;

	return mode - CXL_DECODER_DC0;

Not sufficient?

> +		if (mode == i)
> +			return index;
> +		index++;
> +	}
> +
> +	return -EINVAL;
> +}
> +
>  static int __cxl_dpa_reserve(struct cxl_endpoint_decoder *cxled,
>  			     resource_size_t base, resource_size_t len,
>  			     resource_size_t skipped)
> @@ -429,6 +442,7 @@ int cxl_dpa_set_mode(struct cxl_endpoint_decoder *cxled,
>  	switch (mode) {
>  	case CXL_DECODER_RAM:
>  	case CXL_DECODER_PMEM:
> +	case CXL_DECODER_DC0 ... CXL_DECODER_DC7:
>  		break;
>  	default:
>  		dev_dbg(dev, "unsupported mode: %d\n", mode);
> @@ -456,6 +470,16 @@ int cxl_dpa_set_mode(struct cxl_endpoint_decoder *cxled,
>  		goto out;
>  	}
>  
> +	for (int i = CXL_DECODER_DC0; i <= CXL_DECODER_DC7; i++) {
> +		int index = dc_mode_to_region_index(i);
> +
> +		if (mode == i && !resource_size(&cxlds->dc_res[index])) {

Not obvious why we have the loop in this patch - perhaps it makes sense later.
If this is to enable later changes, then good to say that in the patch description.
otherwise, something like.

	int index;
	
	rc = dc_mode_to_region_index(i);
	if (rc < 0)
		goto out;

	index = rc;
	if (!resource_size(&cxlds->dc_res[index]) {
	....
		
	
	 	

> +			dev_dbg(dev, "no available dynamic capacity\n");
> +			rc = -ENXIO;
> +			goto out;
> +		}
> +	}
> +
>  	cxled->mode = mode;
>  	rc = 0;
>  out:
> diff --git a/drivers/cxl/core/port.c b/drivers/cxl/core/port.c
> index f58cf01f8d2c..ce4a66865db3 100644
> --- a/drivers/cxl/core/port.c
> +++ b/drivers/cxl/core/port.c
> @@ -197,6 +197,22 @@ static ssize_t mode_store(struct device *dev, struct device_attribute *attr,
>  		mode = CXL_DECODER_PMEM;
>  	else if (sysfs_streq(buf, "ram"))
>  		mode = CXL_DECODER_RAM;
> +	else if (sysfs_streq(buf, "dc0"))
> +		mode = CXL_DECODER_DC0;
> +	else if (sysfs_streq(buf, "dc1"))
> +		mode = CXL_DECODER_DC1;
> +	else if (sysfs_streq(buf, "dc2"))
> +		mode = CXL_DECODER_DC2;
> +	else if (sysfs_streq(buf, "dc3"))
> +		mode = CXL_DECODER_DC3;
> +	else if (sysfs_streq(buf, "dc4"))
> +		mode = CXL_DECODER_DC4;
> +	else if (sysfs_streq(buf, "dc5"))
> +		mode = CXL_DECODER_DC5;
> +	else if (sysfs_streq(buf, "dc6"))
> +		mode = CXL_DECODER_DC6;
> +	else if (sysfs_streq(buf, "dc7"))
> +		mode = CXL_DECODER_DC7;
>  	else
>  		return -EINVAL;
>  
> 


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 2C358C6FA8F
	for <linux-cxl@archiver.kernel.org>; Tue, 29 Aug 2023 14:40:48 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S234589AbjH2OkS (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 29 Aug 2023 10:40:18 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:54426 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S232893AbjH2Ojs (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 29 Aug 2023 10:39:48 -0400
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 190CECC;
        Tue, 29 Aug 2023 07:39:46 -0700 (PDT)
Received: from lhrpeml500005.china.huawei.com (unknown [172.18.147.207])
        by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4RZqhM0VpDz67wsC;
        Tue, 29 Aug 2023 22:34:59 +0800 (CST)
Received: from localhost (10.202.227.76) by lhrpeml500005.china.huawei.com
 (7.191.163.240) with Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id 15.1.2507.31; Tue, 29 Aug
 2023 15:39:43 +0100
Date: Tue, 29 Aug 2023 15:39:42 +0100
From: Jonathan Cameron <Jonathan.Cameron@Huawei.com>
To: Ira Weiny <ira.weiny@intel.com>
CC: Dan Williams <dan.j.williams@intel.com>,
        Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
Subject: Re: [PATCH RFC v2 04/18] cxl/region: Add Dynamic Capacity decoder
 and region modes
Message-ID: <20230829153942.000072b9@Huawei.com>
In-Reply-To: <20230604-dcd-type2-upstream-v2-4-f740c47e7916@intel.com>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
        <20230604-dcd-type2-upstream-v2-4-f740c47e7916@intel.com>
Organization: Huawei Technologies Research and Development (UK) Ltd.
X-Mailer: Claws Mail 4.1.0 (GTK 3.24.33; x86_64-w64-mingw32)
MIME-Version: 1.0
Content-Type: text/plain; charset="US-ASCII"
Content-Transfer-Encoding: 7bit
X-Originating-IP: [10.202.227.76]
X-ClientProxiedBy: lhrpeml500003.china.huawei.com (7.191.162.67) To
 lhrpeml500005.china.huawei.com (7.191.163.240)
X-CFilter-Loop: Reflected
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

On Mon, 28 Aug 2023 22:20:55 -0700
Ira Weiny <ira.weiny@intel.com> wrote:

> Both regions and decoders will need a new mode to reflect the new type
> of partition they are targeting on a device.  Regions reflect a dynamic
> capacity type which may point to different Dynamic Capacity (DC)
> Regions.  Decoder mode reflects a specific DC Region.
> 
> Define the new modes to use in subsequent patches and the helper
> functions associated with them.
> 
> Co-developed-by: Navneet Singh <navneet.singh@intel.com>
> Signed-off-by: Navneet Singh <navneet.singh@intel.com>
> Signed-off-by: Ira Weiny <ira.weiny@intel.com>

Looks fine, though I'll be interested to see how it is used in later patches
as DC region does feel somewhat separate from the other types.

Reviewed-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
> 
> ---
> Changes for v2:
> [iweiny: split out from: Add dynamic capacity cxl region support.]
> ---
>  drivers/cxl/core/region.c |  4 ++++
>  drivers/cxl/cxl.h         | 23 +++++++++++++++++++++++
>  2 files changed, 27 insertions(+)
> 
> diff --git a/drivers/cxl/core/region.c b/drivers/cxl/core/region.c
> index 75041903b72c..69af1354bc5b 100644
> --- a/drivers/cxl/core/region.c
> +++ b/drivers/cxl/core/region.c
> @@ -1772,6 +1772,8 @@ static bool cxl_modes_compatible(enum cxl_region_mode rmode,
>  		return true;
>  	if (rmode == CXL_REGION_PMEM && dmode == CXL_DECODER_PMEM)
>  		return true;
> +	if (rmode == CXL_REGION_DC && cxl_decoder_mode_is_dc(dmode))
> +		return true;
>  
>  	return false;
>  }
> @@ -2912,6 +2914,8 @@ cxl_decoder_to_region_mode(enum cxl_decoder_mode mode)
>  		return CXL_REGION_PMEM;
>  	case CXL_DECODER_DEAD:
>  		return CXL_REGION_DEAD;
> +	case CXL_DECODER_DC0 ... CXL_DECODER_DC7:
> +		return CXL_REGION_DC;
>  	case CXL_DECODER_MIXED:
>  	default:
>  		return CXL_REGION_MIXED;
> diff --git a/drivers/cxl/cxl.h b/drivers/cxl/cxl.h
> index ed282dcd5cf5..d41f3f14fbe3 100644
> --- a/drivers/cxl/cxl.h
> +++ b/drivers/cxl/cxl.h
> @@ -356,6 +356,14 @@ enum cxl_decoder_mode {
>  	CXL_DECODER_NONE,
>  	CXL_DECODER_RAM,
>  	CXL_DECODER_PMEM,
> +	CXL_DECODER_DC0,
> +	CXL_DECODER_DC1,
> +	CXL_DECODER_DC2,
> +	CXL_DECODER_DC3,
> +	CXL_DECODER_DC4,
> +	CXL_DECODER_DC5,
> +	CXL_DECODER_DC6,
> +	CXL_DECODER_DC7,
>  	CXL_DECODER_MIXED,
>  	CXL_DECODER_DEAD,
>  };
> @@ -366,6 +374,14 @@ static inline const char *cxl_decoder_mode_name(enum cxl_decoder_mode mode)
>  		[CXL_DECODER_NONE] = "none",
>  		[CXL_DECODER_RAM] = "ram",
>  		[CXL_DECODER_PMEM] = "pmem",
> +		[CXL_DECODER_DC0] = "dc0",
> +		[CXL_DECODER_DC1] = "dc1",
> +		[CXL_DECODER_DC2] = "dc2",
> +		[CXL_DECODER_DC3] = "dc3",
> +		[CXL_DECODER_DC4] = "dc4",
> +		[CXL_DECODER_DC5] = "dc5",
> +		[CXL_DECODER_DC6] = "dc6",
> +		[CXL_DECODER_DC7] = "dc7",
>  		[CXL_DECODER_MIXED] = "mixed",
>  	};
>  
> @@ -374,10 +390,16 @@ static inline const char *cxl_decoder_mode_name(enum cxl_decoder_mode mode)
>  	return "mixed";
>  }
>  
> +static inline bool cxl_decoder_mode_is_dc(enum cxl_decoder_mode mode)
> +{
> +	return (mode >= CXL_DECODER_DC0 && mode <= CXL_DECODER_DC7);
> +}
> +
>  enum cxl_region_mode {
>  	CXL_REGION_NONE,
>  	CXL_REGION_RAM,
>  	CXL_REGION_PMEM,
> +	CXL_REGION_DC,
>  	CXL_REGION_MIXED,
>  	CXL_REGION_DEAD,
>  };
> @@ -388,6 +410,7 @@ static inline const char *cxl_region_mode_name(enum cxl_region_mode mode)
>  		[CXL_REGION_NONE] = "none",
>  		[CXL_REGION_RAM] = "ram",
>  		[CXL_REGION_PMEM] = "pmem",
> +		[CXL_REGION_DC] = "dc",
>  		[CXL_REGION_MIXED] = "mixed",
>  	};
>  
> 


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 0AD3BC6FA8F
	for <linux-cxl@archiver.kernel.org>; Tue, 29 Aug 2023 14:38:06 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S232689AbjH2Ohh (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 29 Aug 2023 10:37:37 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:52758 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S237020AbjH2Oh2 (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 29 Aug 2023 10:37:28 -0400
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 4E2AE198;
        Tue, 29 Aug 2023 07:37:18 -0700 (PDT)
Received: from lhrpeml500005.china.huawei.com (unknown [172.18.147.200])
        by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4RZqf13DNMz67n0t;
        Tue, 29 Aug 2023 22:32:57 +0800 (CST)
Received: from localhost (10.202.227.76) by lhrpeml500005.china.huawei.com
 (7.191.163.240) with Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id 15.1.2507.31; Tue, 29 Aug
 2023 15:37:15 +0100
Date: Tue, 29 Aug 2023 15:37:14 +0100
From: Jonathan Cameron <Jonathan.Cameron@Huawei.com>
To: <ira.weiny@intel.com>
CC: Dan Williams <dan.j.williams@intel.com>,
        Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
Subject: Re: [PATCH RFC v2 03/18] cxl/mem: Read Dynamic capacity
 configuration from the device
Message-ID: <20230829153714.00000a4c@Huawei.com>
In-Reply-To: <20230604-dcd-type2-upstream-v2-3-f740c47e7916@intel.com>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
        <20230604-dcd-type2-upstream-v2-3-f740c47e7916@intel.com>
Organization: Huawei Technologies Research and Development (UK) Ltd.
X-Mailer: Claws Mail 4.1.0 (GTK 3.24.33; x86_64-w64-mingw32)
MIME-Version: 1.0
Content-Type: text/plain; charset="US-ASCII"
Content-Transfer-Encoding: 7bit
X-Originating-IP: [10.202.227.76]
X-ClientProxiedBy: lhrpeml500003.china.huawei.com (7.191.162.67) To
 lhrpeml500005.china.huawei.com (7.191.163.240)
X-CFilter-Loop: Reflected
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

On Mon, 28 Aug 2023 22:20:54 -0700
ira.weiny@intel.com wrote:

> From: Navneet Singh <navneet.singh@intel.com>
> 
> Devices can optionally support Dynamic Capacity (DC).  These devices are
> known as Dynamic Capacity Devices (DCD).
> 
> Implement the DC (opcode 48XXh) mailbox commands as specified in CXL 3.0
> section 8.2.9.8.9.  Read the DC configuration and store the DC region
> information in the device state.
> 
> Co-developed-by: Navneet Singh <navneet.singh@intel.com>
> Signed-off-by: Navneet Singh <navneet.singh@intel.com>
> Signed-off-by: Ira Weiny <ira.weiny@intel.com>
> 
Hi.

A few minor things inline.  Otherwise, I wonder if it's worth separating
the mode of the region from that of the endpoint decoder in a precusor patch.
That's a large part of this one and not really related to the mbox command stuff.

Jonathan


...

> +
> +/* Returns the number of regions in dc_resp or -ERRNO */
> +static int cxl_get_dc_id(struct cxl_memdev_state *mds, u8 start_region,
> +			 struct cxl_mbox_dynamic_capacity *dc_resp,
> +			 size_t dc_resp_size)
> +{
> +	struct cxl_mbox_get_dc_config get_dc = (struct cxl_mbox_get_dc_config) {
> +		.region_count = CXL_MAX_DC_REGION,
> +		.start_region_index = start_region,
> +	};
> +	struct cxl_mbox_cmd mbox_cmd = (struct cxl_mbox_cmd) {
> +		.opcode = CXL_MBOX_OP_GET_DC_CONFIG,
> +		.payload_in = &get_dc,
> +		.size_in = sizeof(get_dc),
> +		.size_out = dc_resp_size,
> +		.payload_out = dc_resp,
> +		.min_out = 1,
> +	};
> +	struct device *dev = mds->cxlds.dev;
> +	int rc;
> +
> +	rc = cxl_internal_send_cmd(mds, &mbox_cmd);
> +	if (rc < 0)
> +		return rc;
> +
> +	rc = dc_resp->avail_region_count - start_region;
> +
> +	/*
> +	 * The number of regions in the payload may have been truncated due to
> +	 * payload_size limits; if so adjust the count in this query.

Not adjusting the query.  "if so adjust the returned count to match."

> +	 */
> +	if (mbox_cmd.size_out < sizeof(*dc_resp))
> +		rc = CXL_REGIONS_RETURNED(mbox_cmd.size_out);
> +
> +	dev_dbg(dev, "Read %d/%d DC regions\n", rc, dc_resp->avail_region_count);
> +
> +	return rc;
> +}
> +
> +/**
> + * cxl_dev_dynamic_capacity_identify() - Reads the dynamic capacity
> + *					 information from the device.
> + * @mds: The memory device state
> + *
> + * This will dispatch the get_dynamic_capacity command to the device
> + * and on success populate structures to be exported to sysfs.

I'd skip the 'exported to sysfs' as I'd guess this will have other uses
(maybe) in the longer term.

and on success populate state structures for later use.

> + *
> + * Return: 0 if identify was executed successfully, -ERRNO on error.
> + */
> +int cxl_dev_dynamic_capacity_identify(struct cxl_memdev_state *mds)
> +{
> +	struct cxl_mbox_dynamic_capacity *dc_resp;
> +	struct device *dev = mds->cxlds.dev;
> +	size_t dc_resp_size = mds->payload_size;
> +	u8 start_region;
> +	int i, rc = 0;
> +
> +	for (i = 0; i < CXL_MAX_DC_REGION; i++)
> +		snprintf(mds->dc_region[i].name, CXL_DC_REGION_STRLEN, "<nil>");
> +
> +	/* Check GET_DC_CONFIG is supported by device */
> +	if (!test_bit(CXL_DCD_ENABLED_GET_CONFIG, mds->dcd_cmds)) {
> +		dev_dbg(dev, "unsupported cmd: get_dynamic_capacity_config\n");
> +		return 0;
> +	}
> +
> +	dc_resp = kvmalloc(dc_resp_size, GFP_KERNEL);                         
> +	if (!dc_resp)                                                                
> +		return -ENOMEM;                                                 
> +
> +	start_region = 0;
> +	do {
> +		int j;
> +
> +		rc = cxl_get_dc_id(mds, start_region, dc_resp, dc_resp_size);

I'd spell out identify.
Initially I thought this was getting an index.


> +		if (rc < 0)
> +			goto free_resp;
> +
> +		mds->nr_dc_region += rc;
> +
> +		if (mds->nr_dc_region < 1 || mds->nr_dc_region > CXL_MAX_DC_REGION) {
> +			dev_err(dev, "Invalid num of dynamic capacity regions %d\n",
> +				mds->nr_dc_region);
> +			rc = -EINVAL;
> +			goto free_resp;
> +		}
> +
> +		for (i = start_region, j = 0; i < mds->nr_dc_region; i++, j++) {
> +			rc = cxl_dc_save_region_info(mds, i, &dc_resp->region[j]);
> +			if (rc)
> +				goto free_resp;
> +		}
> +
> +		start_region = mds->nr_dc_region;
> +
> +	} while (mds->nr_dc_region < dc_resp->avail_region_count);
> +
> +	mds->dynamic_cap =
> +		mds->dc_region[mds->nr_dc_region - 1].base +
> +		mds->dc_region[mds->nr_dc_region - 1].decode_len -
> +		mds->dc_region[0].base;
> +	dev_dbg(dev, "Total dynamic capacity: %#llx\n", mds->dynamic_cap);
> +
> +free_resp:
> +	kfree(dc_resp);

Maybe a first use for __free in cxl?

See include/linux/cleanup.h
Would enable returns rather than goto and label.



> +	if (rc)
> +		dev_err(dev, "Failed to get DC info: %d\n", rc);

I'd prefer to see more specific debug in the few paths that don't already
print it above.

> +	return rc;
> +}
> +EXPORT_SYMBOL_NS_GPL(cxl_dev_dynamic_capacity_identify, CXL);
> +
>  static int add_dpa_res(struct device *dev, struct resource *parent,
>  		       struct resource *res, resource_size_t start,
>  		       resource_size_t size, const char *type)
> @@ -1208,8 +1369,12 @@ int cxl_mem_create_range_info(struct cxl_memdev_state *mds)
>  {
>  	struct cxl_dev_state *cxlds = &mds->cxlds;
>  	struct device *dev = cxlds->dev;
> +	size_t untenanted_mem;
>  	int rc;
>  
> +	untenanted_mem = mds->dc_region[0].base - mds->static_cap;
> +	mds->total_bytes = mds->static_cap + untenanted_mem + mds->dynamic_cap;
> +
>  	if (!cxlds->media_ready) {
>  		cxlds->dpa_res = DEFINE_RES_MEM(0, 0);
>  		cxlds->ram_res = DEFINE_RES_MEM(0, 0);
> @@ -1217,8 +1382,16 @@ int cxl_mem_create_range_info(struct cxl_memdev_state *mds)
>  		return 0;
>  	}
>  
> -	cxlds->dpa_res =
> -		(struct resource)DEFINE_RES_MEM(0, mds->total_bytes);
> +	cxlds->dpa_res = (struct resource)DEFINE_RES_MEM(0, mds->total_bytes);

Beat back that auto-formater! Or just run it once and fix everything before
doing anything new.

> +
> +	for (int i = 0; i < mds->nr_dc_region; i++) {
> +		struct cxl_dc_region_info *dcr = &mds->dc_region[i];
> +
> +		rc = add_dpa_res(dev, &cxlds->dpa_res, &cxlds->dc_res[i],
> +				 dcr->base, dcr->decode_len, dcr->name);
> +		if (rc)
> +			return rc;
> +	}
>  
>  	if (mds->partition_align_bytes == 0) {
>  		rc = add_dpa_res(dev, &cxlds->dpa_res, &cxlds->ram_res, 0,
> diff --git a/drivers/cxl/core/region.c b/drivers/cxl/core/region.c
> index 252bc8e1f103..75041903b72c 100644
> --- a/drivers/cxl/core/region.c
> +++ b/drivers/cxl/core/region.c
> @@ -46,7 +46,7 @@ static ssize_t uuid_show(struct device *dev, struct device_attribute *attr,
>  	rc = down_read_interruptible(&cxl_region_rwsem);
>  	if (rc)
>  		return rc;
> -	if (cxlr->mode != CXL_DECODER_PMEM)
> +	if (cxlr->mode != CXL_REGION_PMEM)
>  		rc = sysfs_emit(buf, "\n");
>  	else
>  		rc = sysfs_emit(buf, "%pUb\n", &p->uuid);
> @@ -359,7 +359,7 @@ static umode_t cxl_region_visible(struct kobject *kobj, struct attribute *a,
>  	 * Support tooling that expects to find a 'uuid' attribute for all
>  	 * regions regardless of mode.
>  	 */
> -	if (a == &dev_attr_uuid.attr && cxlr->mode != CXL_DECODER_PMEM)
> +	if (a == &dev_attr_uuid.attr && cxlr->mode != CXL_REGION_PMEM)
>  		return 0444;
>  	return a->mode;
>  }
> @@ -537,7 +537,7 @@ static ssize_t mode_show(struct device *dev, struct device_attribute *attr,
>  {
>  	struct cxl_region *cxlr = to_cxl_region(dev);
>  
> -	return sysfs_emit(buf, "%s\n", cxl_decoder_mode_name(cxlr->mode));
> +	return sysfs_emit(buf, "%s\n", cxl_region_mode_name(cxlr->mode));
>  }
>  static DEVICE_ATTR_RO(mode);
>  
> @@ -563,7 +563,7 @@ static int alloc_hpa(struct cxl_region *cxlr, resource_size_t size)
>  
>  	/* ways, granularity and uuid (if PMEM) need to be set before HPA */
>  	if (!p->interleave_ways || !p->interleave_granularity ||
> -	    (cxlr->mode == CXL_DECODER_PMEM && uuid_is_null(&p->uuid)))
> +	    (cxlr->mode == CXL_REGION_PMEM && uuid_is_null(&p->uuid)))
>  		return -ENXIO;
>  
>  	div_u64_rem(size, SZ_256M * p->interleave_ways, &remainder);
> @@ -1765,6 +1765,17 @@ static int cxl_region_sort_targets(struct cxl_region *cxlr)
>  	return rc;
>  }
>  
> +static bool cxl_modes_compatible(enum cxl_region_mode rmode,
> +				 enum cxl_decoder_mode dmode)
> +{
> +	if (rmode == CXL_REGION_RAM && dmode == CXL_DECODER_RAM)
> +		return true;
> +	if (rmode == CXL_REGION_PMEM && dmode == CXL_DECODER_PMEM)
> +		return true;
> +
> +	return false;
> +}
> +
>  static int cxl_region_attach(struct cxl_region *cxlr,
>  			     struct cxl_endpoint_decoder *cxled, int pos)
>  {
> @@ -1778,9 +1789,11 @@ static int cxl_region_attach(struct cxl_region *cxlr,
>  	lockdep_assert_held_write(&cxl_region_rwsem);
>  	lockdep_assert_held_read(&cxl_dpa_rwsem);
>  
> -	if (cxled->mode != cxlr->mode) {
> -		dev_dbg(&cxlr->dev, "%s region mode: %d mismatch: %d\n",
> -			dev_name(&cxled->cxld.dev), cxlr->mode, cxled->mode);
> +	if (!cxl_modes_compatible(cxlr->mode, cxled->mode)) {
> +		dev_dbg(&cxlr->dev, "%s region mode: %s mismatch decoder: %s\n",
> +			dev_name(&cxled->cxld.dev),
> +			cxl_region_mode_name(cxlr->mode),
> +			cxl_decoder_mode_name(cxled->mode));
>  		return -EINVAL;
>  	}
>  
> @@ -2234,7 +2247,7 @@ static struct cxl_region *cxl_region_alloc(struct cxl_root_decoder *cxlrd, int i
>   * devm_cxl_add_region - Adds a region to a decoder
>   * @cxlrd: root decoder
>   * @id: memregion id to create, or memregion_free() on failure
> - * @mode: mode for the endpoint decoders of this region
> + * @mode: mode of this region
>   * @type: select whether this is an expander or accelerator (type-2 or type-3)
>   *
>   * This is the second step of region initialization. Regions exist within an
> @@ -2245,7 +2258,7 @@ static struct cxl_region *cxl_region_alloc(struct cxl_root_decoder *cxlrd, int i
>   */
>  static struct cxl_region *devm_cxl_add_region(struct cxl_root_decoder *cxlrd,
>  					      int id,
> -					      enum cxl_decoder_mode mode,
> +					      enum cxl_region_mode mode,
>  					      enum cxl_decoder_type type)
>  {
>  	struct cxl_port *port = to_cxl_port(cxlrd->cxlsd.cxld.dev.parent);
> @@ -2254,11 +2267,12 @@ static struct cxl_region *devm_cxl_add_region(struct cxl_root_decoder *cxlrd,
>  	int rc;
>  
>  	switch (mode) {
> -	case CXL_DECODER_RAM:
> -	case CXL_DECODER_PMEM:
> +	case CXL_REGION_RAM:
> +	case CXL_REGION_PMEM:
>  		break;
>  	default:
> -		dev_err(&cxlrd->cxlsd.cxld.dev, "unsupported mode %d\n", mode);

Arguably should have been moved to the cxl_decoder_mode_name() in patch 1
before being changed to cxl_region_mode_name() when the two are separated in this
patch.  You could just add a note to patch 1 to say 'other instances will be
covered by refactors shortly'. 

> +		dev_err(&cxlrd->cxlsd.cxld.dev, "unsupported mode %s\n",
> +			cxl_region_mode_name(mode));
>  		return ERR_PTR(-EINVAL);
>  	}
>  
> @@ -2308,7 +2322,7 @@ static ssize_t create_ram_region_show(struct device *dev,
>  }
>  
>  static struct cxl_region *__create_region(struct cxl_root_decoder *cxlrd,
> -					  int id, enum cxl_decoder_mode mode,
> +					  int id, enum cxl_region_mode mode,
>  					  enum cxl_decoder_type type)
>  {
>  	int rc;
> @@ -2337,7 +2351,7 @@ static ssize_t create_pmem_region_store(struct device *dev,
>  	if (rc != 1)
>  		return -EINVAL;
>  
> -	cxlr = __create_region(cxlrd, id, CXL_DECODER_PMEM,
> +	cxlr = __create_region(cxlrd, id, CXL_REGION_PMEM,
>  			       CXL_DECODER_HOSTONLYMEM);
>  	if (IS_ERR(cxlr))
>  		return PTR_ERR(cxlr);
> @@ -2358,7 +2372,7 @@ static ssize_t create_ram_region_store(struct device *dev,
>  	if (rc != 1)
>  		return -EINVAL;
>  
> -	cxlr = __create_region(cxlrd, id, CXL_DECODER_RAM,
> +	cxlr = __create_region(cxlrd, id, CXL_REGION_RAM,
>  			       CXL_DECODER_HOSTONLYMEM);
>  	if (IS_ERR(cxlr))
>  		return PTR_ERR(cxlr);
> @@ -2886,10 +2900,31 @@ static void construct_region_end(void)
>  	up_write(&cxl_region_rwsem);
>  }
>  
> +static enum cxl_region_mode
> +cxl_decoder_to_region_mode(enum cxl_decoder_mode mode)
> +{
> +	switch (mode) {
> +	case CXL_DECODER_NONE:
> +		return CXL_REGION_NONE;
> +	case CXL_DECODER_RAM:
> +		return CXL_REGION_RAM;
> +	case CXL_DECODER_PMEM:
> +		return CXL_REGION_PMEM;
> +	case CXL_DECODER_DEAD:
> +		return CXL_REGION_DEAD;
> +	case CXL_DECODER_MIXED:
> +	default:
> +		return CXL_REGION_MIXED;
> +	}
> +
> +	return CXL_REGION_MIXED;
> +}
> +
>  static struct cxl_region *
>  construct_region_begin(struct cxl_root_decoder *cxlrd,
>  		       struct cxl_endpoint_decoder *cxled)
>  {
> +	enum cxl_region_mode mode = cxl_decoder_to_region_mode(cxled->mode);
>  	struct cxl_memdev *cxlmd = cxled_to_memdev(cxled);
>  	struct cxl_region_params *p;
>  	struct cxl_region *cxlr;
> @@ -2897,7 +2932,7 @@ construct_region_begin(struct cxl_root_decoder *cxlrd,
>  
>  	do {
>  		cxlr = __create_region(cxlrd, atomic_read(&cxlrd->region_id),
> -				       cxled->mode, cxled->cxld.target_type);
> +				       mode, cxled->cxld.target_type);
>  	} while (IS_ERR(cxlr) && PTR_ERR(cxlr) == -EBUSY);
>  
>  	if (IS_ERR(cxlr)) {
> @@ -3200,9 +3235,9 @@ static int cxl_region_probe(struct device *dev)
>  		return rc;
>  
>  	switch (cxlr->mode) {
> -	case CXL_DECODER_PMEM:
> +	case CXL_REGION_PMEM:
>  		return devm_cxl_add_pmem_region(cxlr);
> -	case CXL_DECODER_RAM:
> +	case CXL_REGION_RAM:
>  		/*
>  		 * The region can not be manged by CXL if any portion of
>  		 * it is already online as 'System RAM'
> @@ -3223,8 +3258,8 @@ static int cxl_region_probe(struct device *dev)
>  		/* HDM-H routes to device-dax */
>  		return devm_cxl_add_dax_region(cxlr);
>  	default:
> -		dev_dbg(&cxlr->dev, "unsupported region mode: %d\n",
> -			cxlr->mode);
> +		dev_dbg(&cxlr->dev, "unsupported region mode: %s\n",
> +			cxl_region_mode_name(cxlr->mode));
>  		return -ENXIO;
>  	}
>  }
> diff --git a/drivers/cxl/cxl.h b/drivers/cxl/cxl.h
> index cd4a9ffdacc7..ed282dcd5cf5 100644
> --- a/drivers/cxl/cxl.h
> +++ b/drivers/cxl/cxl.h
> @@ -374,6 +374,28 @@ static inline const char *cxl_decoder_mode_name(enum cxl_decoder_mode mode)
>  	return "mixed";
>  }
>  
> +enum cxl_region_mode {
> +	CXL_REGION_NONE,
> +	CXL_REGION_RAM,
> +	CXL_REGION_PMEM,
> +	CXL_REGION_MIXED,
> +	CXL_REGION_DEAD,
> +};

It feels to me like you could have yanked the introduction and use of cxl_region_mode
out as a trivial precursor patch with a note saying the separation will be needed
shortly and why it will be needed.

> +
> +static inline const char *cxl_region_mode_name(enum cxl_region_mode mode)
> +{
> +	static const char * const names[] = {
> +		[CXL_REGION_NONE] = "none",
> +		[CXL_REGION_RAM] = "ram",
> +		[CXL_REGION_PMEM] = "pmem",
> +		[CXL_REGION_MIXED] = "mixed",
> +	};
> +
> +	if (mode >= CXL_REGION_NONE && mode <= CXL_REGION_MIXED)
> +		return names[mode];
> +	return "mixed";
> +}
> +
>  /*
>   * Track whether this decoder is reserved for region autodiscovery, or
>   * free for userspace provisioning.
> @@ -502,7 +524,8 @@ struct cxl_region_params {
>   * struct cxl_region - CXL region
>   * @dev: This region's device
>   * @id: This region's id. Id is globally unique across all regions
> - * @mode: Endpoint decoder allocation / access mode
> + * @mode: Region mode which defines which endpoint decoder mode the region is
> + *        compatible with
>   * @type: Endpoint decoder target type
>   * @cxl_nvb: nvdimm bridge for coordinating @cxlr_pmem setup / shutdown
>   * @cxlr_pmem: (for pmem regions) cached copy of the nvdimm bridge
> @@ -512,7 +535,7 @@ struct cxl_region_params {
>  struct cxl_region {
>  	struct device dev;
>  	int id;
> -	enum cxl_decoder_mode mode;
> +	enum cxl_region_mode mode;
>  	enum cxl_decoder_type type;
>  	struct cxl_nvdimm_bridge *cxl_nvb;
>  	struct cxl_pmem_region *cxlr_pmem;
> diff --git a/drivers/cxl/cxlmem.h b/drivers/cxl/cxlmem.h
> index 5f2e65204bf9..8c8f47b397ab 100644
> --- a/drivers/cxl/cxlmem.h
> +++ b/drivers/cxl/cxlmem.h
> @@ -396,6 +396,7 @@ enum cxl_devtype {
>  	CXL_DEVTYPE_CLASSMEM,
>  };
>  
> +#define CXL_MAX_DC_REGION 8
>  /**
>   * struct cxl_dev_state - The driver device state
>   *
> @@ -412,6 +413,8 @@ enum cxl_devtype {
>   * @dpa_res: Overall DPA resource tree for the device
>   * @pmem_res: Active Persistent memory capacity configuration
>   * @ram_res: Active Volatile memory capacity configuration
> + * @dc_res: Active Dynamic Capacity memory configuration for each possible
> + *          region
>   * @component_reg_phys: register base of component registers
>   * @serial: PCIe Device Serial Number
>   * @type: Generic Memory Class device or Vendor Specific Memory device
> @@ -426,11 +429,23 @@ struct cxl_dev_state {
>  	struct resource dpa_res;
>  	struct resource pmem_res;
>  	struct resource ram_res;
> +	struct resource dc_res[CXL_MAX_DC_REGION];
>  	resource_size_t component_reg_phys;
>  	u64 serial;
>  	enum cxl_devtype type;
>  };
>  
> +#define CXL_DC_REGION_STRLEN 7
> +struct cxl_dc_region_info {
> +	u64 base;
> +	u64 decode_len;
> +	u64 len;
> +	u64 blk_size;
> +	u32 dsmad_handle;
> +	u8 flags;
> +	u8 name[CXL_DC_REGION_STRLEN];
> +};
> +
>  /**
>   * struct cxl_memdev_state - Generic Type-3 Memory Device Class driver data
>   *
> @@ -449,6 +464,8 @@ struct cxl_dev_state {
>   * @enabled_cmds: Hardware commands found enabled in CEL.
>   * @exclusive_cmds: Commands that are kernel-internal only
>   * @total_bytes: sum of all possible capacities
> + * @static_cap: Sum of RAM and PMEM capacities

Sum of static RAM and PMEM capacities

Dynamic cap may well be RAM or PMEM!

> + * @dynamic_cap: Complete DPA range occupied by DC regions
>   * @volatile_only_bytes: hard volatile capacity
>   * @persistent_only_bytes: hard persistent capacity
>   * @partition_align_bytes: alignment size for partition-able capacity
> @@ -456,6 +473,10 @@ struct cxl_dev_state {
>   * @active_persistent_bytes: sum of hard + soft persistent
>   * @next_volatile_bytes: volatile capacity change pending device reset
>   * @next_persistent_bytes: persistent capacity change pending device reset
> + * @nr_dc_region: number of DC regions implemented in the memory device
> + * @dc_region: array containing info about the DC regions
> + * @dc_event_log_size: The number of events the device can store in the
> + * Dynamic Capacity Event Log before it overflows
>   * @event: event log driver state
>   * @poison: poison driver state info
>   * @fw: firmware upload / activation state
> @@ -473,7 +494,10 @@ struct cxl_memdev_state {
>  	DECLARE_BITMAP(dcd_cmds, CXL_DCD_ENABLED_MAX);
>  	DECLARE_BITMAP(enabled_cmds, CXL_MEM_COMMAND_ID_MAX);
>  	DECLARE_BITMAP(exclusive_cmds, CXL_MEM_COMMAND_ID_MAX);
> +
>  	u64 total_bytes;
> +	u64 static_cap;
> +	u64 dynamic_cap;
>  	u64 volatile_only_bytes;
>  	u64 persistent_only_bytes;
>  	u64 partition_align_bytes;
> @@ -481,6 +505,11 @@ struct cxl_memdev_state {
>  	u64 active_persistent_bytes;
>  	u64 next_volatile_bytes;
>  	u64 next_persistent_bytes;
> +
> +	u8 nr_dc_region;
> +	struct cxl_dc_region_info dc_region[CXL_MAX_DC_REGION];
> +	size_t dc_event_log_size;
> +
>  	struct cxl_event_state event;
>  	struct cxl_poison_state poison;
>  	struct cxl_security_state security;
> @@ -587,6 +616,7 @@ struct cxl_mbox_identify {
>  	__le16 inject_poison_limit;
>  	u8 poison_caps;
>  	u8 qos_telemetry_caps;
> +	__le16 dc_event_log_size;
>  } __packed;
>  
>  /*
> @@ -741,9 +771,31 @@ struct cxl_mbox_set_partition_info {
>  	__le64 volatile_capacity;
>  	u8 flags;
>  } __packed;
> -

?

>  #define  CXL_SET_PARTITION_IMMEDIATE_FLAG	BIT(0)
>  
> +struct cxl_mbox_get_dc_config {
> +	u8 region_count;
> +	u8 start_region_index;
> +} __packed;
> +
> +/* See CXL 3.0 Table 125 get dynamic capacity config Output Payload */
> +struct cxl_mbox_dynamic_capacity {

Can we rename to make it more clear which payload this is?

> +	u8 avail_region_count;
> +	u8 rsvd[7];
> +	struct cxl_dc_region_config {
> +		__le64 region_base;
> +		__le64 region_decode_length;
> +		__le64 region_length;
> +		__le64 region_block_size;
> +		__le32 region_dsmad_handle;
> +		u8 flags;
> +		u8 rsvd[3];
> +	} __packed region[];
> +} __packed;
> +#define CXL_DYNAMIC_CAPACITY_SANITIZE_ON_RELEASE_FLAG BIT(0)
> +#define CXL_REGIONS_RETURNED(size_out) \
> +	((size_out - 8) / sizeof(struct cxl_dc_region_config))
> +
>  /* Set Timestamp CXL 3.0 Spec 8.2.9.4.2 */
>  struct cxl_mbox_set_timestamp_in {
>  	__le64 timestamp;
> @@ -867,6 +919,7 @@ enum {
>  int cxl_internal_send_cmd(struct cxl_memdev_state *mds,
>  			  struct cxl_mbox_cmd *cmd);
>  int cxl_dev_state_identify(struct cxl_memdev_state *mds);
> +int cxl_dev_dynamic_capacity_identify(struct cxl_memdev_state *mds);
>  int cxl_await_media_ready(struct cxl_dev_state *cxlds);
>  int cxl_enumerate_cmds(struct cxl_memdev_state *mds);
>  int cxl_mem_create_range_info(struct cxl_memdev_state *mds);

ta

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 230CEC71153
	for <linux-cxl@archiver.kernel.org>; Tue, 29 Aug 2023 14:08:54 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S236902AbjH2OIY (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 29 Aug 2023 10:08:24 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:34828 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S236834AbjH2OIB (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 29 Aug 2023 10:08:01 -0400
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 76EA11AE;
        Tue, 29 Aug 2023 07:07:49 -0700 (PDT)
Received: from lhrpeml500005.china.huawei.com (unknown [172.18.147.206])
        by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4RZpzD2r8Wz6K6M7;
        Tue, 29 Aug 2023 22:02:48 +0800 (CST)
Received: from localhost (10.202.227.76) by lhrpeml500005.china.huawei.com
 (7.191.163.240) with Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id 15.1.2507.31; Tue, 29 Aug
 2023 15:07:32 +0100
Date: Tue, 29 Aug 2023 15:07:32 +0100
From: Jonathan Cameron <Jonathan.Cameron@Huawei.com>
To: Ira Weiny <ira.weiny@intel.com>
CC: Dan Williams <dan.j.williams@intel.com>,
        Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
Subject: Re: [PATCH RFC v2 02/18] cxl/mbox: Flag support for Dynamic
 Capacity Devices (DCD)
Message-ID: <20230829150732.00004181@Huawei.com>
In-Reply-To: <20230604-dcd-type2-upstream-v2-2-f740c47e7916@intel.com>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
        <20230604-dcd-type2-upstream-v2-2-f740c47e7916@intel.com>
Organization: Huawei Technologies Research and Development (UK) Ltd.
X-Mailer: Claws Mail 4.1.0 (GTK 3.24.33; x86_64-w64-mingw32)
MIME-Version: 1.0
Content-Type: text/plain; charset="US-ASCII"
Content-Transfer-Encoding: 7bit
X-Originating-IP: [10.202.227.76]
X-ClientProxiedBy: lhrpeml500005.china.huawei.com (7.191.163.240) To
 lhrpeml500005.china.huawei.com (7.191.163.240)
X-CFilter-Loop: Reflected
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

On Mon, 28 Aug 2023 22:20:53 -0700
Ira Weiny <ira.weiny@intel.com> wrote:

> Per the CXL 3.0 specification software must check the Command Effects
> Log (CEL) to know if a device supports DC.  If the device does support
> DC the specifics of the DC Regions (0-7) are read through the mailbox.
> 
> Flag DC Device (DCD) commands in a device if they are supported.
> Subsequent patches will key off these bits to configure a DCD.
> 
> Co-developed-by: Navneet Singh <navneet.singh@intel.com>
> Signed-off-by: Navneet Singh <navneet.singh@intel.com>
> Signed-off-by: Ira Weiny <ira.weiny@intel.com>
> 

Trivial unrelated change seems to have sneaked in. Other than that
this looks good to me.

So with that tidied up.

Reviewed-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>


Thanks,

Jonathan

> +
>  static bool cxl_is_security_command(u16 opcode)
>  {
>  	int i;
> @@ -677,9 +705,10 @@ static void cxl_walk_cel(struct cxl_memdev_state *mds, size_t size, u8 *cel)
>  		u16 opcode = le16_to_cpu(cel_entry[i].opcode);
>  		struct cxl_mem_command *cmd = cxl_mem_find_command(opcode);
>  
> -		if (!cmd && !cxl_is_poison_command(opcode)) {
> -			dev_dbg(dev,
> -				"Opcode 0x%04x unsupported by driver\n", opcode);
> +		if (!cmd && !cxl_is_poison_command(opcode) &&
> +		    !cxl_is_dcd_command(opcode)) {
> +			dev_dbg(dev, "Opcode 0x%04x unsupported by driver\n",
> +				opcode);

Clang format has been playing?
Better to leave this alone and save reviewers wondering what the change
in the dev_dbg() was.

>  			continue;
>  		}


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id B73D6C71153
	for <linux-cxl@archiver.kernel.org>; Tue, 29 Aug 2023 14:04:37 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S230359AbjH2OEI (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 29 Aug 2023 10:04:08 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:34780 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S236693AbjH2ODh (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 29 Aug 2023 10:03:37 -0400
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 1FAA5114;
        Tue, 29 Aug 2023 07:03:24 -0700 (PDT)
Received: from lhrpeml500005.china.huawei.com (unknown [172.18.147.206])
        by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4RZpyj3fHJz6HJjy;
        Tue, 29 Aug 2023 22:02:21 +0800 (CST)
Received: from localhost (10.202.227.76) by lhrpeml500005.china.huawei.com
 (7.191.163.240) with Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id 15.1.2507.31; Tue, 29 Aug
 2023 15:03:21 +0100
Date: Tue, 29 Aug 2023 15:03:20 +0100
From: Jonathan Cameron <Jonathan.Cameron@Huawei.com>
To: Ira Weiny <ira.weiny@intel.com>
CC: Dan Williams <dan.j.williams@intel.com>,
        Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
Subject: Re: [PATCH RFC v2 01/18] cxl/hdm: Debug, use decoder name function
Message-ID: <20230829150320.00007f08@Huawei.com>
In-Reply-To: <20230604-dcd-type2-upstream-v2-1-f740c47e7916@intel.com>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
        <20230604-dcd-type2-upstream-v2-1-f740c47e7916@intel.com>
Organization: Huawei Technologies Research and Development (UK) Ltd.
X-Mailer: Claws Mail 4.1.0 (GTK 3.24.33; x86_64-w64-mingw32)
MIME-Version: 1.0
Content-Type: text/plain; charset="US-ASCII"
Content-Transfer-Encoding: 7bit
X-Originating-IP: [10.202.227.76]
X-ClientProxiedBy: lhrpeml500005.china.huawei.com (7.191.163.240) To
 lhrpeml500005.china.huawei.com (7.191.163.240)
X-CFilter-Loop: Reflected
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

On Mon, 28 Aug 2023 22:20:52 -0700
Ira Weiny <ira.weiny@intel.com> wrote:

> The decoder enum has a name conversion function defined now.
> 
> Use that instead of open coding.
> 
> Suggested-by: Navneet Singh <navneet.singh@intel.com>
> Signed-off-by: Ira Weiny <ira.weiny@intel.com>
> 

Perhaps pull this one out so it can go upstream before the rest are ready,
or could be picked up from here.

Whilst we probably won't see the other decoder modes in here, there
is no reason why anyone reading the code should have to figure that out.
As such much better to use the more generic function.

Reviewed-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

> ---
> Changes for v2:
> [iweiny: new patch, split out]
> ---
>  drivers/cxl/core/hdm.c | 3 +--
>  1 file changed, 1 insertion(+), 2 deletions(-)
> 
> diff --git a/drivers/cxl/core/hdm.c b/drivers/cxl/core/hdm.c
> index b01a77b67511..a254f79dd4e8 100644
> --- a/drivers/cxl/core/hdm.c
> +++ b/drivers/cxl/core/hdm.c
> @@ -550,8 +550,7 @@ int cxl_dpa_alloc(struct cxl_endpoint_decoder *cxled, unsigned long long size)
>  
>  	if (size > avail) {
>  		dev_dbg(dev, "%pa exceeds available %s capacity: %pa\n", &size,
> -			cxled->mode == CXL_DECODER_RAM ? "ram" : "pmem",
> -			&avail);
> +			cxl_decoder_mode_name(cxled->mode), &avail);
>  		rc = -ENOSPC;
>  		goto out;
>  	}
> 


From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 47059EE3F3F
	for <linux-cxl@archiver.kernel.org>; Tue, 12 Sep 2023 22:08:19 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S230150AbjILWIW (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 12 Sep 2023 18:08:22 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:52162 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S229651AbjILWIV (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 12 Sep 2023 18:08:21 -0400
Received: from mgamail.intel.com (mgamail.intel.com [134.134.136.20])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id C07F310D9;
        Tue, 12 Sep 2023 15:08:17 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1694556497; x=1726092497;
  h=date:from:to:cc:subject:message-id:references:
   in-reply-to:mime-version;
  bh=VgfTeRHOaXeKq7GIXd4n1dbiMam+mhX7PrYOlYKyfas=;
  b=UET1boJgRlcA7IWQSGpe7V9mb9ag2ENOpSJ3MhMYicqhKj/3wqiWE3vL
   uJD30aQy27GjiaMLz8TjDIOwBk5WUz82NLN/RkdtPLvEjwky6DUz0VVUh
   wDQlf+VLLbKAq3IQlYLKLiSLHe3RD7+Ukm6WLwEXglCrbQqjeB7LqjZe5
   1//MLF8yCT2ESbBY7LUBFdjDJP4q8lKF7EZKPMiiXg46aaMYKVvXcovhH
   sbsxyjzAVAY1obbRa/QwjvuYCLjQtk2FfxPBTz50RWrL1lnHvXliuEtaP
   XbfGPh/a0tnDcQQUNivXG2WrJttaG2zsePFiRFl/T0HvNea+YtyH8/d6u
   g==;
X-IronPort-AV: E=McAfee;i="6600,9927,10831"; a="368770836"
X-IronPort-AV: E=Sophos;i="6.02,141,1688454000"; 
   d="scan'208";a="368770836"
Received: from orsmga008.jf.intel.com ([10.7.209.65])
  by orsmga101.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 12 Sep 2023 15:08:17 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10831"; a="773206479"
X-IronPort-AV: E=Sophos;i="6.02,141,1688454000"; 
   d="scan'208";a="773206479"
Received: from orsmsx602.amr.corp.intel.com ([10.22.229.15])
  by orsmga008.jf.intel.com with ESMTP/TLS/AES256-GCM-SHA384; 12 Sep 2023 15:08:17 -0700
Received: from orsmsx611.amr.corp.intel.com (10.22.229.24) by
 ORSMSX602.amr.corp.intel.com (10.22.229.15) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.32; Tue, 12 Sep 2023 15:08:17 -0700
Received: from orsmsx612.amr.corp.intel.com (10.22.229.25) by
 ORSMSX611.amr.corp.intel.com (10.22.229.24) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.32; Tue, 12 Sep 2023 15:08:16 -0700
Received: from orsedg603.ED.cps.intel.com (10.7.248.4) by
 orsmsx612.amr.corp.intel.com (10.22.229.25) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.32 via Frontend Transport; Tue, 12 Sep 2023 15:08:16 -0700
Received: from NAM11-BN8-obe.outbound.protection.outlook.com (104.47.58.168)
 by edgegateway.intel.com (134.134.137.100) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.32; Tue, 12 Sep 2023 15:08:16 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=axZpCt8sEcwlvcPSToBx4kLDfHnp1f5pAhhsIc/2VXdKcpSfD5EifiBGFxuFrE6wYEg6p13QJjXKoL9t+84En7cRzcQl0vNxszlEzq7iGAp25wYPM0SA0ds7KqBdKzkPVyASRsHyb67EXKCejXtdr9JW0gljL3ZUmXwdD3Q+FgDBcUHC0bGkefqB/mKORGNQPVdpCsjjUazB8oRaLBQ6JxWBu4OPrwUuirl2PTdt73hcOjfSUaXEeDmLsK0Gn/qHskH7M9MpM5RKlaFTv//T8zKgGw8DN93mHdk1pp+HtM7RsbJMXTdiZxvX5daBby3YY4zo36FtolBRbTy//oS0NA==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=Ss04s1as/ZnlVqVCVi9GdC0RIXdpAAub5+AcQjprQAg=;
 b=LhkSe0estXZr/pqtuAJ2P7szKhf+qc3j/L9sP+RiIyzDcDSCqr+2E7gBxmgaba5umF+e4ND+54eqifVxlOCOSnOVjDJGj3dtEbjEDQs8D5SyDHWKFZ4MagMgjUumpa8ydbS4aXTh2wsgF0cgjKMdroNffX3Wes9hQzOZJAZINRQIhP/XdiOD2Fym+Ecgzi6/rrgT5slS199u5gwGuNqZIr9ymXH4be2u3kMeXPY9hQJNIbOSwyNk0CRX/LHx/Uei1raFPn/e8fuyM96gDgYDvCW/xYU6G3JfTPN0POk8NrZ+nT67xnw12n22rmvmCh5JLBHYtNHLmKnOBq6VofClow==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from SA1PR11MB6733.namprd11.prod.outlook.com (2603:10b6:806:25c::17)
 by BN9PR11MB5273.namprd11.prod.outlook.com (2603:10b6:408:132::8) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.6792.19; Tue, 12 Sep
 2023 22:08:14 +0000
Received: from SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938]) by SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938%6]) with mapi id 15.20.6768.029; Tue, 12 Sep 2023
 22:08:14 +0000
Date: Tue, 12 Sep 2023 15:08:10 -0700
From: Ira Weiny <ira.weiny@intel.com>
To: Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Ira Weiny <ira.weiny@intel.com>
CC: Dan Williams <dan.j.williams@intel.com>,
        Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
Subject: Re: [PATCH RFC v2 14/18] dax/region: Support DAX device creation on
 dynamic DAX regions
Message-ID: <6500e14a8588c_314b6629439@iweiny-mobl.notmuch>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
 <20230604-dcd-type2-upstream-v2-14-f740c47e7916@intel.com>
 <20230830125025.00000fea@Huawei.com>
 <64f80177c2c21_1e8e7829487@iweiny-mobl.notmuch>
 <20230912174904.00005fed@Huawei.com>
Content-Type: text/plain; charset="us-ascii"
Content-Disposition: inline
In-Reply-To: <20230912174904.00005fed@Huawei.com>
X-ClientProxiedBy: BY5PR17CA0006.namprd17.prod.outlook.com
 (2603:10b6:a03:1b8::19) To SA1PR11MB6733.namprd11.prod.outlook.com
 (2603:10b6:806:25c::17)
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: SA1PR11MB6733:EE_|BN9PR11MB5273:EE_
X-MS-Office365-Filtering-Correlation-Id: f55b5564-78f6-4092-d99b-08dbb3dcc288
X-LD-Processed: 46c98d88-e344-4ed4-8496-4ed7712e255d,ExtAddr
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;
X-Microsoft-Antispam-Message-Info: /BQzUWmT+d+Ei5Ocb3QrRlPY7wv1hGI/FhnwIEz1F/hdqR+oS/I96VNsampm0f6rDKfMbHjB7iQkYPyRx1rfSSfVtYHnCfBufnvdWtdS6P3XVRG3lJ4FrwUMjlrcr3M+Ir2BU/fAAdaksS8ejSTKmOWAOJviShe7X4fI/AqNnmn01cZIqWnKtfG4PWi3PP1NxphZfavOcD46lVdecxjR6visVqgMNXDp1zFBhjqJFxsIywX5v5bRK660NDvaWp8QOs0tkthUD/PNsO2PhGAeekUa15M+rrGS4PRYHA1JidK7JWf5z5Isr8toYuLzOTG/ez1UGVcMv4SdsB679JZYJ6AXJBXfE4ojp6hwDHR0d7FJkVCVmFVVowZmX0AwyfrGlTQKVES/uLVvAcQhRDfq3alLUTm41O8v9ALBI48PCuTsP0phzBkaR+whMHbOoFugiogE3h5VbFipY2NoAgglaGSyycgiwBSuPpRQHFxcPEMnvAXdpU7tc86AzM4j1jnCYLaiNvICe+yNJkBPFHDqSbh4ijD2FnxcQypYXXg3ABd7o97kapUAqDLNEM7GapUG
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:SA1PR11MB6733.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230031)(136003)(346002)(39860400002)(366004)(396003)(376002)(451199024)(1800799009)(186009)(8676002)(8936002)(86362001)(4326008)(5660300002)(44832011)(2906002)(6666004)(38100700002)(83380400001)(82960400001)(6506007)(6512007)(9686003)(6486002)(26005)(478600001)(316002)(110136005)(54906003)(66476007)(66556008)(66946007)(41300700001);DIR:OUT;SFP:1102;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?us-ascii?Q?yHvKTDcRO691EVl9nWo7+xXbZVoDKb1ZbOTl4IDuU1gB1GZqXE60QCCykuSs?=
 =?us-ascii?Q?/kmlr+l/j534zz4Z3MsYkP4gnLMNQ6IV0gn4P+2+u+8/9RU5C+PY/EP1tt0R?=
 =?us-ascii?Q?JmDGHhbBnBPDMw4tPHCIVInrT00DZr00d6eldpEtHwi12CTk9nThGKt2gDR1?=
 =?us-ascii?Q?yEWj4aXxu3J7GrBGyt1VvI8+0r4nNDwe9r6lqO/lzJTAolDufLDHpkIbuFgJ?=
 =?us-ascii?Q?KxECewUZI+SqMnwMpPMiuXFOfsyxp1HtkV73mGzvLFhVUweR6NNXxLwD7MGw?=
 =?us-ascii?Q?yQLDziZ5uVU6goceyzi3V9OJ8iVU8pUvNJzIpVDyBGLfPtajeIRP2mXYflJd?=
 =?us-ascii?Q?qnSgI60ELys3gdSfSsAC/42tz4fcyE6JYCtiKZg1XkxhF+ij5x+5IFQW8Ybc?=
 =?us-ascii?Q?O5EtD7kSFUnZSNcW5lLXdiMSPcaHxFxgT1t766J3uUVGJlYi1KraXaDKY8O2?=
 =?us-ascii?Q?YsUDm8j29p9K1c40Tn402yZC+n9fNIUW4t4Hgn4oneJ07nie79eNoK9AkvbG?=
 =?us-ascii?Q?3qAE90C42R6DuXJ9BxAkrM+cytprpDGAEK43NKOAwb4HhnWJzIl6r/VmfcF0?=
 =?us-ascii?Q?pQYsG9MDvGryxgTqbvhGYvmw0iH76i0CPTLxONLTRGRENtF4ZgtuK1qcHHeC?=
 =?us-ascii?Q?cOabshlS66BWH4xZ5tLlieB3aqyXxtv1rZzganZSGVLBA3rHfpiAr4IJd3QZ?=
 =?us-ascii?Q?Ocrxt1/GskM5r/fYGnNnyjxxqXXp2UTcl2lUfvJ12tNS+W+rPTFLcy/vkurk?=
 =?us-ascii?Q?uiiRpR2kZqjOAUKg8byxTGCS7Kyv2t2Z8nKzlKKMwhi9tEbbIKMqszmrRVM1?=
 =?us-ascii?Q?syqGRoKcsmJJKByf5pB87dVHFMpd62Go653iBEmBZXLmRwyDyLnTi44xdxic?=
 =?us-ascii?Q?lo4bCH3VJasNI8AtrT06As1tXMoFj+PGNCOdJWyJAYTBCgfZsDh+8+zrdd3m?=
 =?us-ascii?Q?DDzKbt0yqCZu1r66q6sxlDMq/vZ/1Pq0li2Td63DpkoJBaw6pLCOLYrANffL?=
 =?us-ascii?Q?4xemOy8VkxtZcQ3v/xL4Evx65tfw9LrvMkQVBT/5tNG9JYOQ4pMqu/PTy5fQ?=
 =?us-ascii?Q?vmLb+cnT4QJzOzwk6H03CcXwSxnPQaYr8G4w/Bx50c4lKeFQofEFDD8tbgUg?=
 =?us-ascii?Q?Lgu+6c5s0PzPi40h0Mim47OiHult2nw7YSqYbQ8I07+5OoKMLapnEexNkHl6?=
 =?us-ascii?Q?mN92itU3G1FXLbS2y7PdadqyNF+CW/fCFHR0+KAn5CnoNagucnuEWWDSH/7O?=
 =?us-ascii?Q?e73IM53bo3WT1eKMR6p/9syuNa0SUd9+j+7hYw5tpvdvgdLwneK/w38ZuHoS?=
 =?us-ascii?Q?1LUiaS7sfmRF3E5S8nivXdeMc9w78PvUNWTvqyLu/OpB9A6V0/CV6PzsklUe?=
 =?us-ascii?Q?ep8Z0KCQzhVkNPeqc1ntJqU4+kQoZpm+BKd7JaPQiA2a8AThVr+k6XMY3Nn5?=
 =?us-ascii?Q?feskwBlEQ1WtTlbBw5RuQdwPGHLfUKdBv4Bp6hC1DlnMBX92/413vgAxTKr5?=
 =?us-ascii?Q?R34yE+7M/4LlawPlHjdysS9gotzBDeKTfxK45YdjqYMYGmI6L1X18qoAmC/N?=
 =?us-ascii?Q?QNdIQrPOkgaC55P5JHgoBie3p3hWXn4QmGwhCytM?=
X-MS-Exchange-CrossTenant-Network-Message-Id: f55b5564-78f6-4092-d99b-08dbb3dcc288
X-MS-Exchange-CrossTenant-AuthSource: SA1PR11MB6733.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 12 Sep 2023 22:08:14.2789
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: zZ2D6kAQHhKk1Ms8pl3NVQnpJSfGahjKSdIdYI4lAQry4vzZBImybxpHiRAAmH4NQFU1n7+YEyOFrP4a6l0Gxg==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: BN9PR11MB5273
X-OriginatorOrg: intel.com
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

Jonathan Cameron wrote:
> On Tue, 5 Sep 2023 21:35:03 -0700
> Ira Weiny <ira.weiny@intel.com> wrote:
> 
> > Jonathan Cameron wrote:
> > > On Mon, 28 Aug 2023 22:21:05 -0700
> > > Ira Weiny <ira.weiny@intel.com> wrote:
> > >   
> > > > Dynamic Capacity (DC) DAX regions have a list of extents which define
> > > > the memory of the region which is available.
> > > > 
> > > > Now that DAX region extents are fully realized support DAX device
> > > > creation on dynamic regions by adjusting the allocation algorithms
> > > > to account for the extents.  Remember also references must be held on
> > > > the extents until the DAX devices are done with the memory.
> > > > 
> > > > Redefine the region available size to include only extent space.  Reuse
> > > > the size allocation algorithm by defining sub-resources for each extent
> > > > and limiting range allocation to those extents which have space.  Do not
> > > > support direct mapping of DAX devices on dynamic devices.
> > > > 
> > > > Enhance DAX device range objects to hold references on the extents until
> > > > the DAX device is destroyed.
> > > > 
> > > > NOTE: At this time all extents within a region are created equally.
> > > > However, labels are associated with extents which can be used with
> > > > future DAX device labels to group which extents are used.  
> > > 
> > > This sound like a bad place to start to me as we are enabling something
> > > that is probably 'wrong' in the long term as opposed to just not enabling it
> > > until we have appropriate support.  
> > 
> > I disagree.  I don't think the kernel should be trying to process tags at
> > the lower level.
> > 
> > > I'd argue better to just reject any extents with different labels for now.  
> > 
> > Again I disagree.  This is less restrictive.  The idea is that labels can
> > be changed such that user space can ultimately decided which extents
> > should be used for which devices.  I have some work on that already.
> > (Basically it becomes quite easy to assign a label to a dax device and
> > have the extent search use only dax extents which match that label.)
> 
> That sounds good - but if someone expects that and uses it with an old
> kernel I'm not sure if it is better to say 'we don't support it yet' or
> do something different from a newer kernel.

This does provide the 'we don't support that yet' in that dax device
creation can't be associated with a label yet.  So surfacing the extents
with the tag as a default label and letting those labels change is more
informational at this point and not functional.  Simple use cases can use
the label (from the tag) to detect that some extent with the wrong tag got
in the region but can't correct it without going through the FM.

It is easy enough to remove the label sysfs and defer that until the dax
device has a label and this support though.

> 
> 
> > > > @@ -1400,8 +1507,10 @@ struct dev_dax *devm_create_dev_dax(struct dev_dax_data *data)
> > > >  	device_initialize(dev);
> > > >  	dev_set_name(dev, "dax%d.%d", dax_region->id, dev_dax->id);
> > > >  
> > > > +	dev_WARN_ONCE(parent, is_dynamic(dax_region) && data->size,
> > > > +		      "Dynamic DAX devices are created initially with 0 size");  
> > > 
> > > dev_info() maybe more appropriate?  
> > 
> > Unless I'm mistaken this can happen from userspace but only if something
> > in the code changes later.  Because the dax layer is trying to support
> > non-dynamic regions (which dynamic may be a bad name), I was worried that
> > the creation with a size might slip through...
> 
> Fair enough - if strong chance userspace will control it at somepoitn then
> ONCE seems fine.
> 
> > 
> > > Is this common enough that we need the
> > > _ONCE?  
> > 
> > once is because it could end up spamming a log later if something got
> > coded up wrong.
> 
> I'm not sure I care about bugs spamming the log.   Only things that
> are userspace controlled or likely hardware failures etc.
> 

Understood.  Let me trace them again but I think these can be triggered by
user space.  If not I'll remove the ONCE.

Thanks again,
Ira

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id AAB5DEE3F37
	for <linux-cxl@archiver.kernel.org>; Tue, 12 Sep 2023 21:32:46 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S233965AbjILVct (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 12 Sep 2023 17:32:49 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:34050 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S231775AbjILVcs (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 12 Sep 2023 17:32:48 -0400
Received: from mailout2.w2.samsung.com (mailout2.w2.samsung.com [211.189.100.12])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 0890F10D0;
        Tue, 12 Sep 2023 14:32:45 -0700 (PDT)
Received: from uscas1p1.samsung.com (unknown [182.198.245.206])
        by mailout2.w2.samsung.com (KnoxPortal) with ESMTP id 20230912213244usoutp02abef0275c3abcc3cb5a187e4a5bc77af~ERDdOl2mR1550215502usoutp02t;
        Tue, 12 Sep 2023 21:32:44 +0000 (GMT)
DKIM-Filter: OpenDKIM Filter v2.11.0 mailout2.w2.samsung.com 20230912213244usoutp02abef0275c3abcc3cb5a187e4a5bc77af~ERDdOl2mR1550215502usoutp02t
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=samsung.com;
        s=mail20170921; t=1694554364;
        bh=QgJzk0LFw6AGu8v5Ju1ew6zxSY87McNCclcicOQTPz0=;
        h=From:To:CC:Subject:Date:In-Reply-To:References:From;
        b=iRVV4YwyIRtfKSq3XsWaO1+iXASqUexqg1MXXqDxfsa9jBhNnIfD4ta+gFOuP39+5
         3zsn3NfnldKYXuTVCgVE8respffxDfq9bA5DmvwYV1G7JC4ovcx7vVwCTT1rWBLuLP
         0wNQWXm8jrI+7QoEA61aSjPe/63SirVwQDg0NE1s=
Received: from ussmges1new.samsung.com (u109.gpu85.samsung.co.kr
        [203.254.195.109]) by uscas1p2.samsung.com (KnoxPortal) with ESMTP id
        20230912213243uscas1p2082313b51d35971208ee5bedb3e44ff2~ERDc73jUX1320613206uscas1p2p;
        Tue, 12 Sep 2023 21:32:43 +0000 (GMT)
Received: from uscas1p1.samsung.com ( [182.198.245.206]) by
        ussmges1new.samsung.com (USCPEMTA) with SMTP id D7.CC.50148.BF8D0056; Tue,
        12 Sep 2023 17:32:43 -0400 (EDT)
Received: from ussmgxs3new.samsung.com (u92.gpu85.samsung.co.kr
        [203.254.195.92]) by uscas1p1.samsung.com (KnoxPortal) with ESMTP id
        20230912213243uscas1p17fa844630bf6caf6af9119c651e4759b~ERDcintwd2491324913uscas1p1N;
        Tue, 12 Sep 2023 21:32:43 +0000 (GMT)
X-AuditID: cbfec36d-7bdff7000002c3e4-73-6500d8fba816
Received: from SSI-EX2.ssi.samsung.com ( [105.128.2.145]) by
        ussmgxs3new.samsung.com (USCPEXMTA) with SMTP id 33.22.31410.BF8D0056; Tue,
        12 Sep 2023 17:32:43 -0400 (EDT)
Received: from SSI-EX2.ssi.samsung.com (105.128.2.227) by
        SSI-EX2.ssi.samsung.com (105.128.2.227) with Microsoft SMTP Server
        (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384) id
        15.1.2375.24; Tue, 12 Sep 2023 14:32:42 -0700
Received: from SSI-EX2.ssi.samsung.com ([105.128.2.227]) by
        SSI-EX2.ssi.samsung.com ([105.128.2.227]) with mapi id 15.01.2375.024; Tue,
        12 Sep 2023 14:32:42 -0700
From: Fan Ni <fan.ni@samsung.com>
To: Ira Weiny <ira.weiny@intel.com>
CC: Fan Ni <fan.ni@gmx.us>, Dan Williams <dan.j.williams@intel.com>,
        "Navneet Singh" <navneet.singh@intel.com>,
        Jonathan Cameron <Jonathan.Cameron@huawei.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        "Dave Jiang" <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        "linux-cxl@vger.kernel.org" <linux-cxl@vger.kernel.org>,
        "linux-kernel@vger.kernel.org" <linux-kernel@vger.kernel.org>
Subject: Re: [PATCH RFC v2 03/18] cxl/mem: Read Dynamic capacity
 configuration from the device
Thread-Topic: [PATCH RFC v2 03/18] cxl/mem: Read Dynamic capacity
        configuration from the device
Thread-Index: AQHZ2jkK/pP/klWxW0KG5oR5AqJrLLAD1zsAgA435ICABjMaAA==
Date: Tue, 12 Sep 2023 21:32:42 +0000
Message-ID: <20230912213242.GD2859961@sjcvldevvm72>
In-Reply-To: <64fba59f73319_1e8e78294e2@iweiny-mobl.notmuch>
Accept-Language: en-US
Content-Language: en-US
X-MS-Has-Attach: 
X-MS-TNEF-Correlator: 
x-originating-ip: [105.128.2.176]
Content-Type: text/plain; charset="us-ascii"
Content-ID: <E5E5A3975330C243BEF1F709F73946DF@ssi.samsung.com>
Content-Transfer-Encoding: quoted-printable
MIME-Version: 1.0
X-CFilter-Loop: Reflected
X-Brightmail-Tracker: H4sIAAAAAAAAA+NgFtrPKsWRmVeSWpSXmKPExsWy7djXc7q/bzCkGtz5rmtx9/EFNovpUy8w
        Wpy42chmsfrmGkaLW6cOM1rsf/qcxWLVwmtsFudnnWKxuLxrDpvF8TUTWC1uTTjG5MDt8Wz3
        OmaPliNvWT0W73nJ5DF1dr3H501yAaxRXDYpqTmZZalF+nYJXBmLZt1hLDgtU7H46UvWBsb5
        Yl2MnBwSAiYSB39uYu1i5OIQEljJKLHo3EZGCKeVSeL49wOsMFXb3vVDJdYySnx++hTK+cQo
        0XL6PpSzjFHi9J+JjCAtbAKKEvu6trOB2CICyhKn/11lAyliFjjCLHH1yFYmkISwQILEl7ub
        oYoSJdqm/GTpYuQAsp0k1kxPBQmzCKhKvH33iB3E5hUwlnjQ0wdmcwrYSPxtuAhmMwqISXw/
        tQZsJLOAuMStJ/OZIM4WlFg0ew8zhC0m8W/XQzYIW1Hi/veX7BD1OhILdn9ig7DtJB5s2MEM
        YWtLLFv4mhlir6DEyZlPWCB6JSUOrrjBAvKLhMAXDommk/OglrlInJu0HGqBtMT0NZfBfpEQ
        SJZY9ZELIpwjMX/JFqg51hIL/6xnmsCoMgvJ2bOQnDQLyUmzkJw0C8lJCxhZVzGKlxYX56an
        FhvmpZbrFSfmFpfmpesl5+duYgSmsdP/DufuYNxx66PeIUYmDsZDjBIczEoivCWH/qYI8aYk
        VlalFuXHF5XmpBYfYpTmYFES5zW0PZksJJCeWJKanZpakFoEk2Xi4JRqYNoYf1s+WU45u7Bb
        bmGDpKTijSIVTYPzRcJhaWn53hufSlqwbt16VrbR5VxfdQH3Dj6l6umtxccDWQ8+urNw0o6s
        qESHC2d/Lc1dsd/e/F7k9v+qDVeD6pZfuPFts+uhWyGnXZynT/0RXJN6fuFztyMsdTVGq1fW
        dL0x+JsWe1jkamd/TJDQsf36G9dPEbuddSDwlMqnnYIuExdeZmrP3/jE2lrJxXytzJICszk/
        27xNjkZqX2tm3rBlJ3dF0NzpO/7EFombvXt1KiZxGYuo+LZvLQlvMl3VX3EX3P0hdCUl65hy
        9rGkwLr3u7jiEr6414t0B57IFb+zwCGpv0r80KK5zLtqG6oPqHG13RbJV2Ipzkg01GIuKk4E
        AL1Y3SrSAwAA
X-Brightmail-Tracker: H4sIAAAAAAAAA+NgFrrLIsWRmVeSWpSXmKPExsWS2cA0Uff3DYZUg2cThS3uPr7AZjF96gVG
        ixM3G9ksVt9cw2hx69RhRov9T5+zWKxaeI3N4vysUywWl3fNYbM4vmYCq8WtCceYHLg9nu1e
        x+zRcuQtq8fiPS+ZPKbOrvf4vEkugDWKyyYlNSezLLVI3y6BK2PRrDuMBadlKhY/fcnawDhf
        rIuRk0NCwERi27t+RhBbSGA1o8Tj7ypdjFxA9idGiSXTnrJBOMsYJbat+Q1WxSagKLGvazsb
        iC0ioCxx+t9VsCJmgSPMEse23WcFSQgLJEi83vuQEaIoUWLL6adANgeQ7SSxZnoqSJhFQFXi
        7btH7CA2r4CxxIOePnaIZYuZJF7f/AGW4BSwkfjbcBHMZhQQk/h+ag0TiM0sIC5x68l8JogX
        BCSW7DnPDGGLSrx8/I8VwlaUuP/9JTtEvY7Egt2f2CBsO4kHG3YwQ9jaEssWvmaGOEJQ4uTM
        JywQvZISB1fcYJnAKDELybpZSEbNQjJqFpJRs5CMWsDIuopRvLS4ODe9otg4L7Vcrzgxt7g0
        L10vOT93EyMwBZz+dzhmB+O9Wx/1DjEycTAeYpTgYFYS4S059DdFiDclsbIqtSg/vqg0J7X4
        EKM0B4uSOO+OKRdThATSE0tSs1NTC1KLYLJMHJxSDUzpa+fKd3rGXclVvCome3FCB3fBBZO1
        UwQFrLLy2fmOtv9nUfVIWqYnX35ga9iJBwIVlS0WinHe+Wf8L6z56Hh8753jhXnSWy66F6/Y
        5LS8eJqZOsd8Vsmbucqhrmli1lfal6jwB2tEe3JPyP+7Tm+Xk475C/l7XkFHlghcOLxZpWwX
        8yfn/xUqPL+06hZXzF6zOOu5bMhKy+0MlZqn7c7+bv/X9eJEQs7WjBmvlvHN/i087wXnROFr
        G2NelvyLZUhfF1a13oxry98TrdUBSZx/N2S8Su6/GJ2f+zXXcB2nVkrU2XUdfqy7C1yl2Hew
        bOftcn/527OzN/Ke3oyuxA+aXPPKPtyMr6jZP2eFuRJLcUaioRZzUXEiAKq+4olwAwAA
X-CMS-MailID: 20230912213243uscas1p17fa844630bf6caf6af9119c651e4759b
CMS-TYPE: 301P
X-CMS-RootMailID: 20230908225229uscas1p2f1013a8dd9977718cbd19e6433adef57
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
        <20230604-dcd-type2-upstream-v2-3-f740c47e7916@intel.com>
        <ZO+4Qql0rOslp0bl@debian>
        <CGME20230908225229uscas1p2f1013a8dd9977718cbd19e6433adef57@uscas1p2.samsung.com>
        <64fba59f73319_1e8e78294e2@iweiny-mobl.notmuch>
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

On Fri, Sep 08, 2023 at 03:52:15PM -0700, Ira Weiny wrote:

> Fan Ni wrote:
> > On Mon, Aug 28, 2023 at 10:20:54PM -0700, ira.weiny@intel.com wrote:
> > > From: Navneet Singh <navneet.singh@intel.com>
> > >
>=20
> [snip]
>=20
> > >
> > > +static int cxl_dc_save_region_info(struct cxl_memdev_state *mds, int=
 index,
> > > +				   struct cxl_dc_region_config *region_config)
> > > +{
> > > +	struct cxl_dc_region_info *dcr =3D &mds->dc_region[index];
> > > +	struct device *dev =3D mds->cxlds.dev;
> > > +
> > > +	dcr->base =3D le64_to_cpu(region_config->region_base);
> > > +	dcr->decode_len =3D le64_to_cpu(region_config->region_decode_length=
);
> > > +	dcr->decode_len *=3D CXL_CAPACITY_MULTIPLIER;
> > > +	dcr->len =3D le64_to_cpu(region_config->region_length);
> > > +	dcr->blk_size =3D le64_to_cpu(region_config->region_block_size);
> > > +	dcr->dsmad_handle =3D le32_to_cpu(region_config->region_dsmad_handl=
e);
> > > +	dcr->flags =3D region_config->flags;
> > > +	snprintf(dcr->name, CXL_DC_REGION_STRLEN, "dc%d", index);
> > > +
> > > +	/* Check regions are in increasing DPA order */
> > > +	if (index > 0) {
> > > +		struct cxl_dc_region_info *prev_dcr =3D &mds->dc_region[index - 1]=
;
> > > +
> > > +		if ((prev_dcr->base + prev_dcr->decode_len) > dcr->base) {
> > > +			dev_err(dev,
> > > +				"DPA ordering violation for DC region %d and %d\n",
> > > +				index - 1, index);
> > > +			return -EINVAL;
> > > +		}
> > > +	}
> > > +
> > > +	/* Check the region is 256 MB aligned */
> > > +	if (!IS_ALIGNED(dcr->base, SZ_256M)) {
> > > +		dev_err(dev, "DC region %d not aligned to 256MB: %#llx\n",
> > > +			index, dcr->base);
> > > +		return -EINVAL;
> > > +	}
> > > +
> > > +	/* Check Region base and length are aligned to block size */
> > > +	if (!IS_ALIGNED(dcr->base, dcr->blk_size) ||
> > > +	    !IS_ALIGNED(dcr->len, dcr->blk_size)) {
> > > +		dev_err(dev, "DC region %d not aligned to %#llx\n", index,
> > > +			dcr->blk_size);
> > > +		return -EINVAL;
> > > +	}
> >=20
> > Based on on cxl 3.0 spec: Table 8-126, we may need some extra checks
> > here:
> > 1. region len <=3D decode_len
> > 2. region block size should be power of 2 and a multiple of 40H.
>=20
> Thanks for pointing these additional checks out!  I've added these.
>=20
> >=20
> > Also, if region len or block size is 0, it mentions that DC will not be
> > available, we may also need to handle that.
>=20
> I've just added checks for 0 in region length, length and block size.
>=20
> I don't think we need to handle this in any special way.  Any of these
> checks will fail the device probe.  From my interpretation of the spec
> reading these values as 0 would indicate an invalid device configuration.
>=20
> That said I think the spec is a bit vague here.  On the one hand the
> number of DC regions should reflect the number of valid regions.
>=20
> Table 8-125 'Number of Available Regions':
> 	"This is the number of valid region configurations returned in
> 	this payload."
>=20
> But it also says:
> 	"Each region may be unconfigured or configured with a different
> 	block size and capacity."
>=20
> I don't believe that a 0 in the Region Decode Length, Region Length, or
> Region Block Size is going to happen with the code structured the way it
> is.  I believe these values are used if the host specifically requests th=
e
> configuration of a region not indicated by 'Number of Available Regions'
> through the Starting Region Index in Table 8-163.  This code does not do
> that.
>=20
> Would you agree with this?

Agreed.

Fan
>=20
> Thanks again,
> Ira=

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id E9414CA0EEB
	for <linux-cxl@archiver.kernel.org>; Tue, 12 Sep 2023 16:49:09 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S237011AbjILQtM (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 12 Sep 2023 12:49:12 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:37880 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S236062AbjILQtM (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 12 Sep 2023 12:49:12 -0400
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 848C6110;
        Tue, 12 Sep 2023 09:49:08 -0700 (PDT)
Received: from lhrpeml500005.china.huawei.com (unknown [172.18.147.206])
        by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4RlV034NmJz67g1D;
        Wed, 13 Sep 2023 00:48:35 +0800 (CST)
Received: from localhost (10.202.227.76) by lhrpeml500005.china.huawei.com
 (7.191.163.240) with Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id 15.1.2507.31; Tue, 12 Sep
 2023 17:49:05 +0100
Date: Tue, 12 Sep 2023 17:49:04 +0100
From: Jonathan Cameron <Jonathan.Cameron@Huawei.com>
To: Ira Weiny <ira.weiny@intel.com>
CC: Dan Williams <dan.j.williams@intel.com>,
        Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
Subject: Re: [PATCH RFC v2 14/18] dax/region: Support DAX device creation on
 dynamic DAX regions
Message-ID: <20230912174904.00005fed@Huawei.com>
In-Reply-To: <64f80177c2c21_1e8e7829487@iweiny-mobl.notmuch>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
        <20230604-dcd-type2-upstream-v2-14-f740c47e7916@intel.com>
        <20230830125025.00000fea@Huawei.com>
        <64f80177c2c21_1e8e7829487@iweiny-mobl.notmuch>
Organization: Huawei Technologies Research and Development (UK) Ltd.
X-Mailer: Claws Mail 4.1.0 (GTK 3.24.33; x86_64-w64-mingw32)
MIME-Version: 1.0
Content-Type: text/plain; charset="US-ASCII"
Content-Transfer-Encoding: 7bit
X-Originating-IP: [10.202.227.76]
X-ClientProxiedBy: lhrpeml100001.china.huawei.com (7.191.160.183) To
 lhrpeml500005.china.huawei.com (7.191.163.240)
X-CFilter-Loop: Reflected
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

On Tue, 5 Sep 2023 21:35:03 -0700
Ira Weiny <ira.weiny@intel.com> wrote:

> Jonathan Cameron wrote:
> > On Mon, 28 Aug 2023 22:21:05 -0700
> > Ira Weiny <ira.weiny@intel.com> wrote:
> >   
> > > Dynamic Capacity (DC) DAX regions have a list of extents which define
> > > the memory of the region which is available.
> > > 
> > > Now that DAX region extents are fully realized support DAX device
> > > creation on dynamic regions by adjusting the allocation algorithms
> > > to account for the extents.  Remember also references must be held on
> > > the extents until the DAX devices are done with the memory.
> > > 
> > > Redefine the region available size to include only extent space.  Reuse
> > > the size allocation algorithm by defining sub-resources for each extent
> > > and limiting range allocation to those extents which have space.  Do not
> > > support direct mapping of DAX devices on dynamic devices.
> > > 
> > > Enhance DAX device range objects to hold references on the extents until
> > > the DAX device is destroyed.
> > > 
> > > NOTE: At this time all extents within a region are created equally.
> > > However, labels are associated with extents which can be used with
> > > future DAX device labels to group which extents are used.  
> > 
> > This sound like a bad place to start to me as we are enabling something
> > that is probably 'wrong' in the long term as opposed to just not enabling it
> > until we have appropriate support.  
> 
> I disagree.  I don't think the kernel should be trying to process tags at
> the lower level.
> 
> > I'd argue better to just reject any extents with different labels for now.  
> 
> Again I disagree.  This is less restrictive.  The idea is that labels can
> be changed such that user space can ultimately decided which extents
> should be used for which devices.  I have some work on that already.
> (Basically it becomes quite easy to assign a label to a dax device and
> have the extent search use only dax extents which match that label.)

That sounds good - but if someone expects that and uses it with an old
kernel I'm not sure if it is better to say 'we don't support it yet' or
do something different from a newer kernel.


> > > @@ -1400,8 +1507,10 @@ struct dev_dax *devm_create_dev_dax(struct dev_dax_data *data)
> > >  	device_initialize(dev);
> > >  	dev_set_name(dev, "dax%d.%d", dax_region->id, dev_dax->id);
> > >  
> > > +	dev_WARN_ONCE(parent, is_dynamic(dax_region) && data->size,
> > > +		      "Dynamic DAX devices are created initially with 0 size");  
> > 
> > dev_info() maybe more appropriate?  
> 
> Unless I'm mistaken this can happen from userspace but only if something
> in the code changes later.  Because the dax layer is trying to support
> non-dynamic regions (which dynamic may be a bad name), I was worried that
> the creation with a size might slip through...

Fair enough - if strong chance userspace will control it at somepoitn then
ONCE seems fine.

> 
> > Is this common enough that we need the
> > _ONCE?  
> 
> once is because it could end up spamming a log later if something got
> coded up wrong.

I'm not sure I care about bugs spamming the log.   Only things that
are userspace controlled or likely hardware failures etc.




From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id DF83FEE01F1
	for <linux-cxl@archiver.kernel.org>; Wed, 13 Sep 2023 17:30:58 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S229468AbjIMRbC (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Wed, 13 Sep 2023 13:31:02 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:57532 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S229552AbjIMRbB (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Wed, 13 Sep 2023 13:31:01 -0400
Received: from mgamail.intel.com (mgamail.intel.com [134.134.136.100])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 3FDCDC1;
        Wed, 13 Sep 2023 10:30:57 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1694626257; x=1726162257;
  h=date:from:to:cc:subject:message-id:references:
   in-reply-to:mime-version;
  bh=CeY+uqL86X6Cizk49EY9pSJr1OwumcVYxXdXN7aYyo4=;
  b=FMemf+hQNACbzljrNE3ewsOH1vIRtn9cCu3KR9JRLFCzjG6MXxQ/LfOi
   HiBYQxTtMMAYXQ0ZaEmXt9+QjJxR+oPmTPX0rhD7O4xJNl8OmOGAJEJYT
   1A44Hvw24B7I3bYEweaiSLjkStCIe96WKHV5eRsRuxxZO5lzmMw2wfd65
   Z3ej/WIkHgCAqif4weFSFhMilAR7NfjpNOZbQSGy9tmo7yWEwK62649RP
   K1ppepT5pEQB7J9UTzJEDTqkoj624+uCFyELkY35+BABFNDTvy0EXgf3f
   MNn5jMaraiinneqmNMV2876rs3+fSB/u4cCbvBL5ycyHzA6fko7YNG03O
   Q==;
X-IronPort-AV: E=McAfee;i="6600,9927,10832"; a="445167023"
X-IronPort-AV: E=Sophos;i="6.02,143,1688454000"; 
   d="scan'208";a="445167023"
Received: from fmsmga003.fm.intel.com ([10.253.24.29])
  by orsmga105.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 13 Sep 2023 10:30:56 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10832"; a="834396551"
X-IronPort-AV: E=Sophos;i="6.02,143,1688454000"; 
   d="scan'208";a="834396551"
Received: from fmsmsx601.amr.corp.intel.com ([10.18.126.81])
  by FMSMGA003.fm.intel.com with ESMTP/TLS/AES256-GCM-SHA384; 13 Sep 2023 10:30:56 -0700
Received: from fmsmsx610.amr.corp.intel.com (10.18.126.90) by
 fmsmsx601.amr.corp.intel.com (10.18.126.81) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.32; Wed, 13 Sep 2023 10:30:55 -0700
Received: from fmsedg602.ED.cps.intel.com (10.1.192.136) by
 fmsmsx610.amr.corp.intel.com (10.18.126.90) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.32 via Frontend Transport; Wed, 13 Sep 2023 10:30:55 -0700
Received: from NAM10-MW2-obe.outbound.protection.outlook.com (104.47.55.109)
 by edgegateway.intel.com (192.55.55.71) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.32; Wed, 13 Sep 2023 10:30:54 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=OAlHNU4UFSKeYwzBulXAtLazq6LN5OiVjcQO26V/uqOUC7+v4bklFv7IyDYoLOXve5Pc+r8iuaM5NdytYN4iGx3o5AW2CcVh2Ws7tT1R9e3l4gqpy8Qugp0HepVxOI/06iiKbU7KB6FsbvN6vB9zcZB8dhXn91tH9qPQRWR9mkudvqVHZmkE4TyQchsOqXvhtnuejJPtJnHFCEnJ5n+yRIh4trThJ7prdslZ8yQLiW6lKZ26Y8l2DZEUpHzsHCV5nx2cuNhi+S7TDPRp7rJlkWRA/jOsDV48UweNNIbLir7TIIRDpKTQWVW12WZzmZr9bbhWvFJXMpXgJvnwEUks5Q==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=FUFak1FfbgMdHAmMlkQpodS7HixK42KQ2JjDEN4Wsto=;
 b=QIdNWYFbY9KW3SN7cystfCZHiHXrjV0u1EkgYNz/yuraPfL604pXdQJMrliorNiNkq1GaJ/YCE6gl1fhcuEcXJG97rV1UtPR9mjpatOPbQUpMOB1PFCgSRPPjKy6e2MxiVvgAtJyhovoIUw+1h1Dq7Rs1/DiP2WUpCX2HVPqtb020HjQm9ecQLH+gc9LSwONRjhhN/HKUN8ycapzVJ33M3FqaIU6MYBPw5NhdM8SHpVgboBWUQs4yeeEyuItkrKOZIdeuB9Bno0283tSGD2vpVrHWibsqvX6onwPH+BLZTxYMmiP+RtRdwwQJbWYOneu2YuCrNWNBYofqncA+nhjKw==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from SA1PR11MB6733.namprd11.prod.outlook.com (2603:10b6:806:25c::17)
 by PH7PR11MB7025.namprd11.prod.outlook.com (2603:10b6:510:208::12) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.6792.19; Wed, 13 Sep
 2023 17:30:47 +0000
Received: from SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938]) by SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938%6]) with mapi id 15.20.6768.029; Wed, 13 Sep 2023
 17:30:47 +0000
Date: Wed, 13 Sep 2023 10:30:42 -0700
From: Ira Weiny <ira.weiny@intel.com>
To: Dan Williams <dan.j.williams@intel.com>,
        Ira Weiny <ira.weiny@intel.com>,
        Jonathan Cameron <Jonathan.Cameron@huawei.com>
CC: Dan Williams <dan.j.williams@intel.com>,
        Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
Subject: Re: [PATCH RFC v2 14/18] dax/region: Support DAX device creation on
 dynamic DAX regions
Message-ID: <6501f1c29a2c4_31df46294ec@iweiny-mobl.notmuch>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
 <20230604-dcd-type2-upstream-v2-14-f740c47e7916@intel.com>
 <20230830125025.00000fea@Huawei.com>
 <64f80177c2c21_1e8e7829487@iweiny-mobl.notmuch>
 <20230912174904.00005fed@Huawei.com>
 <6500e14a8588c_314b6629439@iweiny-mobl.notmuch>
 <6500e7cdac9dc_71e582945a@dwillia2-xfh.jf.intel.com.notmuch>
Content-Type: text/plain; charset="us-ascii"
Content-Disposition: inline
In-Reply-To: <6500e7cdac9dc_71e582945a@dwillia2-xfh.jf.intel.com.notmuch>
X-ClientProxiedBy: BYAPR02CA0006.namprd02.prod.outlook.com
 (2603:10b6:a02:ee::19) To SA1PR11MB6733.namprd11.prod.outlook.com
 (2603:10b6:806:25c::17)
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: SA1PR11MB6733:EE_|PH7PR11MB7025:EE_
X-MS-Office365-Filtering-Correlation-Id: 9c902936-eba7-4e0b-1786-08dbb47f2a91
X-LD-Processed: 46c98d88-e344-4ed4-8496-4ed7712e255d,ExtAddr
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;
X-Microsoft-Antispam-Message-Info: u/AtXd0RLmvgDoRd3Po+hwzVIQ3ggUaNT0pg8WKIId0EOb18u+oofSvV8HvRxL1VxZ6em2wqa3DeAjbBsZ2ABemVNIMuBjreyJQEOrPGJpucAj/X7yu4VqYWhOL0zd/eovU/5m06ffWV88pdOidRcxD9HJ+KiZgvEGB8nPUu0doK8P+5XiF2MviIGINKRZ5KqY3doKLC4/2DmPFDJpOJ6vEbsWGmUF82GvWL/YC0pIJDcyG/TKXO1S0iAh0w/ub2i2IfDa3xFRwvjHEiIhBMDecCERMGv1KWZqqvOMQTZX/VANOmhcIbHvSTn/EoZ56e02CpfDFmVRJ1ut0A/mBPKD6sIAFL4cM87HFH2TJm/h2KTuayDPxgOJNis2D+32G3xuqur8IHnQe3ut7w6alTO1bC8/YBqRWTlqixYvPBin7U1AU0HPKbvW8oOMOfvEMAxNxZVshk/dBByoFqvEn4PVb8eCF12p2J+1HjKQptfhOZtjWxx51zh+VkWjXL0TgvbV+gX60ZTeT1K6Mz1fuiHXwF99cLopPklYQ9VSssjK8Dycm2eyERHtB0gGAqF6d+
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:SA1PR11MB6733.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230031)(376002)(39860400002)(136003)(346002)(396003)(366004)(451199024)(1800799009)(186009)(86362001)(82960400001)(38100700002)(66899024)(66476007)(54906003)(41300700001)(66946007)(66556008)(8936002)(8676002)(4326008)(316002)(6666004)(26005)(6512007)(478600001)(9686003)(6486002)(6506007)(30864003)(2906002)(110136005)(83380400001)(44832011)(5660300002);DIR:OUT;SFP:1102;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?us-ascii?Q?3sa7e5MfjyLqRg5IKmMDjX/no7g5+x/66nwRJlhDJAr9aknodEkQdLjZfFPH?=
 =?us-ascii?Q?eKBPXM2gCOShPg5m4hXIEVf4ghUEBhkAi8EGzYxRj7Qe21RbdYV4g5Tdp9Cq?=
 =?us-ascii?Q?7yj2saxIQfvGsPN1WaTPaW3n7Z8aKxHbv+K/G4AcgzBZqdutzx+Y6m0QuorI?=
 =?us-ascii?Q?01GenA6yQXrdbyvdsTlceHVg6OxN1nfKqY1+0rffoOP8+ecwHVN+Cs9ASx5p?=
 =?us-ascii?Q?oGeiYpKwnOot0Alw9Pj1TXXTFB3SClKas0OgHve+iJUx/L/6wDFVLJo5vULw?=
 =?us-ascii?Q?BCVgzZdvflZUeaVgwEcDL+ag1b1zMriqdCY8d4lrKCknQI8k0xEy0YuqCe5m?=
 =?us-ascii?Q?LA2IbcEDYln71kIDq/XqMATudBaOT9s0f/3TSJdwdQimBWO0tkP3dpuz4YRu?=
 =?us-ascii?Q?V+A04NcJwm92ajGxU8EYZWtKNIznJRVg5IAlemF0VRz1rGZ863vzSHnnVADs?=
 =?us-ascii?Q?iL6vBBqFc+zxYXdJZYqcOQEa+ZHNwlBYcyyGGwOt9MtUCHjsz6+o1A/d6czH?=
 =?us-ascii?Q?VsgriFueadbdZVNvOcisSb0xXNLopd33gqDZvs3ZlEODz+3l5cTNosJ0zYFy?=
 =?us-ascii?Q?3VPxorgCrl67ZBapRe/BbxCbG4hKpVn8lXXMGnsRxqAZ/uaT+UHcVWXUwVMP?=
 =?us-ascii?Q?nrim0pVoY8A6V/KgOWdLbd7a7FxVxEPQ87EA5WxJyq33/YkDuS0XLvB50Wye?=
 =?us-ascii?Q?YfZJpRQm5eOAsa4LanIiFqwlf9Irj5zfirWX3XLSUW4Hsnp0tZLEDe6jsnTk?=
 =?us-ascii?Q?5PK2oLPqfHwiTfZsxwig3FkorGngdZd1nR77ykWDBApjP2y0+TBfjkfNiyrI?=
 =?us-ascii?Q?ZIcun0JNOMUSl7ObUISbQi6mcFjp5smHZNWLOZOPj5htGmc7/hbzQNuN17uA?=
 =?us-ascii?Q?FcAM3AsmKPJETMiWMdeRbztzWpeLGvuaBhBRtTeHNoc+t88owVVz/yflizWn?=
 =?us-ascii?Q?ORDji79DTYqaDqSCmdXMrvhmQu9Ep1no9/QJhNQ3HQjSdBUsTXKIqjvqRI87?=
 =?us-ascii?Q?oEguu/Dj8Oe2MZ0H5sVgKEA1jv17CtAQuOMoFyTyKy6yd5BztE41wUrXcEab?=
 =?us-ascii?Q?BqeVdK9b4zc7/zuodtX2B+fFGobvRNLb4f60ZQMIXBPcwH2WvucizFJEN1ka?=
 =?us-ascii?Q?CUvPPP3DGuB7aIVbsyj8wh9JHqmSVu1RAAbyqiCxP+IpWcRkzoYI+N/57gg6?=
 =?us-ascii?Q?D0Ssz7KAqQucG5qa3Cfo/TucMPCRzBSa2Ka7NzoDc01HqmvmWemlfm0pVfoG?=
 =?us-ascii?Q?mu6h8fdwGSQkhxZUgBWknXv3842ZgvsTSJLLgfEdfDfoAb29R4J0d7QI8YJF?=
 =?us-ascii?Q?etnjXhdeR7tz3zmyPnwN3mBD2gT+am2vop3Vsstrc8SetonbwcObWDqpD/+K?=
 =?us-ascii?Q?zmgbEgOkI52ytuyYsrdCOIrRf0k9eGryaUGfV1TvoIolfnY2ECiOce/J9CdO?=
 =?us-ascii?Q?uXbiv++Wf+nzeUOQ7R27GFf6mbJq4M9VSoP54edqi1iiAVd3/1tQ1R1aUAh5?=
 =?us-ascii?Q?NiAUhp6N0CJMKKNqIt6Q3X4I2MKau453KjqSnwrMiEZ/ltOWLZWQcAyr5Ne0?=
 =?us-ascii?Q?veQE0SfOWFznoRy6d18JpqaUDc5/8Oa0VvQcuchs?=
X-MS-Exchange-CrossTenant-Network-Message-Id: 9c902936-eba7-4e0b-1786-08dbb47f2a91
X-MS-Exchange-CrossTenant-AuthSource: SA1PR11MB6733.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 13 Sep 2023 17:30:47.3772
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: KkjfEyh+nJg+wYoDF3Z5NtvtFf+v7dk+MIqKdR1dzPI+3E9RUTUJi6v9MTz0Yn0wLC7k3bqMsW01YmfSrkJSvw==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: PH7PR11MB7025
X-OriginatorOrg: intel.com
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

Dan Williams wrote:
> Ira Weiny wrote:
> > Jonathan Cameron wrote:
> > > On Tue, 5 Sep 2023 21:35:03 -0700
> > > Ira Weiny <ira.weiny@intel.com> wrote:
> > > 
> > > > Jonathan Cameron wrote:
> > > > > On Mon, 28 Aug 2023 22:21:05 -0700
> > > > > Ira Weiny <ira.weiny@intel.com> wrote:
> > > > >   
> > > > > > Dynamic Capacity (DC) DAX regions have a list of extents which define
> > > > > > the memory of the region which is available.
> > > > > > 
> > > > > > Now that DAX region extents are fully realized support DAX device
> > > > > > creation on dynamic regions by adjusting the allocation algorithms
> > > > > > to account for the extents.  Remember also references must be held on
> > > > > > the extents until the DAX devices are done with the memory.
> > > > > > 
> > > > > > Redefine the region available size to include only extent space.  Reuse
> > > > > > the size allocation algorithm by defining sub-resources for each extent
> > > > > > and limiting range allocation to those extents which have space.  Do not
> > > > > > support direct mapping of DAX devices on dynamic devices.
> > > > > > 
> > > > > > Enhance DAX device range objects to hold references on the extents until
> > > > > > the DAX device is destroyed.
> > > > > > 
> > > > > > NOTE: At this time all extents within a region are created equally.
> > > > > > However, labels are associated with extents which can be used with
> > > > > > future DAX device labels to group which extents are used.  
> > > > > 
> > > > > This sound like a bad place to start to me as we are enabling something
> > > > > that is probably 'wrong' in the long term as opposed to just not enabling it
> > > > > until we have appropriate support.  
> > > > 
> > > > I disagree.  I don't think the kernel should be trying to process tags at
> > > > the lower level.
> > > > 
> > > > > I'd argue better to just reject any extents with different labels for now.  
> > > > 
> > > > Again I disagree.  This is less restrictive.  The idea is that labels can
> > > > be changed such that user space can ultimately decided which extents
> > > > should be used for which devices.  I have some work on that already.
> > > > (Basically it becomes quite easy to assign a label to a dax device and
> > > > have the extent search use only dax extents which match that label.)
> > > 
> > > That sounds good - but if someone expects that and uses it with an old
> > > kernel I'm not sure if it is better to say 'we don't support it yet' or
> > > do something different from a newer kernel.
> > 
> > This does provide the 'we don't support that yet' in that dax device
> > creation can't be associated with a label yet.  So surfacing the extents
> > with the tag as a default label and letting those labels change is more
> > informational at this point and not functional.  Simple use cases can use
> > the label (from the tag) to detect that some extent with the wrong tag got
> > in the region but can't correct it without going through the FM.
> > 
> > It is easy enough to remove the label sysfs and defer that until the dax
> > device has a label and this support though.
> 
> Catching up on just this point (still need to go through the whole
> thing).  A Sparse DAX region is one where the extents need not be
> present at DAX region instantiation and may be added/removed later. The
> device-dax allocation scheme just takes a size to do a "first-available"
> search for free capacity in the region.

Agreed.  And this is the way things work now.

Also your use of 'Sparse DAX region' seems better than the word 'dynamic'
I have used now.  I know that static regions mean something else but I
could not think of a better word.  I'll make adjustments to the
code/commit messages.

> 
> Given that one of the expected DCD use cases is to provide just in time
> memory for specific jobs the "first-available" search for free capacity
> in a Sparse DAX Region collides with the need to keep allocations
> bounded by tag.

How does it collide?

My attempt here is to leave dax devices 'unlabeled'.  As such they will use
space on a 'first-available' search regardless of extent labels.

Effectively I have defined 'no label' as being 'any label'.  I apologize
for this detail being implicit and not explicit.

My envisioned path would be that older daxctl would continue to work like
this because the kernel would not restrict unlabeled dax device creation.

Newer daxctl could use dax device labels to control the extents used.  But
only when dax device labeling is introduced in a future kernel.  Use of a
newer daxctl on an older DCD kernel could continue to work sans label.

In this way I envisioned a path where the policy is completely dictated by
user space restricted only by the software available.

> 
> I agree with Jonathan that unless and until the allocation scheme is
> updated to be tag aware then there is no reason for allocate by tag to
> exist in the interface.

I will agree that it was perhaps premature to introduce labels on the
extents.  However, I did so to give tags a space to be informationally
surfaced.

IMO we must have a plan forward or wait until that plan is fully formed
and implemented.  The size of this set is rather large.  Therefore, I was
hoping that a plan would be enough to move forward.

> 
> That said, the next question, "is DCD enabling considered a toy until
> the ability to allocate by tag is present?" I think yes, to the point
> where old daxctl binaries should be made fail to create device instances
> by forcing a tag to be selected at allocation time for Sparse DAX
> Regions.

Interesting.  I was not considering allocate by label to be a requirement
but rather an enhancement.  Labels IMO are a further refinement of the
memory space allocation.  I can see a very valid use case (not toy use
case) where all the DCD memory allocated to a node is dedicated to a
singular job and is done without tags or even ignoring tags.  Many HPC
sites run with singular jobs per host.

> 
> The last question is whether *writable* tags are needed to allow for
> repurposing memory allocated to a host without needing to round trip it
> through the FM to get it re-tagged. While that is something the host and
> orchestrator can figure out on their own, it looks like a nice to have
> until the above questions are answered.

Needed?  No.  Of course not.  As you said the orchestrator software can
keep iterating with the FM until it gets what it wants.  It was you who
had the idea of a writable labels and I agreed.

"Seemed like a good idea at the time..."  ;-)

As I have reviewed and rewritten this message I worry that writable labels
are a bad idea.  Interleaving will most likely depend on grouping extent
tags into the CXL/DAX extent.  With this in mind adjusting extents is
potentially going to require an FM interaction to get things set up
anyway.

	[Again re-reading my message I thought of another issue.  What
	happens if the user decides to change the label on an extent after
	some dax device with the old label?  That seems like an additional
	complication which is best left out by not allowing extent labels
	to be writable.]

I think writable labels are orthogonal to the kernel behavior though.
Allowing labels to change after the fact is a policy matter which is not
something the kernel needs to manage.

The kernel does need to manage how it allocates a dax device across the
extents available.  Assigning a dax label and allocating to the extents
matching that label is very straight forward.  The real issue is how to
deal with the 'no label' case.

As a path forward, I made a couple of assumptions.  First was the idea of
'no dax device label' == 'any extent label'.  Second, was that current dax
device creation was done as 'no dax device label'.

In this way I did not see a requirement to fully implement label
restriction on dax devices.  Labels are simply a nice to have thing to
group extents later.  Also, if you want dax devices created with specific
extents you have to assign them a label.  Otherwise they are allocated
'first-available' like they have been in the past.

I see a few ways forward.

One is to define 'no dax device label' as 'any extent label' as I have it
now.  IMO this provides the most backwards compatible dax device creation.
The ndctl region code additions are minimal and there are no daxctl
modifications required at all.

A second is to define 'no dax device label' as 'no extent label' and go
forward with this series but add a restriction on dax device creation to
only extents without a label.  This is still pretty compatible but if tags
are used then some extents would not be available without additional
daxctl modifications.

A third way forward is to fully implement label enabled dax device
creation.  In this case I feel like the direction is to make 'no label' ==
'no label'.  This is not hard but will take a couple more weeks to get the
daxctl code and all the testing.

It warrants mentioning that tags are an optional feature.  I feel like
there is momentum in the community to not use tags initially.  And so I
was targeting an initial implementation which really did not need tags at
all.  Perhaps I am wrong in that assumption?  Or perhaps I was short
sighted (possibly because interleaving becomes more straight forward)?

To summarize I see the following fundamental questions.

	1) Do we require DCD support to require dax device label
	   management?
	2) What does 'no dax device label' mean?
		a) any extent label
		b) no extent label
	3) Should writable labels be allowed on extents?
		a) this is more flexible
		b) security issues?
		c) does it just confuse things with interleaving?
		d) nice to change the tag name to something easy to read?
		e) other issues?
	4) How should the available size for labels be communicated to the
	   user?
	   	a) currently available size reflects an 'any extent label'
		   behavior when there is no label on the dax device.
		b) this becomes an issue if labelless dax devices are
		   restricted to labelless extents.

My current view is:
	1) No.  Current dax devices can be defined as 'no label'
	2) I'm not sure.  I can see both ways having benefits.
	3) No I think the ROI is not worth it.
	4) The use of 'any extent label' in #2 means that available size
	   retains it's meaning for no label dax devices.  Labeled dax
	   devices would require a future enhancement to size information.

> 
> > > > > > @@ -1400,8 +1507,10 @@ struct dev_dax *devm_create_dev_dax(struct dev_dax_data *data)
> > > > > >  	device_initialize(dev);
> > > > > >  	dev_set_name(dev, "dax%d.%d", dax_region->id, dev_dax->id);
> > > > > >  
> > > > > > +	dev_WARN_ONCE(parent, is_dynamic(dax_region) && data->size,
> > > > > > +		      "Dynamic DAX devices are created initially with 0 size");  
> > > > > 
> > > > > dev_info() maybe more appropriate?  
> > > > 
> > > > Unless I'm mistaken this can happen from userspace but only if something
> > > > in the code changes later.  Because the dax layer is trying to support
> > > > non-dynamic regions (which dynamic may be a bad name), I was worried that
> > > > the creation with a size might slip through...
> > > 
> > > Fair enough - if strong chance userspace will control it at somepoitn then
> > > ONCE seems fine.
> > > 
> > > > 
> > > > > Is this common enough that we need the
> > > > > _ONCE?  
> > > > 
> > > > once is because it could end up spamming a log later if something got
> > > > coded up wrong.
> > > 
> > > I'm not sure I care about bugs spamming the log.   Only things that
> > > are userspace controlled or likely hardware failures etc.
> > > 
> > 
> > Understood.  Let me trace them again but I think these can be triggered by
> > user space.  If not I'll remove the ONCE.
> 
> Unless this is an unequivocal kernel bug if it fires, and there is a
> significant potential for active development to do the wrong thing,
> don't leave a panic_on_warn land mine.

Indeed.  I forgot about those panic on warn users.  I'll remove the warn
altogether.

Thanks,
Ira

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 019D9EE3F39
	for <linux-cxl@archiver.kernel.org>; Tue, 12 Sep 2023 22:36:07 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S236366AbjILWgL (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Tue, 12 Sep 2023 18:36:11 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:55216 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S234813AbjILWgK (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Tue, 12 Sep 2023 18:36:10 -0400
Received: from mgamail.intel.com (mgamail.intel.com [192.55.52.88])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 9E7E010E9;
        Tue, 12 Sep 2023 15:36:06 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1694558166; x=1726094166;
  h=date:from:to:cc:subject:message-id:references:
   in-reply-to:mime-version;
  bh=sMSLUWElC9WPmskoHvvVV3ua9cCuoHJeKgSVi6zcn7o=;
  b=T1MvtE2ySkDPHA2MkKTOy2aVApgNxE9JxPjobrsoAt8lvKRKtg6L0Xaw
   KUCiy7I8q0zCb1D8/0RbC7/tEV0OeylAruI8hp5+epPD7FBuAkiMYgx5s
   vwOCWivbnQpWSgmX+0hJHBr4+t226uxbAwfBZShrNXboG6l673jxitCzL
   4lSGAlgt4fTKXuY31mJoXSBE0eV9C09g3H0AUufCcsoNCfwQxwDdkQp6M
   R8q2Ful+2Mx6si25bBIQONQ8FG6sxJHOEEZu1Gppqs/JMLnh74GgO2bE0
   ln4eZHaD/dZYZS008sjUKd25FgsylE4MzudiGMh6UIGyqjB+7KNS+mXzS
   w==;
X-IronPort-AV: E=McAfee;i="6600,9927,10831"; a="409461634"
X-IronPort-AV: E=Sophos;i="6.02,141,1688454000"; 
   d="scan'208";a="409461634"
Received: from fmsmga005.fm.intel.com ([10.253.24.32])
  by fmsmga101.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 12 Sep 2023 15:36:03 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10831"; a="1074712688"
X-IronPort-AV: E=Sophos;i="6.02,141,1688454000"; 
   d="scan'208";a="1074712688"
Received: from fmsmsx601.amr.corp.intel.com ([10.18.126.81])
  by fmsmga005.fm.intel.com with ESMTP/TLS/AES256-GCM-SHA384; 12 Sep 2023 15:36:03 -0700
Received: from fmsmsx603.amr.corp.intel.com (10.18.126.83) by
 fmsmsx601.amr.corp.intel.com (10.18.126.81) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.32; Tue, 12 Sep 2023 15:36:03 -0700
Received: from fmsedg601.ED.cps.intel.com (10.1.192.135) by
 fmsmsx603.amr.corp.intel.com (10.18.126.83) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.32 via Frontend Transport; Tue, 12 Sep 2023 15:36:03 -0700
Received: from NAM02-DM3-obe.outbound.protection.outlook.com (104.47.56.48) by
 edgegateway.intel.com (192.55.55.70) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.32; Tue, 12 Sep 2023 15:36:02 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=m2Iw1gFzM9OcTTKSmpzC6vFkPgfF+FSE5OkI3jt4erpVFpQB9tLdC2EHdH5nA7cm5wa1Qgu5mrL0wZx271h3AX6CmEBpK+8DeT7q05Ly721648rfmQWgwpEv11Q+CjwYvZNuQK57opMQlpA6qwc+8tmCTghOyLGRGuSFrP0n0fNX6rwlR/ZG9pGM8U/6PNQmx8RUYl/lPmbqq+gr4yNXE3VVwrT1MNZMsz1+a6b84IuEaNu8Rrfb1Q3qpp3lgArMDnqScZPbrtI1rhrcSxRkcmXt/siG2HRekudFDGB0tX+N04gOG3xsnBV9ZVSJZ4RqzEgSEw1ycTk0aBvznT/YVQ==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=i/T3JICfy76CGeMDgjTsWgmPfes8nSDzXEiQ0lVYx9s=;
 b=gAvxvUnoJoHLfqB8cIkN9oRi4wmQ1xKxf7AcJewkNjJUpGRm3YRlGUnmHxbFLoqe3ZPlJgWm4o3pKyQhzpYeHeIX4tuaCAgjoWTx6E2jOr6taM0R5x3uUi5vFi7T+64oYIwq8mBxAP6MJ7p01QtVlEZpJWVU0cihJCudWAmsQmh+6ZmgGd2nEb4HeTKUvOSxboid6tKixWqHIy1QYtZfvdS9LqdNfp4FRf/9ZFPavYBYk0JbsX2YgsQVZCaoUvx905suDoA0W6rr1/ECYKrp7R6mjtPeQILVY4KUdrr0kujIEAJzTYz43stQITEQIQOKlifPpE9Q+/Lvmvf9kKkyMg==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from PH8PR11MB8107.namprd11.prod.outlook.com (2603:10b6:510:256::6)
 by CYXPR11MB8755.namprd11.prod.outlook.com (2603:10b6:930:e3::7) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.6768.30; Tue, 12 Sep
 2023 22:36:01 +0000
Received: from PH8PR11MB8107.namprd11.prod.outlook.com
 ([fe80::acb0:6bd3:58a:c992]) by PH8PR11MB8107.namprd11.prod.outlook.com
 ([fe80::acb0:6bd3:58a:c992%5]) with mapi id 15.20.6768.029; Tue, 12 Sep 2023
 22:36:01 +0000
Date: Tue, 12 Sep 2023 15:35:57 -0700
From: Dan Williams <dan.j.williams@intel.com>
To: Ira Weiny <ira.weiny@intel.com>,
        Jonathan Cameron <Jonathan.Cameron@huawei.com>
CC: Dan Williams <dan.j.williams@intel.com>,
        Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
Subject: Re: [PATCH RFC v2 14/18] dax/region: Support DAX device creation on
 dynamic DAX regions
Message-ID: <6500e7cdac9dc_71e582945a@dwillia2-xfh.jf.intel.com.notmuch>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
 <20230604-dcd-type2-upstream-v2-14-f740c47e7916@intel.com>
 <20230830125025.00000fea@Huawei.com>
 <64f80177c2c21_1e8e7829487@iweiny-mobl.notmuch>
 <20230912174904.00005fed@Huawei.com>
 <6500e14a8588c_314b6629439@iweiny-mobl.notmuch>
Content-Type: text/plain; charset="us-ascii"
Content-Disposition: inline
In-Reply-To: <6500e14a8588c_314b6629439@iweiny-mobl.notmuch>
X-ClientProxiedBy: MW3PR06CA0014.namprd06.prod.outlook.com
 (2603:10b6:303:2a::19) To PH8PR11MB8107.namprd11.prod.outlook.com
 (2603:10b6:510:256::6)
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: PH8PR11MB8107:EE_|CYXPR11MB8755:EE_
X-MS-Office365-Filtering-Correlation-Id: 52fcc82e-f76f-427e-8c22-08dbb3e0a40d
X-LD-Processed: 46c98d88-e344-4ed4-8496-4ed7712e255d,ExtAddr
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;
X-Microsoft-Antispam-Message-Info: wKh9w5PpkT9hYcF5uSGT4stoj8m4AobZiPwe8JnjyUjRN8ZaX/ytgTnE2/X7FZhiDyoDN1xdF1crOyvcROgf/gM/uWkheaXUwGVblPJhiw82t5tCJ/2CiiR8KucXAciP1YmPsyH/QFe1JQ+oOi+tbUmmUQK62eyAoz3eMbLDZwaQHUhE1fm9RVvXzECc/RC+VXZH214iQyTXFawrx/KGlMh+E3DrHEOyeZJUWe6sX+tVYF6epx/Jt7pV1AEowk7pdsyiB4Wicv5aQ10acINh2LTs9uqYHQSJZRkwomFB/wjQzhmY5brGzqn/Sztc93oZk4D8fam+xLgInlagTe2sPtXU8u1VlVBmu2uh2/rgUiYtN9cPZzLZjrVkG2irPVMaF/tLv0ZSbs8uEHzYqDnwwqVD47x8gDTnrd/nc8tTdGW/nJkZ09OuD7FL78iMwsZsWfm/qcElaf9lUSLFwWDMOOJT7kiFNa8C4+u5XiyThwBrYry0UYd1DCKxus7gCV0bv3fb66ng6d8He2jCzK5ZuPQAPm/DgVP6FiEf5AWh39E52KQvySDe9y9prbLKCgo3
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:PH8PR11MB8107.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230031)(136003)(376002)(366004)(346002)(396003)(39860400002)(451199024)(186009)(1800799009)(8936002)(4326008)(26005)(8676002)(83380400001)(5660300002)(9686003)(6512007)(41300700001)(6506007)(6486002)(66476007)(54906003)(66556008)(66946007)(110136005)(82960400001)(6666004)(38100700002)(316002)(86362001)(2906002)(478600001);DIR:OUT;SFP:1102;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?us-ascii?Q?ONQFvymT33HR9POmei3E6yLV+SjdvdaPaNky4giBjqMzHfZdwE3e1NqGwi/w?=
 =?us-ascii?Q?yvmvEUeTfKdnlZbMrK+FKXbcyH2oDMDivIG9sLpLcFQF82EMEg3pRmX9XKEk?=
 =?us-ascii?Q?Opqr6pVqyBQzbG+/ZPtGwuBXCT4Z1c+bXjYX9zOXVYVq8s0HPUWlR/39khlz?=
 =?us-ascii?Q?kFz4/k0I16ab2lGVAVK0rABZNdYQuiLPMfb9mIfXbZzs1l/64oC2dcyeyed6?=
 =?us-ascii?Q?I3C9LDgNDxipDbjfbjOC1BU1R9zCjYtIpr3xM6l1rNSFAXMulUltK/KfZzJi?=
 =?us-ascii?Q?npoF4FjwpdLM1+MWCY9YCqGBwhihLS9mms3j/SAhiuVob/WvHLgwKNEAqOMz?=
 =?us-ascii?Q?zAkkipON/49ys7SmIoBY31VPGvtHbS+XJsSErqmXpBjVC/fo5NzJYUq9yJtV?=
 =?us-ascii?Q?wlk+xn2MuHyJGdeXA49yNN8n0zCkSbIh+55lv76GfwdJLEsLMPJRQ2eqQ+bs?=
 =?us-ascii?Q?pXTjr5aH17s4wjGXFhWtZLifivS1b46QGNJraegzwPtiqcr8zQvTG4EHOzv8?=
 =?us-ascii?Q?9EtuCkz1D8m6voLlWQa8WzGMyapSRyE0cKDs+3OmRS0lmvbbycU7lqA/DggQ?=
 =?us-ascii?Q?MhxlsTMtx1jci8Q8QMew+lu5oV6NtG83mJ0We7csH3egqPdZJhCdPhXf+TNH?=
 =?us-ascii?Q?MxXuYvgZJvzyCV2nJ3YVjzCSyBio5X12qGw4xd/o6+6FsrbjRuFzXIErhAqh?=
 =?us-ascii?Q?9qtsaq8CfF8tWsPw3cHJYnO+F4iRfbY2Pj/ws+uOTCNVpEEFrFU4Xt5g9lZ0?=
 =?us-ascii?Q?p6p6367KRbY0r0/+DinOmVQ5XlA/lhIu0EvNSuy/9Pe2uLRO1BM0l+lkkwVS?=
 =?us-ascii?Q?tH+pDNIG+sqC4B6qTBiMCKQOuZuJpfG/A41jKVtj5MLx+mXE5iJDSorZR8KH?=
 =?us-ascii?Q?V2Ga8WhSNw0VVFkFbETp05I1fnWnXOe3TfmxQ+Qp0Ou1hyIlYY/pwU7diJtE?=
 =?us-ascii?Q?ckg4pGPV+mAuXGYqxUl/Gwey/7IcYDeTGmxVUzxj8ZLKJYzcpi6XL0yDiBJo?=
 =?us-ascii?Q?dCWWp9c3b1pBmV5LyX898ZaktWFv42xcJbj3GPLo8rm57J4RDbhs6IPbYZ6B?=
 =?us-ascii?Q?DbPdPPSsaGhQI5XtHrBlM5KAsvlEXnYSML9DzBtKzD9/pBkgKS/Pq/V4kKlq?=
 =?us-ascii?Q?m0cFlmOZMlPu3x/0AdFQt5gYt21UltKWBO+PzbDUadjc7UouYivpsOht4OyR?=
 =?us-ascii?Q?qc4xbA/gtbGuYyzSGXPUALuOInkK5fknpUiG+UPxOQea4/CGQS++Axt8rb4d?=
 =?us-ascii?Q?C+jlSFoH/dSLgriGyFH/ivOqgMBKyMSVdmHqlbWRLpKIE6w8EvOsHwFbKpqP?=
 =?us-ascii?Q?3+yy00vH2ApzTt2ZGA5fdc7ZmeMYgsyJIwZesQ+1VZnNqIUlCeg1+nRSJpI3?=
 =?us-ascii?Q?tA46XZK2JHL2iLvSj4Sz3U4s8p9VfO7pRGKYKuek+0dvk9E+I8t3G3q+nFqm?=
 =?us-ascii?Q?FbkMcAwW4uozHWEfeNI+bmyKv6YSfd94SIcDi6HFxNBkNIaialSrHfY4lKF2?=
 =?us-ascii?Q?HVPbIcrWPeYwVPRYCY5OUwN4+qDl3QW4dHrN2GRJMHYGMtCILfGLxcx/6ccO?=
 =?us-ascii?Q?qcq/jidMRcJ8w5A7/1S1hJS4Kg4iicc/o5I5lU2T+i7RUTBy5Z7rYV/xed3X?=
 =?us-ascii?Q?lA=3D=3D?=
X-MS-Exchange-CrossTenant-Network-Message-Id: 52fcc82e-f76f-427e-8c22-08dbb3e0a40d
X-MS-Exchange-CrossTenant-AuthSource: PH8PR11MB8107.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 12 Sep 2023 22:36:01.1456
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: vj1gzVtCpK9zjMqpRTHJC+NCrDGfrHttcPc2Wt6K4jpzWdY7FZjq7FvTp4/X8zo2BhsVN7p2npVJlbzbgXmiq7IUiJzBPnuvL06k6WL8waA=
X-MS-Exchange-Transport-CrossTenantHeadersStamped: CYXPR11MB8755
X-OriginatorOrg: intel.com
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

Ira Weiny wrote:
> Jonathan Cameron wrote:
> > On Tue, 5 Sep 2023 21:35:03 -0700
> > Ira Weiny <ira.weiny@intel.com> wrote:
> > 
> > > Jonathan Cameron wrote:
> > > > On Mon, 28 Aug 2023 22:21:05 -0700
> > > > Ira Weiny <ira.weiny@intel.com> wrote:
> > > >   
> > > > > Dynamic Capacity (DC) DAX regions have a list of extents which define
> > > > > the memory of the region which is available.
> > > > > 
> > > > > Now that DAX region extents are fully realized support DAX device
> > > > > creation on dynamic regions by adjusting the allocation algorithms
> > > > > to account for the extents.  Remember also references must be held on
> > > > > the extents until the DAX devices are done with the memory.
> > > > > 
> > > > > Redefine the region available size to include only extent space.  Reuse
> > > > > the size allocation algorithm by defining sub-resources for each extent
> > > > > and limiting range allocation to those extents which have space.  Do not
> > > > > support direct mapping of DAX devices on dynamic devices.
> > > > > 
> > > > > Enhance DAX device range objects to hold references on the extents until
> > > > > the DAX device is destroyed.
> > > > > 
> > > > > NOTE: At this time all extents within a region are created equally.
> > > > > However, labels are associated with extents which can be used with
> > > > > future DAX device labels to group which extents are used.  
> > > > 
> > > > This sound like a bad place to start to me as we are enabling something
> > > > that is probably 'wrong' in the long term as opposed to just not enabling it
> > > > until we have appropriate support.  
> > > 
> > > I disagree.  I don't think the kernel should be trying to process tags at
> > > the lower level.
> > > 
> > > > I'd argue better to just reject any extents with different labels for now.  
> > > 
> > > Again I disagree.  This is less restrictive.  The idea is that labels can
> > > be changed such that user space can ultimately decided which extents
> > > should be used for which devices.  I have some work on that already.
> > > (Basically it becomes quite easy to assign a label to a dax device and
> > > have the extent search use only dax extents which match that label.)
> > 
> > That sounds good - but if someone expects that and uses it with an old
> > kernel I'm not sure if it is better to say 'we don't support it yet' or
> > do something different from a newer kernel.
> 
> This does provide the 'we don't support that yet' in that dax device
> creation can't be associated with a label yet.  So surfacing the extents
> with the tag as a default label and letting those labels change is more
> informational at this point and not functional.  Simple use cases can use
> the label (from the tag) to detect that some extent with the wrong tag got
> in the region but can't correct it without going through the FM.
> 
> It is easy enough to remove the label sysfs and defer that until the dax
> device has a label and this support though.

Catching up on just this point (still need to go through the whole
thing).  A Sparse DAX region is one where the extents need not be
present at DAX region instantiation and may be added/removed later. The
device-dax allocation scheme just takes a size to do a "first-available"
search for free capacity in the region.

Given that one of the expected DCD use cases is to provide just in time
memory for specific jobs the "first-available" search for free capacity
in a Sparse DAX Region collides with the need to keep allocations
bounded by tag.

I agree with Jonathan that unless and until the allocation scheme is
updated to be tag aware then there is no reason for allocate by tag to
exist in the interface.

That said, the next question, "is DCD enabling considered a toy until
the ability to allocate by tag is present?" I think yes, to the point
where old daxctl binaries should be made fail to create device instances
by forcing a tag to be selected at allocation time for Sparse DAX
Regions.

The last question is whether *writable* tags are needed to allow for
repurposing memory allocated to a host without needing to round trip it
through the FM to get it re-tagged. While that is something the host and
orchestrator can figure out on their own, it looks like a nice to have
until the above questions are answered.

> > > > > @@ -1400,8 +1507,10 @@ struct dev_dax *devm_create_dev_dax(struct dev_dax_data *data)
> > > > >  	device_initialize(dev);
> > > > >  	dev_set_name(dev, "dax%d.%d", dax_region->id, dev_dax->id);
> > > > >  
> > > > > +	dev_WARN_ONCE(parent, is_dynamic(dax_region) && data->size,
> > > > > +		      "Dynamic DAX devices are created initially with 0 size");  
> > > > 
> > > > dev_info() maybe more appropriate?  
> > > 
> > > Unless I'm mistaken this can happen from userspace but only if something
> > > in the code changes later.  Because the dax layer is trying to support
> > > non-dynamic regions (which dynamic may be a bad name), I was worried that
> > > the creation with a size might slip through...
> > 
> > Fair enough - if strong chance userspace will control it at somepoitn then
> > ONCE seems fine.
> > 
> > > 
> > > > Is this common enough that we need the
> > > > _ONCE?  
> > > 
> > > once is because it could end up spamming a log later if something got
> > > coded up wrong.
> > 
> > I'm not sure I care about bugs spamming the log.   Only things that
> > are userspace controlled or likely hardware failures etc.
> > 
> 
> Understood.  Let me trace them again but I think these can be triggered by
> user space.  If not I'll remove the ONCE.

Unless this is an unequivocal kernel bug if it fires, and there is a
significant potential for active development to do the wrong thing,
don't leave a panic_on_warn land mine.

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id 0CCFEEE0207
	for <linux-cxl@archiver.kernel.org>; Wed, 13 Sep 2023 19:27:08 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S232330AbjIMT1L (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Wed, 13 Sep 2023 15:27:11 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:34612 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S231172AbjIMT1K (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Wed, 13 Sep 2023 15:27:10 -0400
Received: from mgamail.intel.com (mgamail.intel.com [134.134.136.24])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 3DE2DB7;
        Wed, 13 Sep 2023 12:27:06 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1694633226; x=1726169226;
  h=date:from:to:cc:subject:message-id:references:
   in-reply-to:mime-version;
  bh=getsqvkBWu3kcXcFLnVerNsmXgk1UKiCp2q704vi8FE=;
  b=gPmIoZ55TzwKWCqXllaqOznOkTtgYR3NB7omYV3QJC0LsDZM1oFtEjpJ
   wc86roVFWu1mzrp3PEnX0jj6HRhE1MWldEr0ZF5YYO3RTHettYHMCH2bn
   Bh2U5TPsvdm4s8urwYIad9tk7+KliOQnCqVMV1dXaw0PvbWD6XGJHzWXm
   yMhDiFEIUPdjtLHnbnWOqljywfOcLkLj8w+o7e6jLzJh0yoifO5XgtnE6
   HJ0rwApskmvKqM0uiOWdHA/TmSW2TGpDQY+Kcuuh6zmav9Ui2Q6oz+6rq
   7n08/QmgmsHzmpY1p0+7nGmFX1ujL6rW5Scm59bYpuXSGnDNJzamogSoo
   A==;
X-IronPort-AV: E=McAfee;i="6600,9927,10832"; a="381446963"
X-IronPort-AV: E=Sophos;i="6.02,144,1688454000"; 
   d="scan'208";a="381446963"
Received: from fmsmga005.fm.intel.com ([10.253.24.32])
  by orsmga102.jf.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 13 Sep 2023 12:27:05 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10832"; a="1075064150"
X-IronPort-AV: E=Sophos;i="6.02,144,1688454000"; 
   d="scan'208";a="1075064150"
Received: from fmsmsx603.amr.corp.intel.com ([10.18.126.83])
  by fmsmga005.fm.intel.com with ESMTP/TLS/AES256-GCM-SHA384; 13 Sep 2023 12:27:05 -0700
Received: from fmsmsx612.amr.corp.intel.com (10.18.126.92) by
 fmsmsx603.amr.corp.intel.com (10.18.126.83) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.32; Wed, 13 Sep 2023 12:27:05 -0700
Received: from fmsmsx610.amr.corp.intel.com (10.18.126.90) by
 fmsmsx612.amr.corp.intel.com (10.18.126.92) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.32; Wed, 13 Sep 2023 12:27:04 -0700
Received: from fmsedg602.ED.cps.intel.com (10.1.192.136) by
 fmsmsx610.amr.corp.intel.com (10.18.126.90) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.32 via Frontend Transport; Wed, 13 Sep 2023 12:27:04 -0700
Received: from NAM10-MW2-obe.outbound.protection.outlook.com (104.47.55.106)
 by edgegateway.intel.com (192.55.55.71) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.32; Wed, 13 Sep 2023 12:27:04 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=CssORK1k9L2S8UZlqMw5EYkK9ZoT/FOs7LwScjBVcf56b+BQQFzfqPDD11O1Qbsawtsx/TZ4bnHb6kqozReGj07eE66yLcNIyhy3kbqo7Gvx5Bu/q/H09Uk5D3BD08BLxmuZ5CTGoNo5u3VdldHkW4p5Ue4fKgHpmx3CD8Urzy/bdaejGd3zmg3vH9iEuPrEqjftLKv3eBUlLrnKG9UYzIXvnVveWOuWp9fsznuPhiRB2cyYSh1GeyuK9vUXkqL4y/MWWnmT6q0AXzklTMPcapXXa5rHG9ud3TcK7lOv69sO/abRtZg+jVy3TtU35zJFwwJfgNSBQvZlCODmUzSWgg==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=X7sURWxlykVeVM/YruX4PI2FQVbF7OyRqqvCyhQXErI=;
 b=lmio415mFNPjmMqI+HWdeXOxJjzqT6vc0QLJwIM2clTyrWMxW2A2s3c8Xqmtzqtb7dyL6UIop0iXvoLDslM+Wb64MRftNXj/9ip8LNHPaSEBOgpAybnmXBf+pLeKIiGqv82g3MYqkGfwjVeHc28dZ5lJx+0pvxIQyVRp4TobAOgEWhr8io2Iv6FJeOsmK8IKZl15ZoRyc/fVBgNmbY7IR0O652bEAR7sRjr7drOjJq9MBNJvrg5VHdDxAwHNjFKSw1cOzqKOL9MxWBiSkQYaErmxEAYqjDZDHQ39thaT2W6oL5zLmgcUB2iteb2hoQsmMeWVEJYg+W7d9WtPRLaJHA==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from SA1PR11MB6733.namprd11.prod.outlook.com (2603:10b6:806:25c::17)
 by SJ0PR11MB5600.namprd11.prod.outlook.com (2603:10b6:a03:3ab::16) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.6792.19; Wed, 13 Sep
 2023 19:27:02 +0000
Received: from SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938]) by SA1PR11MB6733.namprd11.prod.outlook.com
 ([fe80::6da5:f747:ba54:6938%6]) with mapi id 15.20.6768.029; Wed, 13 Sep 2023
 19:27:02 +0000
Date: Wed, 13 Sep 2023 12:26:58 -0700
From: Ira Weiny <ira.weiny@intel.com>
To: Dan Williams <dan.j.williams@intel.com>,
        Ira Weiny <ira.weiny@intel.com>,
        Jonathan Cameron <Jonathan.Cameron@huawei.com>
CC: Dan Williams <dan.j.williams@intel.com>,
        Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
Subject: Re: [PATCH RFC v2 14/18] dax/region: Support DAX device creation on
 dynamic DAX regions
Message-ID: <65020d0264085_321c802941d@iweiny-mobl.notmuch>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
 <20230604-dcd-type2-upstream-v2-14-f740c47e7916@intel.com>
 <20230830125025.00000fea@Huawei.com>
 <64f80177c2c21_1e8e7829487@iweiny-mobl.notmuch>
 <20230912174904.00005fed@Huawei.com>
 <6500e14a8588c_314b6629439@iweiny-mobl.notmuch>
 <6500e7cdac9dc_71e582945a@dwillia2-xfh.jf.intel.com.notmuch>
 <6501f1c29a2c4_31df46294ec@iweiny-mobl.notmuch>
 <6501f89c9ef86_12747294bd@dwillia2-xfh.jf.intel.com.notmuch>
Content-Type: text/plain; charset="us-ascii"
Content-Disposition: inline
In-Reply-To: <6501f89c9ef86_12747294bd@dwillia2-xfh.jf.intel.com.notmuch>
X-ClientProxiedBy: BYAPR21CA0015.namprd21.prod.outlook.com
 (2603:10b6:a03:114::25) To SA1PR11MB6733.namprd11.prod.outlook.com
 (2603:10b6:806:25c::17)
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: SA1PR11MB6733:EE_|SJ0PR11MB5600:EE_
X-MS-Office365-Filtering-Correlation-Id: 1d4eb6c8-3374-45a6-7f3c-08dbb48f684e
X-LD-Processed: 46c98d88-e344-4ed4-8496-4ed7712e255d,ExtAddr
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;
X-Microsoft-Antispam-Message-Info: x2ag6XPg/c8y0c+v0VnJb3ykps3BPoDkrOhbDyTLzyTh9iLbxu6G5NF1ln85YntUpmQ7b98MsGQyOX50eSKQhiX26fBGhrf+92deSkRgc4a3SXKfCJr7j7LmFUyk487YAkIfqgaHbv0yrBrvAvhCu3TwIKt0ZAilZg5ciNmBeNiZkcVxqpTZsJU45AYm+n8X1V+1WkDF5XM8COO5RRVswxTw1HQ3hqX9Ixd6R5Xndww8iByRLQIYQy6+MqJ7NSynBiaHQbAmmWjlrln9vVKwey9yepJZOc69XY9Dy/WKxqHEO3pKJefn+d0tEAdO0IHZzQQDmFN9B3JuLMESu/nru9XTM1lVgB9X4hrgt5xrpolanBbpsP9S8dnEZxbpY3ntMWXustEyn95gs4zlLI+c4V+1GnKhnuv8I/cuPcjIsRADAUJl4jMqy+phwWYJgFi3M5Fyk6u+uqjcedJGSmg/UgPMbvX6wQXrufiWsK8dMzDC8+GGmWazMTbKMXyXcSs8U4+8mMwyBXpKRzguL7nMmmx4FDksaiYG+Oprg0L2DCcRQHsI4ChI3mr1KaysF+Xj
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:SA1PR11MB6733.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230031)(376002)(39860400002)(346002)(366004)(136003)(396003)(186009)(1800799009)(451199024)(6666004)(6506007)(6486002)(6512007)(9686003)(478600001)(83380400001)(2906002)(44832011)(26005)(66476007)(54906003)(66946007)(66556008)(316002)(8676002)(110136005)(4326008)(5660300002)(41300700001)(8936002)(86362001)(82960400001)(38100700002)(66899024);DIR:OUT;SFP:1102;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?us-ascii?Q?SZ1FR2+PEYk8oNNJQ8bjEHJ4pDO4fIQBqBaVRMMrF0KuC/2gkjYO9nAkMQYk?=
 =?us-ascii?Q?CI0r5CBiZXrA7dx4z+twrj0VEYyVY+NIekLD7fEeYqziOGqVPSCVsXUOw3NT?=
 =?us-ascii?Q?/4plhDIT4ZnkOeT+SUFperopJ4zvSaRObgwENQT8oR8F4nbztlUvRcr7AP0P?=
 =?us-ascii?Q?SpAOIPYITZv/7r4jwFR5tyIsXocD0zIScQ0urVzXNSvKIExESLSqxMQkph5g?=
 =?us-ascii?Q?QzP78Az5zDSf/dhv9nMU0n1N7MKseKurrUX2WTPryXZO1/03Yi9t9/wnWp0E?=
 =?us-ascii?Q?kt/fvhwR+G3Bhfls7onPZmxFI5oVXRiu2Nd8lXCg4z1IJFGtvj0XnXFq3P76?=
 =?us-ascii?Q?2trE0f5LKEUpNqHTQkj8bdNJr6yWjWX7/5N8rVpMxAsUktiQLdN+OwBa7SuF?=
 =?us-ascii?Q?KsKafawPt5UOG6hHK6gKMl9nRNCSfGr//8fZBM3AjhQivZ9IYzGmvybQNk9E?=
 =?us-ascii?Q?W2cEMGp50zj67zKrwMYqOZZFZtatzJPLs7PZDUqPFBXUL3PTyTtPmkjpUH9T?=
 =?us-ascii?Q?jcuhuxJvTxxdqgp4hevd0Z8ZmK0zqcjOOM6PsXzjGOZcPjUFX0TW+XLtb9nm?=
 =?us-ascii?Q?rUhE9Tvr1yE1KFV9xWvlssr/GDceAVnTal9XWnTRq+M5cnrnqb/WXVsXIBa9?=
 =?us-ascii?Q?QnWsEjGdk+OW46+oDbwexZUQicXkqiiQGBj0Uv5Ss/6z/62LwepJR0poiUzF?=
 =?us-ascii?Q?ryjFbF1inMOEHgv33TpkPPIxCZv2VJ1jb+X/AV3mWUqRJQl2d4eESP5NkhF7?=
 =?us-ascii?Q?10gJtSKrwYAxBP5eDGWaeKa+h9cHaPyuIsNZZuPI0fVos7BCcjZCnVOn0Q0m?=
 =?us-ascii?Q?9ZyrgdJRWrISsSM0WQNBPq5byzQIAxuT3SeXrpRO493QOzviDWGE/yjL6aLP?=
 =?us-ascii?Q?vtz079d9/JOWNfbkBK1ahbbQEwJXbAGf2Pga930fKP0P35hDMcqjM+nUqgH+?=
 =?us-ascii?Q?c8s+eqy4AK5GMRu7Dxkxo2Q+mzaj81z2NfGTGqb1AzwIbCUqxWonLtrbLY5G?=
 =?us-ascii?Q?DtkImk0ME8LSs1FiQrkZLYy6NIP0+Mxzc9+B6dBlPo6JQRWeuk5yadc2GEIT?=
 =?us-ascii?Q?SZOAi8qT3ZByMmPuZPuzEH6awjSovUtKlEo4/uu3PXYl9MvfgKxAuFKEy+4q?=
 =?us-ascii?Q?CZjFGVGPX3TCfHzcC/sZ1P6w0hFQAdYATGEY0iOt3t9Gq5Tyxrm3oi3WRwvI?=
 =?us-ascii?Q?C7SdFdTObBvm6XxNM8540nDSVl+04vHlXK5XUdI5SaAAO3iHZiW02CUGw7+7?=
 =?us-ascii?Q?glpOSiCZML9WyQJx/DAPZskiX15TovM4KN9Tm1t7sa47DlIQz0jmRfn5sK7C?=
 =?us-ascii?Q?l9ewwuI6eV4oYnTGNwKKe4WI6XkVQpmfygA6tDPXKYYDNprvppasKms6xnI+?=
 =?us-ascii?Q?LyFd/GnK/3UG5RYAJIx2oxS31gUI5kU8vyHCOGvkTv18Q1D1jxyobmByptCu?=
 =?us-ascii?Q?B00E5Hff5Xoe0yzmmtea7ODbTErRKNvYa0HlqT7qmvBQswo9cONDR7ppJrx5?=
 =?us-ascii?Q?1BtY/oeLZ+ITutyYGWl1ebT/rF8LgcEhbxBwkIYl43o8GwuDGmVysL9FWQim?=
 =?us-ascii?Q?Wf4pCX4N+BvTmOedgQE5EPXE/gFr8rROq3QxIQZP?=
X-MS-Exchange-CrossTenant-Network-Message-Id: 1d4eb6c8-3374-45a6-7f3c-08dbb48f684e
X-MS-Exchange-CrossTenant-AuthSource: SA1PR11MB6733.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 13 Sep 2023 19:27:02.8604
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: UJoqydiLjPkfwX8jbYsjdkfibohUbjyOoAeTuWKnrXFXrrgPaij7hqfGpRzKZrb9IFM966NEJoDGWBIHl8nXqA==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: SJ0PR11MB5600
X-OriginatorOrg: intel.com
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

Dan Williams wrote:
> Ira Weiny wrote:
> [..]
> > > 
> > > Given that one of the expected DCD use cases is to provide just in time
> > > memory for specific jobs the "first-available" search for free capacity
> > > in a Sparse DAX Region collides with the need to keep allocations
> > > bounded by tag.
> > 
> > How does it collide?
> > 
> > My attempt here is to leave dax devices 'unlabeled'.  As such they will use
> > space on a 'first-available' search regardless of extent labels.
> > 
> > Effectively I have defined 'no label' as being 'any label'.  I apologize
> > for this detail being implicit and not explicit.
> > 
> > My envisioned path would be that older daxctl would continue to work like
> > this because the kernel would not restrict unlabeled dax device creation.
> > 
> > Newer daxctl could use dax device labels to control the extents used.  But
> > only when dax device labeling is introduced in a future kernel.  Use of a
> > newer daxctl on an older DCD kernel could continue to work sans label.
> > 
> > In this way I envisioned a path where the policy is completely dictated by
> > user space restricted only by the software available.
> 
> Tags are a core concept in DCD. "Allocate by tag" does not feel like
> something that can come later at least in terms of when the DCD ABI is
> ready for upstream. So, yes, it can remain out of this patchset, but the
> upstream merge of all of DCD would be gated on that facility arriving.

I don't see how this can be left out of this patchset.  Without dax device
support on DCD there is no functionality and this patchset does nothing.

> 
> > > I agree with Jonathan that unless and until the allocation scheme is
> > > updated to be tag aware then there is no reason for allocate by tag to
> > > exist in the interface.
> > 
> > I will agree that it was perhaps premature to introduce labels on the
> > extents.  However, I did so to give tags a space to be informationally
> > surfaced.
> > 
> > IMO we must have a plan forward or wait until that plan is fully formed
> > and implemented.  The size of this set is rather large.  Therefore, I was
> > hoping that a plan would be enough to move forward.
> 
> Leave it out for now to focus on the core mechanisms and then we can
       ^^^^
       it what?
> circle back to it.

Again dax devices need to be created to full test this so I have to create
them in some way.  I'm going to assume you mean 'labelless' and deal with
labels later.

> 
> > > That said, the next question, "is DCD enabling considered a toy until
> > > the ability to allocate by tag is present?" I think yes, to the point
> > > where old daxctl binaries should be made fail to create device instances
> > > by forcing a tag to be selected at allocation time for Sparse DAX
> > > Regions.
> > 
> > Interesting.  I was not considering allocate by label to be a requirement
> > but rather an enhancement.  Labels IMO are a further refinement of the
> > memory space allocation.  I can see a very valid use case (not toy use
> > case) where all the DCD memory allocated to a node is dedicated to a
> > singular job and is done without tags or even ignoring tags.  Many HPC
> > sites run with singular jobs per host.
> 
> Is HPC going to use DCD? My impression is that HPC is statically
> provisioned per node and that DCD is more targeted at Cloud use cases
> where dynamic provisioning is common.

I heard someone mention HPC in a call at some point.

> 
> > > The last question is whether *writable* tags are needed to allow for
> > > repurposing memory allocated to a host without needing to round trip it
> > > through the FM to get it re-tagged. While that is something the host and
> > > orchestrator can figure out on their own, it looks like a nice to have
> > > until the above questions are answered.
> > 
> > Needed?  No.  Of course not.  As you said the orchestrator software can
> > keep iterating with the FM until it gets what it wants.  It was you who
> > had the idea of a writable labels and I agreed.
> 
> Yeah, it was an idea for how to solve the problem of repurposing tag
> without needing to round trip with the FM.
> 
> > "Seemed like a good idea at the time..."  ;-)
> > 
> > As I have reviewed and rewritten this message I worry that writable labels
> > are a bad idea.  Interleaving will most likely depend on grouping extent
> > tags into the CXL/DAX extent.  With this in mind adjusting extents is
> > potentially going to require an FM interaction to get things set up
> > anyway.
> > 
> > 	[Again re-reading my message I thought of another issue.  What
> > 	happens if the user decides to change the label on an extent after
> > 	some dax device with the old label?  That seems like an additional
> > 	complication which is best left out by not allowing extent labels
> > 	to be writable.]
> 
> At least for this point extents can not be relabeled while allocated to
> an instance.

Sure but is having writeable labels worth this extra complexity?

> 
> [..]
> > My current view is:
> > 	1) No.  Current dax devices can be defined as 'no label'
> > 	2) I'm not sure.  I can see both ways having benefits.
> > 	3) No I think the ROI is not worth it.
> > 	4) The use of 'any extent label' in #2 means that available size
> > 	   retains it's meaning for no label dax devices.  Labeled dax
> > 	   devices would require a future enhancement to size information.
> 
> If the ABI is going to change in the future I don't want every debug
> session to start with "which version of daxctl were you using", or "do
> your scripts comprehend Sparse DAX Regions?".

Well then we are stuck.  Because at a minimum they will have to understand
Sparse DAX regions.  cxl create-region needs a new type to create such
regions.

I envisioned an ABI *extension* not change.  The current ABI supports dax
devices without a tag.  Even with DCD no tag is possible.  Unless you want
to restrict it, which it sounds like you do?

I'm ok with that but I know of at least 1 meeting where it was
emphatically mentioned that tags are _not_ required.  So I'd like some
community members to chime in here if requiring tags is ok.

>
> This stance is motivated
> by having seen the problems that the current ABI causes for people that want
> to do things like mitigate the "noisy neighbor" phenomenon in memory
> side caches.

Does a dax device need specific placement within the region?  That sounds
like control at the extent layer when the extent is mapped into the
region.

The mapping store interface does need to be resolved for DCD.  I could
envision the ability for user space to create extents...  Are you thinking
the same thing?

Conceptually from a top down approach _any_ dax region could be a sparse
dax region if I get what you are driving at?  Not just DCD?  In that case
extent creation is even more complicated in the DCD case.

> The allocation ABI is too simple and DCD seems to need
> more.

Are you advocating for an ABI which requires dax devices to be labeled?
It sounds like you don't want the current tool set to work on sparse dax
regions.  Is that correct?  I'm ok with that but I don't think a specific
check in the kernel is the proper way to do that.  Current dax devices are
unlabled.  So I envisioned them being supported with the current ABI.

> 
> The kernel enforced requirement for Sparse DAX Region aware tooling just
> makes it easier on us to maintain. If it means waiting until we ahve
> agreement on the allocation ABI I think that's a simple release valve.

These statements imply to me you have additional requirements for this ABI
beyond what DCD does.  I've tried to make the dax layer DCD/CXL agnostic.
But beyond having the concept of region extents which are labeled and
matched to dax devices based on that label; what other requirements on dax
to region space allocations are there?

> 
> The fundamental mechanisms can be reviewed in the meantime.

Sure,
Ira

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id B96A4EE01FF
	for <linux-cxl@archiver.kernel.org>; Wed, 13 Sep 2023 18:00:07 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S231455AbjIMSAK (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Wed, 13 Sep 2023 14:00:10 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:39764 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S230205AbjIMSAH (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Wed, 13 Sep 2023 14:00:07 -0400
Received: from mgamail.intel.com (mgamail.intel.com [192.55.52.115])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 03D5919AF;
        Wed, 13 Sep 2023 11:00:03 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1694628003; x=1726164003;
  h=date:from:to:cc:subject:message-id:references:
   in-reply-to:mime-version;
  bh=VSu8qer4+Zfa1377Vtg0ju7FDckidDT3XqYYs+8/6ZA=;
  b=hP5lOvxDDWtdLLDd/Rjsaxgf0vyBtIMzQ3ZzbVlRQ+pebXGo1cPkNGp2
   mgxPdzIFPCbsjJKDzp9cR1eDsdc5bTDaAbaKBjk13HJ88TZj+iO0w3v6g
   038XWLjmubeCBFmatvZJIiGtkVMaeBDRBFj+9wKFAmg6f3dVDiq5Nw3Cn
   oj/4X5ilkha41ZK2BA8Q4i5idKd9a261MiY1H88FGNM8LkmrT9OAR3uO6
   1iERqJZkVHJyjc+uyt+rZvAxNCbx1xQ5OK31igWnmfqbIDaSHIhtSfvD/
   Z5rQUde91Cn+rbXntCQbfTLaOakT8GCme2A5QcYdBcsEMUJok/k7KkFri
   g==;
X-IronPort-AV: E=McAfee;i="6600,9927,10832"; a="378656462"
X-IronPort-AV: E=Sophos;i="6.02,143,1688454000"; 
   d="scan'208";a="378656462"
Received: from fmsmga003.fm.intel.com ([10.253.24.29])
  by fmsmga103.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 13 Sep 2023 11:00:02 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=McAfee;i="6600,9927,10832"; a="834408963"
X-IronPort-AV: E=Sophos;i="6.02,143,1688454000"; 
   d="scan'208";a="834408963"
Received: from fmsmsx601.amr.corp.intel.com ([10.18.126.81])
  by FMSMGA003.fm.intel.com with ESMTP/TLS/AES256-GCM-SHA384; 13 Sep 2023 11:00:02 -0700
Received: from fmsmsx603.amr.corp.intel.com (10.18.126.83) by
 fmsmsx601.amr.corp.intel.com (10.18.126.81) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.32; Wed, 13 Sep 2023 11:00:01 -0700
Received: from fmsedg601.ED.cps.intel.com (10.1.192.135) by
 fmsmsx603.amr.corp.intel.com (10.18.126.83) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id
 15.1.2507.32 via Frontend Transport; Wed, 13 Sep 2023 11:00:01 -0700
Received: from NAM11-DM6-obe.outbound.protection.outlook.com (104.47.57.172)
 by edgegateway.intel.com (192.55.55.70) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.32; Wed, 13 Sep 2023 11:00:01 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector9901; d=microsoft.com; cv=none;
 b=DXFkbmhW7Q7iFUb9sfwtCos1LdahhahU+nFipyWYmkxGvnLUZxyvHjmnEMw8N9mBjab2/IEaNRZ13Sjw8v39m6STPKWl8sEXHOnlqXS2jjJXuISj2tve9EdeRtfQWAvwYUTFJZvA6ZjpE+bsrkXsFVwDV+eWCsym7aXpR/KODwU4TfftMauACCHdiGCGNr3YeOwnIfTNT9L6Ww02s3vI6S66Z/24iAlRhF56p6Rg+q51uGWN+1uaiMxDd8CGahu2Mj8oZlAEy3nGd6wf7iGTm+DatkugewEaDWFQHBxKzyVfzDmmegjcEpPHQoHxZQtb3w5dS+Uj0mODTUo2Y0dY5g==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector9901;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=ykRI8V2iEV85fL/Hq1MPPiEIuOycnxMSFB9y/7D1Rpc=;
 b=CpKpKsMr1maCgRuV5B0PUYcjALQTK3Nms4rPC9oyimD8Z2h5ZoLlpDp6Gy/ccmJhrXUYhT2fJhszwDEFhlY/j6RRfMSAEeIngysDJMz1gYBb8SCI5L+JpNjn8Zu35/NOEH70hOudSbrTWNmHjpzwLjz2OxCoU5UZwmJWwviIWEZMPNFbWJkpiU4v6Z5oyEmm0kzWZm47TFACBf1cvfaVYoHBmwdiF0mN1eRB7GGyewtABJvo3qU9g4jha2NWFE+r6Q48mROKt7raV0LyW0qMOAXq8+rpzQbXnutiqEhejyC/QdrrKD+1Jym5hceJXX8OTD60iGAdowV+1P2DudG1eg==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from PH8PR11MB8107.namprd11.prod.outlook.com (2603:10b6:510:256::6)
 by CY8PR11MB7268.namprd11.prod.outlook.com (2603:10b6:930:9b::9) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.6768.30; Wed, 13 Sep
 2023 17:59:59 +0000
Received: from PH8PR11MB8107.namprd11.prod.outlook.com
 ([fe80::acb0:6bd3:58a:c992]) by PH8PR11MB8107.namprd11.prod.outlook.com
 ([fe80::acb0:6bd3:58a:c992%5]) with mapi id 15.20.6768.029; Wed, 13 Sep 2023
 17:59:59 +0000
Date: Wed, 13 Sep 2023 10:59:56 -0700
From: Dan Williams <dan.j.williams@intel.com>
To: Ira Weiny <ira.weiny@intel.com>,
        Dan Williams <dan.j.williams@intel.com>,
        Jonathan Cameron <Jonathan.Cameron@huawei.com>
CC: Dan Williams <dan.j.williams@intel.com>,
        Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
Subject: Re: [PATCH RFC v2 14/18] dax/region: Support DAX device creation on
 dynamic DAX regions
Message-ID: <6501f89c9ef86_12747294bd@dwillia2-xfh.jf.intel.com.notmuch>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
 <20230604-dcd-type2-upstream-v2-14-f740c47e7916@intel.com>
 <20230830125025.00000fea@Huawei.com>
 <64f80177c2c21_1e8e7829487@iweiny-mobl.notmuch>
 <20230912174904.00005fed@Huawei.com>
 <6500e14a8588c_314b6629439@iweiny-mobl.notmuch>
 <6500e7cdac9dc_71e582945a@dwillia2-xfh.jf.intel.com.notmuch>
 <6501f1c29a2c4_31df46294ec@iweiny-mobl.notmuch>
Content-Type: text/plain; charset="us-ascii"
Content-Disposition: inline
In-Reply-To: <6501f1c29a2c4_31df46294ec@iweiny-mobl.notmuch>
X-ClientProxiedBy: MW4PR04CA0107.namprd04.prod.outlook.com
 (2603:10b6:303:83::22) To PH8PR11MB8107.namprd11.prod.outlook.com
 (2603:10b6:510:256::6)
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: PH8PR11MB8107:EE_|CY8PR11MB7268:EE_
X-MS-Office365-Filtering-Correlation-Id: f2a54103-ef73-46c9-1d31-08dbb4833f12
X-LD-Processed: 46c98d88-e344-4ed4-8496-4ed7712e255d,ExtAddr
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;
X-Microsoft-Antispam-Message-Info: IP/7PC44sak3JAuphR55eKUCTyOzOlsRo9z2LIsMr86acGTLYaYD7qYVbBJRX+f711dAVHf2I5VhP4ogkNRJJBW6MCrUrk2hFysjmft0QFqOwd4RBfWdqzkz7Ya3mVoZDXdtho+fqdzAv8+6eHM+NFyFHUHZi21kSDqPwKiyGVNiLD3gjBsHdjBgFijeBLGz98KReV/S4ICqH46gut9fCxBHzqaDsiQ8vzlc9I2BKYsr8LY52/5c7J5TLYQc/90JhWIB9SCPnI16C7O9f9ZB62vDic25an0k73y8nuSuLVB8obd4VhONxfv9i4YzJ9OaljXBU8e0uBeHukLmrQ9og25dTTc0ghtTdjTYYrTPzeD2xYFWqYU+F0S0GLcUIqZ2xTPpl5HvAkSaWCQt38w2bBndLLdYmtp7TgYCB3paJz+e8g2fVZheFo4ZvorpTHmJUTOTJm5V1l2zos+gaK1Ejlo92mDhL3vQchsc5lOZpo5QtsTgr60DN+iBv+e9VhaPgTr6Yzt8Btqsr/bvbfbOvrOEMYkTTCfE65O9mw3o+Gp4PlSGEfX+j6XEBvn9Nwk5
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:PH8PR11MB8107.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230031)(136003)(366004)(376002)(346002)(396003)(39860400002)(451199024)(186009)(1800799009)(8936002)(8676002)(26005)(4326008)(5660300002)(83380400001)(9686003)(6512007)(6486002)(41300700001)(6506007)(66946007)(54906003)(66556008)(110136005)(6666004)(82960400001)(38100700002)(316002)(66476007)(86362001)(2906002)(478600001);DIR:OUT;SFP:1102;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?us-ascii?Q?uvRIxWVff4yx0x2sf5uqRpb2HkgV8T4TUBnlUm3Vemv5JEsrKUglCvIVuP7n?=
 =?us-ascii?Q?xxDjwjEWAqugELATI1oUj8eXxyt2sT3Yw9hYzfMXJRMWf9YLs7Sk8ck/wRew?=
 =?us-ascii?Q?ZtV/XDWL1ok+OQFnwyfMPawX0iKOrIMRRmteKVhCceEqap9AK9AIMkPxVNcA?=
 =?us-ascii?Q?yDhWdMtBMh3ajW72zBvk4Y6CeeDbJ3hcehbHiq49zr+ysKemK1dVkSt4nxVS?=
 =?us-ascii?Q?wfCE5pEE+lr53yddMn3FglPvM/J9MQ9BOCeCoHR1uPP1l20Di0b7jUE58gkj?=
 =?us-ascii?Q?xxWw8r7C0YgRpMcqGkgy6E0l3kK6Q20YFgVjevIOCpM1Xik7VUQXai/NM+Wn?=
 =?us-ascii?Q?/rVf/KjfAu3g5q7YtPzRh4UFqUtmM0Tkwng83ggb/DBL/vtoyKl516Chogg/?=
 =?us-ascii?Q?29VV5gP8z3mEx+6yVQN9XDB50sr3t31hkXrDgcWu0Qp3FRKw/+L7Sm7ztxC8?=
 =?us-ascii?Q?42q9ClA4YH6iMAunr49hhkZuBa6EFhrLWhIqLmZuZMUXmGGCx+vC5zQB6eNe?=
 =?us-ascii?Q?uS0ZssiKPPUi8YRLxQJkUVsD/3lQHn4LU6TnEpWvmZRkAE2Srthm3STrYTnE?=
 =?us-ascii?Q?QNEkcALh9TefSYSPfhk+m4JIGww1LqYBA3RAgQxOab8fvvKDqM/pmB8o7K+l?=
 =?us-ascii?Q?UhVLRDd4cV6b06LFBXHuch51xv1J/RnC1ixV87sJS+dheoNO92L5gaHhT/Ty?=
 =?us-ascii?Q?9tF0XPq19yU1yT7Y5AXOAPG5Z9G1r5OFb+VoRP/mr1+EuC/xDqf6iHGaIpKh?=
 =?us-ascii?Q?IZ33cR3TMIuAup/Y79Y3I/QQUPq1dOS0kvwgzmK5GSzC0N576lfZ04E9o6d6?=
 =?us-ascii?Q?LZnmEgf016+Afql7a6VBNzMdpe9dC+HmAQwKrY06ucABzGI/4O/yJACKrSiI?=
 =?us-ascii?Q?0F9aUD3fNhQHF5FZb6lMdYSxMki87vSwqsbJKb2o5OOi53BJLWnDkyyu7H+u?=
 =?us-ascii?Q?iFNdQ/AnXPVBXNcmcoYprW27MwcI9JsLN9KiOQsBIhYPA1pWyBKUQnu5/1nS?=
 =?us-ascii?Q?1W/f/WfMTuODNL0jy9ilcCzxcCrqp7vIyXeXlmHBCYoLHIvIWmOjnUFASoST?=
 =?us-ascii?Q?Y2xAxG5zcb3/EuJCuWg6QNOywjpvHgw7ed2bMXngYbeV8Eq0MOS71hjAhb9t?=
 =?us-ascii?Q?NNyjc2Xgjhoa+Xtm8gyVjB41E6c577yVA13FSUdIRhJo+5f4rkCduqIy8iCK?=
 =?us-ascii?Q?tGripTCXGjPbShH89lcLXjD+i4brPJPQaFDmYRRWLp8RgauXaB788ynv693S?=
 =?us-ascii?Q?Py/O5NqUf3OZ6YJbCLjh5fRlVJXDBGny3hkructubKHTsCjWmoxXMsrY3qM2?=
 =?us-ascii?Q?PB88enaH+SJ8trUOWtHoEZebWR3Kp+sex1f6QDkqnIC163DmY8nm1M96JtCP?=
 =?us-ascii?Q?4Gw7/M0ymPP9RyyYIlFxoPFeN//obYTOgNY63FaE3XJ6+ZNwcdidFefSeyq7?=
 =?us-ascii?Q?6xjaGxMhfm2reAzCqTrFZW+ig/mDhmjfO27TELr+zgziUWflaffmiaJysH2F?=
 =?us-ascii?Q?4JQ8TmgI0J5BUGY7LY99zz94lx7CVuZlUHtAOM3x5xtzAhui0WraWLOpLg7k?=
 =?us-ascii?Q?opwcEykekXUM93Hkjqo+bbGkEusOyuNiGMQClA7rZJmO3hSGREDDuSQHjnCN?=
 =?us-ascii?Q?3g=3D=3D?=
X-MS-Exchange-CrossTenant-Network-Message-Id: f2a54103-ef73-46c9-1d31-08dbb4833f12
X-MS-Exchange-CrossTenant-AuthSource: PH8PR11MB8107.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 13 Sep 2023 17:59:59.6350
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: jyOxmPndobwyegES2VjdC5McSfEo7naVYFzJLiYs6FOLx7hTH2RG3qeY9190Xi0hrNb6JgU/KPdL03o35jJjTbZCPlbYIMT/mlFo9cerDPQ=
X-MS-Exchange-Transport-CrossTenantHeadersStamped: CY8PR11MB7268
X-OriginatorOrg: intel.com
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

Ira Weiny wrote:
[..]
> > 
> > Given that one of the expected DCD use cases is to provide just in time
> > memory for specific jobs the "first-available" search for free capacity
> > in a Sparse DAX Region collides with the need to keep allocations
> > bounded by tag.
> 
> How does it collide?
> 
> My attempt here is to leave dax devices 'unlabeled'.  As such they will use
> space on a 'first-available' search regardless of extent labels.
> 
> Effectively I have defined 'no label' as being 'any label'.  I apologize
> for this detail being implicit and not explicit.
> 
> My envisioned path would be that older daxctl would continue to work like
> this because the kernel would not restrict unlabeled dax device creation.
> 
> Newer daxctl could use dax device labels to control the extents used.  But
> only when dax device labeling is introduced in a future kernel.  Use of a
> newer daxctl on an older DCD kernel could continue to work sans label.
> 
> In this way I envisioned a path where the policy is completely dictated by
> user space restricted only by the software available.

Tags are a core concept in DCD. "Allocate by tag" does not feel like
something that can come later at least in terms of when the DCD ABI is
ready for upstream. So, yes, it can remain out of this patchset, but the
upstream merge of all of DCD would be gated on that facility arriving.

> > I agree with Jonathan that unless and until the allocation scheme is
> > updated to be tag aware then there is no reason for allocate by tag to
> > exist in the interface.
> 
> I will agree that it was perhaps premature to introduce labels on the
> extents.  However, I did so to give tags a space to be informationally
> surfaced.
> 
> IMO we must have a plan forward or wait until that plan is fully formed
> and implemented.  The size of this set is rather large.  Therefore, I was
> hoping that a plan would be enough to move forward.

Leave it out for now to focus on the core mechanisms and then we can
circle back to it.

> > That said, the next question, "is DCD enabling considered a toy until
> > the ability to allocate by tag is present?" I think yes, to the point
> > where old daxctl binaries should be made fail to create device instances
> > by forcing a tag to be selected at allocation time for Sparse DAX
> > Regions.
> 
> Interesting.  I was not considering allocate by label to be a requirement
> but rather an enhancement.  Labels IMO are a further refinement of the
> memory space allocation.  I can see a very valid use case (not toy use
> case) where all the DCD memory allocated to a node is dedicated to a
> singular job and is done without tags or even ignoring tags.  Many HPC
> sites run with singular jobs per host.

Is HPC going to use DCD? My impression is that HPC is statically
provisioned per node and that DCD is more targeted at Cloud use cases
where dynamic provisioning is common.

> > The last question is whether *writable* tags are needed to allow for
> > repurposing memory allocated to a host without needing to round trip it
> > through the FM to get it re-tagged. While that is something the host and
> > orchestrator can figure out on their own, it looks like a nice to have
> > until the above questions are answered.
> 
> Needed?  No.  Of course not.  As you said the orchestrator software can
> keep iterating with the FM until it gets what it wants.  It was you who
> had the idea of a writable labels and I agreed.

Yeah, it was an idea for how to solve the problem of repurposing tag
without needing to round trip with the FM.

> "Seemed like a good idea at the time..."  ;-)
> 
> As I have reviewed and rewritten this message I worry that writable labels
> are a bad idea.  Interleaving will most likely depend on grouping extent
> tags into the CXL/DAX extent.  With this in mind adjusting extents is
> potentially going to require an FM interaction to get things set up
> anyway.
> 
> 	[Again re-reading my message I thought of another issue.  What
> 	happens if the user decides to change the label on an extent after
> 	some dax device with the old label?  That seems like an additional
> 	complication which is best left out by not allowing extent labels
> 	to be writable.]

At least for this point extents can not be relabeled while allocated to
an instance.

[..]
> My current view is:
> 	1) No.  Current dax devices can be defined as 'no label'
> 	2) I'm not sure.  I can see both ways having benefits.
> 	3) No I think the ROI is not worth it.
> 	4) The use of 'any extent label' in #2 means that available size
> 	   retains it's meaning for no label dax devices.  Labeled dax
> 	   devices would require a future enhancement to size information.

If the ABI is going to change in the future I don't want every debug
session to start with "which version of daxctl were you using", or "do
your scripts comprehend Sparse DAX Regions?". This stance is motivated
by having seen the problems that the current ABI causes for people that want
to do things like mitigate the "noisy neighbor" phenomenon in memory
side caches. The allocation ABI is too simple and DCD seems to need
more.

The kernel enforced requirement for Sparse DAX Region aware tooling just
makes it easier on us to maintain. If it means waiting until we ahve
agreement on the allocation ABI I think that's a simple release valve.

The fundamental mechanisms can be reviewed in the meantime.

From mboxrd@z Thu Jan  1 00:00:00 1970
Return-Path: <linux-cxl-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by smtp.lore.kernel.org (Postfix) with ESMTP id CC853EDE99C
	for <linux-cxl@archiver.kernel.org>; Thu, 14 Sep 2023 10:32:24 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S230198AbjINKc0 (ORCPT <rfc822;linux-cxl@archiver.kernel.org>);
        Thu, 14 Sep 2023 06:32:26 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:53232 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S237100AbjINKcW (ORCPT
        <rfc822;linux-cxl@vger.kernel.org>); Thu, 14 Sep 2023 06:32:22 -0400
Received: from frasgout.his.huawei.com (frasgout.his.huawei.com [185.176.79.56])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id A6B941FC2;
        Thu, 14 Sep 2023 03:32:06 -0700 (PDT)
Received: from lhrpeml500005.china.huawei.com (unknown [172.18.147.226])
        by frasgout.his.huawei.com (SkyGuard) with ESMTP id 4RmYX01Fscz6K5pj;
        Thu, 14 Sep 2023 18:31:28 +0800 (CST)
Received: from localhost (10.202.227.76) by lhrpeml500005.china.huawei.com
 (7.191.163.240) with Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id 15.1.2507.31; Thu, 14 Sep
 2023 11:32:03 +0100
Date: Thu, 14 Sep 2023 11:32:00 +0100
From: Jonathan Cameron <Jonathan.Cameron@Huawei.com>
To: Ira Weiny <ira.weiny@intel.com>
CC: Dan Williams <dan.j.williams@intel.com>,
        Navneet Singh <navneet.singh@intel.com>,
        Fan Ni <fan.ni@samsung.com>,
        Davidlohr Bueso <dave@stgolabs.net>,
        Dave Jiang <dave.jiang@intel.com>,
        Alison Schofield <alison.schofield@intel.com>,
        Vishal Verma <vishal.l.verma@intel.com>,
        <linux-cxl@vger.kernel.org>, <linux-kernel@vger.kernel.org>
Subject: Re: [PATCH RFC v2 14/18] dax/region: Support DAX device creation on
 dynamic DAX regions
Message-ID: <20230914113200.000060a8@Huawei.com>
In-Reply-To: <65020d0264085_321c802941d@iweiny-mobl.notmuch>
References: <20230604-dcd-type2-upstream-v2-0-f740c47e7916@intel.com>
        <20230604-dcd-type2-upstream-v2-14-f740c47e7916@intel.com>
        <20230830125025.00000fea@Huawei.com>
        <64f80177c2c21_1e8e7829487@iweiny-mobl.notmuch>
        <20230912174904.00005fed@Huawei.com>
        <6500e14a8588c_314b6629439@iweiny-mobl.notmuch>
        <6500e7cdac9dc_71e582945a@dwillia2-xfh.jf.intel.com.notmuch>
        <6501f1c29a2c4_31df46294ec@iweiny-mobl.notmuch>
        <6501f89c9ef86_12747294bd@dwillia2-xfh.jf.intel.com.notmuch>
        <65020d0264085_321c802941d@iweiny-mobl.notmuch>
Organization: Huawei Technologies Research and Development (UK) Ltd.
X-Mailer: Claws Mail 4.1.0 (GTK 3.24.33; x86_64-w64-mingw32)
MIME-Version: 1.0
Content-Type: text/plain; charset="US-ASCII"
Content-Transfer-Encoding: 7bit
X-Originating-IP: [10.202.227.76]
X-ClientProxiedBy: lhrpeml100006.china.huawei.com (7.191.160.224) To
 lhrpeml500005.china.huawei.com (7.191.163.240)
X-CFilter-Loop: Reflected
Precedence: bulk
List-ID: <linux-cxl.vger.kernel.org>
X-Mailing-List: linux-cxl@vger.kernel.org

On Wed, 13 Sep 2023 12:26:58 -0700
Ira Weiny <ira.weiny@intel.com> wrote:

> Dan Williams wrote:
> > Ira Weiny wrote:

Jumping in on randomly selected points :)

> > [..]  
> > > > 
> > > > Given that one of the expected DCD use cases is to provide just in time
> > > > memory for specific jobs the "first-available" search for free capacity
> > > > in a Sparse DAX Region collides with the need to keep allocations
> > > > bounded by tag.  
> > > 
> > > How does it collide?
> > > 
> > > My attempt here is to leave dax devices 'unlabeled'.  As such they will use
> > > space on a 'first-available' search regardless of extent labels.
> > > 
> > > Effectively I have defined 'no label' as being 'any label'.  I apologize
> > > for this detail being implicit and not explicit.
> > > 
> > > My envisioned path would be that older daxctl would continue to work like
> > > this because the kernel would not restrict unlabeled dax device creation.
> > > 
> > > Newer daxctl could use dax device labels to control the extents used.  But
> > > only when dax device labeling is introduced in a future kernel.  Use of a
> > > newer daxctl on an older DCD kernel could continue to work sans label.
> > > 
> > > In this way I envisioned a path where the policy is completely dictated by
> > > user space restricted only by the software available.  
> > 
> > Tags are a core concept in DCD. "Allocate by tag" does not feel like
> > something that can come later at least in terms of when the DCD ABI is
> > ready for upstream. So, yes, it can remain out of this patchset, but the
> > upstream merge of all of DCD would be gated on that facility arriving.  
> 
> I don't see how this can be left out of this patchset.  Without dax device
> support on DCD there is no functionality and this patchset does nothing.

Agreed - but I think one path you suggest is fine.

No label dax == no label DCD extents.

That one should be true for ever (or until writeable tags added) so
is safe and gets us going.

> 
> >   
> > > > I agree with Jonathan that unless and until the allocation scheme is
> > > > updated to be tag aware then there is no reason for allocate by tag to
> > > > exist in the interface.  
> > > 
> > > I will agree that it was perhaps premature to introduce labels on the
> > > extents.  However, I did so to give tags a space to be informationally
> > > surfaced.
> > > 
> > > IMO we must have a plan forward or wait until that plan is fully formed
> > > and implemented.  The size of this set is rather large.  Therefore, I was
> > > hoping that a plan would be enough to move forward.  
> > 
> > Leave it out for now to focus on the core mechanisms and then we can  
>        ^^^^
>        it what?
> > circle back to it.  
> 
> Again dax devices need to be created to full test this so I have to create
> them in some way.  I'm going to assume you mean 'labelless' and deal with
> labels later.
> 
> >   
> > > > That said, the next question, "is DCD enabling considered a toy until
> > > > the ability to allocate by tag is present?" I think yes, to the point
> > > > where old daxctl binaries should be made fail to create device instances
> > > > by forcing a tag to be selected at allocation time for Sparse DAX
> > > > Regions.  
> > > 
> > > Interesting.  I was not considering allocate by label to be a requirement
> > > but rather an enhancement.  Labels IMO are a further refinement of the
> > > memory space allocation.  I can see a very valid use case (not toy use
> > > case) where all the DCD memory allocated to a node is dedicated to a
> > > singular job and is done without tags or even ignoring tags.  Many HPC
> > > sites run with singular jobs per host.  
> > 
> > Is HPC going to use DCD? My impression is that HPC is statically
> > provisioned per node and that DCD is more targeted at Cloud use cases
> > where dynamic provisioning is common.  
> 
> I heard someone mention HPC in a call at some point.

I'd not rule it out.  Some HPC systems run very mixed workloads in parallel
so would benefit form Dynamic capacity - though maybe not with the same
rate of change as cloud workloads.

> 
> >   
> > > > The last question is whether *writable* tags are needed to allow for
> > > > repurposing memory allocated to a host without needing to round trip it
> > > > through the FM to get it re-tagged. While that is something the host and
> > > > orchestrator can figure out on their own, it looks like a nice to have
> > > > until the above questions are answered.  
> > > 
> > > Needed?  No.  Of course not.  As you said the orchestrator software can
> > > keep iterating with the FM until it gets what it wants.  It was you who
> > > had the idea of a writable labels and I agreed.  
> > 
> > Yeah, it was an idea for how to solve the problem of repurposing tag
> > without needing to round trip with the FM.
> >   
> > > "Seemed like a good idea at the time..."  ;-)
> > > 
> > > As I have reviewed and rewritten this message I worry that writable labels
> > > are a bad idea.  Interleaving will most likely depend on grouping extent
> > > tags into the CXL/DAX extent.  With this in mind adjusting extents is
> > > potentially going to require an FM interaction to get things set up
> > > anyway.
> > > 
> > > 	[Again re-reading my message I thought of another issue.  What
> > > 	happens if the user decides to change the label on an extent after
> > > 	some dax device with the old label?  That seems like an additional
> > > 	complication which is best left out by not allowing extent labels
> > > 	to be writable.]  
> > 
> > At least for this point extents can not be relabeled while allocated to
> > an instance.  
> 
> Sure but is having writeable labels worth this extra complexity?

No. Or not yet anyway.


> 
> > 
> > [..]  
> > > My current view is:
> > > 	1) No.  Current dax devices can be defined as 'no label'
> > > 	2) I'm not sure.  I can see both ways having benefits.

> 2) What does 'no dax device label' mean?
> 		a) any extent label
> 		b) no extent label
(that bit got cropped)

Option b seems something we can support for ever.  Not sure that works
for option a.

> > > 	3) No I think the ROI is not worth it.
> > > 	4) The use of 'any extent label' in #2 means that available size
> > > 	   retains it's meaning for no label dax devices.  Labeled dax
> > > 	   devices would require a future enhancement to size information.  
> > 
> > If the ABI is going to change in the future I don't want every debug
> > session to start with "which version of daxctl were you using", or "do
> > your scripts comprehend Sparse DAX Regions?".  
> 
> Well then we are stuck.  Because at a minimum they will have to understand
> Sparse DAX regions.  cxl create-region needs a new type to create such
> regions.
> 
> I envisioned an ABI *extension* not change.  The current ABI supports dax
> devices without a tag.  Even with DCD no tag is possible.  Unless you want
> to restrict it, which it sounds like you do?
> 
> I'm ok with that but I know of at least 1 meeting where it was
> emphatically mentioned that tags are _not_ required.  So I'd like some
> community members to chime in here if requiring tags is ok.

They are definitely not required and I don't think we want to make
it a Linux requirement that tags are needed.


> 
> >
> > This stance is motivated
> > by having seen the problems that the current ABI causes for people that want
> > to do things like mitigate the "noisy neighbor" phenomenon in memory
> > side caches.  
> 
> Does a dax device need specific placement within the region?  That sounds
> like control at the extent layer when the extent is mapped into the
> region.
> 
> The mapping store interface does need to be resolved for DCD.  I could
> envision the ability for user space to create extents...  Are you thinking
> the same thing?
> 
> Conceptually from a top down approach _any_ dax region could be a sparse
> dax region if I get what you are driving at?  Not just DCD?  In that case
> extent creation is even more complicated in the DCD case.

For now at least I'd push any clever noisy neighbour mess on to the
Fabric manager once we have tags.  Not sure the OS even has the visibility to
do this sort of fine tuning.  We could provide it of course, but that's
a whole level of system description that we don't have today.

> 
> > The allocation ABI is too simple and DCD seems to need
> > more.  
> 
> Are you advocating for an ABI which requires dax devices to be labeled?
> It sounds like you don't want the current tool set to work on sparse dax
> regions.  Is that correct?  I'm ok with that but I don't think a specific
> check in the kernel is the proper way to do that.  Current dax devices are
> unlabled.  So I envisioned them being supported with the current ABI.
> 
> > 
> > The kernel enforced requirement for Sparse DAX Region aware tooling just
> > makes it easier on us to maintain. If it means waiting until we ahve
> > agreement on the allocation ABI I think that's a simple release valve.  
> 
> These statements imply to me you have additional requirements for this ABI
> beyond what DCD does.  I've tried to make the dax layer DCD/CXL agnostic.
> But beyond having the concept of region extents which are labeled and
> matched to dax devices based on that label; what other requirements on dax
> to region space allocations are there?
> 
> > 
> > The fundamental mechanisms can be reviewed in the meantime.  
> 
> Sure,
> Ira
> 


