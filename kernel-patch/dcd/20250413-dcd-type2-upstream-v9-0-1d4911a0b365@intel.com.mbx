From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from mgamail.intel.com (mgamail.intel.com [192.198.163.7])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id CB07E14EC73
	for <nvdimm@lists.linux.dev>; Sun, 13 Apr 2025 22:51:58 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=fail smtp.client-ip=192.198.163.7
ARC-Seal: i=2; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1744584720; cv=fail; b=kFzFnadhXAq/C5vkzW0SBgHIXJpJIEnV+7UxtrB6yvXRvcO7ZP9/EBgppUjnOD/5yW0BQNhOYjVMEtSUZI9qFEqZW5F9QtEonFMthbr25qQTXSgAXzoJnRcBEHYitX9Nrky99TSqq1KfcFIXgLzL+rfSiAyxJBdoI3tXMVrL26Y=
ARC-Message-Signature: i=2; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1744584720; c=relaxed/simple;
	bh=kuFpqRxuP9q/teSWR7hnUn/oSHfdB2w/5nTQSy0Kb50=;
	h=From:Subject:Date:Message-ID:Content-Type:To:CC:MIME-Version; b=oYh3BsdKr3guAwse28ffi15FO+qSG2ay332UbQSF9AJeAnQEt7F0oiyU6vq8BoMXr/1j5iKf0lj9EtBOFOdkbjrYnXQ/Ui8+Bt6tgwuk4Jv45o6vrvL/Nl1ngZQ8fWo3C1aQFHih5+mvo0JHwgO3pgzo0RROLo8DYct87oAC5cI=
ARC-Authentication-Results: i=2; smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=intel.com; spf=pass smtp.mailfrom=intel.com; dkim=pass (2048-bit key) header.d=intel.com header.i=@intel.com header.b=jOQalkqJ; arc=fail smtp.client-ip=192.198.163.7
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=intel.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=intel.com
Authentication-Results: smtp.subspace.kernel.org;
	dkim=pass (2048-bit key) header.d=intel.com header.i=@intel.com header.b="jOQalkqJ"
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1744584718; x=1776120718;
  h=from:subject:date:message-id:content-transfer-encoding:
   to:cc:mime-version;
  bh=kuFpqRxuP9q/teSWR7hnUn/oSHfdB2w/5nTQSy0Kb50=;
  b=jOQalkqJtTKbdzvxSWvJ3Gz0MqeYStvqK442Rrpg8rl7rFGt0/vQq/Tj
   g12LcYQnbCOA0o+CTXxfc3PzIbRNFBjgdAik+eO++37JpbHexwoPzZYT5
   3vI3qby97oFCLke12/9QhVQ85ABSvQ8DhY8yj/1+PCltBT3rZBkGQLCCE
   7OK1XF40zDz0yZTsHNia9mQ6KZRt5Yw+t9QKIVVFZT3h40dyS4JHIOKwj
   UjGuUIDHSRjFnvvqP4AdmFpkd220ONQ6Ct6cF8SoFiRdxkKJ45W8nZmWI
   +pu7mdwW2tIsBMu9zIDBbDQ3K8bo9EnG1bbcTGWTzq36WlMDftjj6iXQ3
   A==;
X-CSE-ConnectionGUID: ks9EJvVNQwWefJzdev4U2w==
X-CSE-MsgGUID: wecujQ00QIa9/WgfDbMV2A==
X-IronPort-AV: E=McAfee;i="6700,10204,11402"; a="71431107"
X-IronPort-AV: E=Sophos;i="6.15,211,1739865600"; 
   d="scan'208";a="71431107"
Received: from fmviesa005.fm.intel.com ([10.60.135.145])
  by fmvoesa101.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 13 Apr 2025 15:51:58 -0700
X-CSE-ConnectionGUID: n/6Mb6LkQzKzRIU5MfPMTg==
X-CSE-MsgGUID: ik/5wCnGSXOsshYJtf6uow==
X-ExtLoop1: 1
X-IronPort-AV: E=Sophos;i="6.15,211,1739865600"; 
   d="scan'208";a="134405541"
Received: from orsmsx901.amr.corp.intel.com ([10.22.229.23])
  by fmviesa005.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 13 Apr 2025 15:51:58 -0700
Received: from ORSMSX901.amr.corp.intel.com (10.22.229.23) by
 ORSMSX901.amr.corp.intel.com (10.22.229.23) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.2.1544.14; Sun, 13 Apr 2025 15:51:57 -0700
Received: from ORSEDG602.ED.cps.intel.com (10.7.248.7) by
 ORSMSX901.amr.corp.intel.com (10.22.229.23) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.2.1544.14 via Frontend Transport; Sun, 13 Apr 2025 15:51:57 -0700
Received: from NAM11-BN8-obe.outbound.protection.outlook.com (104.47.58.168)
 by edgegateway.intel.com (134.134.137.103) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.44; Sun, 13 Apr 2025 15:51:56 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector10001; d=microsoft.com; cv=none;
 b=MHUMA3fbTTpVBrvHgOtFjNZM5JH3z1K6v2eoASzDGK/Nhc4gCLMNnCWGKStweUHFMXwawT3VLptorVBwzMjyLLa96dEenvnNoaqNQav3gIY5NdPVPtZOZQBX5FtcJ1EbaDPP7Im1m0zmeKTtgBa11wIt0Wa8OSJck7W+FmjNiZqmzYy/q/BTB7AT/LfFQxFv0REXnbRLZvzLP+n5zisPa1r14p0Q3REJeZ7XL0XdfJPcna1NbtVb1Y3Aqkhahla2oe/D+YFn9mUu1Dy+8XRLftdW28nDBmU0zkOYyjz4hsn/WNmGzYZc8jGrTKuPtJjXAEkylhRPzi+820ASYRtuow==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector10001;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=ISPmh7gnXNbNyw58K3xu16xeaXHsIHXfX8cJQttIzQQ=;
 b=py+q3d/TMC2LI7rm5fRkjgODxvH4RWRyGNREJ6B4UfdIDYFSgoSidT63AgrYZwxjbCk22XUPc8Iz5oj/jj+wPzx7pU+k2nYnoMl/2ejM81ETtlAvYdB8BnRN/PaCpam4lL/sGj5dr/GT7Ps+MWFlvwsHytq9hsEsd5zUCtRhCMnrWrdwSkkxKtmqc4+TiaepQHHp+osfhdPkdR1WpY04p7EvltdSNWF4HTmj3VTGHLxyzsuuVLOdk/N9sJubJwa/uE/cZ97jAg83810kf2x5mqQGXrXZkezVNttriTnqkc8oIt+Eg45bs7TfOGE8R21UgGJ32eL9mEYHObk2MItIrw==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from MW4PR11MB6739.namprd11.prod.outlook.com (2603:10b6:303:20b::19)
 by DM4PR11MB6042.namprd11.prod.outlook.com (2603:10b6:8:61::18) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.8632.28; Sun, 13 Apr
 2025 22:51:42 +0000
Received: from MW4PR11MB6739.namprd11.prod.outlook.com
 ([fe80::a7ad:a6e8:fced:3f24]) by MW4PR11MB6739.namprd11.prod.outlook.com
 ([fe80::a7ad:a6e8:fced:3f24%4]) with mapi id 15.20.8606.033; Sun, 13 Apr 2025
 22:51:42 +0000
From: Ira Weiny <ira.weiny@intel.com>
Subject: [PATCH v9 00/19] DCD: Add support for Dynamic Capacity Devices
 (DCD)
Date: Sun, 13 Apr 2025 17:52:08 -0500
Message-ID: <20250413-dcd-type2-upstream-v9-0-1d4911a0b365@intel.com>
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: 7bit
X-B4-Tracking: v=1; b=H4sIABhA/GcC/4XQzU7DMAwH8FdBPRNkO4nTcuI9EId8uKwSdFNbK
 qZp704yCVZKgaMj/3+2c6pGGToZq/ubUzXI3I3dvs9Fc3tTxZ3vn0V1KdcVAWlgMCrFpKbjQUi
 9HcZpEP+qICa0LRNym6ocDH4UFQbfx12Jfu8uDYdB2u79MvXxKde7bpz2w/GyxIzl9c95MypQD
 gNrg8GLNQ9dP8nLXdxf9Bw1oOn3aHABIDFpJruIlk1m+n86ZaJ1BqJx4hrkNaE/CQM18iahywG
 xCQ3H4Dm5NWG+CARwm4TJRCRGERZJktaEXRDUbBI2E7XTTQzsonZmTfCVQLCbBBfCRtd6QgOtr
 Am3JLYPcZmw7GsjzCHqH99ZXwlC2CTqsgVSbcmCMQBL4nw+fwCYopHW5QIAAA==
X-Change-ID: 20230604-dcd-type2-upstream-0cd15f6216fd
To: Dave Jiang <dave.jiang@intel.com>, Fan Ni <fan.ni@samsung.com>, "Jonathan
 Cameron" <Jonathan.Cameron@huawei.com>
CC: Dan Williams <dan.j.williams@intel.com>, Davidlohr Bueso
	<dave@stgolabs.net>, Alison Schofield <alison.schofield@intel.com>, "Vishal
 Verma" <vishal.l.verma@intel.com>, Ira Weiny <ira.weiny@intel.com>,
	<linux-cxl@vger.kernel.org>, <nvdimm@lists.linux.dev>,
	<linux-kernel@vger.kernel.org>, Li Ming <ming.li@zohomail.com>
X-Mailer: b4 0.15-dev-c25d1
X-Developer-Signature: v=1; a=ed25519-sha256; t=1744584735; l=13223;
 i=ira.weiny@intel.com; s=20221211; h=from:subject:message-id;
 bh=kuFpqRxuP9q/teSWR7hnUn/oSHfdB2w/5nTQSy0Kb50=;
 b=tcHqaJWGAGfUXu6OPnVtDlvMkUwAG0Md7xx7heo14aGCJN2C0fNqTcbROJ4HszIWBpGJKed2/
 cRnNr+1JM9sD4Ndu5286EHNyTYpN1MBtvDoLRFtn6ozUUkZVYAsz9BH
X-Developer-Key: i=ira.weiny@intel.com; a=ed25519;
 pk=noldbkG+Wp1qXRrrkfY1QJpDf7QsOEthbOT7vm0PqsE=
X-ClientProxiedBy: MW4PR03CA0227.namprd03.prod.outlook.com
 (2603:10b6:303:b9::22) To MW4PR11MB6739.namprd11.prod.outlook.com
 (2603:10b6:303:20b::19)
Precedence: bulk
X-Mailing-List: nvdimm@lists.linux.dev
List-Id: <nvdimm.lists.linux.dev>
List-Subscribe: <mailto:nvdimm+subscribe@lists.linux.dev>
List-Unsubscribe: <mailto:nvdimm+unsubscribe@lists.linux.dev>
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: MW4PR11MB6739:EE_|DM4PR11MB6042:EE_
X-MS-Office365-Filtering-Correlation-Id: 3815a3fe-7341-4a52-397d-08dd7addc1ef
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;ARA:13230040|376014|1800799024|366016;
X-Microsoft-Antispam-Message-Info: =?utf-8?B?SHB2cDRGNlFjMlFpV09zOHFid3BCcGliRWFYbnY5WVdKdmYrRUNkREhTaGFV?=
 =?utf-8?B?Ni8zcUlLK0xnYUJZTjdjdUJ5WnJVQ2VpQVFYRFM2Y0VZRDdVK2lvVUY1WjNG?=
 =?utf-8?B?YnJqc1JpUjdRN0xLaG1jTjF1RlBtMU1RT0lYOS9ub1VFakNaWVU5REZheTNl?=
 =?utf-8?B?clpEbzdSUG5NUlBMN1NkTGw4Y3ZJSGlZMWNWYUxaVURRTzl1TDVhVzV3NkJZ?=
 =?utf-8?B?NjhpekM1NmlRUzB4MkV1NTUzS0dSQythS0ZIL05HeVAvcVFRcUhTS05LWHdn?=
 =?utf-8?B?VkY1dEZkQ2QycUpIaC8zREhTWDB3Y1RCdGlyamRGWVBKdjV1MDdNaktHYkRH?=
 =?utf-8?B?MmZYOEYvUC9aY3J1MDJuRy9LNnQ0V0hWelJHWkszdHBSTVFOR3RKYURPWER4?=
 =?utf-8?B?bW12S3h6V0pBcDZrUGhKMFZlYndqOU91SmpJKzJzZXo2SklIdkIzc1JuZ3pQ?=
 =?utf-8?B?OVJNVHg0ZjdvL1QxcUgwVVhsRldvTkI3OGdYeUw4QmdoWGNDRGo5Q2tGcTBD?=
 =?utf-8?B?cDhKUWNlY2d5K0Y5NUtXaUpud1liTDhuMkxLZWxwbWVPVmxTczk2TWhDWk1y?=
 =?utf-8?B?SmRZNmFVM29ZN2pDaTRkRlZrbUxiTjUrekxwL0QzN0dRbm1qMWhwUkJ4ZkR0?=
 =?utf-8?B?UkdZQlIyQ2s2UW1YaUlQbCtpYTNEemVNS0ZiK2gzMTlQWGc3aHVqVHBGZUUw?=
 =?utf-8?B?dXQ0aUpKZ1hZOXRCOS9jaWJGUW42YitpMXVWa3o3cUlMUHh5cEdoVnJ0cGtZ?=
 =?utf-8?B?QSsvd2RuMXpMZ1RTK2tnM2VWeWtjVjVWdUNmRXRJWlczNDZ5Z0JWdjZHeERw?=
 =?utf-8?B?c0JHc3BiU2ZLZElqR1BVQTFLTFVnZnJhVHdwTkNQckw3NkhoeFpHOGJ3dmxo?=
 =?utf-8?B?ZlhIaUVRNHNjazFhd3BqaC9rQWRoVTRqWlA0MjhYRmFVQXJVczBUeGczUnp5?=
 =?utf-8?B?TzJnOXVvUDN2RTdtanp1VHJ3VEZpNkVRVzlub05TcFhBNHVZMmJuMm9mc09j?=
 =?utf-8?B?WFNXUDFKUjdqY3JKbDRWOUZPcnVhMU9tUnV0NFhKWVNZSTB2aWtYQnZoWmN5?=
 =?utf-8?B?eHA2VEFsNWt1dHhEQTU0Njd5N05URUVGdmF2L1hrU2xDZFpabnZRbmdRODRz?=
 =?utf-8?B?djB6K0dUdkVrT1lpbGU4d1N3QXlkWEovNlhnTU1idWZnTXYxdUQvZ0ZaZC9N?=
 =?utf-8?B?Sm5pVGtUNjdSUG9LTkM0ellnNVpjNkVSSVVzWTdZUkFuNHUvaUJqRlI2ZDZa?=
 =?utf-8?B?UUUralIrdGphb3Q2clorbXNaT0RnVjcrTktEWjZicDFYNWxuUm5TRUhDSnp1?=
 =?utf-8?B?dW1Hck96YkVTWmQ4NVFlM3FTenNtNW5kRm5BMWRzZFQvWjhUc0VHV3VDVVoz?=
 =?utf-8?B?S3VOUmJqWEJSTVNvQzlXcVI4OW5VTG0xcFRiNmpuVGgrb0JKc0xKZ3IxN2pl?=
 =?utf-8?B?YVNIR0pkQ1lFSEpZUlp0K1Y4bVg4VTFNNHRFVS8vdmlPdGdaNlZ3Y001MGp0?=
 =?utf-8?B?WTdYbWt0aEl1WHhGZXZHM09hc3A5NWxsYXBWUTJNbElLdG9kUHdIdEhUeDg1?=
 =?utf-8?B?bmRWOXY1UDFaMWQ0eDBtQ0RXLzNFNU1qS0s1aGZvQnRSUUNweGw4UDJZQnlo?=
 =?utf-8?B?SjUzcnRCc1lDZi9rQ2JHVXM5NjN2ckxqb1BVM1pjZEhQcnVtYk5FUnFGWnlh?=
 =?utf-8?B?bUFtY2tNVkIzWkkwMElSUWlENDlIa3VyNGIrd09wM2tjWVl4THp1MUhCZUFp?=
 =?utf-8?B?M2Era0l6dFl4NUM1UEtIVUNsR0duZlFpVlE1RjBxUXZjVXc3eWxhU2lwckoy?=
 =?utf-8?B?MlhEeVNKdkcxMnI1RE15b0dnb0dYTEd3SERGdlBTanZ6eVRaVlF4MjRZYzlw?=
 =?utf-8?Q?8JuHswnq+VFpa?=
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:MW4PR11MB6739.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230040)(376014)(1800799024)(366016);DIR:OUT;SFP:1101;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?utf-8?B?RW80QWNFeUtCa0NrOGxEY25wbEZOYTR2L3BtdU15QlR5cUVGNmJ6b0xZRTBz?=
 =?utf-8?B?WmhDVFVBb1F0QTNNYzJuaUJPTmFSNit5VmUwTURWRDhwMklCTGJnN2ZjdDlD?=
 =?utf-8?B?K2Y2TjNSSUozT1Y3aE9mNTlxOFcwbUFtUXg4QTloR1FhUW40MWZEZ2ZGVkNz?=
 =?utf-8?B?c0pnNFl5aDFyRmgxN0NVemU1Qzg3aUcxSnRBQ3lYSjdOeUlsUDkzUTNsaGVQ?=
 =?utf-8?B?RzlVdjVyWlVkdHBwK3RkYm9senFvSTBMaXVCN1ltU1FLSXNSMXVNMW5tSmdJ?=
 =?utf-8?B?bm9tS3J5bGpkTE5STlQyNkp6SGxpVmVzTE1KUVBzKzE1NG9GVndJZGp6TW5y?=
 =?utf-8?B?VS80dWtNbWpxWVpQWTFWZ1JyYVdYL0Y1R3NRSTh2UCtsb2Zpcit5eGZSY0w2?=
 =?utf-8?B?MGRqTC9OUXcvMmFsQ2VGMDMzWXkzQTNNK1kwVDdHWHNQbFhENU1JUERSc0th?=
 =?utf-8?B?Tkt3dHI5S0NzTEk3VUtiUnNsbzJkSkh5S0NNeC9WTFJiYXZxalNCMjdjNlZC?=
 =?utf-8?B?bUQwTXhWbkVzOVBVN0t2R1VuWVpUUGJtNmdqWTFmdnN4LzFWYUpPbFBJaUV6?=
 =?utf-8?B?Yy9kT2RJd3FTTjlCSHgvekJsUXBoYlhUanp4Sm9KWDNjRDBzNW1PK1l2VTI1?=
 =?utf-8?B?cEFWNVFlV2YwNUlTZm9ySEE4VnpIOXowcUpMS0pObG9hakYxaTlJRWY2SGEy?=
 =?utf-8?B?VG4rajE3Q1B1Ty95R1k0NEJ0S2t3VTIySkd4VWttdDFYZTNrNmhLZ1RPZ3k5?=
 =?utf-8?B?TnRGemFFenVONjZmT2dvYnJ2QmIwSkpWSmdXbis5VDVrbzAzOFJXZGtlTk9Z?=
 =?utf-8?B?b3d6V1ROdit3RUJubGxqUzlVSThkMEJrT2JLZTV0WTNFbHc4WlFjV2EzSzM5?=
 =?utf-8?B?dDhhbEVkeUphK3k0V1VobGRsbDAwaHB5am5YNUpzaTNlS2ZZeVg1UUJZd2hY?=
 =?utf-8?B?QnpFb1pHZ0EyUlRHU1RLREdCUFBtZTNHNXlic1JWL1ZXMnlUY29JblBFWGQr?=
 =?utf-8?B?ZDlkVXNzcUdGeEYwUUJIWVhxYzdGZWI1MlNaQ2dlRFdjbGxaTVY0U1FOakVN?=
 =?utf-8?B?Q0VQSDFuQzBDM01XZ2pPRUtYREpsZEM4WXFqUXpYZGVYL0tVMEdFdzFHYkJp?=
 =?utf-8?B?L2kyekZldXBBL3hkRURPZHJWNnpuaENXZndBN0hZc2plNFF4c25xdCtuUUEv?=
 =?utf-8?B?N3dudVVrN3IrYWpGSnRraWUzYW5LdXVVbk9qK0Z5SDc2UFpoVVNGNVA3SjFO?=
 =?utf-8?B?azJBTkw3MlhvUTZGSXVBcVVRRUN1OE5FNjdqbW5ZNHdtMDllajFSeTE4Uk1r?=
 =?utf-8?B?MWkrK1lDcGdpTHVxSjRnOHZkbkFQa3BnZmJ6bVNVUE9XN21ibEdFSWhRUTBB?=
 =?utf-8?B?c1lZbEx0b0o4TEk0M0dPRnhBbDJKaW5qMW1MUUp0S0dVUnl2UHFIWkh1NGhv?=
 =?utf-8?B?RHRJNVE2V0UyOVZXVS8vTVFJM0s3MytTUXJId2pmQU91cGxLUWpKMDVxdm11?=
 =?utf-8?B?ZmVCWW5sQWdGWklHRVdPMElMZkRjcHAxQWpqM0lEOVJGa2hnYlZLNFllNFhw?=
 =?utf-8?B?Zkk4eG9FQUI5M2Y4RXV1UStHVStvNVNrNDFaYnRRQzlXVkN2Z1dhbjBwZ3F3?=
 =?utf-8?B?dkdYdHJSS3J6TCtsaTlGVjJGcGRMM0QzSVQ4b1EwUmJuQWhRWTlHSjFTSE40?=
 =?utf-8?B?WlEwcisxQnRjSGtORkZCeU9xRFc2VURkMTVBZzBKZnVxOVVHRlNlcXliU3ow?=
 =?utf-8?B?REdsN0c4OEdjYW03VUlUZGJQdzl4UFlxWG80ZmZzRGdUWk1aNkxtRU1ad3R0?=
 =?utf-8?B?eXl1Mm1leFQzTHZFMmRMTEptY253K01BeVlVTGJuV2oySWY3QXhINHdUTHlX?=
 =?utf-8?B?aDAzbzh2TWl1U0s0ZEZvS1lPaWNJM0N0TWRTU2phVFhkK1FLTHBHcmZRRUE4?=
 =?utf-8?B?cWlFdmJTWFNZSWJqZHBkSk9TK2FjaGpTZU1pSTVKMnU5RWFyODBMZGlyUjNh?=
 =?utf-8?B?cllJZVhocDAyQy8rZzRIM0M0QnFRdWdUc1J6Qkx1RHlFaFVZRmUrUk9adnh4?=
 =?utf-8?B?ZEVYVGZHT0FNYXl5RVI5SWl5Uk45UGVhUGlYdXdtd2x5OUhmMk9NM1dIRy9J?=
 =?utf-8?Q?x1uhnUmJDfMfx0GanvAWDaGGm?=
X-MS-Exchange-CrossTenant-Network-Message-Id: 3815a3fe-7341-4a52-397d-08dd7addc1ef
X-MS-Exchange-CrossTenant-AuthSource: MW4PR11MB6739.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 13 Apr 2025 22:51:42.1339
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: yPPCG1n/52x+PlZliUkJiyPAb06aee4aL7wg1e3DDLqIInsfF68Bc1xN5vQX/Fv8LY4kyVrZHKXUB2aLdg2xSg==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: DM4PR11MB6042
X-OriginatorOrg: intel.com
Status: RO
X-Status: A
Content-Length: 12937
Lines: 288

A git tree of this series can be found here:

	https://github.com/weiny2/linux-kernel/tree/dcd-v6-2025-04-13

This is now based on 6.15-rc2.

Due to the stagnation of solid requirements for users of DCD I do not
plan to rev this work in Q2 of 2025 and possibly beyond.

It is anticipated that this will support at least the initial
implementation of DCD devices, if and when they appear in the ecosystem.
The patch set should be reviewed with the limited set of functionality in
mind.  Additional functionality can be added as devices support them.

It is strongly encouraged for individuals or companies wishing to bring
DCD devices to market review this set with the customer use cases they
have in mind.

Series info
===========

This series has 2 parts:

Patch 1-17: Core DCD support
Patch 18-19: cxl_test support

Background
==========

A Dynamic Capacity Device (DCD) (CXL 3.1 sec 9.13.3) is a CXL memory
device that allows memory capacity within a region to change
dynamically without the need for resetting the device, reconfiguring
HDM decoders, or reconfiguring software DAX regions.

One of the biggest anticipated use cases for Dynamic Capacity is to
allow hosts to dynamically add or remove memory from a host within a
data center without physically changing the per-host attached memory nor
rebooting the host.

The general flow for the addition or removal of memory is to have an
orchestrator coordinate the use of the memory.  Generally there are 5
actors in such a system, the Orchestrator, Fabric Manager, the Logical
device, the Host Kernel, and a Host User.

An example work flow is shown below.

Orchestrator      FM         Device       Host Kernel    Host User

    |             |           |            |               |
    |-------------- Create region ------------------------>|
    |             |           |            |               |
    |             |           |            |<-- Create ----|
    |             |           |            |    Region     |
    |             |           |            |(dynamic_ram_a)|
    |<------------- Signal done ---------------------------|
    |             |           |            |               |
    |-- Add ----->|-- Add --->|--- Add --->|               |
    |  Capacity   |  Extent   |   Extent   |               |
    |             |           |            |               |
    |             |<- Accept -|<- Accept  -|               |
    |             |   Extent  |   Extent   |               |
    |             |           |            |<- Create ---->|
    |             |           |            |   DAX dev     |-- Use memory
    |             |           |            |               |   |
    |             |           |            |               |   |
    |             |           |            |<- Release ----| <-+
    |             |           |            |   DAX dev     |
    |             |           |            |               |
    |<------------- Signal done ---------------------------|
    |             |           |            |               |
    |-- Remove -->|- Release->|- Release ->|               |
    |  Capacity   |  Extent   |   Extent   |               |
    |             |           |            |               |
    |             |<- Release-|<- Release -|               |
    |             |   Extent  |   Extent   |               |
    |             |           |            |               |
    |-- Add ----->|-- Add --->|--- Add --->|               |
    |  Capacity   |  Extent   |   Extent   |               |
    |             |           |            |               |
    |             |<- Accept -|<- Accept  -|               |
    |             |   Extent  |   Extent   |               |
    |             |           |            |<- Create -----|
    |             |           |            |   DAX dev     |-- Use memory
    |             |           |            |               |   |
    |             |           |            |<- Release ----| <-+
    |             |           |            |   DAX dev     |
    |<------------- Signal done ---------------------------|
    |             |           |            |               |
    |-- Remove -->|- Release->|- Release ->|               |
    |  Capacity   |  Extent   |   Extent   |               |
    |             |           |            |               |
    |             |<- Release-|<- Release -|               |
    |             |   Extent  |   Extent   |               |
    |             |           |            |               |
    |-- Add ----->|-- Add --->|--- Add --->|               |
    |  Capacity   |  Extent   |   Extent   |               |
    |             |           |            |<- Create -----|
    |             |           |            |   DAX dev     |-- Use memory
    |             |           |            |               |   |
    |-- Remove -->|- Release->|- Release ->|               |   |
    |  Capacity   |  Extent   |   Extent   |               |   |
    |             |           |            |               |   |
    |             |           |     (Release Ignored)      |   |
    |             |           |            |               |   |
    |             |           |            |<- Release ----| <-+
    |             |           |            |   DAX dev     |
    |<------------- Signal done ---------------------------|
    |             |           |            |               |
    |             |- Release->|- Release ->|               |
    |             |  Extent   |   Extent   |               |
    |             |           |            |               |
    |             |<- Release-|<- Release -|               |
    |             |   Extent  |   Extent   |               |
    |             |           |            |<- Destroy ----|
    |             |           |            |   Region      |
    |             |           |            |               |

Implementation
==============

This series requires the creation of regions and DAX devices to be
closely synchronized with the Orchestrator and Fabric Manager.  The host
kernel will reject extents if a region is not yet created.  It also
ignores extent release if memory is in use (DAX device created).  These
synchronizations are not anticipated to be an issue with real
applications.

Only a single dynamic ram partition is supported (dynamic_ram_a).  The
requirements, use cases, and existence of actual hardware devices to
support more than one DC partition is unknown at this time.  So a less
complex implementation was chosen.

In order to allow for capacity to be added and removed a new concept of
a sparse DAX region is introduced.  A sparse DAX region may have 0 or
more bytes of available space.  The total space depends on the number
and size of the extents which have been added.

It is anticipated that users of the memory will carefully coordinate the
surfacing of capacity with the creation of DAX devices which use that
capacity.  Therefore, the allocation of the memory to DAX devices does
not allow for specific associations between DAX device and extent.  This
keeps allocations of DAX devices similar to existing DAX region
behavior.

To keep the DAX memory allocation aligned with the existing DAX devices
which do not have tags, extents are not allowed to have tags in this
implementation.  Future support for tags can be added when real use
cases surface.

Great care was taken to keep the extent tracking simple.  Some xarray's
needed to be added but extra software objects are kept to a minimum.

Region extents are tracked as sub-devices of the DAX region.  This
ensures that region destruction cleans up all extent allocations
properly.

The major functionality of this series includes:

- Getting the dynamic capacity (DC) configuration information from cxl
  devices

- Configuring a DC partition found in hardware.

- Enhancing the CXL and DAX regions for dynamic capacity support
	a. Maintain a logical separation between hardware extents and
	   software managed extents.  This provides an abstraction
	   between the layers and should allow for interleaving in the
	   future

- Get existing hardware extent lists for endpoint decoders upon region
  creation.

- Respond to DC capacity events and adjust available region memory.
        a. Add capacity Events
	b. Release capacity events

- Host response for add capacity
	a. do not accept the extent if:
		If the region does not exist
		or an error occurs realizing the extent
	b. If the region does exist
		realize a DAX region extent with 1:1 mapping (no
		interleave yet)
	c. Support the event more bit by processing a list of extents
	   marked with the more bit together before setting up a
	   response.

- Host response for remove capacity
	a. If no DAX device references the extent; release the extent
	b. If a reference does exist, ignore the request.
	   (Require FM to issue release again.)
	c. Release extents flagged with the 'more' bit individually as
	   the specification allows for the asynchronous release of
	   memory and the implementation is simplified by doing so.

- Modify DAX device creation/resize to account for extents within a
  sparse DAX region

- Trace Dynamic Capacity events for debugging

- Add cxl-test infrastructure to allow for faster unit testing
  (See new ndctl branch for cxl-dcd.sh test[1])

- Only support 0 value extent tags

Fan Ni's upstream of Qemu DCD was used for testing.

Remaining work:

	1) Allow mapping to specific extents (perhaps based on
	   label/tag)
	   1a) devise region size reporting based on tags
	2) Interleave support

Possible additional work depending on requirements:

	1) Accept a new extent which extends (but overlaps) already
	   accepted extent(s)
	2) Rework DAX device interfaces, memfd has been explored a bit
	3) Support more than 1 DC partition

[1] https://github.com/weiny2/ndctl/tree/dcd-region3-2025-04-13

---
Changes in v9:
- djbw: pare down support to only a single DC parition
- djbw: adjust to the new core partition processing which aligns with
  new type2 work.
- iweiny: address smaller comments from v8
- iweiny: rebase off of 6.15-rc1
- Link to v8: https://patch.msgid.link/20241210-dcd-type2-upstream-v8-0-812852504400@intel.com

---
Ira Weiny (19):
      cxl/mbox: Flag support for Dynamic Capacity Devices (DCD)
      cxl/mem: Read dynamic capacity configuration from the device
      cxl/cdat: Gather DSMAS data for DCD partitions
      cxl/core: Enforce partition order/simplify partition calls
      cxl/mem: Expose dynamic ram A partition in sysfs
      cxl/port: Add 'dynamic_ram_a' to endpoint decoder mode
      cxl/region: Add sparse DAX region support
      cxl/events: Split event msgnum configuration from irq setup
      cxl/pci: Factor out interrupt policy check
      cxl/mem: Configure dynamic capacity interrupts
      cxl/core: Return endpoint decoder information from region search
      cxl/extent: Process dynamic partition events and realize region extents
      cxl/region/extent: Expose region extent information in sysfs
      dax/bus: Factor out dev dax resize logic
      dax/region: Create resources on sparse DAX regions
      cxl/region: Read existing extents on region creation
      cxl/mem: Trace Dynamic capacity Event Record
      tools/testing/cxl: Make event logs dynamic
      tools/testing/cxl: Add DC Regions to mock mem data

 Documentation/ABI/testing/sysfs-bus-cxl |  100 ++-
 drivers/cxl/core/Makefile               |    2 +-
 drivers/cxl/core/cdat.c                 |   11 +
 drivers/cxl/core/core.h                 |   33 +-
 drivers/cxl/core/extent.c               |  495 +++++++++++++++
 drivers/cxl/core/hdm.c                  |   13 +-
 drivers/cxl/core/mbox.c                 |  632 ++++++++++++++++++-
 drivers/cxl/core/memdev.c               |   87 ++-
 drivers/cxl/core/port.c                 |    5 +
 drivers/cxl/core/region.c               |   76 ++-
 drivers/cxl/core/trace.h                |   65 ++
 drivers/cxl/cxl.h                       |   61 +-
 drivers/cxl/cxlmem.h                    |  134 +++-
 drivers/cxl/mem.c                       |    2 +-
 drivers/cxl/pci.c                       |  115 +++-
 drivers/dax/bus.c                       |  356 +++++++++--
 drivers/dax/bus.h                       |    4 +-
 drivers/dax/cxl.c                       |   71 ++-
 drivers/dax/dax-private.h               |   40 ++
 drivers/dax/hmem/hmem.c                 |    2 +-
 drivers/dax/pmem.c                      |    2 +-
 include/cxl/event.h                     |   31 +
 include/linux/ioport.h                  |    3 +
 tools/testing/cxl/Kbuild                |    3 +-
 tools/testing/cxl/test/mem.c            | 1021 +++++++++++++++++++++++++++----
 25 files changed, 3102 insertions(+), 262 deletions(-)
---
base-commit: 8ffd015db85fea3e15a77027fda6c02ced4d2444
change-id: 20230604-dcd-type2-upstream-0cd15f6216fd

Best regards,
-- 
Ira Weiny <ira.weiny@intel.com>


From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from mgamail.intel.com (mgamail.intel.com [192.198.163.18])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id 751F718FDA5
	for <nvdimm@lists.linux.dev>; Sun, 13 Apr 2025 22:51:59 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=fail smtp.client-ip=192.198.163.18
ARC-Seal: i=2; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1744584722; cv=fail; b=MH0aWY833bAgyAA1FPAkiBsoGrKc+2k4jp4gPIaXPIJ/52yYDtdhwj/33aDv43DGbO8sICwVKhh654tvFiY6nlQq3i0ioiTwOpjFBKNUyYD3S+q/1RwvOB8nE8YxMMQspcIWHOTocTcTMBy5VRZn2ASUp425Dw4eJRHlu7g6TpA=
ARC-Message-Signature: i=2; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1744584722; c=relaxed/simple;
	bh=yKu5GzCSwhClZskfPSul/l1KNzhV4Imp85VjVWq1kVA=;
	h=From:Date:Subject:Content-Type:Message-ID:References:In-Reply-To:
	 To:CC:MIME-Version; b=eAxEXTPb9UKKJUD/XqpdCW/mB0U2pMjTC5sFmQuk9GxoFsXE0jpNQT9lecm77p4Koa1/JHGj14ovu0Ip1n9L24nl7uV3pMQIgxSs2SkjCR4h+bdRuBz9ZyqbqZuEr6vW7BYe0+PIB/dtNfCq+zdzgj3WGTr2OJw76WcGtXoyr8Y=
ARC-Authentication-Results: i=2; smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=intel.com; spf=pass smtp.mailfrom=intel.com; dkim=pass (2048-bit key) header.d=intel.com header.i=@intel.com header.b=U0ADUzrF; arc=fail smtp.client-ip=192.198.163.18
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=intel.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=intel.com
Authentication-Results: smtp.subspace.kernel.org;
	dkim=pass (2048-bit key) header.d=intel.com header.i=@intel.com header.b="U0ADUzrF"
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1744584720; x=1776120720;
  h=from:date:subject:content-transfer-encoding:message-id:
   references:in-reply-to:to:cc:mime-version;
  bh=yKu5GzCSwhClZskfPSul/l1KNzhV4Imp85VjVWq1kVA=;
  b=U0ADUzrFS6ljStSHzzHtt4NPQwvKbqrGR5/EOaS8WjmQp8dsMfhYbpA8
   eKStF8B4wZQuF+Uh6uRReX8R9dUD3MaUp06IBpFw23IDB2Io4iL5gTJOR
   vyiJh+wvkuPgRkiciohDRgs78W5+zblCYk0vIhmQ+A01rIIp8FiHYFtNE
   gf7P0uJfpbYzt6bkq562dmq1a7ZjhEnNxHDc0zTDMlJiPo26MFlGzJHZO
   75wUzcs8PT4UReU5v/tP3Dwlf52COh0ObzMZWtD+UOdHikec+X3Bl8j9W
   RTnnyHN29jIH/Z3oJko2CtoAm/0L3tQgW8UtP4j2MZ5TsaW1vK85Pvw8M
   A==;
X-CSE-ConnectionGUID: dBRovmfaR6agA5qfOZo7Iw==
X-CSE-MsgGUID: Rjim1ztnQuu6JIONr1X6Sw==
X-IronPort-AV: E=McAfee;i="6700,10204,11402"; a="45280885"
X-IronPort-AV: E=Sophos;i="6.15,211,1739865600"; 
   d="scan'208";a="45280885"
Received: from fmviesa007.fm.intel.com ([10.60.135.147])
  by fmvoesa112.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 13 Apr 2025 15:51:59 -0700
X-CSE-ConnectionGUID: N4SWL+r6QBiYshQ4t4sEgA==
X-CSE-MsgGUID: inuCNsY4SvaZ4XrBUEuOMg==
X-ExtLoop1: 1
X-IronPort-AV: E=Sophos;i="6.15,211,1739865600"; 
   d="scan'208";a="129657424"
Received: from orsmsx902.amr.corp.intel.com ([10.22.229.24])
  by fmviesa007.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 13 Apr 2025 15:51:58 -0700
Received: from ORSMSX901.amr.corp.intel.com (10.22.229.23) by
 ORSMSX902.amr.corp.intel.com (10.22.229.24) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.2.1544.14; Sun, 13 Apr 2025 15:51:58 -0700
Received: from ORSEDG602.ED.cps.intel.com (10.7.248.7) by
 ORSMSX901.amr.corp.intel.com (10.22.229.23) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.2.1544.14 via Frontend Transport; Sun, 13 Apr 2025 15:51:57 -0700
Received: from NAM11-BN8-obe.outbound.protection.outlook.com (104.47.58.168)
 by edgegateway.intel.com (134.134.137.103) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.44; Sun, 13 Apr 2025 15:51:57 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector10001; d=microsoft.com; cv=none;
 b=khs8704fxCoppVAEvlPzgBiMVxbxiTioxn5zLThlzDm+MSLTb1qftLut4Tk6kUGPhvyzKXjrT+NLNd8ZNtbo4QQVYEwpSACqMydCBdfU99lNYxSCn/WtwqwdETH/cZAkrWn6VikzeThsm7qYHAn2nFuOryVa15lAVTiXlVXM6/7sVgiMxYR61srmcVCOMk7gvkle8lWaV6iAoI/Db9V4t23EogJaBK1R+0Ur9h7RW2PpxVgpZf6mmoC6E0QQEu4OY6zeCCJ4r6pBBrkBJDY66bP1qu7Ocsmu+YinpiPgCZzQg2EdacE20+KBSOpGgJx0EtcFyjKoAYPQiZElSTpJQg==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector10001;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=QkoHo8DOZ66Z7EiSbnZBmZz8Tw+rUGijfRBcpfBpfYU=;
 b=iM/nXwdp649Tev/uEMXzMA1tnIEOkAeRNiOuvoqeKNK+03o+SR207AfdQ6p9kKcseJnYZKXeQrQOJuVS2aDTquUUlmderPcXk8upQKWI9Gp5oh4xgckFeiDw9KHjOrxchOj6bFwWil7Zx7YN+inQ1UdxIOsDhv5MY9PsG0oEI5KqsU0XHWtFI1MX0eTgQS/KgYwZv+fRlLLLymx2ROlRBE+dwPKSIXTki8Akjs4nsxW6rb2ox7p/ABQcqqqecoF0PlwArbOQoweHigHKtJAt59obg+IfXGjNFFv4z0UtsJ+rJeAnh9PQYIHduZ3pJpCw/P7dIAnjxnlddha1bssA7g==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from MW4PR11MB6739.namprd11.prod.outlook.com (2603:10b6:303:20b::19)
 by DM4PR11MB6042.namprd11.prod.outlook.com (2603:10b6:8:61::18) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.8632.28; Sun, 13 Apr
 2025 22:51:45 +0000
Received: from MW4PR11MB6739.namprd11.prod.outlook.com
 ([fe80::a7ad:a6e8:fced:3f24]) by MW4PR11MB6739.namprd11.prod.outlook.com
 ([fe80::a7ad:a6e8:fced:3f24%4]) with mapi id 15.20.8606.033; Sun, 13 Apr 2025
 22:51:45 +0000
From: Ira Weiny <ira.weiny@intel.com>
Date: Sun, 13 Apr 2025 17:52:10 -0500
Subject: [PATCH v9 02/19] cxl/mem: Read dynamic capacity configuration from
 the device
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: 7bit
Message-ID: <20250413-dcd-type2-upstream-v9-2-1d4911a0b365@intel.com>
References: <20250413-dcd-type2-upstream-v9-0-1d4911a0b365@intel.com>
In-Reply-To: <20250413-dcd-type2-upstream-v9-0-1d4911a0b365@intel.com>
To: Dave Jiang <dave.jiang@intel.com>, Fan Ni <fan.ni@samsung.com>, "Jonathan
 Cameron" <Jonathan.Cameron@huawei.com>
CC: Dan Williams <dan.j.williams@intel.com>, Davidlohr Bueso
	<dave@stgolabs.net>, Alison Schofield <alison.schofield@intel.com>, "Vishal
 Verma" <vishal.l.verma@intel.com>, Ira Weiny <ira.weiny@intel.com>,
	<linux-cxl@vger.kernel.org>, <nvdimm@lists.linux.dev>,
	<linux-kernel@vger.kernel.org>
X-Mailer: b4 0.15-dev-c25d1
X-Developer-Signature: v=1; a=ed25519-sha256; t=1744584735; l=12514;
 i=ira.weiny@intel.com; s=20221211; h=from:subject:message-id;
 bh=yKu5GzCSwhClZskfPSul/l1KNzhV4Imp85VjVWq1kVA=;
 b=bN1/2MH5VstkPjHZQa4RmCVO2wG0EP+Ci0FetDpq9W9nIkT5q8Ja/2+TnNzC5vVldDEtCfEqr
 XNP4trGWR3FBHv9R4V5auPkBSOwcxjZlGX9mAqPB3JEccOcGuNqXI/8
X-Developer-Key: i=ira.weiny@intel.com; a=ed25519;
 pk=noldbkG+Wp1qXRrrkfY1QJpDf7QsOEthbOT7vm0PqsE=
X-ClientProxiedBy: MW4PR03CA0227.namprd03.prod.outlook.com
 (2603:10b6:303:b9::22) To MW4PR11MB6739.namprd11.prod.outlook.com
 (2603:10b6:303:20b::19)
Precedence: bulk
X-Mailing-List: nvdimm@lists.linux.dev
List-Id: <nvdimm.lists.linux.dev>
List-Subscribe: <mailto:nvdimm+subscribe@lists.linux.dev>
List-Unsubscribe: <mailto:nvdimm+unsubscribe@lists.linux.dev>
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: MW4PR11MB6739:EE_|DM4PR11MB6042:EE_
X-MS-Office365-Filtering-Correlation-Id: a10f9a32-c0d7-46cf-3d7f-08dd7addc41e
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;ARA:13230040|376014|1800799024|366016;
X-Microsoft-Antispam-Message-Info: =?utf-8?B?b3VkS2N6cUg0NUdpNFZGeGhIYXJ2eHhwOHVWWU52NGQ2MUk3UHorcmVIWVpy?=
 =?utf-8?B?d2puUGtPUFdqcnozS1V1K1M0NWtqd1lrWVg5VWk4YTlUdS9uc2RYa3MrTytH?=
 =?utf-8?B?VHRDalBBeStyaGx6TldDcnJVUVA3Z1VLdGl1SXBzOC94aDlPbEx6ZVlEejZn?=
 =?utf-8?B?eUxXU0oxWWFyMnVHQ01ldHg0UlRJZ1JLeDNTSEVBcHQ3U0V6cjFwVjdOWEhZ?=
 =?utf-8?B?TVlHcWtoNWN6b1YyR0ZrM1hIZDFrVEJFcGlKUEJTZU1oUGM3WVQzRldLU1Bl?=
 =?utf-8?B?T3BDQTdIL1d2QmFZa0YzbE1WdW8zeHEwRVIxL3RYVmV5K1VmT3cyeURidTUw?=
 =?utf-8?B?TE95N1AvVXhRWXZIVEM5WmVMVC9RbW1OM05WWmI1d001MUMzWkdZU0JyTmE3?=
 =?utf-8?B?cHJpNXNBREVxUXBEc05vUjNOeWtDUk5ic09jZFh0aWdKZDl4RTNNMnRIMHRi?=
 =?utf-8?B?SHBUUlZMd0ttajNhS01KcjJWNDdVS0U3WElQNW84QnVJbCtsekZtZzZxbVN3?=
 =?utf-8?B?UVpxZWhnVE5FdStTcmh0N3I4bmxvSUMyb1VLTzlMcVBlSElTbENuUEYyRVN6?=
 =?utf-8?B?cE1VRXVDbGFpVm9yZzBWZng5NzJPQmh0YlorNjlZd1RjZzJLVTg2VTJESTgz?=
 =?utf-8?B?RU5RMEFvQktzQWNCT3lDOTdOcEh5WW9HVlZ1bDlYQlMzalRRYTBqNkpEWkxB?=
 =?utf-8?B?OHBjU0RQOUpFVEtGSm0zenZlT2xTTGtVT0ZqNXRPR2FneWVRaHhYOHRCL2Fj?=
 =?utf-8?B?WDJKTWU2REJzY1BUZEQ0bzl2aHluNzZmbUNQSTBESi85ekEzY3BhWTBIWk82?=
 =?utf-8?B?U2wzVGN4MVRZQk1JdVJkdFBsZ1kxeFBFdDZmaGg2U0o4Q3JtQnY0SHJzOTln?=
 =?utf-8?B?RytSWnVSTGsya29BbFF2WFBVVnFhcDNONE1Nd1N1Z2hUT0IydHBEdWNyZTBF?=
 =?utf-8?B?OUtiK2djaXhCSTFoYmxVc1ZpWkZoOUlYVzhUK1BqOEgxVXY3cnBVZkhmaVFH?=
 =?utf-8?B?Smh1OG9mZzk5TUU5L2hOUDZPck0wNHBra1R4V2cxelNtVWVlY0ZvRnJ5Wmtj?=
 =?utf-8?B?Qi96eUlaNkhxZkNJQU5kT0hxV2dOM0c3N0gyOHdhWm9OeWphKzJGcXBqL01D?=
 =?utf-8?B?UVFuR1lzZThzbmFWTUl6ZFc0djE1OW9ESWhnWDNNOTg5QXgyNU9LUGk0SjZ5?=
 =?utf-8?B?SVVmR09rcUVhMHlXanZZRGFJQzVpTVlnYkZ5ek5aVjVEUlNsSHc0NXdaaHY2?=
 =?utf-8?B?K1ljVW9hSFFGeVNMUGVwYWlCcXRlV1hBMHZBNWtTR3hoZzhmYmx1SE5ySGU0?=
 =?utf-8?B?NTlDQzZVSERWYU5PamZIK2FaM0Zlc285TUs1M0dUUzVLZElZem5TVERqcmNv?=
 =?utf-8?B?ZU9vUW8rR1FMUmo0RFVlOFZKSzNDcTdGWUsyOW1JMHY1bmg4NnEwZ3Z4VUNE?=
 =?utf-8?B?MUpmT2t0MWU2Wm4xdytxVWdGK3dzRGk5akhnZG5Kc2Erd1p6MDlQWTJWSVlU?=
 =?utf-8?B?UjlsZHc2MFNwVmZjSFlNaWJtaGFtdG9CbnBpNVZ2UlBkTU8wT0lRVlIyTktk?=
 =?utf-8?B?ZDRvem5aVWZHN3N3N2ZGVzRVeWRpOWMyM3FKRDk0RlkxYVdoeVlVM2lvSDNw?=
 =?utf-8?B?eW5zY2I2T0o2QjFyZ1R5T2FLYXc4UXFWWi9xSDhlbnR3dlVtcDYrZTNzZ05R?=
 =?utf-8?B?NnY1dXdrUkl1SDZNYkVzVCtoOERwaVQxbWJmVWFMY01qdHE0VDNXM0dIZE9T?=
 =?utf-8?B?R0N6TTFYWlkyMmxZWnR4aXV3UXRvTmptK1VGbUtJR3FZYjRhYmYxODhjYit0?=
 =?utf-8?B?ZjZpVlpsU2Vzd1ZWUCs4Q1FTY0dpQ3B3Mk1KdVY4R0xtclZOZFBWY1Z3TjJt?=
 =?utf-8?B?UDhTYWt3YkxnYzJUNXVJQmY4NXYzZ0kxOW5VaVZRNVFUdExvZkNKVHJacXpZ?=
 =?utf-8?Q?kgUwHC8vnto=3D?=
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:MW4PR11MB6739.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230040)(376014)(1800799024)(366016);DIR:OUT;SFP:1101;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?utf-8?B?U2pXQUd3M3ZqRVA1cWoxdnI0M2VCY0luaDlFMU5BaGg4Wmdhc0RQbE5YM244?=
 =?utf-8?B?aFBTbE54OXlhZk5ZSGsyUkY1RlNpc0tNYnBqUzNIbXVvZUN5ZXBRUzIySk1M?=
 =?utf-8?B?VlFJWjBBczZDWmE4TjlReTlpQlBOMUJCMU5YZ0wybFpUVHlXOEJ1TzRjOXl0?=
 =?utf-8?B?OXc4RWpvRUxiWVYrZi9QS0w1WVVxejBkanc2aTFRQWpHQlNiN3hUWFFEb0Nn?=
 =?utf-8?B?SEFlcVFpNHI1aUN4RFFYa3FMeDJtQUU2T2Y1RWQvMDVmOWR5VXp3VndiYzZ4?=
 =?utf-8?B?alZMeUUyNTVWUG1qS3FxUkFqMUNhMWltbVEybjJEVUJGOGJJRXM0T2t1MTJo?=
 =?utf-8?B?STdqUWJlNlkvdUZ0am1xcG9rcFFGeWpFVHI3RUY0cFRWVlpVVG1XY2hHSGU1?=
 =?utf-8?B?cVNYVGVhQnpic3FsSVE1VnBSMmlab1RYd0FRWEgydi96Y00vMFlVSmRNZTYw?=
 =?utf-8?B?UzZlOURzd0J5Qy9QWC9va1NtTXdCNVRsb0xFWFlEdjAwTG1RRGRDc2RDbFYw?=
 =?utf-8?B?RFJXVjNWNXJXb2VOM2R6TitzTlNFeDVlem1vamlHWnZVMzlOK3JkMWlxQWMz?=
 =?utf-8?B?bDk0QXZ0bTdMZlVaVzBwTVNaV3Nna2hIL2hhbHREYzI1ZUhFRlQwemY5TDJa?=
 =?utf-8?B?OGMrTVo5VXZraW5OREl5SmJoRU5KeFFoRjRlQTJtOEYxSDltMlZPcnJPYTJh?=
 =?utf-8?B?SG4zSXBQaVNRRjJNOWdaY1kyUHNwUUdpemJsWjVrd1FENlNnWE9qQmlnSHE5?=
 =?utf-8?B?dnJFZXJaaXpVVWdYNjlSUmlPNi9sV1dFSGFkZnViZlJ5THh5ZXl0aU8vZk53?=
 =?utf-8?B?bjNtb1JHRGY4WXppeFhMam1vUGtBZGZlK2xnUk03V05FaVRxeERXY2NIQmlM?=
 =?utf-8?B?dFdOWFZiMjZFZkpWQkM0OXhBZzBESkxwbnoybndXVmRaTUFWVkt1S0xORXM5?=
 =?utf-8?B?c0ZzTEMrZVp1Z0xkUHZXNnhUTVVGUjVEeFR3TVpxNlljZzJYbTg2aDFHZ1J6?=
 =?utf-8?B?bEpycCs2V25Ocno2MndpNVM1dFNaVVlzb3JhcTR4SkNkc1FGbFJYVG9iYWQz?=
 =?utf-8?B?N3hGOGxBYU5GV0VZYnJBTHVLQnNGWUVZSTdPd0F6aTFkbUQzeFkxRUlycGs4?=
 =?utf-8?B?eUwzMzhoY1lmZkxEcVEwSElRTElkUisyQm5KUW9pNW5DZ2VlVWZWZTB6U0cr?=
 =?utf-8?B?SlRVOXl4SFluSlBMTmZ2L1JHQ2F6TE54UlVLMzlXaGoyV3BTTkN6MXVPbSs0?=
 =?utf-8?B?NDFscjduUWRJeDcwUDBrVGUrTzFGQzRrczN4QjQ2NU1PNjFBWXFlZS9POEZs?=
 =?utf-8?B?OWVCZi94Wk04UWtOeHFWZks1V1RMNGp1OWNDUHhub3NHUzFaWFZObnVBZjFp?=
 =?utf-8?B?bHZMZlI3VFUxaUhqbmF1NHVsNnhhYnVOMHluaEwvem9yai9tTFN0eVBmUFN1?=
 =?utf-8?B?TWRuZjY5VkEyYnJ0U09nZjJGRnNyK3ZMUHRwUGtjSVhSYzlRbFFxUzl2TFNy?=
 =?utf-8?B?YjlGdENFM0xnK3kwRlV0eGpvUkZjYmtNdDZKUEkveEFMU2VPcjV0WFF1bUdI?=
 =?utf-8?B?ck5hbEZDU202ZFo2cjZDa0tsV2J5VDN6cStQZXNwYWl6blMxb3d5U0JGdDVr?=
 =?utf-8?B?OWNVczliMytVKzdFcERFSllmUnE2VHRKTGNPZ1A2ZnBxUmRNcEVSNUdKN3Rx?=
 =?utf-8?B?MHdtcXMrMk1aVzI0TTliRTFIK1EreWlIUzJNNDFSZVFqTVZySnJBYUpSTHg3?=
 =?utf-8?B?aWYxNFJ2c2R4ZXIra0JVWC9CNWt4WmFsamRCVjhmbUdkazdzeHlHVGZuMFhN?=
 =?utf-8?B?cU9YUm4rb0ZYUEp3THJKZ0NXSE5ibXFmZ25zbHJVb0tCbW9hMEp1cjhPZmNC?=
 =?utf-8?B?YTZ1blNxYXFnSWdSVVRTenh5ZWdGaDBINHNwMFZnL1pMNDEyUk1zMXVQODEx?=
 =?utf-8?B?MHdEUnRaTVZaRC9nZk1UTXdoclBYWXc0K1ZRRUJRWUhEVjErN0poU2hveCsx?=
 =?utf-8?B?Qzg1QVFXZ2tWVWpNWjl3VGpVWm9Hbzc0TW9jNE9oMk9aMlQ4WUlWRUFHUzJV?=
 =?utf-8?B?S3dtZXdJdFAwMjNybmhLczUxTGxOOHZ0dmtFdkl3ZEs1MnRkaWx1OVJVaEtK?=
 =?utf-8?Q?FYVw7/t+V3mP1NwwRqHp48llZ?=
X-MS-Exchange-CrossTenant-Network-Message-Id: a10f9a32-c0d7-46cf-3d7f-08dd7addc41e
X-MS-Exchange-CrossTenant-AuthSource: MW4PR11MB6739.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 13 Apr 2025 22:51:45.5504
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: C4NCX1kzs+mwobyjZI19BQIhbLzxVpPV55BVg8UeiW1OK5bzASyyrDaEpFXh09tpObOy4Fx3vP8DFJKjHfNf/A==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: DM4PR11MB6042
X-OriginatorOrg: intel.com
Status: O
Content-Length: 12135
Lines: 381

Devices which optionally support Dynamic Capacity (DC) are configured
via mailbox commands.  CXL 3.2 section 9.13.3 requires the host to issue
the Get DC Configuration command in order to properly configure DCDs.
Without the Get DC Configuration command DCD can't be supported.

Implement the DC mailbox commands as specified in CXL 3.2 section
8.2.10.9.9 (opcodes 48XXh) to read and store the DCD configuration
information.  Disable DCD if an invalid configuration is found.

Linux has no support for more than one dynamic capacity partition.  Read
and validate all the partitions but configure only the first partition
as 'dynamic ram A'.  Additional partitions can be added in the future if
such a device ever materializes.  Additionally is it anticipated that no
skips will be present from the end of the pmem partition.  Check for an
disallow this configuration as well.

Linux has no use for the trailing fields of the Get Dynamic Capacity
Configuration Output Payload (Total number of supported extents, number
of available extents, total number of supported tags, and number of
available tags).  Avoid defining those fields to use the more useful
dynamic C array.

Based on an original patch by Navneet Singh.

Signed-off-by: Ira Weiny <ira.weiny@intel.com>

---
Changes:
[iweiny: rebase]
[iweiny: Update spec references to 3.2]
[djbw: Limit to 1 partition]
[djbw: Avoid inter-partition skipping]
[djbw: s/region/partition/]
[djbw: remove cxl_dc_region[partition]_info->name]
[iweiny: adjust to lack of dcd_cmds in mds]
[iweiny: remove extra 'region' from names]
[iweiny: remove unused CXL_DYNAMIC_CAPACITY_SANITIZE_ON_RELEASE_FLAG]
---
 drivers/cxl/core/hdm.c  |   2 +
 drivers/cxl/core/mbox.c | 179 ++++++++++++++++++++++++++++++++++++++++++++++++
 drivers/cxl/cxl.h       |   1 +
 drivers/cxl/cxlmem.h    |  54 ++++++++++++++-
 drivers/cxl/pci.c       |   3 +
 5 files changed, 238 insertions(+), 1 deletion(-)

diff --git a/drivers/cxl/core/hdm.c b/drivers/cxl/core/hdm.c
index 70cae4ebf8a4..c5f8a17d00f1 100644
--- a/drivers/cxl/core/hdm.c
+++ b/drivers/cxl/core/hdm.c
@@ -459,6 +459,8 @@ static const char *cxl_mode_name(enum cxl_partition_mode mode)
 		return "ram";
 	case CXL_PARTMODE_PMEM:
 		return "pmem";
+	case CXL_PARTMODE_DYNAMIC_RAM_A:
+		return "dynamic_ram_a";
 	default:
 		return "";
 	};
diff --git a/drivers/cxl/core/mbox.c b/drivers/cxl/core/mbox.c
index 58d378400a4b..866a423d6125 100644
--- a/drivers/cxl/core/mbox.c
+++ b/drivers/cxl/core/mbox.c
@@ -1313,6 +1313,153 @@ int cxl_mem_sanitize(struct cxl_memdev *cxlmd, u16 cmd)
 	return -EBUSY;
 }
 
+static int cxl_dc_check(struct device *dev, struct cxl_dc_partition_info *part_array,
+			u8 index, struct cxl_dc_partition *dev_part)
+{
+	size_t blk_size, len;
+
+	part_array[index].start = le64_to_cpu(dev_part->base);
+	part_array[index].size = le64_to_cpu(dev_part->decode_length);
+	part_array[index].size *= CXL_CAPACITY_MULTIPLIER;
+	len = le64_to_cpu(dev_part->length);
+	blk_size = le64_to_cpu(dev_part->block_size);
+
+	/* Check partitions are in increasing DPA order */
+	if (index > 0) {
+		struct cxl_dc_partition_info *prev_part = &part_array[index - 1];
+
+		if ((prev_part->start + prev_part->size) >
+		     part_array[index].start) {
+			dev_err(dev,
+				"DPA ordering violation for DC partition %d and %d\n",
+				index - 1, index);
+			return -EINVAL;
+		}
+	}
+
+	if (!IS_ALIGNED(part_array[index].start, SZ_256M) ||
+	    !IS_ALIGNED(part_array[index].start, blk_size)) {
+		dev_err(dev, "DC partition %d invalid start %zu blk size %zu\n",
+			index, part_array[index].start, blk_size);
+		return -EINVAL;
+	}
+
+	if (part_array[index].size == 0 || len == 0 ||
+	    part_array[index].size < len || !IS_ALIGNED(len, blk_size)) {
+		dev_err(dev, "DC partition %d invalid length; size %zu len %zu blk size %zu\n",
+			index, part_array[index].size, len, blk_size);
+		return -EINVAL;
+	}
+
+	if (blk_size == 0 || blk_size % CXL_DCD_BLOCK_LINE_SIZE ||
+	    !is_power_of_2(blk_size)) {
+		dev_err(dev, "DC partition %d invalid block size; %zu\n",
+			index, blk_size);
+		return -EINVAL;
+	}
+
+	dev_dbg(dev, "DC partition %d start %zu start %zu size %zu\n",
+		index, part_array[index].start, part_array[index].size,
+		blk_size);
+
+	return 0;
+}
+
+/* Returns the number of partitions in dc_resp or -ERRNO */
+static int cxl_get_dc_config(struct cxl_mailbox *mbox, u8 start_partition,
+			     struct cxl_mbox_get_dc_config_out *dc_resp,
+			     size_t dc_resp_size)
+{
+	struct cxl_mbox_get_dc_config_in get_dc = (struct cxl_mbox_get_dc_config_in) {
+		.partition_count = CXL_MAX_DC_PARTITIONS,
+		.start_partition_index = start_partition,
+	};
+	struct cxl_mbox_cmd mbox_cmd = (struct cxl_mbox_cmd) {
+		.opcode = CXL_MBOX_OP_GET_DC_CONFIG,
+		.payload_in = &get_dc,
+		.size_in = sizeof(get_dc),
+		.size_out = dc_resp_size,
+		.payload_out = dc_resp,
+		.min_out = 1,
+	};
+	int rc;
+
+	rc = cxl_internal_send_cmd(mbox, &mbox_cmd);
+	if (rc < 0)
+		return rc;
+
+	dev_dbg(mbox->host, "Read %d/%d DC partitions\n",
+		dc_resp->partitions_returned, dc_resp->avail_partition_count);
+	return dc_resp->partitions_returned;
+}
+
+/**
+ * cxl_dev_dc_identify() - Reads the dynamic capacity information from the
+ *                         device.
+ * @mbox: Mailbox to query
+ * @dc_info: The dynamic partition information to return
+ *
+ * Read Dynamic Capacity information from the device and return the partition
+ * information.
+ *
+ * Return: 0 if identify was executed successfully, -ERRNO on error.
+ *         on error only dynamic_bytes is left unchanged.
+ */
+int cxl_dev_dc_identify(struct cxl_mailbox *mbox,
+			struct cxl_dc_partition_info *dc_info)
+{
+	struct cxl_dc_partition_info partitions[CXL_MAX_DC_PARTITIONS];
+	size_t dc_resp_size = mbox->payload_size;
+	struct device *dev = mbox->host;
+	u8 start_partition;
+	u8 num_partitions;
+
+	struct cxl_mbox_get_dc_config_out *dc_resp __free(kfree) =
+					kvmalloc(dc_resp_size, GFP_KERNEL);
+	if (!dc_resp)
+		return -ENOMEM;
+
+	/* Read and check all partition information for validity and potential
+	 * debugging; see debug output in cxl_dc_check() */
+	start_partition = 0;
+	do {
+		int rc, i, j;
+
+		rc = cxl_get_dc_config(mbox, start_partition, dc_resp, dc_resp_size);
+		if (rc < 0) {
+			dev_err(dev, "Failed to get DC config: %d\n", rc);
+			return rc;
+		}
+
+		num_partitions += rc;
+
+		if (num_partitions < 1 || num_partitions > CXL_MAX_DC_PARTITIONS) {
+			dev_err(dev, "Invalid num of dynamic capacity partitions %d\n",
+				num_partitions);
+			return -EINVAL;
+		}
+
+		for (i = start_partition, j = 0; i < num_partitions; i++, j++) {
+			rc = cxl_dc_check(dev, partitions, i,
+					  &dc_resp->partition[j]);
+			if (rc)
+				return rc;
+		}
+
+		start_partition = num_partitions;
+
+	} while (num_partitions < dc_resp->avail_partition_count);
+
+	/* Return 1st partition */
+	dc_info->start = partitions[0].start;
+	dc_info->size = partitions[0].size;
+	dev_dbg(dev, "Returning partition 0 %zu size %zu\n",
+		dc_info->start, dc_info->size);
+
+	return 0;
+}
+EXPORT_SYMBOL_NS_GPL(cxl_dev_dc_identify, "CXL");
+
 static void add_part(struct cxl_dpa_info *info, u64 start, u64 size, enum cxl_partition_mode mode)
 {
 	int i = info->nr_partitions;
@@ -1383,6 +1530,38 @@ int cxl_get_dirty_count(struct cxl_memdev_state *mds, u32 *count)
 }
 EXPORT_SYMBOL_NS_GPL(cxl_get_dirty_count, "CXL");
 
+void cxl_configure_dcd(struct cxl_memdev_state *mds, struct cxl_dpa_info *info)
+{
+	struct cxl_dc_partition_info dc_info = { 0 };
+	struct device *dev = mds->cxlds.dev;
+	size_t skip;
+	int rc;
+
+	rc = cxl_dev_dc_identify(&mds->cxlds.cxl_mbox, &dc_info);
+	if (rc) {
+		dev_warn(dev,
+			 "Failed to read Dynamic Capacity config: %d\n", rc);
+		cxl_disable_dcd(mds);
+		return;
+	}
+
+	/* Skips between pmem and the dynamic partition are not supported */
+	skip = dc_info.start - info->size;
+	if (skip) {
+		dev_warn(dev,
+			 "Dynamic Capacity skip from pmem not supported: %zu\n",
+			 skip);
+		cxl_disable_dcd(mds);
+		return;
+	}
+
+	info->size += dc_info.size;
+	dev_dbg(dev, "Adding dynamic ram partition A; %zu size %zu\n",
+		dc_info.start, dc_info.size);
+	add_part(info, dc_info.start, dc_info.size, CXL_PARTMODE_DYNAMIC_RAM_A);
+}
+EXPORT_SYMBOL_NS_GPL(cxl_configure_dcd, "CXL");
+
 int cxl_arm_dirty_shutdown(struct cxl_memdev_state *mds)
 {
 	struct cxl_mailbox *cxl_mbox = &mds->cxlds.cxl_mbox;
diff --git a/drivers/cxl/cxl.h b/drivers/cxl/cxl.h
index be8a7dc77719..a9d42210e8a3 100644
--- a/drivers/cxl/cxl.h
+++ b/drivers/cxl/cxl.h
@@ -485,6 +485,7 @@ struct cxl_region_params {
 enum cxl_partition_mode {
 	CXL_PARTMODE_RAM,
 	CXL_PARTMODE_PMEM,
+	CXL_PARTMODE_DYNAMIC_RAM_A,
 };
 
 /*
diff --git a/drivers/cxl/cxlmem.h b/drivers/cxl/cxlmem.h
index 394a776954f4..057933128d2c 100644
--- a/drivers/cxl/cxlmem.h
+++ b/drivers/cxl/cxlmem.h
@@ -97,7 +97,7 @@ int devm_cxl_dpa_reserve(struct cxl_endpoint_decoder *cxled,
 			 resource_size_t base, resource_size_t len,
 			 resource_size_t skipped);
 
-#define CXL_NR_PARTITIONS_MAX 2
+#define CXL_NR_PARTITIONS_MAX 3
 
 struct cxl_dpa_info {
 	u64 size;
@@ -380,6 +380,7 @@ enum cxl_devtype {
 	CXL_DEVTYPE_CLASSMEM,
 };
 
+#define CXL_MAX_DC_PARTITIONS 8
 /**
  * struct cxl_dpa_perf - DPA performance property entry
  * @dpa_range: range for DPA address
@@ -722,6 +723,31 @@ struct cxl_mbox_set_shutdown_state_in {
 	u8 state;
 } __packed;
 
+/* See CXL 3.2 Table 8-178 get dynamic capacity config Input Payload */
+struct cxl_mbox_get_dc_config_in {
+	u8 partition_count;
+	u8 start_partition_index;
+} __packed;
+
+/* See CXL 3.2 Table 8-179 get dynamic capacity config Output Payload */
+struct cxl_mbox_get_dc_config_out {
+	u8 avail_partition_count;
+	u8 partitions_returned;
+	u8 rsvd[6];
+	/* See CXL 3.2 Table 8-180 */
+	struct cxl_dc_partition {
+		__le64 base;
+		__le64 decode_length;
+		__le64 length;
+		__le64 block_size;
+		__le32 dsmad_handle;
+		u8 flags;
+		u8 rsvd[3];
+	} __packed partition[] __counted_by(partitions_returned);
+	/* Trailing fields unused */
+} __packed;
+#define CXL_DCD_BLOCK_LINE_SIZE 0x40
+
 /* Set Timestamp CXL 3.0 Spec 8.2.9.4.2 */
 struct cxl_mbox_set_timestamp_in {
 	__le64 timestamp;
@@ -845,9 +871,24 @@ enum {
 int cxl_internal_send_cmd(struct cxl_mailbox *cxl_mbox,
 			  struct cxl_mbox_cmd *cmd);
 int cxl_dev_state_identify(struct cxl_memdev_state *mds);
+
+struct cxl_mem_dev_info {
+	u64 total_bytes;
+	u64 volatile_bytes;
+	u64 persistent_bytes;
+};
+
+struct cxl_dc_partition_info {
+	size_t start;
+	size_t size;
+};
+
+int cxl_dev_dc_identify(struct cxl_mailbox *mbox,
+			struct cxl_dc_partition_info *dc_info);
 int cxl_await_media_ready(struct cxl_dev_state *cxlds);
 int cxl_enumerate_cmds(struct cxl_memdev_state *mds);
 int cxl_mem_dpa_fetch(struct cxl_memdev_state *mds, struct cxl_dpa_info *info);
+void cxl_configure_dcd(struct cxl_memdev_state *mds, struct cxl_dpa_info *info);
 struct cxl_memdev_state *cxl_memdev_state_create(struct device *dev);
 void set_exclusive_cxl_commands(struct cxl_memdev_state *mds,
 				unsigned long *cmds);
@@ -860,6 +901,17 @@ void cxl_event_trace_record(const struct cxl_memdev *cxlmd,
 			    const uuid_t *uuid, union cxl_event *evt);
 int cxl_get_dirty_count(struct cxl_memdev_state *mds, u32 *count);
 int cxl_arm_dirty_shutdown(struct cxl_memdev_state *mds);
+
+static inline bool cxl_dcd_supported(struct cxl_memdev_state *mds)
+{
+	return mds->dcd_supported;
+}
+
+static inline void cxl_disable_dcd(struct cxl_memdev_state *mds)
+{
+	mds->dcd_supported = false;
+}
+
 int cxl_set_timestamp(struct cxl_memdev_state *mds);
 int cxl_poison_state_init(struct cxl_memdev_state *mds);
 int cxl_mem_get_poison(struct cxl_memdev *cxlmd, u64 offset, u64 len,
diff --git a/drivers/cxl/pci.c b/drivers/cxl/pci.c
index 7b14a154463c..bc40cf6e2fe9 100644
--- a/drivers/cxl/pci.c
+++ b/drivers/cxl/pci.c
@@ -998,6 +998,9 @@ static int cxl_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	if (rc)
 		return rc;
 
+	if (cxl_dcd_supported(mds))
+		cxl_configure_dcd(mds, &range_info);
+
 	rc = cxl_dpa_setup(cxlds, &range_info);
 	if (rc)
 		return rc;

-- 
2.49.0


From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from mgamail.intel.com (mgamail.intel.com [192.198.163.18])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id DA70419539F
	for <nvdimm@lists.linux.dev>; Sun, 13 Apr 2025 22:52:00 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=fail smtp.client-ip=192.198.163.18
ARC-Seal: i=2; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1744584723; cv=fail; b=Kxy3/bbOzV3heBwx1/ETmCsMgHTQqxOYnFZu4po7f8DuwuliJl95TPjS+4P8w8nubkmY36vhgJQcyaWQBDdHc9okJaphntAZIHQjr3tkaNY720EiNmW/TNyedPaDL5gonX1RCf43aZMXFwReYTOF8nHz4r/RfRa7RjEPO6bdOAs=
ARC-Message-Signature: i=2; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1744584723; c=relaxed/simple;
	bh=V3fWJr3Em3iZQf2yytjyz4d5nf/SXSyrd7uDfepAKP4=;
	h=From:Date:Subject:Content-Type:Message-ID:References:In-Reply-To:
	 To:CC:MIME-Version; b=Y9i/5esGhXQMkUUyNYV/dXZYs/CE6mz1pmCJeLPA0EP06/NpVTFwydXDZ84izZKvo83T8X18TjupkDMH04dyURUEa2DN8ibke5v69rSoFp1dxQtDm2jrYvgKQtWhn4gsx7Al2eQNcuLEMHzLUFVragAZpgTRUjJEzIlpnGA6AjA=
ARC-Authentication-Results: i=2; smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=intel.com; spf=pass smtp.mailfrom=intel.com; dkim=pass (2048-bit key) header.d=intel.com header.i=@intel.com header.b=MqS2Zc9T; arc=fail smtp.client-ip=192.198.163.18
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=intel.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=intel.com
Authentication-Results: smtp.subspace.kernel.org;
	dkim=pass (2048-bit key) header.d=intel.com header.i=@intel.com header.b="MqS2Zc9T"
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1744584721; x=1776120721;
  h=from:date:subject:content-transfer-encoding:message-id:
   references:in-reply-to:to:cc:mime-version;
  bh=V3fWJr3Em3iZQf2yytjyz4d5nf/SXSyrd7uDfepAKP4=;
  b=MqS2Zc9Tq3OuGCNV7/PK21yuqjeIi3f2lYIhV0aKdt3+UewZ+7Wvl9w8
   7us+RAsqFZome5OPUEhw6lupFbyczkNrQTR+TqeLyvf+ARMx5WlQ8ZNxj
   x1pT3by9R1q128e+5yE0UkhUWtgT/QktsoEQj4SJQ+74tAznWmfwS0ZKA
   yUp6ZMH/YF2rlUTiBng2hgdYj+M70pZ3KKqaKnoodtIwqRHellH6OJVGm
   cHYcT+cWS2S5Pm3n5c/+x/tpzE/ce8kgof1OXISiNNMbBffo1QVKndekx
   34rv4YcyfLbhYF8PW1D1ChxPV6joPw/4bmP+b/q9gTh3Kw0S9wtHSBLLO
   A==;
X-CSE-ConnectionGUID: uX5eDUv8QreMr0MOHl3zeg==
X-CSE-MsgGUID: IiZHN0BpSbm3e5ahDMRxXA==
X-IronPort-AV: E=McAfee;i="6700,10204,11402"; a="45280891"
X-IronPort-AV: E=Sophos;i="6.15,211,1739865600"; 
   d="scan'208";a="45280891"
Received: from fmviesa007.fm.intel.com ([10.60.135.147])
  by fmvoesa112.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 13 Apr 2025 15:52:00 -0700
X-CSE-ConnectionGUID: xVHgEbcBRbWcSny/L7WzzA==
X-CSE-MsgGUID: 64Ik891lQGq1Y9+T1Ul4BA==
X-ExtLoop1: 1
X-IronPort-AV: E=Sophos;i="6.15,211,1739865600"; 
   d="scan'208";a="129657430"
Received: from orsmsx903.amr.corp.intel.com ([10.22.229.25])
  by fmviesa007.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 13 Apr 2025 15:51:59 -0700
Received: from ORSMSX901.amr.corp.intel.com (10.22.229.23) by
 ORSMSX903.amr.corp.intel.com (10.22.229.25) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.2.1544.14; Sun, 13 Apr 2025 15:51:58 -0700
Received: from ORSEDG602.ED.cps.intel.com (10.7.248.7) by
 ORSMSX901.amr.corp.intel.com (10.22.229.23) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.2.1544.14 via Frontend Transport; Sun, 13 Apr 2025 15:51:58 -0700
Received: from NAM11-BN8-obe.outbound.protection.outlook.com (104.47.58.168)
 by edgegateway.intel.com (134.134.137.103) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.44; Sun, 13 Apr 2025 15:51:58 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector10001; d=microsoft.com; cv=none;
 b=DWEJtkC5NvYYRQS+rchlsHU3+eIR4vYAeMxNmlXurb5oBWbf41FW/liNyXdFNLVJq1RMtfH2fQKeoLg/yKDan7eNO+gll7MAPbNlmQGkDgllHh/yZsUXV7k22rUqPq7zPyeFaWV8e9AOFnDH5yEtbWuqjSN86JWlJzfURt2zn6py6FNuUnqzyP8ZMgsRAUnzWuKxR+C4QLcmyOf8jE/Gidd3g01cMyul6/nSoobQTgle/e8/NjsyWwcEHHrHfM+1AM9UdDS/pN5CYyXLBcviCOO+2HIWhi9zLNLD/XOmeXqrMKTASnCeBv+ls/VQioDNjeOFv40ZEMdRjqbQrmSZnw==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector10001;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=xKw2/RAcdXZWQN02V1z9yzRy7CXyZCgrhub8YtJUy/o=;
 b=org9c99KH4OuPNz/QYzuwrnrHVWv62+veCeA12J+cOPoOTm8iQ+z6i84ekUjL2yclaYhaBT1Xv/1YFwE4vfayBuhbL6eYNl8t3XrOq6s3PuSaZTo6sBW38Btyd/F6Jw7zWnd0hBBFEGEFYIO5BLqbuG2B4xGl4eexm/54IR08jslhmBgtipl5Xs7aff6NkbziIawV38V17TAX1fJJn7hxvo0L3mK12WRLHa4hNwZDmFEWTdh3N9oWiUlx0naQpGeMESx/PivPt0X2Wb/c0hD2Rp7GvPIVK2PbeZO/m0FNnWeYsu7yS9pR0JeICwlByXyVfIEAcqze0lkL8oV+0gh4A==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from MW4PR11MB6739.namprd11.prod.outlook.com (2603:10b6:303:20b::19)
 by DM4PR11MB6042.namprd11.prod.outlook.com (2603:10b6:8:61::18) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.8632.28; Sun, 13 Apr
 2025 22:51:47 +0000
Received: from MW4PR11MB6739.namprd11.prod.outlook.com
 ([fe80::a7ad:a6e8:fced:3f24]) by MW4PR11MB6739.namprd11.prod.outlook.com
 ([fe80::a7ad:a6e8:fced:3f24%4]) with mapi id 15.20.8606.033; Sun, 13 Apr 2025
 22:51:47 +0000
From: Ira Weiny <ira.weiny@intel.com>
Date: Sun, 13 Apr 2025 17:52:11 -0500
Subject: [PATCH v9 03/19] cxl/cdat: Gather DSMAS data for DCD partitions
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: 7bit
Message-ID: <20250413-dcd-type2-upstream-v9-3-1d4911a0b365@intel.com>
References: <20250413-dcd-type2-upstream-v9-0-1d4911a0b365@intel.com>
In-Reply-To: <20250413-dcd-type2-upstream-v9-0-1d4911a0b365@intel.com>
To: Dave Jiang <dave.jiang@intel.com>, Fan Ni <fan.ni@samsung.com>, "Jonathan
 Cameron" <Jonathan.Cameron@huawei.com>
CC: Dan Williams <dan.j.williams@intel.com>, Davidlohr Bueso
	<dave@stgolabs.net>, Alison Schofield <alison.schofield@intel.com>, "Vishal
 Verma" <vishal.l.verma@intel.com>, Ira Weiny <ira.weiny@intel.com>,
	<linux-cxl@vger.kernel.org>, <nvdimm@lists.linux.dev>,
	<linux-kernel@vger.kernel.org>
X-Mailer: b4 0.15-dev-c25d1
X-Developer-Signature: v=1; a=ed25519-sha256; t=1744584735; l=4875;
 i=ira.weiny@intel.com; s=20221211; h=from:subject:message-id;
 bh=V3fWJr3Em3iZQf2yytjyz4d5nf/SXSyrd7uDfepAKP4=;
 b=AyU5Sbgydhbm2qFavE2D0NLOq67cFT0qHgTrjJZn5EyonDuA4LqaYh1vyvPtk899fCRRyPfSq
 VJ4h4uy1+yoCH/MA3Qz5CTwwJOlkY4s5S2wdbdVLxqhprOY0ofY97Z7
X-Developer-Key: i=ira.weiny@intel.com; a=ed25519;
 pk=noldbkG+Wp1qXRrrkfY1QJpDf7QsOEthbOT7vm0PqsE=
X-ClientProxiedBy: MW4PR03CA0227.namprd03.prod.outlook.com
 (2603:10b6:303:b9::22) To MW4PR11MB6739.namprd11.prod.outlook.com
 (2603:10b6:303:20b::19)
Precedence: bulk
X-Mailing-List: nvdimm@lists.linux.dev
List-Id: <nvdimm.lists.linux.dev>
List-Subscribe: <mailto:nvdimm+subscribe@lists.linux.dev>
List-Unsubscribe: <mailto:nvdimm+unsubscribe@lists.linux.dev>
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: MW4PR11MB6739:EE_|DM4PR11MB6042:EE_
X-MS-Office365-Filtering-Correlation-Id: 2b275f08-8b81-4bd9-6ea2-08dd7addc517
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;ARA:13230040|376014|1800799024|366016;
X-Microsoft-Antispam-Message-Info: =?utf-8?B?Zmk5ZmRMdytvbVdXSlRSWlArRzdDUDlZb0o3RFg4bVlLYm5oR3RRQ05oSEcx?=
 =?utf-8?B?eCtoS1N0Q0NPZ1N6UzBTZXQwZTVNWjhVVUkzbW9GYm8wVzUzSE1qTFUrOXdN?=
 =?utf-8?B?cHNJZUJVa2cwdy9qVjVHSTE2MjJwcDFyRDFuVGl4MTl4V3B0S1pvVG9zMEsy?=
 =?utf-8?B?OXc5aGdpa2wxb3NoY2JSdFdvdjJ6RGFWdEcyUG5lbDVHUFR2QnhBdjZISVd4?=
 =?utf-8?B?WFBaUkVkVWh6STBWa3RiWXRPMlVmdmhLa3ArQXJEcGJlbDR3K1lTVTA2TzJS?=
 =?utf-8?B?eGFQTk1xWWNQdm40eWVzQmhaTUFNd21nV3BMVnVYUUhLMjJtZnJ0YTRKTzRG?=
 =?utf-8?B?MGFHTVNHTkNtZUhsdDEyeU1QRUxpTTJWL0YzSVI4bXZIL2t0ZVdwVVF1UjVs?=
 =?utf-8?B?K1VzSVRYNk14cm1WUCtvV2NxZUpxN0xOeEJ5VTdHME14TUpZT01yL0JhdnE4?=
 =?utf-8?B?Q0VLZjNTbCt6SjBLU0FaQ2hVY0ZWaDZxU2VsdTZzRmk0ZGhNbDRZNXhoOXpD?=
 =?utf-8?B?VjJ3ZEF4djY1SW1ENzU4MElGV0p3cFBJbE43M3RLc1FIZ09vU0poVEtqN3lE?=
 =?utf-8?B?OVhSVWREdmJsTDdwWHh6K3pOYWZVMDAwOHNJdnRSMTZjSUZHcldUUnp6R3dh?=
 =?utf-8?B?a2p5Vmd0MHkxMWk2WGJPUXlrSFFyWjZHby9DMnhoQ1lscTBYYWpOaHB4THdF?=
 =?utf-8?B?SjZvT3hDRmxLQTYrMnlDRTV6Nit2S3pHQmF5cDN4QUt1ajJ2T3N3cWtaSHdS?=
 =?utf-8?B?RWNrMzYyY0ZsTGdURE5ZTHUzR20ybkxDdUl3WnJpVFpiMDF3M25yL1c2eDdJ?=
 =?utf-8?B?SW9RendVdnRIaUNNNWk4dTAxaEkrZjlnbmlkT1V1WWYzSkZ5VzMrUWNIZ0s1?=
 =?utf-8?B?WGNaWFd5RWgxQ0RCNEZCL0FPdW5HeWhXYUV0dGNuaXpIR2ZaVlJqUzhoSXp0?=
 =?utf-8?B?MEZIc1pxYStVblBmWlY2aklBVFYyaVo5VDdDODNUK09QTTdZMENnUXl1cVU1?=
 =?utf-8?B?Z2xERHlmMlZkbStiSUg1bWczRi9rSHF3eGRycWE1RTN0d0RYUjZNYlg1NDhX?=
 =?utf-8?B?ZWVnYmxia0tDT3E5c0k0L1BlUkhpdHNHVUJFNG0vL2dnemgva2IwUEpOR1hB?=
 =?utf-8?B?M0t3N3FSNmxITGxidXFEMUVTcHVsaExNTEhOdzg5TEpRaUNrVy9RSjk0Qll3?=
 =?utf-8?B?Z3JBV25KMllGOGJJS3dtWmZVbGhsYnJMbHNBaUxJbElLdGFMV2QwR2JaYXB1?=
 =?utf-8?B?S3hla0pIeTFIeXZpcmtBL01wWE84WW9UQXJCV2w4SEt3SWRMMHZVWlNKSXhv?=
 =?utf-8?B?TUxBSy9Pd25aM3FJajlHUGZCWm5DN3c2UURpUXZMSWtydFl3MG5WQVpKZ2hq?=
 =?utf-8?B?RDVBM3FEZzI4R1FhOVdIS2c1Z2JtakRQUDVtNGFQQ2RYNzBaRUV3YXlPR3lZ?=
 =?utf-8?B?SWpzRmVoUkxZSXR2OTRockJPTjZUbEczMHNWdXB3cDhuOEgrWVZiWGQxSzQ5?=
 =?utf-8?B?UEhCRFRnQjc5cEgxZTQ4bWR6UmoyY2ZtL3FrUlI5aUhOd29jamFEVzRHbVBw?=
 =?utf-8?B?azNZWUdpUHR6bzByOWVhZUFkWHp2c1hndkE1N0xoWFF0ajV4TlpOSHM2Syt5?=
 =?utf-8?B?NWl2cThYSGFoOU5pTG9pcGxUL0FudXJLcUhjKzNqeEthZC8yNS9GaFFsM3FT?=
 =?utf-8?B?RlBEalJOd0h4cTRVYUdpbGY3am1LdEltZzNhQzhUR3cxQXo3VU41cS9BVWtw?=
 =?utf-8?B?Qnk4NEpBS0dHNzdpQkxRV3AycEFQTGJ3U0sreFI5OXJmRHN0Vi9JUjZoc1BZ?=
 =?utf-8?B?L0p4TVlPeEdKcTZGUzBxSTF3ZFJDTHdVeGpGUHB5TCszVHdLaFFoWXlnMW9l?=
 =?utf-8?B?VUR2Ui9IMDI4L1FDQ21HQnJTaCtQdVkvOGhpWWNpVHI5VWc9PQ==?=
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:MW4PR11MB6739.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230040)(376014)(1800799024)(366016);DIR:OUT;SFP:1101;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?utf-8?B?NlhLbU9xaTVERUJ3UkRtWm9xUlpqZ2tSYkNEblZGWUtEODZvWEJkVisvcVo4?=
 =?utf-8?B?Y2k1WU5nWXR5TlB0d21aM1loTU5RMUZoNTQ1U0JBNEtmR0dMQlZiN01SaThH?=
 =?utf-8?B?czg0SnI4bFBiMFVWdlV6ZWVweUN0VWN5MVlyampCYU9aQ1VBRVErZ1BzSDlL?=
 =?utf-8?B?Y1pRKzNwYVpSUjJzSUYxSXkrdnk5MzdYeDJEUnZCc2taaWtNc3prd3IyQ2R1?=
 =?utf-8?B?cXhaTWI2NnljM0JDVld6L0hhZ0NJN0RHa25xSER4WlU3TnBLQkZiUG5NU3hB?=
 =?utf-8?B?cmw2SXg1RGhVNFhCb20vMTBzZjdFM0NHYmVMd2xzRW1kamF1c2RUUDQ0bVFn?=
 =?utf-8?B?SXBzYnRqMDMyaDVUQURQSTBYTHYvdjl5ZXpoeGMyb3RJbWE1eDg1cUZGK3Nj?=
 =?utf-8?B?YXV1ME9QUlI5L1JzQUxsUDBGVk5KU2xZMDM5RDlodFFQQTNTenJraWVCdUIv?=
 =?utf-8?B?Q3J6Q3g0NUdsN0xDNEc2L0svNnlPNkdid01WdlNDNDNrYmdFZ2tQY3YyK0ZE?=
 =?utf-8?B?eGNKeGhlc2lDVXBxSGtReDNYZ0YrUmlMSkErZDk0aVk1SjdXMDFsN3VNWi9D?=
 =?utf-8?B?TWVUZkZ0VTlITHFxcnhRREhyS0xJcmhWVUVndVloQVdvWVFZMXNTR2NobWox?=
 =?utf-8?B?elYrbFBEWDFOdVZUMzRkM2hmNzlkK2sxTWxQV0Qvdm9lcndncWRwOFZOK2p6?=
 =?utf-8?B?TmNUbWF0L3VwZ3BKdTduVzE1NEpFSFlzYVh4SmprVFZDYjVCSkFGcTRUK3Ry?=
 =?utf-8?B?RmpPclZlM3p3Q2xONE82VmtpdDh3V3BKYm40WGREbVMyOFpvT0ovNTlwQnZn?=
 =?utf-8?B?TXc1OUdSbE1LUDh3aTQrUE1wMVVuRlRtTytRV0tyd1F0a0FnQnRjcmhRRGU5?=
 =?utf-8?B?Y21udnRSMmoralNXaldIWGk1eURBVTVENW9MNU1HS1A2REVpY21kRldpeEti?=
 =?utf-8?B?ekNyTmp5andvS0ErLzZRbFVlcUlMMEFFbHZPTXFjZjlCTzJ1YWN0Z0Mvc3JY?=
 =?utf-8?B?cjN1dHNvclVnSCtGWHRGQnd2eHMxVkxhNkNKT3hYZ0ZPWWNzbVdjdDlGK2Zk?=
 =?utf-8?B?ZEZsczl2MnlmRzQ2andGUyt1SllJK2t1WHR2OTAyT0wyV1l0Q1NGV2NwWjcw?=
 =?utf-8?B?MGc0TnRaWUJDaWUveWxza0h5cmdtdzlqblhvQUw5N3hGZzJndGE5WTdHeEhw?=
 =?utf-8?B?UkdJcVg0Y0szazdnVWNPTWUzaFRtaXIybDkwMDJrV3ZQVSsyVVpXVWNSVVZM?=
 =?utf-8?B?VUpDVkFMb1JsYmxSaWZpejR4TjJvNkdoWUJRL1VoUGFEb2VXT241RVVsM1dy?=
 =?utf-8?B?ME5adWtvQi9qTldBcHZ6aWJJc3lSQU1kOXQyZ3RWU2RxVzRXRUdQNG45dnBt?=
 =?utf-8?B?VXB5dnh2Zzg2aUFLd2J2NTZCT1pUR3R5U1JLM05EV2hUNitYK0htVGR6dlpC?=
 =?utf-8?B?cDNhVTEzdkl0emcvM1FwejlhY0tVQ1dYUy9zSlhJODhiYzZCNmRpMnhlTy91?=
 =?utf-8?B?SENjaEhKTURIWjYwR2l2aEZ0QS9KTTZITERoeWNVaWNFdytDSlJtM3cveERS?=
 =?utf-8?B?RUlZOWx1YTNyM2dzSnNxYkdhTjdWbEdDV3hGZ0JGZXVlZnh3c0RSamxRTVNI?=
 =?utf-8?B?cndqdUUrc1Fsc3VsbnYvTUhIVUhraEVKRDRkUFpSc2sxUUpZeGJDYVJaVFB0?=
 =?utf-8?B?UWNwVjJwRmJFd0JIRnM3OGd2b0k0VnVhZ0h6QWpCNXMzMEhSeUpBaTZkNTMz?=
 =?utf-8?B?MVRoc2RuRHlsOHNXL3BWeXVHUVJjK0tGU0xXVzRvQTRpc3NnT3NKRkYvNjZS?=
 =?utf-8?B?aUdvamNvaGdHMHhmOHhHQnRIb05HWTlzd2NpSmp3T01MRXY3U0o4TXB3UWE1?=
 =?utf-8?B?Wk9hc0dZeUkwalh0Y2dWVDQ2THJ1bCsyQ1F0R2s4dU0vdFk5WFcwQ0dSRlhw?=
 =?utf-8?B?L0M0Zk01QnlrU0grZ09PS2pHWFZpRFNzbXpqNVc5aFJnNVBXWEpjUkdFZ3Y2?=
 =?utf-8?B?eTNhZGhTUHVIY3p3TmdTdndWanBqOUxBbzFBMFdTVkZGT01XTUdGUmpSN2JY?=
 =?utf-8?B?UkVPK1FQSCtPTmZjdHhka0J1RzNvTzdKWTZUM1BQK1lFamFmNHNyYjNwdlhR?=
 =?utf-8?Q?RqOwwchRp5k3lOjszT1xEH0nQ?=
X-MS-Exchange-CrossTenant-Network-Message-Id: 2b275f08-8b81-4bd9-6ea2-08dd7addc517
X-MS-Exchange-CrossTenant-AuthSource: MW4PR11MB6739.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 13 Apr 2025 22:51:47.2554
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: tnWNTg5dVhoU2PWzio5UvYtxgSzapntFAx2J5o3z5HYKkRnwpr3+CDCpwZnHdb9ImOxNrU1PW/04+wjrCKejaw==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: DM4PR11MB6042
X-OriginatorOrg: intel.com
Status: O
Content-Length: 4737
Lines: 140

Additional DCD partition (AKA region) information is contained in the
DSMAS CDAT tables, including performance, read only, and shareable
attributes.

Match DCD partitions with DSMAS tables and store the meta data.

Signed-off-by: Ira Weiny <ira.weiny@intel.com>

---
Changes:
[iweiny: Adjust for new perf/partition infrastructure]
---
 drivers/cxl/core/cdat.c | 11 +++++++++++
 drivers/cxl/core/mbox.c |  2 ++
 drivers/cxl/cxlmem.h    |  6 ++++++
 3 files changed, 19 insertions(+)

diff --git a/drivers/cxl/core/cdat.c b/drivers/cxl/core/cdat.c
index edb4f41eeacc..ad93713f4364 100644
--- a/drivers/cxl/core/cdat.c
+++ b/drivers/cxl/core/cdat.c
@@ -17,6 +17,7 @@ struct dsmas_entry {
 	struct access_coordinate cdat_coord[ACCESS_COORDINATE_MAX];
 	int entries;
 	int qos_class;
+	bool shareable;
 };
 
 static u32 cdat_normalize(u16 entry, u64 base, u8 type)
@@ -74,6 +75,7 @@ static int cdat_dsmas_handler(union acpi_subtable_headers *header, void *arg,
 		return -ENOMEM;
 
 	dent->handle = dsmas->dsmad_handle;
+	dent->shareable = dsmas->flags & ACPI_CDAT_DSMAS_SHAREABLE;
 	dent->dpa_range.start = le64_to_cpu((__force __le64)dsmas->dpa_base_address);
 	dent->dpa_range.end = le64_to_cpu((__force __le64)dsmas->dpa_base_address) +
 			      le64_to_cpu((__force __le64)dsmas->dpa_length) - 1;
@@ -244,6 +246,7 @@ static void update_perf_entry(struct device *dev, struct dsmas_entry *dent,
 		dpa_perf->coord[i] = dent->coord[i];
 		dpa_perf->cdat_coord[i] = dent->cdat_coord[i];
 	}
+	dpa_perf->shareable = dent->shareable;
 	dpa_perf->dpa_range = dent->dpa_range;
 	dpa_perf->qos_class = dent->qos_class;
 	dev_dbg(dev,
@@ -266,13 +269,21 @@ static void cxl_memdev_set_qos_class(struct cxl_dev_state *cxlds,
 		bool found = false;
 
 		for (int i = 0; i < cxlds->nr_partitions; i++) {
+			enum cxl_partition_mode mode = cxlds->part[i].mode;
 			struct resource *res = &cxlds->part[i].res;
+			u8 handle = cxlds->part[i].handle;
 			struct range range = {
 				.start = res->start,
 				.end = res->end,
 			};
 
 			if (range_contains(&range, &dent->dpa_range)) {
+				if (mode == CXL_PARTMODE_DYNAMIC_RAM_A &&
+				    dent->handle != handle)
+					dev_warn(dev,
+						"Dynamic RAM perf mismatch; %pra (%u) vs %pra (%u)\n",
+						&range, handle, &dent->dpa_range, dent->handle);
+
 				update_perf_entry(dev, dent,
 						  &cxlds->part[i].perf);
 				found = true;
diff --git a/drivers/cxl/core/mbox.c b/drivers/cxl/core/mbox.c
index 866a423d6125..c589d8a330bb 100644
--- a/drivers/cxl/core/mbox.c
+++ b/drivers/cxl/core/mbox.c
@@ -1321,6 +1321,7 @@ static int cxl_dc_check(struct device *dev, struct cxl_dc_partition_info *part_a
 	part_array[index].start = le64_to_cpu(dev_part->base);
 	part_array[index].size = le64_to_cpu(dev_part->decode_length);
 	part_array[index].size *= CXL_CAPACITY_MULTIPLIER;
+	part_array[index].handle = le32_to_cpu(dev_part->dsmad_handle) & 0xFF;
 	len = le64_to_cpu(dev_part->length);
 	blk_size = le64_to_cpu(dev_part->block_size);
 
@@ -1453,6 +1454,7 @@ int cxl_dev_dc_identify(struct cxl_mailbox *mbox,
 	/* Return 1st partition */
 	dc_info->start = partitions[0].start;
 	dc_info->size = partitions[0].size;
+	dc_info->handle = partitions[0].handle;
 	dev_dbg(dev, "Returning partition 0 %zu size %zu\n",
 		dc_info->start, dc_info->size);
 
diff --git a/drivers/cxl/cxlmem.h b/drivers/cxl/cxlmem.h
index 057933128d2c..96d8edaa5003 100644
--- a/drivers/cxl/cxlmem.h
+++ b/drivers/cxl/cxlmem.h
@@ -104,6 +104,7 @@ struct cxl_dpa_info {
 	struct cxl_dpa_part_info {
 		struct range range;
 		enum cxl_partition_mode mode;
+		u8 handle;
 	} part[CXL_NR_PARTITIONS_MAX];
 	int nr_partitions;
 };
@@ -387,12 +388,14 @@ enum cxl_devtype {
  * @coord: QoS performance data (i.e. latency, bandwidth)
  * @cdat_coord: raw QoS performance data from CDAT
  * @qos_class: QoS Class cookies
+ * @shareable: Is the range sharable
  */
 struct cxl_dpa_perf {
 	struct range dpa_range;
 	struct access_coordinate coord[ACCESS_COORDINATE_MAX];
 	struct access_coordinate cdat_coord[ACCESS_COORDINATE_MAX];
 	int qos_class;
+	bool shareable;
 };
 
 /**
@@ -400,11 +403,13 @@ struct cxl_dpa_perf {
  * @res: shortcut to the partition in the DPA resource tree (cxlds->dpa_res)
  * @perf: performance attributes of the partition from CDAT
  * @mode: operation mode for the DPA capacity, e.g. ram, pmem, dynamic...
+ * @handle: DMASS handle intended to represent this partition
  */
 struct cxl_dpa_partition {
 	struct resource res;
 	struct cxl_dpa_perf perf;
 	enum cxl_partition_mode mode;
+	u8 handle;
 };
 
 /**
@@ -881,6 +886,7 @@ struct cxl_mem_dev_info {
 struct cxl_dc_partition_info {
 	size_t start;
 	size_t size;
+	u8 handle;
 };
 
 int cxl_dev_dc_identify(struct cxl_mailbox *mbox,

-- 
2.49.0


From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from mgamail.intel.com (mgamail.intel.com [192.198.163.18])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id 68981199230
	for <nvdimm@lists.linux.dev>; Sun, 13 Apr 2025 22:52:02 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=fail smtp.client-ip=192.198.163.18
ARC-Seal: i=2; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1744584724; cv=fail; b=WhyvYMKmZrNIWeHEksmf7IAYONPAC5WYBfkK/9sLcLCMeFEAifgh1lS+GTH4Df/XTmiVDRwbTGmDuPBDbetXP67ZJYoVp6xDOtuaToCRry1Hru/F7YfmtnokaY/Ldak54SgHxx6t+2fsmTjxxOFCw59xtX7KYAtoB/0fD2bW8UE=
ARC-Message-Signature: i=2; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1744584724; c=relaxed/simple;
	bh=QWIUOdTsybkdMzgUkQnUMwA8ER+kALdCrOEkHqc97M0=;
	h=From:Date:Subject:Content-Type:Message-ID:References:In-Reply-To:
	 To:CC:MIME-Version; b=vGHilzZb0SkPfN48RWdvtPgaerQ70S7BE8NFJz+RPRhwAuk3hDT6v0j+UkoqsuvolXvBcHZ6AFVqvMKV+BwpwKM2rC2XKuec1YR3d/maudVzSEE2b0NlDY+1aME06EgwKSnUFAWxuPTmm5kPsjX87vOkT/M58T1gt7MNL78Fa7c=
ARC-Authentication-Results: i=2; smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=intel.com; spf=pass smtp.mailfrom=intel.com; dkim=pass (2048-bit key) header.d=intel.com header.i=@intel.com header.b=d15mz+r+; arc=fail smtp.client-ip=192.198.163.18
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=intel.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=intel.com
Authentication-Results: smtp.subspace.kernel.org;
	dkim=pass (2048-bit key) header.d=intel.com header.i=@intel.com header.b="d15mz+r+"
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1744584723; x=1776120723;
  h=from:date:subject:content-transfer-encoding:message-id:
   references:in-reply-to:to:cc:mime-version;
  bh=QWIUOdTsybkdMzgUkQnUMwA8ER+kALdCrOEkHqc97M0=;
  b=d15mz+r+xUwzBS6sFU3K2pRkPiYzCXrMAU+kyVQPFhAv8pMedSOrq72T
   gN+EKh7UsiJI953JeguqWETuN1dJbNAeGGnDGHgFTmX1Qf2ckICCOf//c
   OCfHapnpZNRB6z6UvPpDCsJYVRea60aQHeo4emglCFKnbOTGAsrnFjnAw
   7W3EYAs4B3C6iuVsqD8aQz9CFj7wWHrCVKfHNliLcYYTKyzXTjW/j7qEf
   bwECXv9dcf7hClXj+2iyN1948UKN8ykpLLzKeT2bPPgfm/Df8lWr5bViM
   ZgDVmyb4z5PCH1jEFUWLkbGB0E0n/PI1zLM0B+b+KClq3CsfyGi/lX9yM
   Q==;
X-CSE-ConnectionGUID: +4DdVGUmQgy4vfaCq277Nw==
X-CSE-MsgGUID: 1Rbobwu6SZ6vcl1l2lPM5A==
X-IronPort-AV: E=McAfee;i="6700,10204,11402"; a="45280896"
X-IronPort-AV: E=Sophos;i="6.15,211,1739865600"; 
   d="scan'208";a="45280896"
Received: from fmviesa007.fm.intel.com ([10.60.135.147])
  by fmvoesa112.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 13 Apr 2025 15:52:00 -0700
X-CSE-ConnectionGUID: xV8WZal4TcSenoAGXnnouA==
X-CSE-MsgGUID: jwunai7NSvWhWqVLmlkJkA==
X-ExtLoop1: 1
X-IronPort-AV: E=Sophos;i="6.15,211,1739865600"; 
   d="scan'208";a="129657436"
Received: from orsmsx902.amr.corp.intel.com ([10.22.229.24])
  by fmviesa007.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 13 Apr 2025 15:52:00 -0700
Received: from ORSMSX901.amr.corp.intel.com (10.22.229.23) by
 ORSMSX902.amr.corp.intel.com (10.22.229.24) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.2.1544.14; Sun, 13 Apr 2025 15:51:59 -0700
Received: from ORSEDG602.ED.cps.intel.com (10.7.248.7) by
 ORSMSX901.amr.corp.intel.com (10.22.229.23) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.2.1544.14 via Frontend Transport; Sun, 13 Apr 2025 15:51:59 -0700
Received: from NAM11-BN8-obe.outbound.protection.outlook.com (104.47.58.168)
 by edgegateway.intel.com (134.134.137.103) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.44; Sun, 13 Apr 2025 15:51:59 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector10001; d=microsoft.com; cv=none;
 b=ULAItf1T2IQmu6+PeAAh3UhxpOXxsZdw2axXLN0AqE+s8w8s6pIKbKLr59xtfcqV/xM4eA2mnsUaws1+wUHUlnZf+GWj4pLwpx9sgRghqFvf7w6haRSsZHgNxcfMt5q8yYNh/IqWuj2TLqUBH8ZsDcLwtR0Ozn3c4NEVmZaFdJMjSYSIbU4qX9/CPwRtVVTiI0IsUSm1tUXXztwFS1WjJo0yeqJfPar3UpSXk8tzqgGPVm/lYRc2Uwfyr4p0qeWKHNy3nll2Bodq6NXsbKfrK+EqyEouLJYZPckgC9fOI3Sqb9RMJXvXtQRN4tSay9myNvByrDZbCZBFQjUcfhYo9w==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector10001;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=XRCSEVRqzMVLB9sUkTAqkxwHRS2MdCyEZXOrYPgN78Q=;
 b=xetbZdd/lvK62NBnL0hkUa4YP5Wc/4KUUJ2QFfuUY/ggDWIZOJmxDSx0SWnTmMNsYMB2u8X0VcyU5/QMZudp5hLYlIVJ8R4mmbl4IPWWbUsq1T5RmMAk7nvF+Cc73KQnm85VG/tDMupSdngjhrXqOjlZEGTxFIJzb7fnO2Ov4aLJr55xO4pGBZqjLP5g9Jzm+tHI47yMVEwQp8z82YrO/4KCQz1TSu6BKxVtX03+d4SDTzkDnH7KrM8XyxR0mJyPPz2UQ4EEjnIi1eKPmdlfDunpETQOV+rXkeyRyHPuEpQsR3UXBSfMSSdV+YZCN9HWYzG/o9+8FoaiVJqSaT+wkQ==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from MW4PR11MB6739.namprd11.prod.outlook.com (2603:10b6:303:20b::19)
 by DM4PR11MB6042.namprd11.prod.outlook.com (2603:10b6:8:61::18) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.8632.28; Sun, 13 Apr
 2025 22:51:48 +0000
Received: from MW4PR11MB6739.namprd11.prod.outlook.com
 ([fe80::a7ad:a6e8:fced:3f24]) by MW4PR11MB6739.namprd11.prod.outlook.com
 ([fe80::a7ad:a6e8:fced:3f24%4]) with mapi id 15.20.8606.033; Sun, 13 Apr 2025
 22:51:48 +0000
From: Ira Weiny <ira.weiny@intel.com>
Date: Sun, 13 Apr 2025 17:52:12 -0500
Subject: [PATCH v9 04/19] cxl/core: Enforce partition order/simplify
 partition calls
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: 7bit
Message-ID: <20250413-dcd-type2-upstream-v9-4-1d4911a0b365@intel.com>
References: <20250413-dcd-type2-upstream-v9-0-1d4911a0b365@intel.com>
In-Reply-To: <20250413-dcd-type2-upstream-v9-0-1d4911a0b365@intel.com>
To: Dave Jiang <dave.jiang@intel.com>, Fan Ni <fan.ni@samsung.com>, "Jonathan
 Cameron" <Jonathan.Cameron@huawei.com>
CC: Dan Williams <dan.j.williams@intel.com>, Davidlohr Bueso
	<dave@stgolabs.net>, Alison Schofield <alison.schofield@intel.com>, "Vishal
 Verma" <vishal.l.verma@intel.com>, Ira Weiny <ira.weiny@intel.com>,
	<linux-cxl@vger.kernel.org>, <nvdimm@lists.linux.dev>,
	<linux-kernel@vger.kernel.org>
X-Mailer: b4 0.15-dev-c25d1
X-Developer-Signature: v=1; a=ed25519-sha256; t=1744584735; l=6891;
 i=ira.weiny@intel.com; s=20221211; h=from:subject:message-id;
 bh=QWIUOdTsybkdMzgUkQnUMwA8ER+kALdCrOEkHqc97M0=;
 b=3xtF7gtSQBOSRiRuM4Pmou0rdAEf9ybrI8OOhE/D44AoGI4QrLYY9hv+/tlyPnGPaZITIvnzy
 zsQIqH6chMFDryjPBTBQ3WeHnzsUBEQiETeCCbhnYaVncOZgFSxDbQd
X-Developer-Key: i=ira.weiny@intel.com; a=ed25519;
 pk=noldbkG+Wp1qXRrrkfY1QJpDf7QsOEthbOT7vm0PqsE=
X-ClientProxiedBy: MW4PR03CA0227.namprd03.prod.outlook.com
 (2603:10b6:303:b9::22) To MW4PR11MB6739.namprd11.prod.outlook.com
 (2603:10b6:303:20b::19)
Precedence: bulk
X-Mailing-List: nvdimm@lists.linux.dev
List-Id: <nvdimm.lists.linux.dev>
List-Subscribe: <mailto:nvdimm+subscribe@lists.linux.dev>
List-Unsubscribe: <mailto:nvdimm+unsubscribe@lists.linux.dev>
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: MW4PR11MB6739:EE_|DM4PR11MB6042:EE_
X-MS-Office365-Filtering-Correlation-Id: cde2e068-9156-4a3a-6ff7-08dd7addc611
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;ARA:13230040|376014|1800799024|366016;
X-Microsoft-Antispam-Message-Info: =?utf-8?B?Z3RsbGg4TERVNFh3QlNQYWdJMUFpa2w4WXdrM0RiQXhyVm5EWTNmMklBMmJF?=
 =?utf-8?B?UThLVmJKL1c4RTZUMUJYL2FiSk01TFFSZUMwQThjMkJRL2tKVmhYTnJyaEFR?=
 =?utf-8?B?VC8vbGRtelhyRW5ZT0VZVkpiNGprM2IyVk8rNW5qRDFXY2gzS2hUYmJPYnM1?=
 =?utf-8?B?Vy9iYnV6NGlyVkQ5b2tFSEZOTHI2V3BPZ3gwcjV1ejl1OXppOWpMNkhvZjZC?=
 =?utf-8?B?Q3NrVllaeXlmUS9qc05WYzVOYWpTUGRFbjlkZmtBUFZQRTlBUVMrVWF3Wndl?=
 =?utf-8?B?MHJNbms5b1R0YmJVeERMM3FSdkNhdzFCZE9kRGNzNDY3MVRsNzliUitibDZ1?=
 =?utf-8?B?aERqNUd1NzhiT3FDai9zWFBMaTFoSzZ4V1pKM1NFaGpTMjk0ZEtSeExXR1Yr?=
 =?utf-8?B?cTAyU01kZ1ZuS2R4emFNdURpNHllc0NocXZwRlFtN1lIa1ZhRlBaeTFXMWVF?=
 =?utf-8?B?SnlBZGY1eVc4T3YxWmwwSjFJUDFSSDBMU2tXL2J4M0pGQVo2d3p2d2xIMFow?=
 =?utf-8?B?RURsbDZ1aDNHKzZ6SGx5SFB5a2tQSnZLam90a2tSZFkzVkxYdXpDZkFBRVMx?=
 =?utf-8?B?SUxNT1hlOTBxZ25sVy93Ky9BQjdlRWdzWU1MSEZ2V1o3TFozZjhIMWRNeVdZ?=
 =?utf-8?B?Wjl6akFHOUJGY0paSU5GekN0YzNGNUJZa3FpY3h3Q1IvMDlsaVF2TUVsZy83?=
 =?utf-8?B?WVFQdG80Ky9YY0JGbnVjVHpkc1d3WDUxQlNDc0hmcVEraGpraUwyN0VWSFkr?=
 =?utf-8?B?TlczR3VOOEU4ZTkxZitmWEhVZmJRc3VFU3JvdEwvNC8zeEhRL0J4Zjg3dnMy?=
 =?utf-8?B?QUtOaFB3Si96ZHF1cC9pZ3E3ejJrUk5uSUNZY1lQNi84bldRTGlKTlBIN3Jr?=
 =?utf-8?B?czVXWFJSZVJYRG51R0toVnlEdjluakVyZWJZM2p0MXNCOFpnRFd3MXJWUHdB?=
 =?utf-8?B?NW9ZVUJycWxpc3prNUtpVzJ0ekJ4SEVhV05SUVRtdGVsS2Fnd3RpZ211TU94?=
 =?utf-8?B?YktDanFvRlNQZW90QUZiV0VJeDdFTFdoSDRyaE1tZnprK1lUaVhQOFpDaDc0?=
 =?utf-8?B?eCtLaGg4czVBQzgzL3hOTmp5WERVeDRrWWpLVGNnT3pvdGlsWDdiUjYrbnBV?=
 =?utf-8?B?bGlPTldIK2pQeEFCYnpVSTl0VFVuSmhIeklOdDVPbXRaVitqNFBaNzQxMlRE?=
 =?utf-8?B?SktkUlNvZm5CNlJqc1VVL1ZXNHJmbnYyOThTanJ5RHNHY0dLSnFLenJOTE1Z?=
 =?utf-8?B?dGVRdTIvNjNSZkVkd2gyR0lJRDh0ZnZZMUZ6b2dlL0w4aE9XMUJtK1NxbVlZ?=
 =?utf-8?B?ZGFIeE5XNXdhNmxjUkxnZlBacTJxcjJvQzBVc0hTYWZwbndzRkxtNWM0MHkr?=
 =?utf-8?B?d1drOWdHSUs4Qnc5UGM2WVVjbEZsa2tKdURybjFVZUd0Y09meEdxZElRb0tq?=
 =?utf-8?B?OWFVUE1YU05rOWE4bW1QWGlDOTBiS2pYM1ZyODVuZitiSER2N3dKNUw4eThL?=
 =?utf-8?B?cnNSODRUQkMzLzdra0VyY25QZlhWK2xrZHVFOHQvcjhldzBRMW9MVUxnYlRF?=
 =?utf-8?B?ci9JeDVHUXQ3T2Jva1JlYUpCbnFhQVJsS0RTdDhjVm9nQnViY3BQUlJaMWxa?=
 =?utf-8?B?eCtwallnUmpBNlNwWjdHQTJaSHJCV2dJNHR3ZytTcDIyVzduUmlKZ1BPZENz?=
 =?utf-8?B?dVQydWNHaWtZWHA3U0Nzdlc2MStXVXBMVlVWUTJtWCs1SmNsVklDSlA1WXJE?=
 =?utf-8?B?TEsyVEtjNnBIcG0vYysyWFZORXNLZzNRMnY3NDZ0Wlc2TmJnUVFEMzZOWVhH?=
 =?utf-8?B?SFZXeE5RdVBBRGtZQkFIdU9OaHNtL2hqVUh0UFhmWGRmQjJCTkxzTWRIUEo5?=
 =?utf-8?B?WXp1em5OTGRTd1p5K29CdmhmK25HV2tJN2c4d21kSG92b2hXQW5QZDlzTlkr?=
 =?utf-8?Q?JEPU82XVzzU=3D?=
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:MW4PR11MB6739.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230040)(376014)(1800799024)(366016);DIR:OUT;SFP:1101;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?utf-8?B?NzB4VHVkQUFmVmVzTEJTQS9HTjNaRmZqVkN1MWE3Nnlia3JOTzY1Ykh4QW9k?=
 =?utf-8?B?ejlGa05BaDFQaU5zYlEySmhvejFPaXQ4YUVaWnRXRWc0R2JIWVVCN0ptTXlk?=
 =?utf-8?B?SjlRSWE2UVBoLzFXL2EzMHpxUE9HRnpiZmgyY09BK25sLzZxWXZib2xrc21C?=
 =?utf-8?B?c3REL2Jrd3lrd1V4OW5qNFpMRVpDcUVWcG04blBQTmc5MWxKck5QTlJzSWtj?=
 =?utf-8?B?TkUyTGpVZHVteVlxRXhaZHpGOUh3UE9ybno4RFhUMlFwMTdvUEtwRUFlMStD?=
 =?utf-8?B?aXdxK1dzNHFvMFoyUkRMemFBWXFJakQ5WFA3dGlFdHF5OXR6SVprTjJCNk9K?=
 =?utf-8?B?dGgycGhuQ3NBdS8vM2xhb0NrVUhWWU9rS2U5eWhpSUpWcERHT0tuT29jOG9n?=
 =?utf-8?B?Y0dha05yNzBGOWFHTWpYUG5Rb2ZFTEV2amxOa2poNWdqcmI0VHpMYURLNDNC?=
 =?utf-8?B?QzRoa1dlSDZWcTBhOXFUL1EzUnBxZmo1cFVzQzkxRkJMRDB5RzMwZjN5SnFK?=
 =?utf-8?B?UUVTRWg1dEZjOU81Ui9zeGlSem9yVURQbkl3K0N0UG15Y0lCVjdsb0lYSXdL?=
 =?utf-8?B?Z3NHZ3J0NlgzYVhTWHFiSDhhc2ZpWEp5RUVXR09paEgxVlJrUFIvU0RLekh6?=
 =?utf-8?B?VFp3T0hhV1hsbHdZRzkzeFQ1c0wrdEpKeENaMldEQUh6RG5pUnhxSzdlMTJG?=
 =?utf-8?B?Ui9OcXpYaUZNeWNtUzlxQUR0T0FQTXN2K1Y1U1k0Ynd1QXNCcUwwYmlTQ3d4?=
 =?utf-8?B?dmdqOTJ0VTRxMnpWaFVrd0pFSkhrZmhSQjFxdTQyeVJlQkdHdlJwcTRpRGpq?=
 =?utf-8?B?Y2JQWnNaems0S2E0WXFUcWNaSHJDV3RYQzJ2aERqTm5lM1VLbU9JSSsxbGdV?=
 =?utf-8?B?OWhPOU4yKzJQUFFvNitJSDEyZWlaM0VLM0VGZ3Q2cjZJdDVaUkJKYkFKdmZj?=
 =?utf-8?B?MmFXMG1ONmx6akd0NUpoMW8zMUVuTHhvTmltdm9wdEovRy9rMGk5V1JoRVhH?=
 =?utf-8?B?WW9JNXF0MEZPTzg0UVBYdjgyRjVSYm5qVGNhQm1MNmttU3NwOG9aek9Xd3h1?=
 =?utf-8?B?UFBCeVVtd1JmSGtwazFTNHB2czJQTVpsZ0o4KytCUlRuY0MxQVpVQ29oaDZV?=
 =?utf-8?B?QUR4YUZoc2dqMXFoKzBGUUlPdDJ0elNMd2RBOFI3Vkl5L0NMM3JtUFk3NXhu?=
 =?utf-8?B?VnlxajFqT21iN25XQmxLbE1mNHRwZzAwdkJialdSVEZFZkVoTDc0K05hUlZF?=
 =?utf-8?B?VWZncjJla0NrNHlSM1lvMVphZGhuN1ZXVVRmSlJsdzB4U0IzbzlqWjIyT2sr?=
 =?utf-8?B?eWRBTS8vT2M0VVJQejlkRXc3RlUrNXBXNDZ4VFN4bXNlV0lXOFhMd2MrU3ph?=
 =?utf-8?B?bW5leXdkRW5NdWNLNnNhaExXeHpjUDVyYTBFNFFFb3pGeXhMcitMLzB1akhB?=
 =?utf-8?B?Q0xUUmU4YzlqRHMxb1h3eUxNOGhSUzArdkRIc1pxWEZkUk0wVnlnaGxQRWdn?=
 =?utf-8?B?enZzejQyM2t4V2phV2ZyRnluNFk4QVBsVFFpUDUyQURSeEQ4aFdIak9rN3h2?=
 =?utf-8?B?WWl4a0V5TkRaT2g0ZFEyb2xjYWV1RllrMkVBSWxENVg3TThoNHo4dGx1Nzk1?=
 =?utf-8?B?TFdOaGZYa29WcmVnSk5zVkExcVBXUytVVFY2RXFTVnl1VWt0QXMyYS95YVNC?=
 =?utf-8?B?c1kwcVJGVzV1T01rU3VramxUcUVJNTdScENiSjI5bWt5cWc5eUlzY2JNWUpa?=
 =?utf-8?B?ZGlKWUxmdE0yVlhLZEp3ZnpuN1NOcWRaVmJxVDJ5SU5RRE5lNnYrTDU5NXFO?=
 =?utf-8?B?UnpGWjJ1V3NiYm5lV2tzejMwbDlXV1Zpa0N3U1dReC9nNU9YMEVKVDNDTSth?=
 =?utf-8?B?RkhBUG9Uc2tFc29taDJONytTc1ppUUVuNHcvYWQ2Mk1XZjNtcWNpM3dYT3BV?=
 =?utf-8?B?NktkTitYMXA4czhUSHl5M25hYjhOWTZ1SWxjdno0TXY0eUVYK1FydFZyV0FW?=
 =?utf-8?B?M0tNcFJhSTlhNWRQb2p5c2ppdUI4N2VJWThUcGhqVnRPT3dkZ1RPbEdQcVRG?=
 =?utf-8?B?eThXWEliVWdLUitTczJtZU1MMWNKWk9IL3pCbVlsaGMzM09uUkpNQlpXaFh4?=
 =?utf-8?Q?hFi9ygGlUxA0tWh7gUm4RHoHB?=
X-MS-Exchange-CrossTenant-Network-Message-Id: cde2e068-9156-4a3a-6ff7-08dd7addc611
X-MS-Exchange-CrossTenant-AuthSource: MW4PR11MB6739.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 13 Apr 2025 22:51:48.8167
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: pOB0zDvmq8rRIT6CZVl4SsF+r8siwZkL4OwBQhdjgKKpHL3OtGMSizu7+ivivNqP9CCq7t0WBHOw3PgYjNJG1A==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: DM4PR11MB6042
X-OriginatorOrg: intel.com
Status: O
Content-Length: 6697
Lines: 196

Device partitions have an implied order which is made more complex by
the addition of a dynamic partition.

Remove the ram special case information calls in favor of generic calls
with a check ahead of time to ensure the preservation of the implied
partition order.

Signed-off-by: Ira Weiny <ira.weiny@intel.com>
---
 drivers/cxl/core/hdm.c    | 11 ++++++++++-
 drivers/cxl/core/memdev.c | 32 +++++++++-----------------------
 drivers/cxl/cxl.h         |  1 +
 drivers/cxl/cxlmem.h      |  9 +++------
 drivers/cxl/mem.c         |  2 +-
 5 files changed, 24 insertions(+), 31 deletions(-)

diff --git a/drivers/cxl/core/hdm.c b/drivers/cxl/core/hdm.c
index c5f8a17d00f1..92e1a24e2109 100644
--- a/drivers/cxl/core/hdm.c
+++ b/drivers/cxl/core/hdm.c
@@ -470,6 +470,7 @@ static const char *cxl_mode_name(enum cxl_partition_mode mode)
 int cxl_dpa_setup(struct cxl_dev_state *cxlds, const struct cxl_dpa_info *info)
 {
 	struct device *dev = cxlds->dev;
+	int i;
 
 	guard(rwsem_write)(&cxl_dpa_rwsem);
 
@@ -482,9 +483,17 @@ int cxl_dpa_setup(struct cxl_dev_state *cxlds, const struct cxl_dpa_info *info)
 		return 0;
 	}
 
+	/* Verify partitions are in expected order. */
+	for (i = 1; i < info->nr_partitions; i++) {
+		if (cxlds->part[i].mode < cxlds->part[i-1].mode) {
+			dev_err(dev, "Partition order mismatch\n");
+			return 0;
+		}
+	}
+
 	cxlds->dpa_res = DEFINE_RES_MEM(0, info->size);
 
-	for (int i = 0; i < info->nr_partitions; i++) {
+	for (i = 0; i < info->nr_partitions; i++) {
 		const struct cxl_dpa_part_info *part = &info->part[i];
 		int rc;
 
diff --git a/drivers/cxl/core/memdev.c b/drivers/cxl/core/memdev.c
index a16a5886d40a..9d6f8800e37a 100644
--- a/drivers/cxl/core/memdev.c
+++ b/drivers/cxl/core/memdev.c
@@ -75,20 +75,12 @@ static ssize_t label_storage_size_show(struct device *dev,
 }
 static DEVICE_ATTR_RO(label_storage_size);
 
-static resource_size_t cxl_ram_size(struct cxl_dev_state *cxlds)
-{
-	/* Static RAM is only expected at partition 0. */
-	if (cxlds->part[0].mode != CXL_PARTMODE_RAM)
-		return 0;
-	return resource_size(&cxlds->part[0].res);
-}
-
 static ssize_t ram_size_show(struct device *dev, struct device_attribute *attr,
 			     char *buf)
 {
 	struct cxl_memdev *cxlmd = to_cxl_memdev(dev);
 	struct cxl_dev_state *cxlds = cxlmd->cxlds;
-	unsigned long long len = cxl_ram_size(cxlds);
+	unsigned long long len = cxl_part_size(cxlds, CXL_PARTMODE_RAM);
 
 	return sysfs_emit(buf, "%#llx\n", len);
 }
@@ -101,7 +93,7 @@ static ssize_t pmem_size_show(struct device *dev, struct device_attribute *attr,
 {
 	struct cxl_memdev *cxlmd = to_cxl_memdev(dev);
 	struct cxl_dev_state *cxlds = cxlmd->cxlds;
-	unsigned long long len = cxl_pmem_size(cxlds);
+	unsigned long long len = cxl_part_size(cxlds, CXL_PARTMODE_PMEM);
 
 	return sysfs_emit(buf, "%#llx\n", len);
 }
@@ -407,10 +399,11 @@ static struct attribute *cxl_memdev_attributes[] = {
 	NULL,
 };
 
-static struct cxl_dpa_perf *to_pmem_perf(struct cxl_dev_state *cxlds)
+static struct cxl_dpa_perf *part_perf(struct cxl_dev_state *cxlds,
+				      enum cxl_partition_mode mode)
 {
 	for (int i = 0; i < cxlds->nr_partitions; i++)
-		if (cxlds->part[i].mode == CXL_PARTMODE_PMEM)
+		if (cxlds->part[i].mode == mode)
 			return &cxlds->part[i].perf;
 	return NULL;
 }
@@ -421,7 +414,7 @@ static ssize_t pmem_qos_class_show(struct device *dev,
 	struct cxl_memdev *cxlmd = to_cxl_memdev(dev);
 	struct cxl_dev_state *cxlds = cxlmd->cxlds;
 
-	return sysfs_emit(buf, "%d\n", to_pmem_perf(cxlds)->qos_class);
+	return sysfs_emit(buf, "%d\n", part_perf(cxlds, CXL_PARTMODE_PMEM)->qos_class);
 }
 
 static struct device_attribute dev_attr_pmem_qos_class =
@@ -433,20 +426,13 @@ static struct attribute *cxl_memdev_pmem_attributes[] = {
 	NULL,
 };
 
-static struct cxl_dpa_perf *to_ram_perf(struct cxl_dev_state *cxlds)
-{
-	if (cxlds->part[0].mode != CXL_PARTMODE_RAM)
-		return NULL;
-	return &cxlds->part[0].perf;
-}
-
 static ssize_t ram_qos_class_show(struct device *dev,
 				  struct device_attribute *attr, char *buf)
 {
 	struct cxl_memdev *cxlmd = to_cxl_memdev(dev);
 	struct cxl_dev_state *cxlds = cxlmd->cxlds;
 
-	return sysfs_emit(buf, "%d\n", to_ram_perf(cxlds)->qos_class);
+	return sysfs_emit(buf, "%d\n", part_perf(cxlds, CXL_PARTMODE_RAM)->qos_class);
 }
 
 static struct device_attribute dev_attr_ram_qos_class =
@@ -482,7 +468,7 @@ static umode_t cxl_ram_visible(struct kobject *kobj, struct attribute *a, int n)
 {
 	struct device *dev = kobj_to_dev(kobj);
 	struct cxl_memdev *cxlmd = to_cxl_memdev(dev);
-	struct cxl_dpa_perf *perf = to_ram_perf(cxlmd->cxlds);
+	struct cxl_dpa_perf *perf = part_perf(cxlmd->cxlds, CXL_PARTMODE_RAM);
 
 	if (a == &dev_attr_ram_qos_class.attr &&
 	    (!perf || perf->qos_class == CXL_QOS_CLASS_INVALID))
@@ -501,7 +487,7 @@ static umode_t cxl_pmem_visible(struct kobject *kobj, struct attribute *a, int n
 {
 	struct device *dev = kobj_to_dev(kobj);
 	struct cxl_memdev *cxlmd = to_cxl_memdev(dev);
-	struct cxl_dpa_perf *perf = to_pmem_perf(cxlmd->cxlds);
+	struct cxl_dpa_perf *perf = part_perf(cxlmd->cxlds, CXL_PARTMODE_PMEM);
 
 	if (a == &dev_attr_pmem_qos_class.attr &&
 	    (!perf || perf->qos_class == CXL_QOS_CLASS_INVALID))
diff --git a/drivers/cxl/cxl.h b/drivers/cxl/cxl.h
index a9d42210e8a3..4bb0ff4d8f5f 100644
--- a/drivers/cxl/cxl.h
+++ b/drivers/cxl/cxl.h
@@ -482,6 +482,7 @@ struct cxl_region_params {
 	resource_size_t cache_size;
 };
 
+/* Modes should be in the implied DPA order */
 enum cxl_partition_mode {
 	CXL_PARTMODE_RAM,
 	CXL_PARTMODE_PMEM,
diff --git a/drivers/cxl/cxlmem.h b/drivers/cxl/cxlmem.h
index 96d8edaa5003..a74ac2d70d8d 100644
--- a/drivers/cxl/cxlmem.h
+++ b/drivers/cxl/cxlmem.h
@@ -453,14 +453,11 @@ struct cxl_dev_state {
 #endif
 };
 
-static inline resource_size_t cxl_pmem_size(struct cxl_dev_state *cxlds)
+static inline resource_size_t cxl_part_size(struct cxl_dev_state *cxlds,
+					    enum cxl_partition_mode mode)
 {
-	/*
-	 * Static PMEM may be at partition index 0 when there is no static RAM
-	 * capacity.
-	 */
 	for (int i = 0; i < cxlds->nr_partitions; i++)
-		if (cxlds->part[i].mode == CXL_PARTMODE_PMEM)
+		if (cxlds->part[i].mode == mode)
 			return resource_size(&cxlds->part[i].res);
 	return 0;
 }
diff --git a/drivers/cxl/mem.c b/drivers/cxl/mem.c
index 9675243bd05b..b58b915708f9 100644
--- a/drivers/cxl/mem.c
+++ b/drivers/cxl/mem.c
@@ -152,7 +152,7 @@ static int cxl_mem_probe(struct device *dev)
 		return -ENXIO;
 	}
 
-	if (cxl_pmem_size(cxlds) && IS_ENABLED(CONFIG_CXL_PMEM)) {
+	if (cxl_part_size(cxlds, CXL_PARTMODE_PMEM) && IS_ENABLED(CONFIG_CXL_PMEM)) {
 		rc = devm_cxl_add_nvdimm(parent_port, cxlmd);
 		if (rc) {
 			if (rc == -ENODEV)

-- 
2.49.0


From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from mgamail.intel.com (mgamail.intel.com [192.198.163.18])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id 088F919C558
	for <nvdimm@lists.linux.dev>; Sun, 13 Apr 2025 22:52:02 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=fail smtp.client-ip=192.198.163.18
ARC-Seal: i=2; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1744584725; cv=fail; b=NakTxLkhTvNWZLvcCeHCgKX9ryGaNWcQ56TTv6xGqC4NzY/2rfoT6mBV7g2mUL8BBXC21xWOTgsYPnN+nlARJz0T1YZQRzVk1uUvc9fAFuPcigglDpFvBVRS99ivIt0Pxewkq7XTPlpAlDB4jesNLg3EIu7qymfoWAXv2+xAFTU=
ARC-Message-Signature: i=2; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1744584725; c=relaxed/simple;
	bh=TdJg89owSQ09YHez2+5qf+RnBC3Budv6uZ6C5fSYAY0=;
	h=From:Date:Subject:Content-Type:Message-ID:References:In-Reply-To:
	 To:CC:MIME-Version; b=CD3EGM4xodYY9pisEb4dxl5SLlZ1hBqoW5eVe3szNo9MZ+Dqxy6/5usnH1+l+RpnrtcusbGAFEPn/Zc9vUOWgEJDyemP5vG1YNQCG4XCfQ2l8DRzsy0Xr/9P+DmvLnibC5hhjAWzKfhBXF5Oxa9cnZJCEmdJoJbGOjL9FUFpDgU=
ARC-Authentication-Results: i=2; smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=intel.com; spf=pass smtp.mailfrom=intel.com; dkim=pass (2048-bit key) header.d=intel.com header.i=@intel.com header.b=hYffbEKi; arc=fail smtp.client-ip=192.198.163.18
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=intel.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=intel.com
Authentication-Results: smtp.subspace.kernel.org;
	dkim=pass (2048-bit key) header.d=intel.com header.i=@intel.com header.b="hYffbEKi"
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1744584723; x=1776120723;
  h=from:date:subject:content-transfer-encoding:message-id:
   references:in-reply-to:to:cc:mime-version;
  bh=TdJg89owSQ09YHez2+5qf+RnBC3Budv6uZ6C5fSYAY0=;
  b=hYffbEKi645vUf6v/TvdkYDXgLoDUDOQZAgmh+Wo3pmQm6ELarjJWlWm
   6mbYHJIjE3mMbQnm5xY3lumZCpQodAicKSwTYDZVvKI5zzYKay06/Dlep
   mGvaTsXDeWdUUL3XLyweywKACgpIIr5f/7oK+oAs8Db8Dmj/5oA3W7+Ui
   z74qYPU7YwFlwbbMaGRO6vcWMXX5A4Tk0p6suvQXpL9NIT6ACkJI/vgVT
   7DfIwWZoexlET8sn8CI62z+0RR3/gEBJGl8Wa2SgHMzU41LT5SdzI8haZ
   873X4PvsgftixXO1SBXkJliIKJK1HYu6QBDfsg1iaN3snRgwZIbRl0UPY
   A==;
X-CSE-ConnectionGUID: QdHIq2jmRjyC6UW/tlhxXA==
X-CSE-MsgGUID: kYkqfBkjTJaMARwq8THesg==
X-IronPort-AV: E=McAfee;i="6700,10204,11402"; a="45280901"
X-IronPort-AV: E=Sophos;i="6.15,211,1739865600"; 
   d="scan'208";a="45280901"
Received: from fmviesa007.fm.intel.com ([10.60.135.147])
  by fmvoesa112.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 13 Apr 2025 15:52:01 -0700
X-CSE-ConnectionGUID: cw9qAucuTI2MxsEE9TmFfw==
X-CSE-MsgGUID: R7Vezj7yQ8ijVOd8oT602Q==
X-ExtLoop1: 1
X-IronPort-AV: E=Sophos;i="6.15,211,1739865600"; 
   d="scan'208";a="129657443"
Received: from orsmsx902.amr.corp.intel.com ([10.22.229.24])
  by fmviesa007.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 13 Apr 2025 15:52:00 -0700
Received: from ORSMSX901.amr.corp.intel.com (10.22.229.23) by
 ORSMSX902.amr.corp.intel.com (10.22.229.24) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.2.1544.14; Sun, 13 Apr 2025 15:52:00 -0700
Received: from ORSEDG602.ED.cps.intel.com (10.7.248.7) by
 ORSMSX901.amr.corp.intel.com (10.22.229.23) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.2.1544.14 via Frontend Transport; Sun, 13 Apr 2025 15:52:00 -0700
Received: from NAM11-BN8-obe.outbound.protection.outlook.com (104.47.58.168)
 by edgegateway.intel.com (134.134.137.103) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.44; Sun, 13 Apr 2025 15:51:59 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector10001; d=microsoft.com; cv=none;
 b=eBQaFRjOMLZaAKTugbGzGxbqDEMSIEevlin4ZoQ69Skwzg6WfIihHzEvfS1cIL4KmSGF+Q8QRiPyErSo7m/cotiDMaSLS8vnHQIeEFY7aODDnhmv3X5TNywPa0ucv6AAh522BH8qcRMsM7Ij54Ah8YZ0k//s7CDP0lrujKNrGjaZ3BzCn+dzPSiIVqOBm3k2owyeOGWdJCezV/Q2ohVo/KwcwazS0aDlWmvn8ffA91V0UXK/P1M0bH/pqzWUEkE8fyx+msAnxfCdxDgK10W3HlbzqPbmKtcHK5WffLVGcCCULalo8xr/oyqO/eGS5dLJLns8//u6GsnyTlf6Y0HDBg==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector10001;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=zpWif/CnuOIudWRzPn5nWqW7axZb6SRcXPd+Zv+hJJo=;
 b=M1BjPQ1leSW9dUq652ZbZIWjq+EN5BjJE6osGwBIy5mRoqa/99l31NF/M1AYaMgwzKYKRsV6A8PiLCvH5zFTYAKZ8TeA3crMQmDKEKraOKTLc/ne93pRNVqQy2f+n2FsEfzo2yg6aZRgEQH4RNVGEMDbdcNKf7IF5M7yy/0g1S8w0ewLeEtyNpIs9djoRAWw80ZHOg2QTfu/1m3lBbJeQnNL8b7HtiBwRHENw2BVkbmxie4vBaav8qjgrthZ1VnFaIM14KC5Km3R1wjYdeUxmDyCMy2NUWNWSUmXLVMXAkgjYpVYzVyYqI/pV4+hxzNhpIpyFU9ktdjKUypQlc+EGA==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from MW4PR11MB6739.namprd11.prod.outlook.com (2603:10b6:303:20b::19)
 by DM4PR11MB6042.namprd11.prod.outlook.com (2603:10b6:8:61::18) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.8632.28; Sun, 13 Apr
 2025 22:51:50 +0000
Received: from MW4PR11MB6739.namprd11.prod.outlook.com
 ([fe80::a7ad:a6e8:fced:3f24]) by MW4PR11MB6739.namprd11.prod.outlook.com
 ([fe80::a7ad:a6e8:fced:3f24%4]) with mapi id 15.20.8606.033; Sun, 13 Apr 2025
 22:51:50 +0000
From: Ira Weiny <ira.weiny@intel.com>
Date: Sun, 13 Apr 2025 17:52:13 -0500
Subject: [PATCH v9 05/19] cxl/mem: Expose dynamic ram A partition in sysfs
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: 7bit
Message-ID: <20250413-dcd-type2-upstream-v9-5-1d4911a0b365@intel.com>
References: <20250413-dcd-type2-upstream-v9-0-1d4911a0b365@intel.com>
In-Reply-To: <20250413-dcd-type2-upstream-v9-0-1d4911a0b365@intel.com>
To: Dave Jiang <dave.jiang@intel.com>, Fan Ni <fan.ni@samsung.com>, "Jonathan
 Cameron" <Jonathan.Cameron@huawei.com>
CC: Dan Williams <dan.j.williams@intel.com>, Davidlohr Bueso
	<dave@stgolabs.net>, Alison Schofield <alison.schofield@intel.com>, "Vishal
 Verma" <vishal.l.verma@intel.com>, Ira Weiny <ira.weiny@intel.com>,
	<linux-cxl@vger.kernel.org>, <nvdimm@lists.linux.dev>,
	<linux-kernel@vger.kernel.org>
X-Mailer: b4 0.15-dev-c25d1
X-Developer-Signature: v=1; a=ed25519-sha256; t=1744584735; l=5374;
 i=ira.weiny@intel.com; s=20221211; h=from:subject:message-id;
 bh=TdJg89owSQ09YHez2+5qf+RnBC3Budv6uZ6C5fSYAY0=;
 b=bYaZ8kzJIjb8F8TRq5BXse1Q94wKep+lL9bHykZ8N+OJ0h4nKYHFt6wGA7a7K6RPoLilfcLqD
 R47OVHjjVT4BOdGO4lMq24TVqNMRpIdQCV7KvHoihEDvEA3JoSLld4q
X-Developer-Key: i=ira.weiny@intel.com; a=ed25519;
 pk=noldbkG+Wp1qXRrrkfY1QJpDf7QsOEthbOT7vm0PqsE=
X-ClientProxiedBy: MW4PR03CA0227.namprd03.prod.outlook.com
 (2603:10b6:303:b9::22) To MW4PR11MB6739.namprd11.prod.outlook.com
 (2603:10b6:303:20b::19)
Precedence: bulk
X-Mailing-List: nvdimm@lists.linux.dev
List-Id: <nvdimm.lists.linux.dev>
List-Subscribe: <mailto:nvdimm+subscribe@lists.linux.dev>
List-Unsubscribe: <mailto:nvdimm+unsubscribe@lists.linux.dev>
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: MW4PR11MB6739:EE_|DM4PR11MB6042:EE_
X-MS-Office365-Filtering-Correlation-Id: 22ed960e-0423-4f3c-0fa4-08dd7addc71e
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;ARA:13230040|376014|1800799024|366016;
X-Microsoft-Antispam-Message-Info: =?utf-8?B?YzBrdHZsWHM4OTROci9LSGhObXMyVG44WDROY055R2xIa0N2R3poSi9JOEpn?=
 =?utf-8?B?Q2xMMFBpTUZRTlJnQnB0bjZpMElJRUcxSnQzK1ZRTDFFV0Y5dXhUai9UNlJY?=
 =?utf-8?B?b1lBaUNlcnRZUFVmY1VSK01xeHBmRTZnNnpsUG5VWjE5UkVveDhHSThhVldF?=
 =?utf-8?B?UXJmM0E2Y05sM2c2bEZST1E1bGtLa1p0d01CSC83UmlKVlRZNXFnd1RQM1Rz?=
 =?utf-8?B?YlIwMit4TUJBb1UybWtyeG1RbldRclRIb1lNL29nRDEyaWVYWUVxMUUyZWhS?=
 =?utf-8?B?b3ZUWjNIR2M1WDI1OFhqc3BEYU1aTVQySCsxdFh2bnBKUXRsWllVS0FLMzNs?=
 =?utf-8?B?NkR1bUh6RXFxRDBsejBUV2NmSW9paDdzNHJkSTlnZlFudk9ZREU1Z0x2Wndk?=
 =?utf-8?B?WVZDOEgyNlU1c2tIS1ZTMXpEcXFpWGo1NHlDZDZPeWdmSUcrUDFVenoxL0FO?=
 =?utf-8?B?WWtwUnRBZElJalNONkw5NldJVmtkZTA4T2didS91eWhKRnd3Tjd5dnZLWkhZ?=
 =?utf-8?B?bkd2Qk9vSTNicllBN3pyTHp5WmlYYjdkWHZYRUdHUERLWU4wVmw3MFc5dkND?=
 =?utf-8?B?ZWFlWnpDbE9FMGRMcGZXZFhJL20wRkN3bXlOcGFIM3RYdDY2T241UEFCTWQz?=
 =?utf-8?B?U3RFcEdtWmM5c1JuL2xIQmozV3IwNlQ2bFFvNkRiaXNQTG9qTUNIdkJNZlFj?=
 =?utf-8?B?NkV5bDlPQ3VDcXJaa1c0VWJpbjNwZlArbzFJVFlDVjNMZWZEakk4WkJ3UmVQ?=
 =?utf-8?B?bnR2QW4wbm5EUWZMUHg4dm02My9qdTZkcTM3NTI2ZzhjaEl6WXFlMG5mRGJm?=
 =?utf-8?B?RkdMekVyanRJVlBic24vbTM2K0RSb2Z1czhBVnRCUkNiTlBReVVkb3pTcHE1?=
 =?utf-8?B?dkE0anhMcy9vUEJqNlBYRjBqaW11SHdmUTNEWk1ndWhLT2h1VjhRaUs4VGtK?=
 =?utf-8?B?Yk5yd2F0d3VjVVZuNkxqNjRTR0V3MXJYZmlhMEV4Rk90TlM5QUs1K2EyRUNW?=
 =?utf-8?B?Z2d3RTJ2UzNCaGRUN1p6RUplQWFhTytseVpNM2w5MGExWDQ4YjRCdGtTZFhy?=
 =?utf-8?B?L2xwRWt0d0ptOW1ucDBZNTQ3QTY3NHkybWN0bHoyQXVZa0IwVWFjck0xdWxX?=
 =?utf-8?B?S3VOM2NDSFNWUmE2cTlkM2NmU09MbWtsdnlOdnRGYkVDcVlOeHlDNkNCaDRo?=
 =?utf-8?B?S1hXSUFzN2hKR1prOUs3WDFCb1IrckNRbWNOWUdCaUprRmNTSjJ4aWM5ZEFG?=
 =?utf-8?B?L2pSNjRzV00rOUxwTS9ZMWFoZmR0OWlyTktKcXZCb2hDc2N1UlFGSGVlUnpx?=
 =?utf-8?B?dFZOYlg4eFFYNHdDUHY4Z043UUNsRnRFWE4vRTZxSGZ4NDhFUkpnK0hsQVY4?=
 =?utf-8?B?L21QRHJtSCtvYzMzTkFVSU1nc3NhS1hFNEV5Ukdod2I5SUJRVmswc2E3QWZl?=
 =?utf-8?B?WWNjeVJFSnpKRmszVTlGcFBCcTZsUjRVbG04Q2VCZk1ndnVaNFVkcExPRUtV?=
 =?utf-8?B?QWd5WnZrR3pIcjN0amhyWnF4QmJFUGIxYTRvT0hFdkFYZzFlcTczd0pjMTNt?=
 =?utf-8?B?SVY3MWZXWG1KL1dtcEFuS3pWa1dYUkJPeGY1TGxMSnV5cUhHNmN3cW1wcEdK?=
 =?utf-8?B?UzYxaFRLZU5rOElzTnBySUZ3SE10WUhtRU1yZWxhMk5VVGJOSkQ4UGdqMjda?=
 =?utf-8?B?dFR6WEJpYjBLR082UkN5NUp5bFlITVlPdEg3M3ZjYjAwUk92OVNTWStnQW81?=
 =?utf-8?B?cnNrRTUyaXNZeWRCaFIxcm5iOWFaczdDZ0FLSlY4MTN6MlYyN0E5MC9FQ2Zr?=
 =?utf-8?B?SVJvaUlVZW0yamJsN1JtL29NcDcrL3plcVY5SUY2N2Mra3JrRzZpNFFRaktt?=
 =?utf-8?B?T0JDUmh2TU91MnpTRVdGWUxFTGR1MWRNQlRaZ2o1akk5aS95UzZyQnpSRHY2?=
 =?utf-8?Q?OrtUc/+5Hyc=3D?=
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:MW4PR11MB6739.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230040)(376014)(1800799024)(366016);DIR:OUT;SFP:1101;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?utf-8?B?aEIvNit2bjdBc2tVeUVzcC9JV1BOanB3ZW5IM1FMVVprWWVWdkZWYVBQbWRo?=
 =?utf-8?B?TEowQ0doMnVXaityNDZvOFcwb0VZVktjc05KUjFxTlk5bU9hTlJuMTdidjNU?=
 =?utf-8?B?aWNhWFpPM0xoWGl4elFJY1pNV2wzMFZaajJtTE45dUs4amxlNUlaWERvR2VO?=
 =?utf-8?B?eXVqdDRSQmsvMHVlZy8wUkM1bFhXbFlLMEwxL1NibFFWaEY3SE1FaHFBMXIr?=
 =?utf-8?B?R0hNeWpJbjRBRlJhT3dqd0JDYWZOY2tGY1ZjcWM0aDJ4YXEwdHBKOXBxZVcr?=
 =?utf-8?B?SzBLYUdTRjQrRmt1Z01pdlVwVy9ndWpxRUVvM0RaNkM3V2xsNHBaeG5BQUda?=
 =?utf-8?B?SUJIV2hPVVgwQUVpeGdlSEFhc2FpKzhORXlWeDdnWDBlcWoxN2Fvbm13VmpH?=
 =?utf-8?B?Z3JhdWlxVCtYWDdmSkJZcWdsUGVZRmJTVTc1encwUitPZjNWVXcxOE5lT3Bp?=
 =?utf-8?B?MkRiZUd4STU4ZWdiYWpSdzE3NDBzck1hV3ZTMVI0RnQ1Y2p6VUNFSE43Wlhk?=
 =?utf-8?B?SHovUndTRWl0bW5qYVRJMHBtRksrMVFaMHVlQzVNeW8rNm1JTVpsWjdJTnps?=
 =?utf-8?B?S3E2SnlSRG9TNlRFRGxpUTEwVWZmNEwxUURDcTh2d05jMFNLQzFPQXUraUtU?=
 =?utf-8?B?TThvcm5YelFkU0xaMEVsSksxa1d3RzB0UktVSEVmYU5rZG9TM0tDT3ZPNlM2?=
 =?utf-8?B?OGxsTCs2RHRqZ1o2ZUhCTFZmVmIxSTRjSFZ2TjJRNzB6YUdwc2swT2V5c2lQ?=
 =?utf-8?B?TWlvRTVSazNRVFZPYk12TXR2emhqSXVhb3VHdUVYT3ZQWjBjSDhUMlpCTEpE?=
 =?utf-8?B?YVMvaW9rMG9OTVV4QWlRTndwcU43dEMxZEE2MVRRNVcyWTBnSE9XQ0VsbFVU?=
 =?utf-8?B?VWJLMnQ0ZDdNN3h1YzhNZEpyNWlqaEhEdEM1UHdPTkFiRENlV1FpaCtkNTJ0?=
 =?utf-8?B?clh3SWYyenNZK1FDQ1I5cUlkZlhJQW9UWDBGS1g1TzMrb3orNmkwd2txYmJB?=
 =?utf-8?B?VDQ5TTlJbzIyVTNEdmxDMWJMQlFibXJkVGZ1VUlYUlp4ZXV4RXhqR0JCTHpO?=
 =?utf-8?B?YlZ1VVByekxzK3JUVEU5NWZDTW1MRXJKRGxIVVZLMFA4YkJzVXp5Z01FNDF4?=
 =?utf-8?B?Z2E0SGV0bHdLRWlVV2tWUm9CQ05TMzhaK0F5R2xsMHpURU9xWFgvWnR0WlVx?=
 =?utf-8?B?WklGRHEyc0ZQaWlvQnZmOXpjbVZxaUh5elNac1NFZTNRY2g1RjgyRm1YUE96?=
 =?utf-8?B?U2VWNmhsWFZMWmcwOFVYY3JmUWR6ckowSm1lRXBYTFh1OVBqeDlMbTZYakMr?=
 =?utf-8?B?cFFJQUpkTU5nRzI3OEgyQThWSjRaZWJOSXN1OVRvQkIzTVZQdkRYTzVPcTBm?=
 =?utf-8?B?S0ZNUjAwK3I2NUJrdTJmVEVqQStHMnZhTjZlbWVkMkxVNDd5Y2lKMUhISHJn?=
 =?utf-8?B?Z09BdXpsdTUyTDJxaEpqR1M4OVRpOFNZeG52bTBFOTBReUxsUHhLYWRwYW5C?=
 =?utf-8?B?by9zZHZ3RHpiUDVBN01tN084elVIQ3hSVGRWSE5RRUU3Q09Bc1Z2NTdCK3N2?=
 =?utf-8?B?dWtiMlNCOEhVdTZpbVlqVklsUFIyOHBRY2RMc2JXNUVkMVdvZ0lFSldZOHVH?=
 =?utf-8?B?SzJuaGpCb1VodytSY0FhTklVS3oxVTBxaHJmY2pETUpvRUxBRlhuU2ZJRmow?=
 =?utf-8?B?TUdXTmVWR1lHSlBpRUxtRng0a0QrWXRQR3JaRkhGWHZPSGhheGJBOWdFU0hr?=
 =?utf-8?B?eUVJZWI5K2lBcmg4M1lYWG5zNUNzOTd1RGxDZjM5VldZOTZjZDhOMG9XTFF2?=
 =?utf-8?B?MXRvOHNTNUFueTFFZ281MU03NmFuRUQ2Y3hxR2ppam0yVUp6VFN6Um9pb213?=
 =?utf-8?B?elJ3U3pUOTRLTC9MeUtmNVVacGZseVhOVENHT01IazNkQVhELys0SVVRVUhk?=
 =?utf-8?B?ZTQ1U2FrUlZzeW9jZmNvVTYxeENtQmdZTVhPWHFYQzF0NEYzSGdGck5MN2hj?=
 =?utf-8?B?dFJvVGszYWF2ZHpBOVdDN3VvZysxZTUyeDBOTEZKdXY3Znk5RTVnTVhCRTM5?=
 =?utf-8?B?dHhlN0pTK25OS3VHNmV5Ymo0MUtjOEpSU00vZ1BaMzVkUDJrK2ZyS0FpZGhN?=
 =?utf-8?Q?JEwShftjc9ycBc2hlNWziK7Hd?=
X-MS-Exchange-CrossTenant-Network-Message-Id: 22ed960e-0423-4f3c-0fa4-08dd7addc71e
X-MS-Exchange-CrossTenant-AuthSource: MW4PR11MB6739.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 13 Apr 2025 22:51:50.5782
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: s89zLihhIQAAQ/wHPymdfRXuw1qTU4e5TIr+nG/ncRTMlKTlWrno2qPgke8hv7OqQaJ2o673ztDowHLCyV9ZKA==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: DM4PR11MB6042
X-OriginatorOrg: intel.com
Status: O
Content-Length: 5226
Lines: 150

To properly configure CXL regions user space will need to know the
details of the dynamic ram partition.

Expose the first dynamic ram partition through sysfs.

Signed-off-by: Ira Weiny <ira.weiny@intel.com>

---
Changes:
[iweiny: Complete rewrite of the old patch.]
---
 Documentation/ABI/testing/sysfs-bus-cxl | 24 ++++++++++++++
 drivers/cxl/core/memdev.c               | 57 +++++++++++++++++++++++++++++++++
 2 files changed, 81 insertions(+)

diff --git a/Documentation/ABI/testing/sysfs-bus-cxl b/Documentation/ABI/testing/sysfs-bus-cxl
index 99bb3faf7a0e..2b59041bb410 100644
--- a/Documentation/ABI/testing/sysfs-bus-cxl
+++ b/Documentation/ABI/testing/sysfs-bus-cxl
@@ -89,6 +89,30 @@ Description:
 		and there are platform specific performance related
 		side-effects that may result. First class-id is displayed.
 
+What:		/sys/bus/cxl/devices/memX/dynamic_ram_a/size
+Date:		May, 2025
+KernelVersion:	v6.16
+Contact:	linux-cxl@vger.kernel.org
+Description:
+		(RO) The first Dynamic RAM partition capacity as bytes.
+
+
+What:		/sys/bus/cxl/devices/memX/dynamic_ram_a/qos_class
+Date:		May, 2025
+KernelVersion:	v6.16
+Contact:	linux-cxl@vger.kernel.org
+Description:
+		(RO) For CXL host platforms that support "QoS Telemmetry"
+		this attribute conveys a comma delimited list of platform
+		specific cookies that identifies a QoS performance class
+		for the persistent partition of the CXL mem device. These
+		class-ids can be compared against a similar "qos_class"
+		published for a root decoder. While it is not required
+		that the endpoints map their local memory-class to a
+		matching platform class, mismatches are not recommended
+		and there are platform specific performance related
+		side-effects that may result. First class-id is displayed.
+
 
 What:		/sys/bus/cxl/devices/memX/serial
 Date:		January, 2022
diff --git a/drivers/cxl/core/memdev.c b/drivers/cxl/core/memdev.c
index 9d6f8800e37a..063a14c1973a 100644
--- a/drivers/cxl/core/memdev.c
+++ b/drivers/cxl/core/memdev.c
@@ -101,6 +101,19 @@ static ssize_t pmem_size_show(struct device *dev, struct device_attribute *attr,
 static struct device_attribute dev_attr_pmem_size =
 	__ATTR(size, 0444, pmem_size_show, NULL);
 
+static ssize_t dynamic_ram_a_size_show(struct device *dev, struct device_attribute *attr,
+			      char *buf)
+{
+	struct cxl_memdev *cxlmd = to_cxl_memdev(dev);
+	struct cxl_dev_state *cxlds = cxlmd->cxlds;
+	unsigned long long len = cxl_part_size(cxlds, CXL_PARTMODE_DYNAMIC_RAM_A);
+
+	return sysfs_emit(buf, "%#llx\n", len);
+}
+
+static struct device_attribute dev_attr_dynamic_ram_a_size =
+	__ATTR(size, 0444, dynamic_ram_a_size_show, NULL);
+
 static ssize_t serial_show(struct device *dev, struct device_attribute *attr,
 			   char *buf)
 {
@@ -426,6 +439,25 @@ static struct attribute *cxl_memdev_pmem_attributes[] = {
 	NULL,
 };
 
+static ssize_t dynamic_ram_a_qos_class_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct cxl_memdev *cxlmd = to_cxl_memdev(dev);
+	struct cxl_dev_state *cxlds = cxlmd->cxlds;
+
+	return sysfs_emit(buf, "%d\n",
+			  part_perf(cxlds, CXL_PARTMODE_DYNAMIC_RAM_A)->qos_class);
+}
+
+static struct device_attribute dev_attr_dynamic_ram_a_qos_class =
+	__ATTR(qos_class, 0444, dynamic_ram_a_qos_class_show, NULL);
+
+static struct attribute *cxl_memdev_dynamic_ram_a_attributes[] = {
+	&dev_attr_dynamic_ram_a_size.attr,
+	&dev_attr_dynamic_ram_a_qos_class.attr,
+	NULL,
+};
+
 static ssize_t ram_qos_class_show(struct device *dev,
 				  struct device_attribute *attr, char *buf)
 {
@@ -502,6 +534,29 @@ static struct attribute_group cxl_memdev_pmem_attribute_group = {
 	.is_visible = cxl_pmem_visible,
 };
 
+static umode_t cxl_dynamic_ram_a_visible(struct kobject *kobj, struct attribute *a, int n)
+{
+	struct device *dev = kobj_to_dev(kobj);
+	struct cxl_memdev *cxlmd = to_cxl_memdev(dev);
+	struct cxl_dpa_perf *perf = part_perf(cxlmd->cxlds, CXL_PARTMODE_DYNAMIC_RAM_A);
+
+	if (a == &dev_attr_dynamic_ram_a_qos_class.attr &&
+	    (!perf || perf->qos_class == CXL_QOS_CLASS_INVALID))
+		return 0;
+
+	if (a == &dev_attr_dynamic_ram_a_size.attr &&
+	    (!cxl_part_size(cxlmd->cxlds, CXL_PARTMODE_DYNAMIC_RAM_A)))
+		return 0;
+
+	return a->mode;
+}
+
+static struct attribute_group cxl_memdev_dynamic_ram_a_attribute_group = {
+	.name = "dynamic_ram_a",
+	.attrs = cxl_memdev_dynamic_ram_a_attributes,
+	.is_visible = cxl_dynamic_ram_a_visible,
+};
+
 static umode_t cxl_memdev_security_visible(struct kobject *kobj,
 					   struct attribute *a, int n)
 {
@@ -530,6 +585,7 @@ static const struct attribute_group *cxl_memdev_attribute_groups[] = {
 	&cxl_memdev_attribute_group,
 	&cxl_memdev_ram_attribute_group,
 	&cxl_memdev_pmem_attribute_group,
+	&cxl_memdev_dynamic_ram_a_attribute_group,
 	&cxl_memdev_security_attribute_group,
 	NULL,
 };
@@ -538,6 +594,7 @@ void cxl_memdev_update_perf(struct cxl_memdev *cxlmd)
 {
 	sysfs_update_group(&cxlmd->dev.kobj, &cxl_memdev_ram_attribute_group);
 	sysfs_update_group(&cxlmd->dev.kobj, &cxl_memdev_pmem_attribute_group);
+	sysfs_update_group(&cxlmd->dev.kobj, &cxl_memdev_dynamic_ram_a_attribute_group);
 }
 EXPORT_SYMBOL_NS_GPL(cxl_memdev_update_perf, "CXL");
 

-- 
2.49.0


From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from mgamail.intel.com (mgamail.intel.com [192.198.163.18])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id 869071A314E
	for <nvdimm@lists.linux.dev>; Sun, 13 Apr 2025 22:52:03 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=fail smtp.client-ip=192.198.163.18
ARC-Seal: i=2; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1744584725; cv=fail; b=gZno8HhAfvcxqKVtHgBh/sBYnlOJhjqyZcbkP3YhQsUYhYVsbjPNtrs4YIk/i52R8zcqBXeD8jPxsGm4LkNSAFuJPSBJWY0hunmo/5X6KK3dQfaHoYMe4N+FDGx7ldWkAn8+ZC/qoTGR8MeuKkxJBerb2SDr8Ww7G1Hcuf0ld+c=
ARC-Message-Signature: i=2; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1744584725; c=relaxed/simple;
	bh=ubkszuk8OOj91HHaqwNgXvdiZweiDuzDaFgiJyN6lDo=;
	h=From:Date:Subject:Content-Type:Message-ID:References:In-Reply-To:
	 To:CC:MIME-Version; b=n085m+kwF4tySG8e5ZGylGl0KANmlJPizYWzJ57GwbdcwXTB/R9dWzaAJrZQnCBAKinYIEWVoKh+DU//XLYi0GCm+D5/fE7gomIKFLBkSPicM5/U+DXZ3vzh50wLa73s1sMzju/Ug49xOCs9IK8deUCavdTCWZXD7cqPxg7FZuk=
ARC-Authentication-Results: i=2; smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=intel.com; spf=pass smtp.mailfrom=intel.com; dkim=pass (2048-bit key) header.d=intel.com header.i=@intel.com header.b=aUK0rlOs; arc=fail smtp.client-ip=192.198.163.18
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=intel.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=intel.com
Authentication-Results: smtp.subspace.kernel.org;
	dkim=pass (2048-bit key) header.d=intel.com header.i=@intel.com header.b="aUK0rlOs"
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1744584724; x=1776120724;
  h=from:date:subject:content-transfer-encoding:message-id:
   references:in-reply-to:to:cc:mime-version;
  bh=ubkszuk8OOj91HHaqwNgXvdiZweiDuzDaFgiJyN6lDo=;
  b=aUK0rlOshktwjIYx0iSfbYu8lHU6qfL3U32+EKSGTM7j75ujoevPrAYU
   cuKnPDFCYfQdCg11rTALXCnapLWEJbZgAEFJKcT00vMj7VpRAbP6vNrg4
   h7omMhAfauBeQn/IDxXJtq/aDqZoZYU7KO53qfaQXqxApQCjxschDRcvc
   zNXXJ7CgZ2gp/6VaCZzS3d4BIA95PCctoJDhI3SMb0xkZpgWPBLc4n/9o
   cRUDvzey2mB/keU81wYTdVEjcobYAljhn44JTbk/ZOUk8zCQc2ca1PeCL
   I+vqIOSI300U0oI1D6nHsJCsN0mDZqGq3FB1IbjGOlpoDGvy/OUZgw+80
   w==;
X-CSE-ConnectionGUID: PFmHxcsIRMqmLBm61JSSPw==
X-CSE-MsgGUID: LJ3wwJtrTt+VOCjHo9cPMA==
X-IronPort-AV: E=McAfee;i="6700,10204,11402"; a="45280906"
X-IronPort-AV: E=Sophos;i="6.15,211,1739865600"; 
   d="scan'208";a="45280906"
Received: from fmviesa007.fm.intel.com ([10.60.135.147])
  by fmvoesa112.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 13 Apr 2025 15:52:02 -0700
X-CSE-ConnectionGUID: Xh9v8XCLSDC5H+iLXuSEHg==
X-CSE-MsgGUID: tplrpwWXRu+e+PeQyBnsDw==
X-ExtLoop1: 1
X-IronPort-AV: E=Sophos;i="6.15,211,1739865600"; 
   d="scan'208";a="129657453"
Received: from orsmsx903.amr.corp.intel.com ([10.22.229.25])
  by fmviesa007.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 13 Apr 2025 15:52:01 -0700
Received: from ORSMSX901.amr.corp.intel.com (10.22.229.23) by
 ORSMSX903.amr.corp.intel.com (10.22.229.25) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.2.1544.14; Sun, 13 Apr 2025 15:52:00 -0700
Received: from ORSEDG602.ED.cps.intel.com (10.7.248.7) by
 ORSMSX901.amr.corp.intel.com (10.22.229.23) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.2.1544.14 via Frontend Transport; Sun, 13 Apr 2025 15:52:00 -0700
Received: from NAM11-BN8-obe.outbound.protection.outlook.com (104.47.58.168)
 by edgegateway.intel.com (134.134.137.103) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.44; Sun, 13 Apr 2025 15:52:00 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector10001; d=microsoft.com; cv=none;
 b=jZ87yonip5Zz+nSBkTMAQ1A08Ic1A3xjIjSc+uwBUMC8Z7Xye9uCtHgbOo9Mai970eCbCvDJGY5RRUd9Vywp09NCrF+wIlPZdrxL5isKZu8grSflZpD3VTz3RaxDOhh21qQLamZa6qB4F4wgPtapo99XTEf/KySYhxAYixEcAD8Dsq4YIOLtV3Zv156F8uZ71UfU9hHQhNngDbgSMIkEb3Bf8PBiyeLLlcvq1OJ0Y4PKcbzW9V3xP6CdFX71D7Ua7vlhhHpCF8Aof8GJtDWSbtVGtlj7Tcuffngv6oD1ghNwTr3Fp3bT9nl+KWOGOWHZ7HmNzBlHL9bKD55vnKlucg==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector10001;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=rQK0+O4GqSKPKOs9Sr/fszqYqvtsWCSqVUxvStUxO3E=;
 b=AzmljhdD6N+PfDkBOMNznhWXnGuM723cqfxOdsr9HWTfHBwiEzT9AuLvN5f5FLZFjV27p9Q/DUPtdT1PrflKuUpdgFT3ZIoGTCcxRXqsUAAL00FVMziaTLxlx2en2lCqsS9tyoNo7C8mg+1dMj7FZn8nC6GaohBLeh4yf4h+PaFVIJiDbjLHj9+o6Ynx+d5dva3JyIaPU2AtP+XVtLTgAD9thGBK8Ytl7ePOEWzWly0uZhhvI7V/pwTuRZaPV6i0QaDR5+65iPRUZPceNnTqZsp6PuTnMRG/4lStrW2oq/3NWfbWMwE3LxNeFX1VBVoEeqGErFIqwtCJRy9f72wrVQ==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from MW4PR11MB6739.namprd11.prod.outlook.com (2603:10b6:303:20b::19)
 by DM4PR11MB6042.namprd11.prod.outlook.com (2603:10b6:8:61::18) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.8632.28; Sun, 13 Apr
 2025 22:51:52 +0000
Received: from MW4PR11MB6739.namprd11.prod.outlook.com
 ([fe80::a7ad:a6e8:fced:3f24]) by MW4PR11MB6739.namprd11.prod.outlook.com
 ([fe80::a7ad:a6e8:fced:3f24%4]) with mapi id 15.20.8606.033; Sun, 13 Apr 2025
 22:51:52 +0000
From: Ira Weiny <ira.weiny@intel.com>
Date: Sun, 13 Apr 2025 17:52:14 -0500
Subject: [PATCH v9 06/19] cxl/port: Add 'dynamic_ram_a' to endpoint decoder
 mode
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: 7bit
Message-ID: <20250413-dcd-type2-upstream-v9-6-1d4911a0b365@intel.com>
References: <20250413-dcd-type2-upstream-v9-0-1d4911a0b365@intel.com>
In-Reply-To: <20250413-dcd-type2-upstream-v9-0-1d4911a0b365@intel.com>
To: Dave Jiang <dave.jiang@intel.com>, Fan Ni <fan.ni@samsung.com>, "Jonathan
 Cameron" <Jonathan.Cameron@huawei.com>
CC: Dan Williams <dan.j.williams@intel.com>, Davidlohr Bueso
	<dave@stgolabs.net>, Alison Schofield <alison.schofield@intel.com>, "Vishal
 Verma" <vishal.l.verma@intel.com>, Ira Weiny <ira.weiny@intel.com>,
	<linux-cxl@vger.kernel.org>, <nvdimm@lists.linux.dev>,
	<linux-kernel@vger.kernel.org>
X-Mailer: b4 0.15-dev-c25d1
X-Developer-Signature: v=1; a=ed25519-sha256; t=1744584735; l=3257;
 i=ira.weiny@intel.com; s=20221211; h=from:subject:message-id;
 bh=ubkszuk8OOj91HHaqwNgXvdiZweiDuzDaFgiJyN6lDo=;
 b=PqrpuoOgqfEFIv5Kmfg2/Jpcf6p/+KUEk1ohlJOdVsWF+mMLc/Dtjg2VYYzjPMSOZX5GjI+pY
 XENW8xJ4pD/BPaI+4OsCHUdn12rI5HJccuek6nFn/yuQs+M8l0hIKy2
X-Developer-Key: i=ira.weiny@intel.com; a=ed25519;
 pk=noldbkG+Wp1qXRrrkfY1QJpDf7QsOEthbOT7vm0PqsE=
X-ClientProxiedBy: MW4PR03CA0227.namprd03.prod.outlook.com
 (2603:10b6:303:b9::22) To MW4PR11MB6739.namprd11.prod.outlook.com
 (2603:10b6:303:20b::19)
Precedence: bulk
X-Mailing-List: nvdimm@lists.linux.dev
List-Id: <nvdimm.lists.linux.dev>
List-Subscribe: <mailto:nvdimm+subscribe@lists.linux.dev>
List-Unsubscribe: <mailto:nvdimm+unsubscribe@lists.linux.dev>
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: MW4PR11MB6739:EE_|DM4PR11MB6042:EE_
X-MS-Office365-Filtering-Correlation-Id: d62e3194-dadb-4df5-6767-08dd7addc807
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;ARA:13230040|376014|1800799024|366016;
X-Microsoft-Antispam-Message-Info: =?utf-8?B?ZVlHWFFPQjhYS21pOVYrMkVUT0lyL1ZKc0E4YjMxTHFsZGpBVUtmT2hDOFFM?=
 =?utf-8?B?RTlXaFl2OThZazduSXRMMGNnV0Z0TFJYQitFSzRoWWJOTDloOWROTnp3Q29O?=
 =?utf-8?B?TnpRUkxBL3A3UW1IWVlUSGdURFo4aEx1eDJ6OUt3VmtGK0x4TzlkdzNnYmov?=
 =?utf-8?B?eElRcG9kdkdxMjZKcEVpQnFxUWo2M2lPUWNlUnlsc2JuT3dhemFoQ2xxMWNO?=
 =?utf-8?B?SFFRWG54aGRwZmdYSzFaMER4ZkVWclEyRDBwYnNXQnNxeHF3YTRHTDNNZDJW?=
 =?utf-8?B?djkrcFZkOUNxN2UzdVBkaVFEVDA0aGpmc21HNCsyVDAyVi9jdGs0WU5RdXNn?=
 =?utf-8?B?aXdUZ2o4ZUtEQWhZRUxyMUpiR0ZrT3p1STdYOUtCTTdIeElUaDhPMFZhVXA5?=
 =?utf-8?B?amlENDhFYnU3cnVFZGVhc1pEemxXZ28zdElHM3Y0TlU4d3QyTkNqeVZzTHl4?=
 =?utf-8?B?djA0NnlqQkExS2g4VVhocmRkanE5bElCOFNPS0tCTFR0ZWVOcG5LOXYyTXZU?=
 =?utf-8?B?WnpMTVp4aEFadnZUWkhKV3RUUFcxQ0FuczdUbm9sZXhYVTB0ZXg4WHVkWGhL?=
 =?utf-8?B?ajBCU2VQLzNqU04yaGVobFNvRUFpNlB6TDlHamp1V01yWEEwcXB2ZDVLVnhM?=
 =?utf-8?B?L3lCaGtWbWpBWERQSWhDY0ZHQms1TkY1ZktjY0FqR2QybGhPNmQ4WXcwaWNk?=
 =?utf-8?B?UnFmM01xcmxPWDVpRXhUV2Z6ems4WHl0VjhaYzI2Zm5pek5hSHJuTmtEWDln?=
 =?utf-8?B?WkdDWU5VVTNtcTM1TDdoV3BYK0RCR3REUUlzSEFVSkx1R0ZER1duL0I1MnFv?=
 =?utf-8?B?a0paK3dyRm9PKzdCT3cwYTdRT1VBZEczemhMTFFUM3lmM0h0WU1kT2x1UXg4?=
 =?utf-8?B?c0M0SDRFR0xlSk1UMFBPMStyVWg5a2hKQlpUZXhVQlgyNTlUQWJESGl2cWM0?=
 =?utf-8?B?TTU0dTVtUW1ydEJjNlh1cnNQdTA3ejFFMXRKVWpWSGwyUXVVc0dzR2Z0Tm9i?=
 =?utf-8?B?RVZKdUJpL3dqc1dxbmYzU2VHaE1qcXFESUJob1VzSEhPaXFLbjNIcHhHbXJv?=
 =?utf-8?B?ZWh4NFFzUHNrYnVhWFQvMHl1ZithUEQ2SUpQYlVXSnBTTnkxRUNqdEVIUWpu?=
 =?utf-8?B?SHNVUm1pcGNBWVZvSEZ2T29ZWFB6NGNsZVMrbGtRUG1TVkJkcS9CNlRxT1pW?=
 =?utf-8?B?UmxlTEJsSGlJcmN5Q2ZpUlRxeVBBVm5PZ0c5KzFPYWFnS1o2ZlNwc3owL1hz?=
 =?utf-8?B?WHVrU2lZbWJOK2l6WnMzTnhOaGJXUWtDbHpjaXNiVE9sS2lHamJCYlFkREdz?=
 =?utf-8?B?TmxjYnJpUFpmbjd6YlhSRnVSSkJSWU5EV0JvbXdoUjVZbnpVaGIwYWRRbVpv?=
 =?utf-8?B?WExYWnlpdkt0UEJTK3NtampJaWhyQlExZWVhOC9VVEJsK2l0M2pvVUlMZ0hy?=
 =?utf-8?B?aTFac0JCUzJjeElDYlNsbXVPNlVGWGRDN0drUGxrMm1KSUt4eFV6SnpVQ0xG?=
 =?utf-8?B?ZXZOSWhlNS9WREZyOTNFdTdTY3drSUJVbU0vTWl2WFVXR0JRWmV4YUdCTWt4?=
 =?utf-8?B?RjBvRzRkZHdlWUZ1RVk1bHdYUzY2K0JWNFRPZHZKYUVMLzNCRmVaaHRwOC9R?=
 =?utf-8?B?UURCRnRpN0FRekFKVnJZOVJGMnhhTFNidUJyYVBSNEJIZW5tZURPaUE3b3lC?=
 =?utf-8?B?MEJldndmREZiYStrZERTbVhuMTNZc1lzajAveDcyUEVZS0JsNWhVZWNDVXpR?=
 =?utf-8?B?VWlCQXZIOVYzSU1ab2xvbE1tKzU1VVE2TFBMUlF6SUVaZXdlcURVdzNXeWxQ?=
 =?utf-8?B?b3pnRmczZ3ppTUFUUWhtWno5TU5EOEdMakNMY1NTTCtaMjRyUnJvbm1ucWxh?=
 =?utf-8?B?bVhZWU05Ymg5TUdVTXV3SVp2VHhCNkh6K09xd3dhb21RcUt1Tm5laXYvSE9o?=
 =?utf-8?Q?HF7R/bei6Zo=3D?=
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:MW4PR11MB6739.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230040)(376014)(1800799024)(366016);DIR:OUT;SFP:1101;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?utf-8?B?M0luSm80MWhBRXZXZ0tPRTR5MUZsOXgvZ3dhc0lmcDJ1T0ZoQytwQTVqV1Vr?=
 =?utf-8?B?RllOYitxaVZOV0lDMkVVVERXakZhbG85V1BBUmdIVW03YXhES3dpYm5Jd1kr?=
 =?utf-8?B?WU5EYUY4TDJhei9oTndYNW5XZ1F1c2JUcmpTKzhTNU9WRXJQYURjVGc1N1k3?=
 =?utf-8?B?aGhJZXpZemhWTkxRQ2NFQ3ZlOGtXL3JpR0dhY2EwWUxSczZTend5NW5Lem5S?=
 =?utf-8?B?TnVsZTk1b3hRdmFRNEFwU1dLazU4QmdheWdHbVdiSVF3d0xUMEtaUnZaeGxn?=
 =?utf-8?B?MWxWVmtPNkp6bGxrajVHamJ4cmdIYXBuWk81R0QwNm42Qm1HczUrTkNYQ05M?=
 =?utf-8?B?Tmk2R052dWJnUDBYWEpNMTNUNTN1TVBxVjcwbTlDUTc0aEltOENJem16NVBi?=
 =?utf-8?B?SDlDTWlvUlRQTUhrVXF4SUFCcU1RZWwya0VtLzhoOExRK2kxOUJVOUtIa1Yy?=
 =?utf-8?B?bFN6cUVuY0tHQWI3MW1GMk1RRGdsOXl4SXphTWtLR2d3MlN6Q2Jmb2NEczhO?=
 =?utf-8?B?MjhpWU40bVpiU25GWklBWm82RG40N2NseDF5b20wUVlaOHd4UG5rSVJ1QUd5?=
 =?utf-8?B?YUQrYU5KY2ZKbk9ibEdrYUtCN0o2SEhuUlhlVjVaVHR4cklDVDdHSlltSFNr?=
 =?utf-8?B?MDAyZ2lyckpNS2FrYXJvR0E0Y2pvckpQS0IwMkZvMjgzUGR1MnF0c2V0MHBp?=
 =?utf-8?B?MEREQ1liYWZuUGVlaWYvWnhwVzJnTnBtMHBBVFBLd2gyTVA4b1YzeUpUd1Rn?=
 =?utf-8?B?WWNybmdVOWdqWnhiaUNKMmJ4ZTAyUE1UNWtraXplS3VLUnFSemFLNnlEN3dw?=
 =?utf-8?B?RmlyZGRxc0hsSUVVZUQyZW5veENoN2pvckFPNmM1QUkyYXJLQm55TldsaUV4?=
 =?utf-8?B?dU9OTmdycEc3dFBCWC9yY0NadHdpNWR3VUhsSkdsc2xZb0twckxjUGpCYmZj?=
 =?utf-8?B?TXJvdVppWWtHUTRYM2pSZkowZEc2czNTNFM4cm1Xc0c2bGZ3eTVTOTJDaXNU?=
 =?utf-8?B?VWtlTUlxaDMya0JRSkcvN3J0eHdaRjVvYTlPbHVaVW53M3ozL2dkbjBlcDRq?=
 =?utf-8?B?ZkpJbUxHRFFtY3VicnlXVGxTL21QdXRzd0hCeFNRelpWeVlSU1hwOFNNWXVt?=
 =?utf-8?B?UUQ5bDd4SUM0MkhiKzBMQjRvMkg0ekF0UURxdE8rdlNmUVNDSWR0NlFxRDRD?=
 =?utf-8?B?ZDJPdXZSaUcwWjhCZVI2SzdUTzU2em9XV2pSYlBmU0tTakRPME9PYVRNazZH?=
 =?utf-8?B?a1JPbEY5R2ZCSW9kZldNUSt4UDlIUS9lbFlZWmUzK2JkQkdkM2V2MWJSeHN2?=
 =?utf-8?B?Z2xocWJJRW9VcmxRK3hrSVdNNVNSVm4zY1BrcnBibDh1cDd2MVBqNzJ3NzhT?=
 =?utf-8?B?V3Zyc1YvRlZ5Z1l1VTdmNmg0a0d3NTJhNjkxZ3M5NWlETjd5MUw3MTlvMzF2?=
 =?utf-8?B?cGprOHVIQVlXemFSUW1PeUwzdmpQbHUwNTdkZzJCcGd1RCt4OFc1SEVabUdW?=
 =?utf-8?B?QmlMWWdLK0dRTjBFSDBON0MrYldXeitpcU00emhlNGs3WFBSdWJoUWZSUWF4?=
 =?utf-8?B?WDY3dnlqRkNqY3BmaXMwRGx3bDZrcHR1L2pEejFDYWE2ZE9FWDhodDFxOVhR?=
 =?utf-8?B?UUlZdzdiMDRvclUrN2U2T25pNUh1NTNHQ2ZHTkJ0b2VmWitXdGd0bDRmeDlq?=
 =?utf-8?B?ekZjNUFzbll4K2xKd2FNaHV1NVBBakZCYmV0eDczQ2k2L1hjRUNIMGVFai9R?=
 =?utf-8?B?Z2IzK1UxbXB2Q2xRUUx4Uk9nSmRIZTNPc09nN09sMXhUdU5iNXNLSUtiRkN2?=
 =?utf-8?B?QXhJeVRPckNFQkEzSitIbmVJWm01NHY2SW9adGVGYUYrY291UlNtSjFEdUZy?=
 =?utf-8?B?eFREZjdsbHJ2endIaTFFKzRUdE9rQ2Vpd25TQjdRMlZ5U2xhdFVmSGE4N0Z1?=
 =?utf-8?B?MkE1WEZ2UWEydTFELzlSY2Zvb2NCc2Zmc3lCeE9NTncydnV5WlhqQUE1Zmxx?=
 =?utf-8?B?ZmFaNUpheldWbWNJVnlNMkZkVTNWczZGVEZsWFB4OW8rbjZTU081VXhwYzRO?=
 =?utf-8?B?WGNiRXlxWTE5ekM3ekx2N2ZVTVQvM0dxNDlzMkMyNDdzT0JucUprUUtSTm51?=
 =?utf-8?Q?75Si/VnDXYEkxb3gqT7GcTb8p?=
X-MS-Exchange-CrossTenant-Network-Message-Id: d62e3194-dadb-4df5-6767-08dd7addc807
X-MS-Exchange-CrossTenant-AuthSource: MW4PR11MB6739.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 13 Apr 2025 22:51:52.0536
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: vCzSVqp9hV1BqoZUQxT3PydRuagBpIaCVKOdyh+ZaSk8XeRan1Or+kWfSL81p0FPIWLz31bCYAribZPavJOy5g==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: DM4PR11MB6042
X-OriginatorOrg: intel.com
Status: O
Content-Length: 3174
Lines: 85

Endpoints can now support a single dynamic ram partition following the
persistent memory partition.

Expand the mode to allow a decoder to point to the first dynamic ram
partition.

Signed-off-by: Ira Weiny <ira.weiny@intel.com>

---
Changes:
[iweiny: completely re-written]
---
 Documentation/ABI/testing/sysfs-bus-cxl | 18 +++++++++---------
 drivers/cxl/core/port.c                 |  4 ++++
 2 files changed, 13 insertions(+), 9 deletions(-)

diff --git a/Documentation/ABI/testing/sysfs-bus-cxl b/Documentation/ABI/testing/sysfs-bus-cxl
index 2b59041bb410..b2754e6047ca 100644
--- a/Documentation/ABI/testing/sysfs-bus-cxl
+++ b/Documentation/ABI/testing/sysfs-bus-cxl
@@ -358,22 +358,22 @@ Description:
 
 
 What:		/sys/bus/cxl/devices/decoderX.Y/mode
-Date:		May, 2022
-KernelVersion:	v6.0
+Date:		May, 2022, May 2025
+KernelVersion:	v6.0, v6.16 (dynamic_ram_a)
 Contact:	linux-cxl@vger.kernel.org
 Description:
 		(RW) When a CXL decoder is of devtype "cxl_decoder_endpoint" it
 		translates from a host physical address range, to a device
 		local address range. Device-local address ranges are further
-		split into a 'ram' (volatile memory) range and 'pmem'
-		(persistent memory) range. The 'mode' attribute emits one of
-		'ram', 'pmem', or 'none'. The 'none' indicates the decoder is
-		not actively decoding, or no DPA allocation policy has been
-		set.
+		split into a 'ram' (volatile memory) range, 'pmem' (persistent
+		memory), and 'dynamic_ram_a' (first Dynamic RAM) range. The
+		'mode' attribute emits one of 'ram', 'pmem', 'dynamic_ram_a' or
+		'none'. The 'none' indicates the decoder is not actively
+		decoding, or no DPA allocation policy has been set.
 
 		'mode' can be written, when the decoder is in the 'disabled'
-		state, with either 'ram' or 'pmem' to set the boundaries for the
-		next allocation.
+		state, with either 'ram', 'pmem', or 'dynamic_ram_a' to set the
+		boundaries for the next allocation.
 
 
 What:		/sys/bus/cxl/devices/decoderX.Y/dpa_resource
diff --git a/drivers/cxl/core/port.c b/drivers/cxl/core/port.c
index 0fd6646c1a2e..e98605bd39b4 100644
--- a/drivers/cxl/core/port.c
+++ b/drivers/cxl/core/port.c
@@ -125,6 +125,7 @@ static DEVICE_ATTR_RO(name)
 
 CXL_DECODER_FLAG_ATTR(cap_pmem, CXL_DECODER_F_PMEM);
 CXL_DECODER_FLAG_ATTR(cap_ram, CXL_DECODER_F_RAM);
+CXL_DECODER_FLAG_ATTR(cap_dynamic_ram_a, CXL_DECODER_F_RAM);
 CXL_DECODER_FLAG_ATTR(cap_type2, CXL_DECODER_F_TYPE2);
 CXL_DECODER_FLAG_ATTR(cap_type3, CXL_DECODER_F_TYPE3);
 CXL_DECODER_FLAG_ATTR(locked, CXL_DECODER_F_LOCK);
@@ -219,6 +220,8 @@ static ssize_t mode_store(struct device *dev, struct device_attribute *attr,
 		mode = CXL_PARTMODE_PMEM;
 	else if (sysfs_streq(buf, "ram"))
 		mode = CXL_PARTMODE_RAM;
+	else if (sysfs_streq(buf, "dynamic_ram_a"))
+		mode = CXL_PARTMODE_DYNAMIC_RAM_A;
 	else
 		return -EINVAL;
 
@@ -324,6 +327,7 @@ static struct attribute_group cxl_decoder_base_attribute_group = {
 static struct attribute *cxl_decoder_root_attrs[] = {
 	&dev_attr_cap_pmem.attr,
 	&dev_attr_cap_ram.attr,
+	&dev_attr_cap_dynamic_ram_a.attr,
 	&dev_attr_cap_type2.attr,
 	&dev_attr_cap_type3.attr,
 	&dev_attr_target_list.attr,

-- 
2.49.0


From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from mgamail.intel.com (mgamail.intel.com [192.198.163.18])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id 8B9A11E5B70
	for <nvdimm@lists.linux.dev>; Sun, 13 Apr 2025 22:52:04 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=fail smtp.client-ip=192.198.163.18
ARC-Seal: i=2; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1744584727; cv=fail; b=ZVATsUQX6/4Uv+PSqCg192d5AMj9oWCB1qiBPKq5MlLbtymGBegl1kqA7ySMBvW9e5XWqVk2/M3uXJA/y/hny98jmsI+1tjREWmwfs011jpUOQYsEDF0ZQFRjcSnUN8etaxNgoOEtXbNc4GMgR2msgoKG4fo3uX7uZLkSmv6DaY=
ARC-Message-Signature: i=2; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1744584727; c=relaxed/simple;
	bh=Ue9nxkCBAbAQFWbu0CQ3m+slfJ5d9+PWGNBQeO6mizY=;
	h=From:Date:Subject:Content-Type:Message-ID:References:In-Reply-To:
	 To:CC:MIME-Version; b=cn6Rn04ET9egIYjKjxedgVDn+qCQ5QKmTtTu0PvyelP+t0gV4F2kCSeTVM4dETaqvNhU3J5tnMnHzEcA8rxFbL7EdGOPOigD3U/Dbi0484QoVyojIoBUFMMmQa5FMfBTXInZM/qT+dau7KSZsvambTtz47viEYYVi2fUwUjjlQE=
ARC-Authentication-Results: i=2; smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=intel.com; spf=pass smtp.mailfrom=intel.com; dkim=pass (2048-bit key) header.d=intel.com header.i=@intel.com header.b=CvekO5WV; arc=fail smtp.client-ip=192.198.163.18
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=intel.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=intel.com
Authentication-Results: smtp.subspace.kernel.org;
	dkim=pass (2048-bit key) header.d=intel.com header.i=@intel.com header.b="CvekO5WV"
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1744584725; x=1776120725;
  h=from:date:subject:content-transfer-encoding:message-id:
   references:in-reply-to:to:cc:mime-version;
  bh=Ue9nxkCBAbAQFWbu0CQ3m+slfJ5d9+PWGNBQeO6mizY=;
  b=CvekO5WVAuh5vDJfqah554r+9vaU7Lg/6DdiKn1u5sZALBNqqhY/hk+5
   vVNss2h0p7laJZia64xbwibScY6FFZ9Y1nOXZJjyKvR5/Ye0ExhQtwC3H
   NgqJHpvQiJb3iRlirMpZCHMLViXapC22GTtuYyskepViU1whIab+l2ujr
   incRoHfRO1nBE7kL7SB7KVTVkS+T00J0hoF9bmX4CYo/FrrnJB08M6lKF
   o6iboZeiXDl4N4DESWPw9HBP9OkiFJrYKSPwSzceQ9sKW/rQ+Bpthxrb1
   93PDzSlevLhwnpTsmo9Vn6y2T6KuioWBGr7u8/EILqPxxKm2gsnc+42Xp
   w==;
X-CSE-ConnectionGUID: dolVbyvIQS6JmBgDATUbKg==
X-CSE-MsgGUID: m94c6+QeQ/WxyKoL7cvvrg==
X-IronPort-AV: E=McAfee;i="6700,10204,11402"; a="45280911"
X-IronPort-AV: E=Sophos;i="6.15,211,1739865600"; 
   d="scan'208";a="45280911"
Received: from fmviesa007.fm.intel.com ([10.60.135.147])
  by fmvoesa112.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 13 Apr 2025 15:52:02 -0700
X-CSE-ConnectionGUID: G/R6Q/J1REeJWdnJ3PK/FA==
X-CSE-MsgGUID: zcLim1KxSfS87+lZuIhUrg==
X-ExtLoop1: 1
X-IronPort-AV: E=Sophos;i="6.15,211,1739865600"; 
   d="scan'208";a="129657463"
Received: from orsmsx903.amr.corp.intel.com ([10.22.229.25])
  by fmviesa007.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 13 Apr 2025 15:52:02 -0700
Received: from ORSMSX901.amr.corp.intel.com (10.22.229.23) by
 ORSMSX903.amr.corp.intel.com (10.22.229.25) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.2.1544.14; Sun, 13 Apr 2025 15:52:01 -0700
Received: from ORSEDG602.ED.cps.intel.com (10.7.248.7) by
 ORSMSX901.amr.corp.intel.com (10.22.229.23) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.2.1544.14 via Frontend Transport; Sun, 13 Apr 2025 15:52:01 -0700
Received: from NAM11-BN8-obe.outbound.protection.outlook.com (104.47.58.168)
 by edgegateway.intel.com (134.134.137.103) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.44; Sun, 13 Apr 2025 15:52:01 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector10001; d=microsoft.com; cv=none;
 b=UnYaRK2K5joiLzCXU0ypa4E9N4OwIWcVmCTCtTjC5ZfPatbfoA9dGT5YmVZrtZGWoRC5+vdWiEZp5OAc6xpLefcMTNtLZmrScgmlJWiSjyBe9NCn5meGRVhdutAWEexDfPn2yCteusFGyciBTfBIaq0gEMv+Y/RUIgFSQbWG6mh2geCjBLB2k+Xdl+Kv9DnYgtdEtwfUR4MhGmncduY0ddOv4cWaUWCjhRph6ySETtEPBi1f4gWpfXd4Qik+GSceRbNsOt/xTAejjkBfG3bYqmYXycvU0j13tUaokO1ulnF2+DleF53/K8nB03Y0im5MDjG4tJKZEtC6XbHyTEGNWg==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector10001;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=YXIxguaIDgMBQhxvppqbWNbriOR5oVLyqgq47Upy2I8=;
 b=C8k2gxPizLy3UFq6q6jO8+lZgGvdpkSYXtRhmAEDXy3yfvNSMZo+2O+H8jzL8Fs4U273UmaDi29qnnovouhOkWnp/r9G6RBcPsbnPmAwHsUim+8ikN6fJUB+dLucgb3aNEJhVIyoWSjeL1AMWvrHI22GeElJK/BsQngEB50AHJ7AIIS4AfdBevIA0ivJ6NkPXoj1cmhaQuGVT3mv3NdkhFMFbB1wIyynLbhQz2bmwvmsHbGbNorzR6hwIKRVm9YQ+r7KA4olVW0nj+rdPKix4/2mcmvqfgZx84F+3txKfVsKx+V/OxC6/a3qD6rIfGYMuzxBZ607VH1VnE1fzCCwKw==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from MW4PR11MB6739.namprd11.prod.outlook.com (2603:10b6:303:20b::19)
 by DM4PR11MB6042.namprd11.prod.outlook.com (2603:10b6:8:61::18) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.8632.28; Sun, 13 Apr
 2025 22:51:53 +0000
Received: from MW4PR11MB6739.namprd11.prod.outlook.com
 ([fe80::a7ad:a6e8:fced:3f24]) by MW4PR11MB6739.namprd11.prod.outlook.com
 ([fe80::a7ad:a6e8:fced:3f24%4]) with mapi id 15.20.8606.033; Sun, 13 Apr 2025
 22:51:53 +0000
From: Ira Weiny <ira.weiny@intel.com>
Date: Sun, 13 Apr 2025 17:52:15 -0500
Subject: [PATCH v9 07/19] cxl/region: Add sparse DAX region support
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: 7bit
Message-ID: <20250413-dcd-type2-upstream-v9-7-1d4911a0b365@intel.com>
References: <20250413-dcd-type2-upstream-v9-0-1d4911a0b365@intel.com>
In-Reply-To: <20250413-dcd-type2-upstream-v9-0-1d4911a0b365@intel.com>
To: Dave Jiang <dave.jiang@intel.com>, Fan Ni <fan.ni@samsung.com>, "Jonathan
 Cameron" <Jonathan.Cameron@huawei.com>
CC: Dan Williams <dan.j.williams@intel.com>, Davidlohr Bueso
	<dave@stgolabs.net>, Alison Schofield <alison.schofield@intel.com>, "Vishal
 Verma" <vishal.l.verma@intel.com>, Ira Weiny <ira.weiny@intel.com>,
	<linux-cxl@vger.kernel.org>, <nvdimm@lists.linux.dev>,
	<linux-kernel@vger.kernel.org>
X-Mailer: b4 0.15-dev-c25d1
X-Developer-Signature: v=1; a=ed25519-sha256; t=1744584735; l=10968;
 i=ira.weiny@intel.com; s=20221211; h=from:subject:message-id;
 bh=Ue9nxkCBAbAQFWbu0CQ3m+slfJ5d9+PWGNBQeO6mizY=;
 b=tngxmK7sPNauggRF7uFSLXG+oUAuWS0LuNdDUKS4cOUwk3n8EByXRCtN5zVBrkFzpz7Y7IVMP
 cWCd+/VxCJMBlj15chVHMOGxulh4Bcy8If4whOwQEiQPDJBOhTmTGId
X-Developer-Key: i=ira.weiny@intel.com; a=ed25519;
 pk=noldbkG+Wp1qXRrrkfY1QJpDf7QsOEthbOT7vm0PqsE=
X-ClientProxiedBy: MW4PR03CA0227.namprd03.prod.outlook.com
 (2603:10b6:303:b9::22) To MW4PR11MB6739.namprd11.prod.outlook.com
 (2603:10b6:303:20b::19)
Precedence: bulk
X-Mailing-List: nvdimm@lists.linux.dev
List-Id: <nvdimm.lists.linux.dev>
List-Subscribe: <mailto:nvdimm+subscribe@lists.linux.dev>
List-Unsubscribe: <mailto:nvdimm+unsubscribe@lists.linux.dev>
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: MW4PR11MB6739:EE_|DM4PR11MB6042:EE_
X-MS-Office365-Filtering-Correlation-Id: 049bf665-13bd-48e2-f354-08dd7addc8ed
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;ARA:13230040|376014|1800799024|366016;
X-Microsoft-Antispam-Message-Info: =?utf-8?B?VWNnQ21VNGJuUWY4OXl4VytjblhGS21SMmlISEM5d0ZyUDIyZDhKcDhkM1FI?=
 =?utf-8?B?MmZMbjgxaDhCejR4LytmZDAyanNwSDM0cU5YNnVZMXk2OU82TGFMQzlKMEFt?=
 =?utf-8?B?dzR3QWZlaXdQd0hDdjZhNXBFZEFZL25IUlhxTWkvQlczMGx2V0FSWlhWaXpI?=
 =?utf-8?B?cUhWN0R0cWRub2t0b3VmTXJXUUZVZEgyck5QQkJOcVdIdlR6U29sRVUxcXVp?=
 =?utf-8?B?aFhlaVYxSE40UkhoNytEWGZ3OWdWSGtSYisxMFM5Z2lYSUMzY2dmclFJbS9K?=
 =?utf-8?B?SUxwbG00WW5oS1QxblgyQldqdDhadi90U0dSQVVFUGdrdGdjdWpyVG5uVHhW?=
 =?utf-8?B?a044OEZ2dW1MV2ZjWkdkQnFKSExlemxGVko3YzVvSmdYMXBQb0FNQ3RnTWtP?=
 =?utf-8?B?OWcrbzBZY0FKS0N0Vnh6NEVRSW10QlgrTkxVL1I0SjlCNkRhNnlFS2VlQ2pn?=
 =?utf-8?B?Ynd3dXRzYUVkYytKV3UrdEs5cDU5TFNDTTE5UWVzUmJ5ZURBdnIwSUpqMytY?=
 =?utf-8?B?dFk5L0hxN2Zsd1puckJoZVI1ZitvamhtclM1ZU0ya2Jyb1JFTG9NeEgvZGxZ?=
 =?utf-8?B?bXRuWXozT1Q4dm5pbkFLVE1FVWlsVVZOV1FXc1RVM0hUWEJUckJ1RDFoYnBa?=
 =?utf-8?B?bVBvd3g0WndRMHljT014WEJOb2kwbnVJS3ZEdFg0NVBJdlJRTmRtbnU0MFp1?=
 =?utf-8?B?OFhGWWZIRlFqcmk5dy9JNWtWYWYzbHV4am1EQy9zZ0E0eEViMEE5Z0ZVSG1O?=
 =?utf-8?B?ZDkyUEM2Mmo2OEZqa1FoYkNLNVZmSTlZU2RoQ3FhQ0Vxd0U4V09MZHRSdmVj?=
 =?utf-8?B?VGZORnQ5Q2JJVExwaVNUT1BOUittc05JbTJ6UThValNLZ0cxejYxZHhpUisx?=
 =?utf-8?B?elFQamFMWnJmc09JVVZoWk90SGVYVVh6MzJRWGlqL0FJTkNSTWtqQXVXSzVO?=
 =?utf-8?B?L1dzSXlwVW5CcTU5L1FiL2pONWp1WHg3YjJvYnNRVTJZNUI1ODBvYkdBOFBz?=
 =?utf-8?B?YTFaOEtMVWNOTVY2ZnA0SUtib0RTT1NUMERWTlpkeWxzeE9vUFlmOFNrRmdm?=
 =?utf-8?B?VWFWUmpLYVB0M0ZCZkRzUExlRTExaDdHL0V3OUM2S0dQZ05sVk5aSEZqMkVM?=
 =?utf-8?B?dW8ydzVtL3ROSWZsUnY3QVR5TVM0Uis5dTNxUnpDc1NWTmpVZmN5cUd3eTQv?=
 =?utf-8?B?akJhZ013WEpSTjgwWHVjVDBWTC9ENHdCeU1kd1hkcTEvNjc4NjFmTTNFcU9N?=
 =?utf-8?B?aldIZ0JpTXJlM1R1MzJQSFpVc1hNVHdZZmZaQk1LSTZsemthWk1WOEVUbHJL?=
 =?utf-8?B?bE9CNS9YdjNDTmtmMFBHN0Rtci9ESnMvMk5YeWxNdG9tOEpEVUZOS2kzMW1E?=
 =?utf-8?B?Mjl4OUd6WHRmNEtEaGQrWEU1T3lSOFhlaGdha2xIZWhGU2lPeXFSa1RZSm1N?=
 =?utf-8?B?VFRtcUh5Y1FYdEMwUGg2MnFkMWwyZFAydFB1dERLdytrWmI0WUNsdlRic1ZC?=
 =?utf-8?B?M0oyVCtEMXBLMTd4OUNMbmZqczFnS0RqWXdXRUxNeDFGNjJvOGlQdkFQdWNt?=
 =?utf-8?B?UXJWbkg0SkVzSE1tUFZEL09JaWZVMmxvd1pzOU02Mk9yeVRYTUdRWFNZUW83?=
 =?utf-8?B?Z1d6dEJCSUs4WnQrVDhuU0xFYmx5QlNkUXdBV204dzBjU25ld3p4bDVtemFJ?=
 =?utf-8?B?eHBKSUd4UUljSmphdnR6ZCthcEFPbHdwalp6T1RVb2cvT3ZpMjBIeUFUK25z?=
 =?utf-8?B?VzlpaHFSQVZVTzd4T09kckd5alhoNm95NFVUZ01KNndmbXF4aExaNHF5cVVH?=
 =?utf-8?B?K3QzOEVSYXpVV3hnZEd1UDc4ZHFsSnp2M1RTWXg4ZjFxQUdxTHRheXo1N2Fs?=
 =?utf-8?B?UXp6WFFPRVVVYU5kb25iWExXN2pyVElqekYzWk1NMDBTenM3UFdTb1d1S3pR?=
 =?utf-8?Q?v9vjj2abAUg=3D?=
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:MW4PR11MB6739.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230040)(376014)(1800799024)(366016);DIR:OUT;SFP:1101;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?utf-8?B?NGhwZmtvZUdVQm53dDRwdk50TVoxWUxhaEhZb3kvZi9ReENEUTlOWDUwS0lo?=
 =?utf-8?B?QUwxcytPbnN1YzZlRE1CV2F0ZjhGWDdQUHRIdUljYjBzYml0VGY4OG9YaU0w?=
 =?utf-8?B?c29EOWpvUmpQOVk4bllKaTdQUDZVVmJCTFR3NndGY2FockRhajVOcGRSYndN?=
 =?utf-8?B?aS9zeUJCSklqdWNrTkkzbm92MXUxMkVyTnFXcFUxRWxRU1o3ODJ1WlRQYXl5?=
 =?utf-8?B?UVNabmd4dVVaRXp4a09udUoyMEJOVTJuZGJ2aXVyN0p0SkhTSSswVDRnMExy?=
 =?utf-8?B?bkwxbGJ1UGFwMElYSFpReEU2cGJLeXlsU1pUQ21wb3laYkczSlZBaU5GNDYw?=
 =?utf-8?B?Y3g1Q2U5TGRaSmhwMlJrTVhRVU0vRkFlbXNiOXVHVDJpS0haSzBlWVBFWmw5?=
 =?utf-8?B?Qk95UzZPb3FSUUlSOHZaa3FFRVlMSHg5c1RtdjErcjc0eHBxcFgyYk9tUmZk?=
 =?utf-8?B?TU12Vlg4Q1NhTEw0eE9nL2xsZ20rNHBtNkRIRW5aQW4wLzJyQWE3UHJPTExV?=
 =?utf-8?B?WU8xY0hVbmJTUnRpREV6cU1xQTE2RTZ3YXFkVklNWjBUYk9UQ1JJOE5YOFQ0?=
 =?utf-8?B?akQ1Mi9DcTh3ams5clpYSU9mUXR0MXdBRTBDMXNaRjcxTXNrbml5dGlMdkdF?=
 =?utf-8?B?NGtZVFhua2JBNE1iaW96N3daSWs4ZEJTYUliQ3pzVGY0SkdwUWhQUVFpc1Zq?=
 =?utf-8?B?TThJaHNoNGJaa2pkcFNIc0wrVndsdVpHRmczZ09hSEdmQmloQkZZWVNZVmFF?=
 =?utf-8?B?Nk1iS2RFS0E1OGUrUGU1bUxZKzE5ZDFWTVNXc2JnelVXWUFaeVVDdHV1WW5H?=
 =?utf-8?B?RFd2eExmcENGSTJyRDZCUXhsK211WHVNekdkNVVOVnRZVFo1Y3d2bXN3UmFj?=
 =?utf-8?B?RkR1Uk4wQ01sRExLQW85dFFNcFI0Q3IyU01zaUl3djRDSWxScmRBM3dTM1h5?=
 =?utf-8?B?VFVxQk13NzErNEs2cUdkSFBLdStRSnRZOHBLTm9vQ2NHZjBMY01XSDFLODJI?=
 =?utf-8?B?S0lPVm1tQmxyLzRPU1BZeDd4VnA0ZGo1TXV3ek4wVXRNYlpoS01FbFowOEoz?=
 =?utf-8?B?YmdRV3pYYTl3elExNEpHQjNJYm1Fb1hYeHF5ZFZoVC80Mmp5VUtGK1ZpRm8y?=
 =?utf-8?B?TGNyaWlDems5dEhtQTdMZE9jd0dMZURKOHpodTNpMDFsS05PWmtoc1R1bGhK?=
 =?utf-8?B?ckFHT3lQVmtHVXBPYVVsUVE2emtNMWRibEJvYkdVSkYvWG9VMVlGb1lQNDFL?=
 =?utf-8?B?RnhSSnlmbm9pbWlmcjJJQUx3QU9MQ3FJWEpoYUxWY2NJOVJQMExkYStmQmht?=
 =?utf-8?B?TmQxQW1nN0RVUUovc2tRcUtmUWU4QVhDamh1QU1sbm9pejRmcDZ0aVRSNDFn?=
 =?utf-8?B?YXVTamVoVnNtRDBtRjF0NFc4NEM1MllsbXZUb2xmWXFGR1Q2RElFZXl5T3BI?=
 =?utf-8?B?dmljWnpmb0RKaDBsbjA4cktLMW1nbHU1NTY0Q1dJY3RnYThGMnpHQ2ppYkc4?=
 =?utf-8?B?WndKK0F3OU5ncEpxMWZtSzd2bmtCaEFWdCtWaXJBa3BDaEZxSzNvcllzMmxN?=
 =?utf-8?B?cTVrVm91WjZBK1dSd0hZenhPa1JocmlKMktDQ3BSdFUyWXJqWWxvVnZFelZx?=
 =?utf-8?B?THhkeElVelgwOEVsaENqZ0h4MVF5VkFGbEhsS1h2cVY3aTZYT3ZtV0FtYlEv?=
 =?utf-8?B?TWFyOWZMaTgvRW1OZjA3bnIveHNVMTQ4bWwrdU1lRWZjdytjSEpqUzZsOFhu?=
 =?utf-8?B?OE12OTZUbDhLT0JJR29TOGpNUHZYNVNKK3pqdDhVYmE4VkxpcVdidkFaY1du?=
 =?utf-8?B?Y2pyNkRFNWFLeFhEeHpIYzVZS1JGYXZ3SlZjYUt4c2s5Z0orRWlVZk1wVWQ0?=
 =?utf-8?B?MWc2OXZTU1cxSVRiUDZDSTh4T04yQWsySWM3ZUNtUFR1eVRXUzBNQ1d1RUx3?=
 =?utf-8?B?eWR5ejI5MnJDSFl5dndqckNSMTRERElsK2xZME84TW9jZ25rM1Q4RStHSmxV?=
 =?utf-8?B?eXIxV0NibUY3QWNoakR1MWJDeU5rNFZLOXBDRlBUeGR0NU5XaWlFYkZqMVRx?=
 =?utf-8?B?SlZJdjg5R2haeTA3WXFsMlh5dkNSTXVLUHo1UHNiNVdWY24rb1d0ak9sK0Fa?=
 =?utf-8?Q?/N/MbFn4QBtlX7d0kLlW/+OYn?=
X-MS-Exchange-CrossTenant-Network-Message-Id: 049bf665-13bd-48e2-f354-08dd7addc8ed
X-MS-Exchange-CrossTenant-AuthSource: MW4PR11MB6739.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 13 Apr 2025 22:51:53.5872
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: AmZ2zILsHNw2NLrMFaEVkCnLh79qg+VHw66fMAv48+kxaIW4CUHsnFfIQvIuqOFduBJPEt6afMYl9zcwaRQG8Q==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: DM4PR11MB6042
X-OriginatorOrg: intel.com
Status: O
Content-Length: 10670
Lines: 300

Dynamic Capacity CXL regions must allow memory to be added or removed
dynamically.  In addition to the quantity of memory available the
location of the memory within a DC partition is dynamic based on the
extents offered by a device.  CXL DAX regions must accommodate the
sparseness of this memory in the management of DAX regions and devices.

Introduce the concept of a sparse DAX region.  Introduce
create_dynamic_ram_a_region() sysfs entry to create such regions.
Special case dynamic capable regions to create a 0 sized seed DAX device
to maintain compatibility which requires a default DAX device to hold a
region reference.

Indicate 0 byte available capacity until such time that capacity is
added.

Sparse regions complicate the range mapping of dax devices.  There is no
known use case for range mapping on sparse regions.  Avoid the
complication by preventing range mapping of dax devices on sparse
regions.

Interleaving is deferred for now.  Add checks.

Based on an original patch by Navneet Singh.

Signed-off-by: Ira Weiny <ira.weiny@intel.com>

---
Changes:
[iweiny: adjust to new partition mode and new singular dynamic ram
         partition]
---
 Documentation/ABI/testing/sysfs-bus-cxl | 22 +++++++++----------
 drivers/cxl/core/core.h                 | 11 ++++++++++
 drivers/cxl/core/port.c                 |  1 +
 drivers/cxl/core/region.c               | 38 +++++++++++++++++++++++++++++++--
 drivers/dax/bus.c                       | 10 +++++++++
 drivers/dax/bus.h                       |  1 +
 drivers/dax/cxl.c                       | 16 ++++++++++++--
 7 files changed, 84 insertions(+), 15 deletions(-)

diff --git a/Documentation/ABI/testing/sysfs-bus-cxl b/Documentation/ABI/testing/sysfs-bus-cxl
index b2754e6047ca..2e26d95ac66f 100644
--- a/Documentation/ABI/testing/sysfs-bus-cxl
+++ b/Documentation/ABI/testing/sysfs-bus-cxl
@@ -434,20 +434,20 @@ Description:
 		interleave_granularity).
 
 
-What:		/sys/bus/cxl/devices/decoderX.Y/create_{pmem,ram}_region
-Date:		May, 2022, January, 2023
-KernelVersion:	v6.0 (pmem), v6.3 (ram)
+What:		/sys/bus/cxl/devices/decoderX.Y/create_{pmem,ram,dynamic_ram_a}_region
+Date:		May, 2022, January, 2023, May 2025
+KernelVersion:	v6.0 (pmem), v6.3 (ram), v6.16 (dynamic_ram_a)
 Contact:	linux-cxl@vger.kernel.org
 Description:
 		(RW) Write a string in the form 'regionZ' to start the process
-		of defining a new persistent, or volatile memory region
-		(interleave-set) within the decode range bounded by root decoder
-		'decoderX.Y'. The value written must match the current value
-		returned from reading this attribute. An atomic compare exchange
-		operation is done on write to assign the requested id to a
-		region and allocate the region-id for the next creation attempt.
-		EBUSY is returned if the region name written does not match the
-		current cached value.
+		of defining a new persistent, volatile, or dynamic RAM memory
+		region (interleave-set) within the decode range bounded by root
+		decoder 'decoderX.Y'. The value written must match the current
+		value returned from reading this attribute.  An atomic compare
+		exchange operation is done on write to assign the requested id
+		to a region and allocate the region-id for the next creation
+		attempt.  EBUSY is returned if the region name written does not
+		match the current cached value.
 
 
 What:		/sys/bus/cxl/devices/decoderX.Y/delete_region
diff --git a/drivers/cxl/core/core.h b/drivers/cxl/core/core.h
index 15699299dc11..08facbc2d270 100644
--- a/drivers/cxl/core/core.h
+++ b/drivers/cxl/core/core.h
@@ -5,6 +5,7 @@
 #define __CXL_CORE_H__
 
 #include <cxl/mailbox.h>
+#include <cxlmem.h>
 
 extern const struct device_type cxl_nvdimm_bridge_type;
 extern const struct device_type cxl_nvdimm_type;
@@ -12,9 +13,19 @@ extern const struct device_type cxl_pmu_type;
 
 extern struct attribute_group cxl_base_attribute_group;
 
+static inline struct cxl_memdev_state *
+cxled_to_mds(struct cxl_endpoint_decoder *cxled)
+{
+	struct cxl_memdev *cxlmd = cxled_to_memdev(cxled);
+	struct cxl_dev_state *cxlds = cxlmd->cxlds;
+
+	return container_of(cxlds, struct cxl_memdev_state, cxlds);
+}
+
 #ifdef CONFIG_CXL_REGION
 extern struct device_attribute dev_attr_create_pmem_region;
 extern struct device_attribute dev_attr_create_ram_region;
+extern struct device_attribute dev_attr_create_dynamic_ram_a_region;
 extern struct device_attribute dev_attr_delete_region;
 extern struct device_attribute dev_attr_region;
 extern const struct device_type cxl_pmem_region_type;
diff --git a/drivers/cxl/core/port.c b/drivers/cxl/core/port.c
index e98605bd39b4..b2bd24437484 100644
--- a/drivers/cxl/core/port.c
+++ b/drivers/cxl/core/port.c
@@ -334,6 +334,7 @@ static struct attribute *cxl_decoder_root_attrs[] = {
 	&dev_attr_qos_class.attr,
 	SET_CXL_REGION_ATTR(create_pmem_region)
 	SET_CXL_REGION_ATTR(create_ram_region)
+	SET_CXL_REGION_ATTR(create_dynamic_ram_a_region)
 	SET_CXL_REGION_ATTR(delete_region)
 	NULL,
 };
diff --git a/drivers/cxl/core/region.c b/drivers/cxl/core/region.c
index c3f4dc244df7..716d33140ee8 100644
--- a/drivers/cxl/core/region.c
+++ b/drivers/cxl/core/region.c
@@ -480,6 +480,11 @@ static ssize_t interleave_ways_store(struct device *dev,
 	if (rc)
 		return rc;
 
+	if (cxlr->mode == CXL_PARTMODE_DYNAMIC_RAM_A && val != 1) {
+		dev_err(dev, "Interleaving and DCD not supported\n");
+		return -EINVAL;
+	}
+
 	rc = ways_to_eiw(val, &iw);
 	if (rc)
 		return rc;
@@ -2198,6 +2203,7 @@ static size_t store_targetN(struct cxl_region *cxlr, const char *buf, int pos,
 	if (sysfs_streq(buf, "\n"))
 		rc = detach_target(cxlr, pos);
 	else {
+		struct cxl_endpoint_decoder *cxled;
 		struct device *dev;
 
 		dev = bus_find_device_by_name(&cxl_bus_type, NULL, buf);
@@ -2209,8 +2215,13 @@ static size_t store_targetN(struct cxl_region *cxlr, const char *buf, int pos,
 			goto out;
 		}
 
-		rc = attach_target(cxlr, to_cxl_endpoint_decoder(dev), pos,
-				   TASK_INTERRUPTIBLE);
+		cxled = to_cxl_endpoint_decoder(dev);
+		if (cxlr->mode == CXL_PARTMODE_DYNAMIC_RAM_A &&
+		    !cxl_dcd_supported(cxled_to_mds(cxled))) {
+			dev_dbg(dev, "DCD unsupported\n");
+			return -EINVAL;
+		}
+		rc = attach_target(cxlr, cxled, pos, TASK_INTERRUPTIBLE);
 out:
 		put_device(dev);
 	}
@@ -2555,6 +2566,7 @@ static struct cxl_region *__create_region(struct cxl_root_decoder *cxlrd,
 	switch (mode) {
 	case CXL_PARTMODE_RAM:
 	case CXL_PARTMODE_PMEM:
+	case CXL_PARTMODE_DYNAMIC_RAM_A:
 		break;
 	default:
 		dev_err(&cxlrd->cxlsd.cxld.dev, "unsupported mode %d\n", mode);
@@ -2607,6 +2619,21 @@ static ssize_t create_ram_region_store(struct device *dev,
 }
 DEVICE_ATTR_RW(create_ram_region);
 
+static ssize_t create_dynamic_ram_a_region_show(struct device *dev,
+						struct device_attribute *attr,
+						char *buf)
+{
+	return __create_region_show(to_cxl_root_decoder(dev), buf);
+}
+
+static ssize_t create_dynamic_ram_a_region_store(struct device *dev,
+						 struct device_attribute *attr,
+						 const char *buf, size_t len)
+{
+	return create_region_store(dev, buf, len, CXL_PARTMODE_DYNAMIC_RAM_A);
+}
+DEVICE_ATTR_RW(create_dynamic_ram_a_region);
+
 static ssize_t region_show(struct device *dev, struct device_attribute *attr,
 			   char *buf)
 {
@@ -3173,6 +3200,12 @@ static int devm_cxl_add_dax_region(struct cxl_region *cxlr)
 	struct device *dev;
 	int rc;
 
+	if (cxlr->mode == CXL_PARTMODE_DYNAMIC_RAM_A &&
+	    cxlr->params.interleave_ways != 1) {
+		dev_err(&cxlr->dev, "Interleaving DC not supported\n");
+		return -EINVAL;
+	}
+
 	cxlr_dax = cxl_dax_region_alloc(cxlr);
 	if (IS_ERR(cxlr_dax))
 		return PTR_ERR(cxlr_dax);
@@ -3539,6 +3572,7 @@ static int cxl_region_probe(struct device *dev)
 	case CXL_PARTMODE_PMEM:
 		return devm_cxl_add_pmem_region(cxlr);
 	case CXL_PARTMODE_RAM:
+	case CXL_PARTMODE_DYNAMIC_RAM_A:
 		/*
 		 * The region can not be manged by CXL if any portion of
 		 * it is already online as 'System RAM'
diff --git a/drivers/dax/bus.c b/drivers/dax/bus.c
index fde29e0ad68b..d8cb5195a227 100644
--- a/drivers/dax/bus.c
+++ b/drivers/dax/bus.c
@@ -178,6 +178,11 @@ static bool is_static(struct dax_region *dax_region)
 	return (dax_region->res.flags & IORESOURCE_DAX_STATIC) != 0;
 }
 
+static bool is_sparse(struct dax_region *dax_region)
+{
+	return (dax_region->res.flags & IORESOURCE_DAX_SPARSE_CAP) != 0;
+}
+
 bool static_dev_dax(struct dev_dax *dev_dax)
 {
 	return is_static(dev_dax->region);
@@ -301,6 +306,9 @@ static unsigned long long dax_region_avail_size(struct dax_region *dax_region)
 
 	lockdep_assert_held(&dax_region_rwsem);
 
+	if (is_sparse(dax_region))
+		return 0;
+
 	for_each_dax_region_resource(dax_region, res)
 		size -= resource_size(res);
 	return size;
@@ -1373,6 +1381,8 @@ static umode_t dev_dax_visible(struct kobject *kobj, struct attribute *a, int n)
 		return 0;
 	if (a == &dev_attr_mapping.attr && is_static(dax_region))
 		return 0;
+	if (a == &dev_attr_mapping.attr && is_sparse(dax_region))
+		return 0;
 	if ((a == &dev_attr_align.attr ||
 	     a == &dev_attr_size.attr) && is_static(dax_region))
 		return 0444;
diff --git a/drivers/dax/bus.h b/drivers/dax/bus.h
index cbbf64443098..783bfeef42cc 100644
--- a/drivers/dax/bus.h
+++ b/drivers/dax/bus.h
@@ -13,6 +13,7 @@ struct dax_region;
 /* dax bus specific ioresource flags */
 #define IORESOURCE_DAX_STATIC BIT(0)
 #define IORESOURCE_DAX_KMEM BIT(1)
+#define IORESOURCE_DAX_SPARSE_CAP BIT(2)
 
 struct dax_region *alloc_dax_region(struct device *parent, int region_id,
 		struct range *range, int target_node, unsigned int align,
diff --git a/drivers/dax/cxl.c b/drivers/dax/cxl.c
index 13cd94d32ff7..88b051cea755 100644
--- a/drivers/dax/cxl.c
+++ b/drivers/dax/cxl.c
@@ -13,19 +13,31 @@ static int cxl_dax_region_probe(struct device *dev)
 	struct cxl_region *cxlr = cxlr_dax->cxlr;
 	struct dax_region *dax_region;
 	struct dev_dax_data data;
+	resource_size_t dev_size;
+	unsigned long flags;
 
 	if (nid == NUMA_NO_NODE)
 		nid = memory_add_physaddr_to_nid(cxlr_dax->hpa_range.start);
 
+	flags = IORESOURCE_DAX_KMEM;
+	if (cxlr->mode == CXL_PARTMODE_DYNAMIC_RAM_A)
+		flags |= IORESOURCE_DAX_SPARSE_CAP;
+
 	dax_region = alloc_dax_region(dev, cxlr->id, &cxlr_dax->hpa_range, nid,
-				      PMD_SIZE, IORESOURCE_DAX_KMEM);
+				      PMD_SIZE, flags);
 	if (!dax_region)
 		return -ENOMEM;
 
+	if (cxlr->mode == CXL_PARTMODE_DYNAMIC_RAM_A)
+		/* Add empty seed dax device */
+		dev_size = 0;
+	else
+		dev_size = range_len(&cxlr_dax->hpa_range);
+
 	data = (struct dev_dax_data) {
 		.dax_region = dax_region,
 		.id = -1,
-		.size = range_len(&cxlr_dax->hpa_range),
+		.size = dev_size,
 		.memmap_on_memory = true,
 	};
 

-- 
2.49.0


From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from mgamail.intel.com (mgamail.intel.com [192.198.163.18])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id 1DB681F30BB
	for <nvdimm@lists.linux.dev>; Sun, 13 Apr 2025 22:52:05 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=fail smtp.client-ip=192.198.163.18
ARC-Seal: i=2; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1744584727; cv=fail; b=C+SroxEXNGxxYpWE3I8HQb2L3drGzRX6LoOR3dEikgrTWmXhCRjjmIGSvFzpZuhIpTQ4YBu9FXEiwAPfAqRwgozC16ScpiXgvLnds8UC5jcr/OX2C+3urXeYecu7Smcij8EK/UVeezZfXzTjW96HppaqDgqEOnlTp9S6EzL0ip8=
ARC-Message-Signature: i=2; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1744584727; c=relaxed/simple;
	bh=iluJfpsU++oIIgnjHnQQGAMSzSadvi007rxv3Yc4G6U=;
	h=From:Date:Subject:Content-Type:Message-ID:References:In-Reply-To:
	 To:CC:MIME-Version; b=rUaxvstP91WRM0KZTLvEdR3073SCfOqukswdURYdSZA3uLXgLsg2MicdJYv+pNGipNgxz7891chHszWUbdgxiKRG1WeDpbRMmjA6FZaaQ8j4w4X7k4GfvBbSd1BzOd1t7f7YjD35HVekfIVTVI7MmDzLa/6KgsxlEMREko1MafQ=
ARC-Authentication-Results: i=2; smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=intel.com; spf=pass smtp.mailfrom=intel.com; dkim=pass (2048-bit key) header.d=intel.com header.i=@intel.com header.b=b+QnFiB5; arc=fail smtp.client-ip=192.198.163.18
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=intel.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=intel.com
Authentication-Results: smtp.subspace.kernel.org;
	dkim=pass (2048-bit key) header.d=intel.com header.i=@intel.com header.b="b+QnFiB5"
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1744584725; x=1776120725;
  h=from:date:subject:content-transfer-encoding:message-id:
   references:in-reply-to:to:cc:mime-version;
  bh=iluJfpsU++oIIgnjHnQQGAMSzSadvi007rxv3Yc4G6U=;
  b=b+QnFiB5ckAKcjfXsnEoEdJSiVCT8qm+/qIB3X63XTtYNsXUPbWQn6Jo
   xOC1otsWZDdFsngKF2APhQzDcDhBXqYMZuJwBft1Lc9Cjq0Xdj9L7fwcu
   ABx26vl0Z8OBH7i+0/f9UZZyBpOlyIoaoq9odsZxVvAIOS92krslJziLr
   C2+frVD3i9SrGoWS4rqoyqQInBTxIZqbn4eZj1WLwNReZIZPm2ieAsVx4
   OlVqsvds3rhfgu/c/S2No2v9OO8FIqU1rVIRAsGe3ItCd5A4Cd/aqOUhi
   JDst0h3MW327hPxMJjSF2Ml79UlSd7yVgOlHOODrH01qPJTBCFI3YcBOJ
   w==;
X-CSE-ConnectionGUID: zmqNjOUaTmSmsrDAHmaUCw==
X-CSE-MsgGUID: AvaSmOYtS6CqTFVf/Izx5A==
X-IronPort-AV: E=McAfee;i="6700,10204,11402"; a="45280914"
X-IronPort-AV: E=Sophos;i="6.15,211,1739865600"; 
   d="scan'208";a="45280914"
Received: from fmviesa007.fm.intel.com ([10.60.135.147])
  by fmvoesa112.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 13 Apr 2025 15:52:03 -0700
X-CSE-ConnectionGUID: RSqqwHBiTEOjVt3h32dqdQ==
X-CSE-MsgGUID: pAmz1rqtRuuZy+xcQ3PAPQ==
X-ExtLoop1: 1
X-IronPort-AV: E=Sophos;i="6.15,211,1739865600"; 
   d="scan'208";a="129657471"
Received: from orsmsx903.amr.corp.intel.com ([10.22.229.25])
  by fmviesa007.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 13 Apr 2025 15:52:02 -0700
Received: from ORSMSX901.amr.corp.intel.com (10.22.229.23) by
 ORSMSX903.amr.corp.intel.com (10.22.229.25) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.2.1544.14; Sun, 13 Apr 2025 15:52:02 -0700
Received: from ORSEDG602.ED.cps.intel.com (10.7.248.7) by
 ORSMSX901.amr.corp.intel.com (10.22.229.23) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.2.1544.14 via Frontend Transport; Sun, 13 Apr 2025 15:52:02 -0700
Received: from NAM11-BN8-obe.outbound.protection.outlook.com (104.47.58.168)
 by edgegateway.intel.com (134.134.137.103) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.44; Sun, 13 Apr 2025 15:52:02 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector10001; d=microsoft.com; cv=none;
 b=I1D3WTP2TykNmNbIS4YsN27uUoWPjtQZit3EQUUooVODRuFNej7gGwykRtRWzuUd5+BNMTLmj/5ocTEzJmiqafFqQ/zVMlHM3LkuXuC8JGp7HN6Nxi6eaWs3sqtws9tWL3FtmdM7Cyqpmo98kGpTHK13PJeo3BkIxwHRCO8ORQfix+AY4veUPOKBFqjw6wYKwGuvvUr1pO4XvoERMTm6Fxf3yZBpT8Tg61FrHu4tHQAb+tNjzLS6AJ64sz2W15p2utZVW8rmQAukOVNstNm20BYAS+m3vdM/sQKv8pLzsvpZ43LoSSzhUaXc99bJiok0Pudf4AbVUxLiiT6G8U3GwA==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector10001;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=YouiFuSf4pyrHsNUvpkk19Of+rZKju0AJBO992m58ZM=;
 b=BQq2vJglEjs/1GVHsH51zrYYPrtsFjbX9sHMaZFO3zGacbcnTaTi8ksCPtXbBSYVvCZYPWJRFMjSsg1Es9qB+jzrXeqcRExxYyxA4sOnmC2ZAGpoGAzWAaLlrLqJXSW2hphnYjrV5Y+ZWj1l8q3mYKEKQnla+kKY2WzLUYY7rH88u1FBa7uFRFu5QcvUM64wbSaF2ZtKdHH+kblfi2zsfr5DF8Zz90BSQLKGbxtnN9c4v4NcRa81u7hatRiayMRwKqrBi70XpcvU5MopX9IESjOuzTG0HuYq5LTIMQtcmUBo9R3V8/3SJUe8AoPVs7bOOd1qDEWW/TGfpLfQRvYY/Q==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from MW4PR11MB6739.namprd11.prod.outlook.com (2603:10b6:303:20b::19)
 by DM4PR11MB6042.namprd11.prod.outlook.com (2603:10b6:8:61::18) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.8632.28; Sun, 13 Apr
 2025 22:51:55 +0000
Received: from MW4PR11MB6739.namprd11.prod.outlook.com
 ([fe80::a7ad:a6e8:fced:3f24]) by MW4PR11MB6739.namprd11.prod.outlook.com
 ([fe80::a7ad:a6e8:fced:3f24%4]) with mapi id 15.20.8606.033; Sun, 13 Apr 2025
 22:51:55 +0000
From: Ira Weiny <ira.weiny@intel.com>
Date: Sun, 13 Apr 2025 17:52:16 -0500
Subject: [PATCH v9 08/19] cxl/events: Split event msgnum configuration from
 irq setup
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: 7bit
Message-ID: <20250413-dcd-type2-upstream-v9-8-1d4911a0b365@intel.com>
References: <20250413-dcd-type2-upstream-v9-0-1d4911a0b365@intel.com>
In-Reply-To: <20250413-dcd-type2-upstream-v9-0-1d4911a0b365@intel.com>
To: Dave Jiang <dave.jiang@intel.com>, Fan Ni <fan.ni@samsung.com>, "Jonathan
 Cameron" <Jonathan.Cameron@huawei.com>
CC: Dan Williams <dan.j.williams@intel.com>, Davidlohr Bueso
	<dave@stgolabs.net>, Alison Schofield <alison.schofield@intel.com>, "Vishal
 Verma" <vishal.l.verma@intel.com>, Ira Weiny <ira.weiny@intel.com>,
	<linux-cxl@vger.kernel.org>, <nvdimm@lists.linux.dev>,
	<linux-kernel@vger.kernel.org>, Li Ming <ming.li@zohomail.com>
X-Mailer: b4 0.15-dev-c25d1
X-Developer-Signature: v=1; a=ed25519-sha256; t=1744584735; l=2631;
 i=ira.weiny@intel.com; s=20221211; h=from:subject:message-id;
 bh=iluJfpsU++oIIgnjHnQQGAMSzSadvi007rxv3Yc4G6U=;
 b=4ksVC3g/3tEirb+WH7N3h465FU+jX1FXL+aIj5QnuVEdZ+lAUir9vifMLKND8+PDnUSr+/tPI
 Y21mG9OA/XBDj3poiE+6mVzsupZPTUEcljr3cmX+yrxnZUKLQaP7t79
X-Developer-Key: i=ira.weiny@intel.com; a=ed25519;
 pk=noldbkG+Wp1qXRrrkfY1QJpDf7QsOEthbOT7vm0PqsE=
X-ClientProxiedBy: MW4PR03CA0227.namprd03.prod.outlook.com
 (2603:10b6:303:b9::22) To MW4PR11MB6739.namprd11.prod.outlook.com
 (2603:10b6:303:20b::19)
Precedence: bulk
X-Mailing-List: nvdimm@lists.linux.dev
List-Id: <nvdimm.lists.linux.dev>
List-Subscribe: <mailto:nvdimm+subscribe@lists.linux.dev>
List-Unsubscribe: <mailto:nvdimm+unsubscribe@lists.linux.dev>
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: MW4PR11MB6739:EE_|DM4PR11MB6042:EE_
X-MS-Office365-Filtering-Correlation-Id: a88790ab-a0db-4891-b932-08dd7addc9e5
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;ARA:13230040|376014|1800799024|366016|7053199007;
X-Microsoft-Antispam-Message-Info: =?utf-8?B?T25iRUZNM0xMZDh6ZTNhOG8xTVNHWWNBOWVyQmwrTHRUdGluV0JIL3lvd09T?=
 =?utf-8?B?Wm9Zb3JQalBLdUhnY3FCMngwM3pINXBpM3NhdjhIQm5UZm9SRHV6K2ptbHFO?=
 =?utf-8?B?b1QzU2txTGR6NTFON3B5bG9DM25IR0NHblJobVJ0UVZXcTRTWFpURnE5RUZG?=
 =?utf-8?B?K0twL1BPRXZYOVF1YjhVd01KT2lFVjg4V0s4aTRacUU5UCtNWmdNTDZlN25n?=
 =?utf-8?B?aWU3ZDFuS3h3WFZONzlaZXNOekFCWmN4VTRRbXJMVjNVRzZ4MitwajBYaFFN?=
 =?utf-8?B?blE5ZHJwVHp1TmMzaVVVUnRGVDBQbWJDNW5IYitXRnZGdW5tU3hlMHRPZUw3?=
 =?utf-8?B?akdsVWtyR1ZBZE8yS0h6Z0MrTlkzQzIrd2JhQUF4RnBSUEZkSHdZbXBQMWhX?=
 =?utf-8?B?WGtPQ21weFZKeTBDblArZG1LQnpNWFZnakljd254Tm9kTmcrNm5lK0hjc2p4?=
 =?utf-8?B?QjIyN0tja2pWWFFKS2VkOURiSHRUS2hQcm1qeVNiNEM5ZmZaZmV2ZzFZN2Vi?=
 =?utf-8?B?bWFXelBhd1AyeHBjUDVvS3ZQWERnUVljVDBOOERKYXRpWGtia3Q4UjB3MVBa?=
 =?utf-8?B?WVZOSVl5VlZ2L1RFUTZzWXFBTUI3NjQ1aW5MSzhMcEQ0SWpjUytMT0o3cTRs?=
 =?utf-8?B?WkV6R3NKQStwSmhwRVNkOWxjejNoR0lleHFvMWRBT1AyaVlJVU1EMWFncHNK?=
 =?utf-8?B?UEo2a1lYUlpvZk01MFZuRlFpTm9DM0pOZ0dzQStBSllSMTRndmlYYSt6SmJR?=
 =?utf-8?B?NnNEUjZnMUpLcjRocllMc0p0Z2xLOTJhbHdlaGRiR1ZodUdsYXNmbC9UenFY?=
 =?utf-8?B?ZjN2RjZ2WFppRU5WVWlud1NxcjlUcncvOWVnRGk1UjJyZVBlaXZwMnZ0aGVY?=
 =?utf-8?B?OUhZMElQdDVEbE5tNHlZbnBWc2MwZmhVOUlEMis2MVZmbkxYcVpUWm9MV1FO?=
 =?utf-8?B?MzhZYjhiOFQ0RDRoZGR5UE5HYyt0d1drZktnRUY4Um9HUHVOZGtqUENRMDJP?=
 =?utf-8?B?MkdxSDZ3b3UxazV2dmVkMDl6WFlFTkdpTTY5ZkZnbkhrYVN2WlBkdjQ0eExR?=
 =?utf-8?B?d09nUnNQTmo4SDJDRWY5MFVBWlRCZGltaXBsam9BbmhTQS9paGxSWk5ON0gz?=
 =?utf-8?B?aVRMRTRqVklZb2RiZkZnbENPY0ZzeUFldWpyL01lYmRCc3FRMC9tYmg0UTEv?=
 =?utf-8?B?MTFicE12anVFUEFMM0NoUWZrVWczL1A4OEpyc3Nabm1LT1EyU0JrVTNPWUxW?=
 =?utf-8?B?S2tVUFMreXFxajZoK1I1cnd2TFBsbmxQMU42VndYcmVORmljT0Ftc3lVblFQ?=
 =?utf-8?B?VWozN3hFVkNlOFJSck8xOEpTckY2Y1VkOVFTUVlJbkdUN3lEMWg1U1p2NDBM?=
 =?utf-8?B?UkxzQUVNbFVscERCanZ1OXo1OU9BTVZoS2pTaWNaR0ZYVzg4aGpUK3FBejQx?=
 =?utf-8?B?RFl5aDh0S3UwbXMvS0RsdUVueGpTTTc0RnhoL0FtWVhwaC8xNFFyK3pNeFg3?=
 =?utf-8?B?QytpQ0pZZVphU2RjQWZtbnltaUdDSnlObzk5Z3IxK3Znbm5ueWpVUEJUWmdr?=
 =?utf-8?B?OXBDV2U2eitkZDJ1VlJkU0h5VnpXa0VFOGhlNE5zZkxoYU85eFJzaGFWZGxp?=
 =?utf-8?B?VVpPTlpQLy90c0ptVEI5bnlGLzZ5NEd2L0hKQVc5TTA1eXFCWkdDbjFaelR2?=
 =?utf-8?B?QlhuL0ZmNDBTVXFyUndDQ2tZcGZjNnZpWVBVYTJFUHN0OTV0SkNDckJDN3Vv?=
 =?utf-8?B?Nnh5VWZHRU9CSnF0RGVTVDYvVWs0bVJScWo4eXZ0UkVRLzdFVUYyeS9SUGpx?=
 =?utf-8?B?cyszaGh1KzBOTms1QUhBTng5VG9oRFZLUktaWGVRQ29qMzMydHFqTnhpSUdV?=
 =?utf-8?B?UXowc1hFY0E1cjZ6eTFFUXJUVFVMdlpBM2dBREZWa3E5cFBTUmd1c1FEK09W?=
 =?utf-8?Q?o6I5jafosvQ=3D?=
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:MW4PR11MB6739.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230040)(376014)(1800799024)(366016)(7053199007);DIR:OUT;SFP:1101;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?utf-8?B?ejU1c05zNWt5NkRvVHBLUUZWbU1qYXViNVg2Vk5UUEpOUFRvZ1Rqay8wSTlv?=
 =?utf-8?B?WnJaUVVUZ0dkcGhxY1VJOWhOQWxaQ0JrRUdKMUpHdVBvZU9ZdG93cko0Tk84?=
 =?utf-8?B?N09HVUpWVEhjUWMyY0t3WjVqZkJZL014d3Z2VFhKTFBhZzdZUGxYMmN2OTV0?=
 =?utf-8?B?RTliajhXTmt4TTBxbW5sVG5jaHZoS2JCMkE5Mkk0SjhFdGZYbGpvdzFXT3Ax?=
 =?utf-8?B?UGczZ1l6NUJ1K3dhc2gvdHd3Tmx0dUFvdEphaS9sMThDVzQwaVZrMEdicTZP?=
 =?utf-8?B?VHd1TVpaVyt2bGg5Slp2NTJQOHFxOWJYeUMzL0QwM0F1Qytlbzh6Qlp1OHlY?=
 =?utf-8?B?WWExaTVlQ2YyK0pmaDhMY2hIUWRmTDJza1IwemFFMWpDMkNxWUJIWU13SHZx?=
 =?utf-8?B?OSt2WHF2Q3NBMk1sR05RK2YvREZwZWxnR2ppQ1IvRFpVaU01dE1lZmxDOWdl?=
 =?utf-8?B?cytZQVJFbm5GYjJHdUREU2FRbXUvOE4vQ0hJTHppbjB5eThKWnJZUlFuTlZ3?=
 =?utf-8?B?QWgvU08yM2dKdXJUdC94a05ibHl5dGtDUjNlNk8reUpQTXdTTC9xek5JeTU1?=
 =?utf-8?B?YnlCN1FsVU9uRUFxSWdFMEJnN3NXanh2Q3RFVVRFYnpESmQ4U0xNL3p5d2FQ?=
 =?utf-8?B?QmwrQmo0L3ZvVHAxTlNnalVpdXpBWXM0aHU0RGQvQWE1RjkxTnIzVlVmcjN2?=
 =?utf-8?B?QlpVUzhMTGRZbTBhd2FTYkpWaCtGaEJwTmhPUm04a21vS1dEY1Jvdm5vVmdk?=
 =?utf-8?B?RDRnUk9sbGNXcjNDM1djcElWTWdkQnFONUFlSWoySmF5aUQ3bW9sYXc4RDJz?=
 =?utf-8?B?bURrSThJQUNyQjRUVWRBcXowTnZnNUljQU5NVjM5SlljT0tESGUwK2JQOFpH?=
 =?utf-8?B?U1lIRjFkL3lYR3FEUEkxU1hXVVhYcFRWVmF3Um4zS29KbTNvVjRuTjdLd042?=
 =?utf-8?B?ZUN0aFZMQXArNy9JVU5Gak9Oc3VRRFJ4dURkV0FkMm1LQUN1cFh0YUZjZ2NT?=
 =?utf-8?B?SThabkJJNGdWRzJoWDZXMXEvVy90SDBwYTdGUGV2aVN0ZURhWk1lSUFyazA4?=
 =?utf-8?B?aVZjRjFDckN6aEhrWXFLeG9UaENVczhRVWw4MmhScVlvdG1aaEpHeVIyblRY?=
 =?utf-8?B?ZDA0MTZWNnRVQ1M2OTZZYmJWUkduV0ZLSFBqenpvV29EdVZTeS9kQWN3OUVZ?=
 =?utf-8?B?bXlJRzF3ZWdySTdXbm9vTXZYaTVXM0picDhIaTkrYkREVTVsLzdUM2RuZ05S?=
 =?utf-8?B?VVVJYXFOb2tQcnJKMEFCN3FQb3NLTVZTWWtIaXkvQnZWQ0sxVEcwN05FME4w?=
 =?utf-8?B?ajJKWm56UCtOMlFHWjFRMDRtd01KOGFzRUJ5SjBpMjNEdEhGTWh3Vm1GUmZG?=
 =?utf-8?B?RFRBMHRFeGg0ZVhGdnVVeWN4bHkrbTFvRUZINFUyU3ljQ3N5OVp2dng4b01U?=
 =?utf-8?B?NWZaWEJtZk52NVBiL3hEQUd6NWZaNnZSdFJKbEhmRUhjYi9NVmF3bEs2U3Ax?=
 =?utf-8?B?M1FMTVJ5WU1yOVZ0ZWV3em5YMXRzaEtmZTBvajBYUWs2N0VoaE5JME9TcGQw?=
 =?utf-8?B?czhiTmg2Wm5GeHJHU1Z4dzlVYzdBeTZTdDVKY0ZnL0JmOW5YbG5zNnFSNmx1?=
 =?utf-8?B?ejQ5M2NMWUpVMk5zaUFHTnNSYjRYcmpUVWVYVm5sTlR0MmZvam5nOWd2QVBx?=
 =?utf-8?B?WGJBYWltaHFqbTJTR1BTMklISHhiWmRsY2pRQlN0YmZocHpoVXpXZXUyM3ky?=
 =?utf-8?B?bHRoRTlTaDlFWDFQbUEzSkJJZ2Y2TlhwRkIvVWVDbkRwYUdDUUdETWlVNm9l?=
 =?utf-8?B?RTdzUjJIRTFtSFRFMWowcGZVWng0TFdhNUFhbytBZDJQeXByamtaaHpLZ0hQ?=
 =?utf-8?B?SGJTVnE3MlpOVnlaUUxvV29wNm9vK05KNytkQUtINld0OXg1TGJidXFsdlVH?=
 =?utf-8?B?V3UzVVlSTkEzQkdhcGplUm5TempWMlZKbFg3U3MwZUxOeE5LcHdWdUJueDVY?=
 =?utf-8?B?c1FQR3BhYU4wem53bDF2eDlwQmJQYWZueDUzblA4WVJ5Tlc1ZE00WHR0NERT?=
 =?utf-8?B?Y0x6Zk9SY3JaQm9VaGxYS1ZFdFVqRCtMb3VHUmlvYXpsamdEMUc0eFlrZnFu?=
 =?utf-8?Q?2bOUBl+3FOY6tNMU7a9+EB5ay?=
X-MS-Exchange-CrossTenant-Network-Message-Id: a88790ab-a0db-4891-b932-08dd7addc9e5
X-MS-Exchange-CrossTenant-AuthSource: MW4PR11MB6739.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 13 Apr 2025 22:51:55.1929
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: Lij58BCKBgJ8UPZLXHCFCp080M+PmQMYbvZ3PoNFy/UznMfZBTMeQBFuGJjHFNV0ges1iqCkV9t98/4Krg8vbA==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: DM4PR11MB6042
X-OriginatorOrg: intel.com
Status: O
Content-Length: 2549
Lines: 84

Dynamic Capacity Devices (DCD) require event interrupts to process
memory addition or removal.  BIOS may have control over non-DCD event
processing.  DCD interrupt configuration needs to be separate from
memory event interrupt configuration.

Split cxl_event_config_msgnums() from irq setup in preparation for
separate DCD interrupts configuration.

Reviewed-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
Reviewed-by: Fan Ni <fan.ni@samsung.com>
Reviewed-by: Dave Jiang <dave.jiang@intel.com>
Reviewed-by: Li Ming <ming.li@zohomail.com>
Signed-off-by: Ira Weiny <ira.weiny@intel.com>
---
 drivers/cxl/pci.c | 22 +++++++++++-----------
 1 file changed, 11 insertions(+), 11 deletions(-)

diff --git a/drivers/cxl/pci.c b/drivers/cxl/pci.c
index bc40cf6e2fe9..308b05bbb82d 100644
--- a/drivers/cxl/pci.c
+++ b/drivers/cxl/pci.c
@@ -715,35 +715,31 @@ static int cxl_event_config_msgnums(struct cxl_memdev_state *mds,
 	return cxl_event_get_int_policy(mds, policy);
 }
 
-static int cxl_event_irqsetup(struct cxl_memdev_state *mds)
+static int cxl_event_irqsetup(struct cxl_memdev_state *mds,
+			      struct cxl_event_interrupt_policy *policy)
 {
 	struct cxl_dev_state *cxlds = &mds->cxlds;
-	struct cxl_event_interrupt_policy policy;
 	int rc;
 
-	rc = cxl_event_config_msgnums(mds, &policy);
-	if (rc)
-		return rc;
-
-	rc = cxl_event_req_irq(cxlds, policy.info_settings);
+	rc = cxl_event_req_irq(cxlds, policy->info_settings);
 	if (rc) {
 		dev_err(cxlds->dev, "Failed to get interrupt for event Info log\n");
 		return rc;
 	}
 
-	rc = cxl_event_req_irq(cxlds, policy.warn_settings);
+	rc = cxl_event_req_irq(cxlds, policy->warn_settings);
 	if (rc) {
 		dev_err(cxlds->dev, "Failed to get interrupt for event Warn log\n");
 		return rc;
 	}
 
-	rc = cxl_event_req_irq(cxlds, policy.failure_settings);
+	rc = cxl_event_req_irq(cxlds, policy->failure_settings);
 	if (rc) {
 		dev_err(cxlds->dev, "Failed to get interrupt for event Failure log\n");
 		return rc;
 	}
 
-	rc = cxl_event_req_irq(cxlds, policy.fatal_settings);
+	rc = cxl_event_req_irq(cxlds, policy->fatal_settings);
 	if (rc) {
 		dev_err(cxlds->dev, "Failed to get interrupt for event Fatal log\n");
 		return rc;
@@ -790,11 +786,15 @@ static int cxl_event_config(struct pci_host_bridge *host_bridge,
 		return -EBUSY;
 	}
 
+	rc = cxl_event_config_msgnums(mds, &policy);
+	if (rc)
+		return rc;
+
 	rc = cxl_mem_alloc_event_buf(mds);
 	if (rc)
 		return rc;
 
-	rc = cxl_event_irqsetup(mds);
+	rc = cxl_event_irqsetup(mds, &policy);
 	if (rc)
 		return rc;
 

-- 
2.49.0


From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from mgamail.intel.com (mgamail.intel.com [192.198.163.18])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id C11B81F3D31
	for <nvdimm@lists.linux.dev>; Sun, 13 Apr 2025 22:52:05 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=fail smtp.client-ip=192.198.163.18
ARC-Seal: i=2; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1744584727; cv=fail; b=RiaFHLldZqkbSZX+LWWPOoqAgl3wEaEG/S4FS+UiTNfe+c28VVxI0zPT8MVVtMTqy516CCPuiwKOGpCdwtdhrXWYiICvbR2BG1IgIo/txSU8Z7V+wMgErd7g2Kkr4fsOuTVSI7z8MIgObOtjarITNlOVFtRua4rwYTK8+k7z970=
ARC-Message-Signature: i=2; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1744584727; c=relaxed/simple;
	bh=I4hV71hOvjOspfYk0aPxzUTtPYw5QAMg7ynPu+boSlw=;
	h=From:Date:Subject:Content-Type:Message-ID:References:In-Reply-To:
	 To:CC:MIME-Version; b=X9FTxZzhBrpk6E2rNEsXBzbaNDE+398Qo74c4HE+AXVcvrDVtSgEsFpgL9pi/GwiKH17s5yMuCzcJqBaUyskMDJcmCaWHjYiMxwSwcy3U/K3jCtChX6wSERYC8QIyuxj1luwhadsijuS6CXRnAhjveOqmzTgtkIG6MyC1rcMCAE=
ARC-Authentication-Results: i=2; smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=intel.com; spf=pass smtp.mailfrom=intel.com; dkim=pass (2048-bit key) header.d=intel.com header.i=@intel.com header.b=nRCriQeS; arc=fail smtp.client-ip=192.198.163.18
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=intel.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=intel.com
Authentication-Results: smtp.subspace.kernel.org;
	dkim=pass (2048-bit key) header.d=intel.com header.i=@intel.com header.b="nRCriQeS"
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1744584726; x=1776120726;
  h=from:date:subject:content-transfer-encoding:message-id:
   references:in-reply-to:to:cc:mime-version;
  bh=I4hV71hOvjOspfYk0aPxzUTtPYw5QAMg7ynPu+boSlw=;
  b=nRCriQeSJmcpv2I7wXiX98rQaDu/aAmzsRzkKCliTesTL1J5Qc9GZmnC
   fiOfYi6xU+k0QdfWXZwkC6bNC8CjXIuM/y8cNWaajki9RlaOODrrBRU9E
   b+Lsfr3XN3xdZanwmhJsA2lJ0KKSe1M3xcUialyZxZgB1EK13pVb3pkqs
   hMjeSiJe2CY2jkSmPm06ZAJNU11+uvvV5A9DjcgZULZoT36kJ99tH7swZ
   0V6RHcreO77tHitWIMCMr4yegYK5SertCzxrZob7eDouo4voc68Zyq7L1
   3ozPVOBneU8Hp3GnvTPWKUKgTU+NAJzBOhVj8MN+LbH+POPO84TGeTkRc
   Q==;
X-CSE-ConnectionGUID: mvaNDcF4RhWi3iAX66OXeQ==
X-CSE-MsgGUID: 93EU6PtbRWme9YCQJuOfXw==
X-IronPort-AV: E=McAfee;i="6700,10204,11402"; a="45280920"
X-IronPort-AV: E=Sophos;i="6.15,211,1739865600"; 
   d="scan'208";a="45280920"
Received: from fmviesa007.fm.intel.com ([10.60.135.147])
  by fmvoesa112.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 13 Apr 2025 15:52:04 -0700
X-CSE-ConnectionGUID: r3hxRt6/T2unMfPH1JfjjQ==
X-CSE-MsgGUID: LsSwU6+oRpSPyz9S6AFDMg==
X-ExtLoop1: 1
X-IronPort-AV: E=Sophos;i="6.15,211,1739865600"; 
   d="scan'208";a="129657482"
Received: from orsmsx903.amr.corp.intel.com ([10.22.229.25])
  by fmviesa007.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 13 Apr 2025 15:52:03 -0700
Received: from ORSMSX901.amr.corp.intel.com (10.22.229.23) by
 ORSMSX903.amr.corp.intel.com (10.22.229.25) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.2.1544.14; Sun, 13 Apr 2025 15:52:02 -0700
Received: from ORSEDG602.ED.cps.intel.com (10.7.248.7) by
 ORSMSX901.amr.corp.intel.com (10.22.229.23) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.2.1544.14 via Frontend Transport; Sun, 13 Apr 2025 15:52:02 -0700
Received: from NAM11-BN8-obe.outbound.protection.outlook.com (104.47.58.168)
 by edgegateway.intel.com (134.134.137.103) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.44; Sun, 13 Apr 2025 15:52:02 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector10001; d=microsoft.com; cv=none;
 b=pM/b3wRSEVPTKVKnkPc79uHWwAPyUQGsho0i0yVHBk/LmUFf1I6tv8NaD9nfGGPYroq2weck/V9pac95oEo2VPV1G57TuzAP7LjBYUkBgq1Dqau2+gzau0R8aIJAX3NrpEeL0Qp4DRa+niQJo6VbkpTS9zNdO60N1ItyKTPSwJ/a2jSNvT22wUQTNi+qgSUp5ggC4ozJJssbApKbLDhgH54FmnLW7BphirdaEgh+f4Hj1JP1gcXJ3fLGREL0oQZVwnGonO4NoAws+ornw0qajgi/ECZnm0xfeF5YdxnQ+hEMPdDr9YB0+wE7mH4YRdtrz1d1zMmvRsRCupelvcFxhA==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector10001;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=a/GNGXtpj/hr3QtK7ujbvV1FA1d76rRqvbSPhLn3p38=;
 b=WX9VI3Y8Y8v79eWLnsDSEH8DKgQuiuYbMiPYTQqQGtAJ/8l5uw+95G6NkiV/tYgYzBG10j8+729O4jDzx5hnh7doz62TArDT6uvHaF6ibnNYQe/jnadV9PijW2US3EWDu1ZWgE7Oc3WaZmvtGMgSMDWr38EAeHy4Mow5HjAQK2uoZVqHSGW8tQFP3mna3GSp22m8eJ9tmziG/cqpHE5vwLGLZTOxff3NxDHVjQmzyesJ4xRUI2CSXwyO2K61XuTvkX12DrHvDKGFU8gTUACjYTCNQAZqeHT/qRhR5OUbZjZoq8qYOfCme7woDBQHOSv9ubvjPLxOF6r/htfSuuHwjA==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from MW4PR11MB6739.namprd11.prod.outlook.com (2603:10b6:303:20b::19)
 by DM4PR11MB6042.namprd11.prod.outlook.com (2603:10b6:8:61::18) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.8632.28; Sun, 13 Apr
 2025 22:51:57 +0000
Received: from MW4PR11MB6739.namprd11.prod.outlook.com
 ([fe80::a7ad:a6e8:fced:3f24]) by MW4PR11MB6739.namprd11.prod.outlook.com
 ([fe80::a7ad:a6e8:fced:3f24%4]) with mapi id 15.20.8606.033; Sun, 13 Apr 2025
 22:51:57 +0000
From: Ira Weiny <ira.weiny@intel.com>
Date: Sun, 13 Apr 2025 17:52:17 -0500
Subject: [PATCH v9 09/19] cxl/pci: Factor out interrupt policy check
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: 7bit
Message-ID: <20250413-dcd-type2-upstream-v9-9-1d4911a0b365@intel.com>
References: <20250413-dcd-type2-upstream-v9-0-1d4911a0b365@intel.com>
In-Reply-To: <20250413-dcd-type2-upstream-v9-0-1d4911a0b365@intel.com>
To: Dave Jiang <dave.jiang@intel.com>, Fan Ni <fan.ni@samsung.com>, "Jonathan
 Cameron" <Jonathan.Cameron@huawei.com>
CC: Dan Williams <dan.j.williams@intel.com>, Davidlohr Bueso
	<dave@stgolabs.net>, Alison Schofield <alison.schofield@intel.com>, "Vishal
 Verma" <vishal.l.verma@intel.com>, Ira Weiny <ira.weiny@intel.com>,
	<linux-cxl@vger.kernel.org>, <nvdimm@lists.linux.dev>,
	<linux-kernel@vger.kernel.org>, Li Ming <ming.li@zohomail.com>
X-Mailer: b4 0.15-dev-c25d1
X-Developer-Signature: v=1; a=ed25519-sha256; t=1744584735; l=2242;
 i=ira.weiny@intel.com; s=20221211; h=from:subject:message-id;
 bh=I4hV71hOvjOspfYk0aPxzUTtPYw5QAMg7ynPu+boSlw=;
 b=OSXoDp9OrvabwhRjCQQxUU7QdFJTUEigulwgAulz8q2Z4G3jHv58yquDPvV6PQ3Zc97iAdS7h
 SoBRvDF1Sq/CU1fNHJd+273EBhAsp+88JJtvwQauTdtOmKA1Jzo3vgN
X-Developer-Key: i=ira.weiny@intel.com; a=ed25519;
 pk=noldbkG+Wp1qXRrrkfY1QJpDf7QsOEthbOT7vm0PqsE=
X-ClientProxiedBy: MW4PR03CA0227.namprd03.prod.outlook.com
 (2603:10b6:303:b9::22) To MW4PR11MB6739.namprd11.prod.outlook.com
 (2603:10b6:303:20b::19)
Precedence: bulk
X-Mailing-List: nvdimm@lists.linux.dev
List-Id: <nvdimm.lists.linux.dev>
List-Subscribe: <mailto:nvdimm+subscribe@lists.linux.dev>
List-Unsubscribe: <mailto:nvdimm+unsubscribe@lists.linux.dev>
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: MW4PR11MB6739:EE_|DM4PR11MB6042:EE_
X-MS-Office365-Filtering-Correlation-Id: d8b96218-9bd6-4755-3933-08dd7addcae4
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;ARA:13230040|376014|1800799024|366016|7053199007;
X-Microsoft-Antispam-Message-Info: =?utf-8?B?MHBmSnEwaEtJbmlFc2NtZmVpcnZQOGkwSnpYdDVpL0ZmRnBTWWxUaHNJZjk5?=
 =?utf-8?B?Rm4xUUdIWDBXMlJHb0VwRHVnOXVTYVBzQktWU1Q2TDAzb2xQNE4zOUFIVmN2?=
 =?utf-8?B?VmNCRk02bzNQYU5acEZ6NkJxSDVRRVpJRTRRSkJLTURzVFV4bEtuZEFBWWJp?=
 =?utf-8?B?dlpVRFkyYkxEVi9oVDl5NDBPVUZmWWp2UVZPU3FtK2gxNURZVWRlRnE2a05R?=
 =?utf-8?B?eklON1ZCYVI3K0V6RlVPVGI2MS9jYU8xaHpUL01JbUsrQ00rTTN2dk82L1F2?=
 =?utf-8?B?Y294MnUwaTl4azIxdTZRMVVsQ1d0aFVRSHZNRTZMcExjL0dnT1Rzc1BBSno4?=
 =?utf-8?B?L0ZjOVVZa3BUYytwTDEwQi9WaUI2MkZwYVBic1BxV3NXT3NadVZBdlZhVEMy?=
 =?utf-8?B?akZnMmx0TXE5YWhwZTF3dk80QWN4NThYbStoZkdPMThGT0ZFbGtnNis1OXc5?=
 =?utf-8?B?V20rSWE5dVk0Q0VvajhKOFNCYmJnMzhjMm9DS0lHMTYrY2YvelI4eHpyNTJy?=
 =?utf-8?B?TUh4SDhWRHZsWk0zZWxadzRvUktRWWxDTnBSV0FQcUo0czY3R1JHNW9hdVpX?=
 =?utf-8?B?MEN3VnUrTVFLNTFudlhkMi9RbjFvUHBnUGdNTlF2TVhkbURYaHI4bjVvT1gv?=
 =?utf-8?B?Q05EQTNjZmRoZ0JDallKb3Npdzh4d2F2WmFtM3FqRW1vUmNBT1VWWWJjUGdj?=
 =?utf-8?B?WFNXM1hCTk9WaTh1ZlpWZVMvS0c4TERjNEdVejhRTURoOVdlV2E0Z3U1MXZV?=
 =?utf-8?B?VWw1dDZTK1RXYnk3Y1FuM2dJSTBES0Z6UElFdjA1UlpHRWpoMU1xdzdsSEFj?=
 =?utf-8?B?ZWlIeWpLVTg5MHVjUDZMK044dG5YNi9ydDArSzZ5TWVpWE1ybTF5NnUrUWZ4?=
 =?utf-8?B?bGMvdUxPZUV2SGtvYWpwcVpEcUJKaGNlejFpUzIzYjA2aG5DRS9NalpSVFJS?=
 =?utf-8?B?cWo0a0ZlWm9ObDJaOW9qUW5YdytqSDd5SHJjUHA1V1dXUlI3OGdwWnY3ajdQ?=
 =?utf-8?B?cVdTanZCVGdmTW92bkhEaEdrbkV2L1RQYXJ6SmFOdHlaSXA4M2phTzVDZjk2?=
 =?utf-8?B?L1pJYm0xYzdjSzdrRkE4U2dqa3AvL08yMzl1SUdvNnN0QnFtV3NOZ1dIeHZJ?=
 =?utf-8?B?TFovWklaK1ZIbzZQR0ZjRnQzK00rYmZ3cVh4azdQcWZpZmI2WFF3RzNQTVdY?=
 =?utf-8?B?K0pOSC82Y25WQTRMUVNDQVBvS1BXaVBOVDhPWmRtOW9ZcllnYnh6S2ZKTjg1?=
 =?utf-8?B?NUc5aTlTNWEvQ1NWL1daS0l3c0xseGlhdjR1VzViVnBCTklaWTdDNUtPenBw?=
 =?utf-8?B?bjh1NEZLTERPcVdobnFFZGNFK2lGT0tkQVA5L3hLTm0yWEQ5RVhqQ0ZGRVVw?=
 =?utf-8?B?ckZkZlo1SXdaQXdqUUJOZUxtYURkejBWUUpySGtpOGo4WmhuVEpTaEx5ODg3?=
 =?utf-8?B?SEkrRWViVlpGN3JYSzNUMmRoNUNUNXFiZU1DRzlZN2ZNSVNTaDVZVXB2VXNP?=
 =?utf-8?B?YWhWNy9PaFRBVzFJUDZCZ05KcU01akk0TS96R0lKY0NRWGpsMUE2UHUweGNX?=
 =?utf-8?B?V2gva1h0ODB3THdVS1JrY2pMQktweGFIdVM4Zk5iRTZYUFhrekppQ0wvSmlF?=
 =?utf-8?B?eWJvYlRJZ0Y1WUZmb1pMb0d0alpzaFQ3Q2hmS1lrcmp2TVZvKzVWNmY2Qy9j?=
 =?utf-8?B?ZTYrYjZmZFRnaVNTYkVIL1lNRkNZd1lTbmRYd1BMekNwNlBMMmQzQUEwTWRX?=
 =?utf-8?B?QVlPRGV6QzZ4UTFiWmVYRWR2RERzd2gvVFhmSXV4Y0gwcFd5UDhUVEt6YjJM?=
 =?utf-8?B?M3g4YU80dXUvdU15ZDdWYVhGZlo5UThDcXNnUTFaeWpNcnM0SU5ONkprcTJp?=
 =?utf-8?B?SExGTDFwN3hTMU1ZUGRVTDhscFlGaUpZU3lMWnpjUnZQcFZyOFZQQSt4ZzNx?=
 =?utf-8?Q?5uHPMEUlK38=3D?=
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:MW4PR11MB6739.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230040)(376014)(1800799024)(366016)(7053199007);DIR:OUT;SFP:1101;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?utf-8?B?Rk9JTkh1NTlIWlAzdWFnaTVsbnRqZWw1THlDR3ZGbThXVXF6NCtYZzNQNnQw?=
 =?utf-8?B?ODI3ZkhHWnNHSlV4YnJrcUNhMXdRWEVhejFla0F0V2ljdVYwbjFhTUhLQ3Rw?=
 =?utf-8?B?OTZQR01LNWFCL3o1cUZJSFBBZHo4YTh2bzJmMWZrKzdROVo2aDNUellpeUpj?=
 =?utf-8?B?ZXZ6ZVYvNjc5UU1vd2o1aXNqZW1OdGg5MGt5dGpiYk02Vy9VSEQzRXZ4eGpW?=
 =?utf-8?B?T3ViU2Uxcnl1bnRtMUVvaUlKV2JoRThrSE1jVGVkSkFtVFM4NnBnL1owSWxv?=
 =?utf-8?B?OWRKdmErMEdUV2VHODBtbk1KdTRwcGlFbnR3MlZLN1pGck1wUDkyU2JvVlN3?=
 =?utf-8?B?UW9PcEJhT3FvbjdHeit1Z1llcUlua2JEL2tiQUlWKzB0M3FJUmQ2RmMvUGFl?=
 =?utf-8?B?azY2M1lPSCtFQzNxSlp6VDE2SDNScGxpcmNVR3A5OEdMWE1ybEFFR05RMVBJ?=
 =?utf-8?B?RHJNN3ZIUzNvdkJiY1pvaXczcFd2U1p0bys0WVVvaEpLb0JMT21ndHdqZERZ?=
 =?utf-8?B?YlFuNEVtcjZFVmpvMXIveVhXWk8velljcDl4RHdka2hYUUlwd0c2MG1leFdF?=
 =?utf-8?B?VWxMNm1MV2NzSmtGbGFuVkltTnhnRjVoOU5GVnJiRlVjYlBUb2JzQ2pNeVYw?=
 =?utf-8?B?bmlyNzFXempsNVErUkN4bnpybHhyQU5obEc3YVhtSHJkYTBWcHR4aTNvRmwz?=
 =?utf-8?B?S1pWd0YwRkg3NktEU0NOUGQvZmhJd01ncFByeGZsZ3BZOTRZR3hZNXVBZVVt?=
 =?utf-8?B?dG1nN04vdzlxQi9heVBKZnlpSUl0R1U2alV2V0FOeEZpR0llTW5GNUtXSWVz?=
 =?utf-8?B?dmtqODBmbERHQ0pVV25Db1V4dlhYZVozS1JnNGkwRUNBZWpZRGtWZkNEWC9a?=
 =?utf-8?B?UFQ2ekFUWDk4SHNCOXN3M241bG14SkxvQ3lORnJsMFc1SFIxKzJNUTJ5VFV3?=
 =?utf-8?B?T3pBTzN6dUxJQ2VlWnlLM01Fbkt3WnJncTJOQk1aUnd4dnJKdEcreE1ORHBQ?=
 =?utf-8?B?UUZFN1QxcWJsYU5meXNvUHJ0L3BGeEdLYlV1eFA3M29RREFIMzFLSEg3M214?=
 =?utf-8?B?dGdpMURFaFc4dXVIYUtlTU1EU2I1RTJ1YTQyU1h6NXJBZ0tiWXlxbkUyalJt?=
 =?utf-8?B?TEJIRVNDWjg5eVZXUUo5SWViaHZGYlUvZjdWVHJma1Y1czdPWDdaTmFJSVpM?=
 =?utf-8?B?a3AraVhmRDB0SVFlQTE5MlZqanU2VDFmakdxUGkvY3FEa1RNSEk2Vml1NC96?=
 =?utf-8?B?NmlJMmhDYkVkeHE1MitUVml0TnhQbUxuWUdkbUJ2NVR2L2JlL2JEd2NvUyti?=
 =?utf-8?B?b1dwUjVpRG5yTFZxdW5ONExsQkpSTFl6bkozUUt1U2NJbmNUa0NiT1plOVlF?=
 =?utf-8?B?ZWtQNG5RSHFXMm16N1BTaFMrd1RhaUtUYnUvYXZaL0NUamNnQVVvNmNWdjRY?=
 =?utf-8?B?aU0xais2SnVmSklqQVR1c05xcmVPVWNib09rQUNhY3ZmTS82SE9lNUdVQjF0?=
 =?utf-8?B?R2R1STVEZ0xXYjc4OHlIUEZoOE5DMmJvNUJOUFExQzA1YVdMdTZsQUhCd1NK?=
 =?utf-8?B?RVZGejdVVUF6cWdlM2hrMFZqZGMwdFdMSTkvL0V6TUNFOW05YTdibkRQbjVI?=
 =?utf-8?B?UUhCeFpaT2h2UHhGN3E0VXRYSkNVTUlPU25QVXNBNVRtQUdEcTRJRWV3VUpM?=
 =?utf-8?B?UEphYlRJU3FwangvMks1b0pCdHkrYzFBSXlERTZnVkhhUzZHTkhEYk1ZM3Fy?=
 =?utf-8?B?cURpUC9McFVPSFEydkM5OHFheEs2R2svdUhLR3Y2bmV1VUlqdGNVaTc2aHBY?=
 =?utf-8?B?cGY2TFBkbURhMDZpUVZnY2pRaVBzQkx6V3Y3bnEzb1FLbWhQd2FzWXhMdnJZ?=
 =?utf-8?B?ZEJOSmhJWUIxZjREVjNyd05PS0tsVGhUQ3lTN2hMRHMxcEtyTEJabFU4SWh3?=
 =?utf-8?B?Q2xiZm9xVjVxeVdNVFA0ejZ2SjdUOTIvRUMweGVmY1N2YzdtNmRVUFU5VWYw?=
 =?utf-8?B?ZUZibVNZaHB5ZDcxVzRkUUpIcTJpQi9mQ2I1RTNxZUJPbkZSVXA4eUxoVFNG?=
 =?utf-8?B?eW9scCszWVZ6d0djWWIrNkdxUytlQ3d5bkJpVFRDcGRodHRHamRWM3h3Mmdt?=
 =?utf-8?Q?CZKmXwjg/iq48r4n6tyFhSXW5?=
X-MS-Exchange-CrossTenant-Network-Message-Id: d8b96218-9bd6-4755-3933-08dd7addcae4
X-MS-Exchange-CrossTenant-AuthSource: MW4PR11MB6739.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 13 Apr 2025 22:51:56.9538
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: TA69BM0KOA1HMaZ9Sn/WWD7aKXQ5F30ADnuICwpiAXgoqrU4tZSLAFRYCbQwNLULiYGeTcQ/eVEXzdDIi+7GfQ==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: DM4PR11MB6042
X-OriginatorOrg: intel.com
Status: O
Content-Length: 2180
Lines: 64

Dynamic Capacity Devices (DCD) require event interrupts to process
memory addition or removal.  BIOS may have control over non-DCD event
processing.  DCD interrupt configuration needs to be separate from
memory event interrupt configuration.

Factor out event interrupt setting validation.

Reviewed-by: Dave Jiang <dave.jiang@intel.com>
Reviewed-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
Reviewed-by: Fan Ni <fan.ni@samsung.com>
Reviewed-by: Li Ming <ming.li@zohomail.com>
Link: https://lore.kernel.org/all/663922b475e50_d54d72945b@dwillia2-xfh.jf.intel.com.notmuch/ [1]
Suggested-by: Dan Williams <dan.j.williams@intel.com>
Signed-off-by: Ira Weiny <ira.weiny@intel.com>
---
 drivers/cxl/pci.c | 23 ++++++++++++++++-------
 1 file changed, 16 insertions(+), 7 deletions(-)

diff --git a/drivers/cxl/pci.c b/drivers/cxl/pci.c
index 308b05bbb82d..36d031d66dec 100644
--- a/drivers/cxl/pci.c
+++ b/drivers/cxl/pci.c
@@ -755,6 +755,21 @@ static bool cxl_event_int_is_fw(u8 setting)
 	return mode == CXL_INT_FW;
 }
 
+static bool cxl_event_validate_mem_policy(struct cxl_memdev_state *mds,
+					  struct cxl_event_interrupt_policy *policy)
+{
+	if (cxl_event_int_is_fw(policy->info_settings) ||
+	    cxl_event_int_is_fw(policy->warn_settings) ||
+	    cxl_event_int_is_fw(policy->failure_settings) ||
+	    cxl_event_int_is_fw(policy->fatal_settings)) {
+		dev_err(mds->cxlds.dev,
+			"FW still in control of Event Logs despite _OSC settings\n");
+		return false;
+	}
+
+	return true;
+}
+
 static int cxl_event_config(struct pci_host_bridge *host_bridge,
 			    struct cxl_memdev_state *mds, bool irq_avail)
 {
@@ -777,14 +792,8 @@ static int cxl_event_config(struct pci_host_bridge *host_bridge,
 	if (rc)
 		return rc;
 
-	if (cxl_event_int_is_fw(policy.info_settings) ||
-	    cxl_event_int_is_fw(policy.warn_settings) ||
-	    cxl_event_int_is_fw(policy.failure_settings) ||
-	    cxl_event_int_is_fw(policy.fatal_settings)) {
-		dev_err(mds->cxlds.dev,
-			"FW still in control of Event Logs despite _OSC settings\n");
+	if (!cxl_event_validate_mem_policy(mds, &policy))
 		return -EBUSY;
-	}
 
 	rc = cxl_event_config_msgnums(mds, &policy);
 	if (rc)

-- 
2.49.0


From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from mgamail.intel.com (mgamail.intel.com [192.198.163.18])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id 1C4B21F4281
	for <nvdimm@lists.linux.dev>; Sun, 13 Apr 2025 22:52:07 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=fail smtp.client-ip=192.198.163.18
ARC-Seal: i=2; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1744584729; cv=fail; b=fUIzG/tqjN1OatryX538bI1919NmEbr3Icpi6emFXWE6l5n0atA7mSwFG4xYRSgRCEcb0FAv3gq5ON130NEnS1FEhPsGIfDxKfmPmsbLQ7+Uv19IItyuJod8qQRAQTptVTajZNDlx14KgjGclb+8ltZbrnmHKIKDY1ixLDGHNjU=
ARC-Message-Signature: i=2; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1744584729; c=relaxed/simple;
	bh=DweLy/iFYuJN2tVNOKyxcg0lNjkjC4dzRFmq2hss15o=;
	h=From:Date:Subject:Content-Type:Message-ID:References:In-Reply-To:
	 To:CC:MIME-Version; b=QArz6fcMcLDDlR2Cb4XfTEf/CzP/3Qu5kQm7GeADwoWeLlTRKNurTHg4hyprp/jZYzbR6c2Ju8z70ylLMnH1u8D+nkzKVLGsxDbzu9eIU9CrsThIThcuS6/aF9eAEtd07jIBi+2WjquYw9mB7VjR11BpK2vymARbh/8Z08i7WT4=
ARC-Authentication-Results: i=2; smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=intel.com; spf=pass smtp.mailfrom=intel.com; dkim=pass (2048-bit key) header.d=intel.com header.i=@intel.com header.b=aFDLrK6p; arc=fail smtp.client-ip=192.198.163.18
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=intel.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=intel.com
Authentication-Results: smtp.subspace.kernel.org;
	dkim=pass (2048-bit key) header.d=intel.com header.i=@intel.com header.b="aFDLrK6p"
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1744584727; x=1776120727;
  h=from:date:subject:content-transfer-encoding:message-id:
   references:in-reply-to:to:cc:mime-version;
  bh=DweLy/iFYuJN2tVNOKyxcg0lNjkjC4dzRFmq2hss15o=;
  b=aFDLrK6pLK9II205XHRUswU9+5Vpo8qeZdjTzqmFs6ot2AB8UWQZWSQC
   lbJmY5vB1CO+VM/eGgb/Ew6Rj0YGUmVnXrvYg/iKiYpp44gXACaKrIobl
   eEQGTLdFNj+seIb3swsgmWCOWhdxg6tueODF38ui4+M3x7Fzjka6ti8it
   v84ErjYXlXULDD4pDxDRX7F0+4fP4RdfnXJChkt2QFhyjGuKFXAb/58xq
   U+/UCpcHgWEqtRsGKdrZ1y3es79ApKB1AoEj2ovhSk/cPownBWeGqAj9Z
   bhRL7NhnX0LJ33hUGqzLEAHT8GlZZJipzJ6n22bgO5SrVWEm7JYkNxkBU
   Q==;
X-CSE-ConnectionGUID: BmPQZXxjRAmoOrNfFkfMAw==
X-CSE-MsgGUID: ScFYeDswQi6k5NHOyORECw==
X-IronPort-AV: E=McAfee;i="6700,10204,11402"; a="45280927"
X-IronPort-AV: E=Sophos;i="6.15,211,1739865600"; 
   d="scan'208";a="45280927"
Received: from fmviesa007.fm.intel.com ([10.60.135.147])
  by fmvoesa112.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 13 Apr 2025 15:52:05 -0700
X-CSE-ConnectionGUID: sMRIQHZZTXKTL3F5Xbl3rg==
X-CSE-MsgGUID: cSUTNWydTj28tZzYQJ0V+A==
X-ExtLoop1: 1
X-IronPort-AV: E=Sophos;i="6.15,211,1739865600"; 
   d="scan'208";a="129657488"
Received: from orsmsx903.amr.corp.intel.com ([10.22.229.25])
  by fmviesa007.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 13 Apr 2025 15:52:04 -0700
Received: from ORSMSX901.amr.corp.intel.com (10.22.229.23) by
 ORSMSX903.amr.corp.intel.com (10.22.229.25) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.2.1544.14; Sun, 13 Apr 2025 15:52:03 -0700
Received: from ORSEDG602.ED.cps.intel.com (10.7.248.7) by
 ORSMSX901.amr.corp.intel.com (10.22.229.23) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.2.1544.14 via Frontend Transport; Sun, 13 Apr 2025 15:52:03 -0700
Received: from NAM11-BN8-obe.outbound.protection.outlook.com (104.47.58.168)
 by edgegateway.intel.com (134.134.137.103) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.44; Sun, 13 Apr 2025 15:52:03 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector10001; d=microsoft.com; cv=none;
 b=vl+/f8aHDGJ8kSTMrOJRG9ZdTPZgSNxgZZF/PLW7M8vMFxfQQNqhu6SCd7TGbw8KCO6X/2ajTbu5fNobyvUpJtk5vdfornqFAE0nWCrEkM/T+8wz3ybLntqV4d4qLaaKODuml0OgH92QEg3wCiZwdOBIyWba9aBK5dVjmooAt1U6bLmtX5QBCwjxyAbQkQrpWKeIuzVik2U8oBXZW5p1fdNKPL/shwH8uGWvdIBlbX6LG/g4d/8rkjuLVyJqSpICDWpO0HignBYH6maplyCT1caMfI1CWSAxiBHysLJNdwotqsmRP+fjBoNjxPnuXkjQBIQepZZGXKmt3B6HwZTVfw==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector10001;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=YdhHm7MPN9whPt26xmtzjGZbBz7yKJXcWBNKSmyB8kQ=;
 b=s9vMVIzuTYVeZkk/2dr77MO6EmMcltVEFuO4EViqcxj04kLJzRN7q+L3jACOIlZekMyk4TTBifCu52o0u43guvi8FQpEw47GfSOemV2z4TYEs2kftN6rkpuEWsRadrG2rCPeq/qIZ+RRZ9uHnXyVbkYsTHfBRh5X1DDNQX6xfNR6jgG5uE7fh9hAvXhhf6gRSojGWOcberqo54RSS4gdCjfG/KJ4OGMorPAKO/Vga5ULMKh4G+21MtZDvJukfqX1w5M1oV+0H1gU99fN3uKPFJ0fLgfmzOYiA0llJweKAsCjtc15x6SyvlYu9Dw3a0W6rhV4WrUNkWZwKHNO5rG4IA==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from MW4PR11MB6739.namprd11.prod.outlook.com (2603:10b6:303:20b::19)
 by DM4PR11MB6042.namprd11.prod.outlook.com (2603:10b6:8:61::18) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.8632.28; Sun, 13 Apr
 2025 22:51:59 +0000
Received: from MW4PR11MB6739.namprd11.prod.outlook.com
 ([fe80::a7ad:a6e8:fced:3f24]) by MW4PR11MB6739.namprd11.prod.outlook.com
 ([fe80::a7ad:a6e8:fced:3f24%4]) with mapi id 15.20.8606.033; Sun, 13 Apr 2025
 22:51:59 +0000
From: Ira Weiny <ira.weiny@intel.com>
Date: Sun, 13 Apr 2025 17:52:18 -0500
Subject: [PATCH v9 10/19] cxl/mem: Configure dynamic capacity interrupts
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: 7bit
Message-ID: <20250413-dcd-type2-upstream-v9-10-1d4911a0b365@intel.com>
References: <20250413-dcd-type2-upstream-v9-0-1d4911a0b365@intel.com>
In-Reply-To: <20250413-dcd-type2-upstream-v9-0-1d4911a0b365@intel.com>
To: Dave Jiang <dave.jiang@intel.com>, Fan Ni <fan.ni@samsung.com>, "Jonathan
 Cameron" <Jonathan.Cameron@huawei.com>
CC: Dan Williams <dan.j.williams@intel.com>, Davidlohr Bueso
	<dave@stgolabs.net>, Alison Schofield <alison.schofield@intel.com>, "Vishal
 Verma" <vishal.l.verma@intel.com>, Ira Weiny <ira.weiny@intel.com>,
	<linux-cxl@vger.kernel.org>, <nvdimm@lists.linux.dev>,
	<linux-kernel@vger.kernel.org>, Li Ming <ming.li@zohomail.com>
X-Mailer: b4 0.15-dev-c25d1
X-Developer-Signature: v=1; a=ed25519-sha256; t=1744584735; l=5555;
 i=ira.weiny@intel.com; s=20221211; h=from:subject:message-id;
 bh=DweLy/iFYuJN2tVNOKyxcg0lNjkjC4dzRFmq2hss15o=;
 b=n+ag5TvRrreHjgrTSvROpgnVQw5WZXYglhSyUnemZTrMXYOBep823DwswAWmBMAaGW2gN1TlB
 jAUlP8JegpWCY/kVn8N+3y0jvmKaEyO9KUoPBBoLvApcLf4oE0zcwGh
X-Developer-Key: i=ira.weiny@intel.com; a=ed25519;
 pk=noldbkG+Wp1qXRrrkfY1QJpDf7QsOEthbOT7vm0PqsE=
X-ClientProxiedBy: MW4PR03CA0227.namprd03.prod.outlook.com
 (2603:10b6:303:b9::22) To MW4PR11MB6739.namprd11.prod.outlook.com
 (2603:10b6:303:20b::19)
Precedence: bulk
X-Mailing-List: nvdimm@lists.linux.dev
List-Id: <nvdimm.lists.linux.dev>
List-Subscribe: <mailto:nvdimm+subscribe@lists.linux.dev>
List-Unsubscribe: <mailto:nvdimm+unsubscribe@lists.linux.dev>
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: MW4PR11MB6739:EE_|DM4PR11MB6042:EE_
X-MS-Office365-Filtering-Correlation-Id: 3436bfc4-62a0-4485-5e4d-08dd7addcc1d
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;ARA:13230040|376014|1800799024|366016|7053199007;
X-Microsoft-Antispam-Message-Info: =?utf-8?B?ZW1iaktESEdobW9FNnhDMjFJVG5HZzVnQkhlalBwenZOYnZtSU93RWFyaitM?=
 =?utf-8?B?a1ZUZjg5eU1Cc2huS2ZIUjZJSHJyLzd3Y1BCcWxJVytqTmNkME1JcUJGSnZE?=
 =?utf-8?B?WHBxMjY2bnBnYzFpMi9zTWNWQ0E1cm0vRWNQQ256QVFDRjBlWmFpUDJWMVNP?=
 =?utf-8?B?WnVnWWY4WjJPejkwN3lOVmNPWmwyR0RvZlJPMWFpQWtMY0ZYM2dlMUExNnkr?=
 =?utf-8?B?ZnlianhiT2F5WnZCTW9uckFxcTk4dU56RHQ0WTFBMTNLTnBuc1ZibVFOYzl6?=
 =?utf-8?B?Q2tkU05OaEhwRis2V0NrMnRaeXBadFNRNm5aZEdLaXBCRTQ4d09CNURiTDlI?=
 =?utf-8?B?NldUN1hMUk9lS0pyUjRwTmZJWjZVTldGWm1JVWlZQ0wwVHNvaktVSk1KVXhB?=
 =?utf-8?B?dm5hVkx4R3hJTnRuc3ZoNktxVWxzVllnUGx6cUpaNkdWWllkS0xCbWpmREI4?=
 =?utf-8?B?Y0ZmdWNmQTRJRDJMb0hnVWRsckNGdDFndndJVGVnTTNOdDF6aUx5c0ZjNi82?=
 =?utf-8?B?a2VsbGZaM25nRGJ5S2ZpTEdhNFFSSDRtcjZ3Z0ZXL0dSbG5WbzBLV1Z4cEl3?=
 =?utf-8?B?SDM5ekhQYnQ2TGZXb0xWMW9ORkVTcjNoL0VmTnpzRllINEpKaDV5TlMzNVdn?=
 =?utf-8?B?RmFxWXpFSlFiU0VhTkF2KzZtKzJrNXd2QThpZndJNkI3ZXdNYWs3alQzOXg3?=
 =?utf-8?B?TXp1WUZYajRBQjhLVm0zSm16dnRVZFdYQWFmUUp3VDJaNGxsdDdidHptTGJy?=
 =?utf-8?B?SUtORmVCRjRUa3lyZEYzQUJ3Y3ZoR3pva1FtYzBuKzAxNWFBdmlyVkU2YTNQ?=
 =?utf-8?B?QkZtanB2VFlGOUVESndUUWlneXVXWGVUUWg5bmxFMmVzU29qSHhNVW93eHA3?=
 =?utf-8?B?WFBVa2NYcXBQdElUanhjYklHQWlXSis4VzlHZlJlcHR1M1dLYkZuai82UTU3?=
 =?utf-8?B?NXlwYnFDbXRoVkg4bG1PNy9qUjhucnlyVnR2Q1dkekltaHQvYzM0SGRJdzgr?=
 =?utf-8?B?Q3V3UnZobHdpRkt0WlpoaUZuMnd6bmExcldTejVyZlV0VDdiNWdiZEk0Z2Zw?=
 =?utf-8?B?S2tnenVYTEl0U1FLRENpbU1kclBSNmhuaThoRzArY3FzTEEyNFI0SW9QeXFB?=
 =?utf-8?B?K0t4b0E2SEN0T2xYMWV4RTMwOEl6QzJLTTBIbDAyTjlJb09ZWWZVcHdsMklu?=
 =?utf-8?B?Vk9ERXVnRHZFU2xkY3k0WXFzb0NZc1BweDZ4QUxWQW5DeC9hcnh4N3h0ZGpS?=
 =?utf-8?B?SzdCWWRheDB6MWZlTnd2MUlpaVM2TG1NYmxXM0dYRnJTWjRXRjNlNkxRa0pq?=
 =?utf-8?B?OXFtYnBLNW9NSnBoWGxOOCtzaHhXWUkwbS96alBpOHlLVFMwU296RFk2K0I1?=
 =?utf-8?B?bnRVbEFrTmQ4THpTNjFkZ3JSOWtaME55aXVldmNsRnBUTFhkTXJraGRTbkt5?=
 =?utf-8?B?SDMxN2RnYmlaTk9iaWZ2TG1jWnBIVk5VSlRJdkpaSmhRQzBWTUZ6eVZueXlh?=
 =?utf-8?B?Q1hOalFUYkI3N0R5ejIxVGM3K21jMmZlR0EwRWpXRGxvRDNkdHZWVlRXVk5X?=
 =?utf-8?B?enRzcTZaZk51Z2NvbGsyOEZNbmFuNjRCNjVQeGdHWDl2bGpIcjdXL203L2l1?=
 =?utf-8?B?MUZaSm5jUzd4ZUlTTUNLMUZ6YnlnRVYva1NUVUI1S2V2WGd6d25nc0RFUW9H?=
 =?utf-8?B?TStCei9nUTk3eGc1NjA4VFpYVmczRHhweDhDYVdhZnFCV0g2WDJMS3MvT1Zm?=
 =?utf-8?B?alpjdXJmYlRRa0tnaUI2cjNnTzlRYkNOdHBINWlCRGFNT3FtazcxRVVvYjhJ?=
 =?utf-8?B?NnIxR01uQWVQNmttVEJRZncwbWJSMlJrWXJNU21PaGF2REpnaE1FSlBVclVo?=
 =?utf-8?B?L3Y2a3IyZ3FNazRaNUxvbnBkdHFVWm43RXRpL2JiSFpxZ2s3d0ZSbHlzRmhS?=
 =?utf-8?Q?vbg40KKoqPc=3D?=
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:MW4PR11MB6739.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230040)(376014)(1800799024)(366016)(7053199007);DIR:OUT;SFP:1101;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?utf-8?B?K1Z1K2VrY0I3TzVkVy8zcHpJaW1qdzUxanNuYkQweDR0TVVmZFRhSkxoTEhV?=
 =?utf-8?B?dFBkVG1aeTBwNFhGRWRVR1A4YVBZUUpFaGNSZGMrN0R4OXhFc2Yya1I3U21Y?=
 =?utf-8?B?VGU1elF0RWhYVjNsU0xsZjJiUThUY3I5by9DVHl1U3V5QktKZnZLWTdZMjBU?=
 =?utf-8?B?NWJoQlc1b1Fyem9VUkxMcDBDZnVYc0xZeU9nUm82eHprZEZreCs0dVdaVGdV?=
 =?utf-8?B?Ynl3WEx3TVc5TzNkZW5sT0hTZnBvVTBMNXlhbE1NZzZsbkdWUXVMWFYrbDNW?=
 =?utf-8?B?YThCWDF5N0NmZitoaFYzbCszR2JhRk0vUHdqNk5jRXNHOUlkdFFWcGdsRU1q?=
 =?utf-8?B?VmNBdC9qOEZpdkhrdk5VeW5FMmN1ajhSOWVSc3pMN2lvN0tpMHlOeHAyaE0z?=
 =?utf-8?B?M2o5YkZjQmlZUXNRQkVpdHJtVElUWWI0TlBiODlKODdvWTNKVXdTeDJxME5Q?=
 =?utf-8?B?enZsdlBxU3pDSWxQWG5OWkQ1RGJaUmRNZ1NZMUZ0MnN3S1VkU0ozejQ2ODNR?=
 =?utf-8?B?enhIK21IV3JINGJXRmFaZG05MXJhUHl0OHpvSFhEV3ByNVBQanVWbFlJa2NS?=
 =?utf-8?B?bkFEb1NBZ1lJMHlPeHllWnhSZmorUVFJRXR2ZlBRdTZiZnptdk5Sc1Z6QmEx?=
 =?utf-8?B?VTk0ZExpdlNvN1ZOWUgzU2d4dnE1U0NZRjJqb1gzZ3BNVFh5TVFjTG95aWhP?=
 =?utf-8?B?Tlc0TUtUVno5V1JvaGFKU1pHbFQwVTAvazZXWnBhc1dNd0NHZmd6ekpwSDE4?=
 =?utf-8?B?TjZYRytXKzJ2VHVXTzcvYUVyckdFakttUWwvLzdnN2ZYV29xVjB2L09MOXBZ?=
 =?utf-8?B?UHNHN1RDZnNYS0NJWVFyM1RFNVhXM2FPTENydDZEYml5Rk9EcTdPYkN5NEsy?=
 =?utf-8?B?djRtQjEzdlVvdmx6UFVVaElTcDZlMi9BaEVUaXlFVldQMXQ0Q3g0VFcwUXB1?=
 =?utf-8?B?WmVVb2xiT2RsQUc4dDFoYUVIcWl5bUZWZzRxZkYrQXZITzR5SklNdm1pMlJw?=
 =?utf-8?B?VjZ2UEYrVVIxTnJNVjhCcVhJdGNhNjY1MnlaM0NPdDhZUlZGRVcvZ3BWTmk2?=
 =?utf-8?B?UnNMT3BiKzlqNFhuTVhQZ3lWOExPNWtYeFJPVzU1cDlBMHNUMkxOMzlmcXQx?=
 =?utf-8?B?eE0raVd4cXBqTlZqTFI4NVF1TmU2T2Z5L0ZzL3YraEZqVlcwWCtGMXZ2aDdN?=
 =?utf-8?B?amZidjUrK2RBVGZCL3FiUWgwdGxWUGszbmxVZDB2ak9PQTZzWmFKTWQrdVVN?=
 =?utf-8?B?U0pqL3RpZ0tlTENPY2grMW14L05HTUJIY1lvZThnVHJnWnBMUTNWQ1dSdzRP?=
 =?utf-8?B?Q2JGL1JKeFBzOWFacUlSRHpmYUE5L3NDS3ZTWXZ6dmlncDBPaEU4VHFqaTd5?=
 =?utf-8?B?MjVua3pucURNRDdKdXVYNHJLd0wrN2dYbHpENzhEdFZsMmxMa3dUQVdKamJE?=
 =?utf-8?B?a3N1Zzl3QW5lVlBUSmNGV1pvbDU3cWZjU3lDNkJQKytONVBUc3JUemRURVkz?=
 =?utf-8?B?VWVTNnRtdEJqUEUzUTFqV1B4enQ2SEVBaGw0UEN5TzhRaWF3dU5xdFVTSWI4?=
 =?utf-8?B?Y1B2N1ZBaXRwYk0wUDIwanN0T0U0WEN1M1NoN0Z0Qnl3N2gxaVMxWkpPcFdr?=
 =?utf-8?B?NUVsaGtLZVNkdmtKdDhMT2ZXVXFiQVVaVnk0R2lGa1EvaFNlcE9hVXVGQm5M?=
 =?utf-8?B?TDY3VCtPWmthdldicDBNeWNTeGVrbmFoOXN3OU1ZQVJIaC9ZUDNpZ21Ub1Ra?=
 =?utf-8?B?L0VTYUZRdlNERVJDMkRsdHJkeTlzMGZlb0p6NEFyV2ZNaUxMaTBqMEpleVhP?=
 =?utf-8?B?WjAyUXFpYkdIbUxTenRYSnlYSDQxb2pzaUF5eHpSTDFpRzEwdWNrcUxsZ0sw?=
 =?utf-8?B?K1pmNUo3VVZHNEdyTjRDSXhRUHRDdXdON0s1OFE4Qk0vVEorMncxdzFmOFRh?=
 =?utf-8?B?ZitDRmtYNlM4aXg3TzFaVjlXcjMyRkEzVUc4RWkyMVk2VjV5T3ZWWDZCRGZD?=
 =?utf-8?B?RkYzSzJQeUNSemU0a25xOFdCL0t3aEdqTkEzSWppRk0vQUdWeUFOL0EyQXlJ?=
 =?utf-8?B?TlhwS200S2xuOEs1dGtRNDlpcnJhTVFrTDVVN0VGaUROTHZ6dTdtVDZuSDdV?=
 =?utf-8?Q?I79MmYnT569/FC3DfaCnTh9Lq?=
X-MS-Exchange-CrossTenant-Network-Message-Id: 3436bfc4-62a0-4485-5e4d-08dd7addcc1d
X-MS-Exchange-CrossTenant-AuthSource: MW4PR11MB6739.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 13 Apr 2025 22:51:58.9221
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: 2s0j6NgTAbayS5kR4XNUkK6taXnc5s7WyXlq16B+cltOy1hIiEb0dk1ht9UuZRfuXpFuWa8DkdwNymXdou06wA==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: DM4PR11MB6042
X-OriginatorOrg: intel.com
Status: O
Content-Length: 5377
Lines: 180

Dynamic Capacity Devices (DCD) support extent change notifications
through the event log mechanism.  The interrupt mailbox commands were
extended in CXL 3.1 to support these notifications.  Firmware can't
configure DCD events to be FW controlled but can retain control of
memory events.

Configure DCD event log interrupts on devices supporting dynamic
capacity.  Disable DCD if interrupts are not supported.

Care is taken to preserve the interrupt policy set by the FW if FW first
has been selected by the BIOS.

Based on an original patch by Navneet Singh.

Reviewed-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
Reviewed-by: Dave Jiang <dave.jiang@intel.com>
Reviewed-by: Li Ming <ming.li@zohomail.com>
Reviewed-by: Fan Ni <fan.ni@samsung.com>
Signed-off-by: Ira Weiny <ira.weiny@intel.com>
---
 drivers/cxl/cxlmem.h |  2 ++
 drivers/cxl/pci.c    | 73 ++++++++++++++++++++++++++++++++++++++++++----------
 2 files changed, 62 insertions(+), 13 deletions(-)

diff --git a/drivers/cxl/cxlmem.h b/drivers/cxl/cxlmem.h
index a74ac2d70d8d..34a606c5ead0 100644
--- a/drivers/cxl/cxlmem.h
+++ b/drivers/cxl/cxlmem.h
@@ -204,7 +204,9 @@ struct cxl_event_interrupt_policy {
 	u8 warn_settings;
 	u8 failure_settings;
 	u8 fatal_settings;
+	u8 dcd_settings;
 } __packed;
+#define CXL_EVENT_INT_POLICY_BASE_SIZE 4 /* info, warn, failure, fatal */
 
 /**
  * struct cxl_event_state - Event log driver state
diff --git a/drivers/cxl/pci.c b/drivers/cxl/pci.c
index 36d031d66dec..c8a315bbf012 100644
--- a/drivers/cxl/pci.c
+++ b/drivers/cxl/pci.c
@@ -685,23 +685,34 @@ static int cxl_event_get_int_policy(struct cxl_memdev_state *mds,
 }
 
 static int cxl_event_config_msgnums(struct cxl_memdev_state *mds,
-				    struct cxl_event_interrupt_policy *policy)
+				    struct cxl_event_interrupt_policy *policy,
+				    bool native_cxl)
 {
 	struct cxl_mailbox *cxl_mbox = &mds->cxlds.cxl_mbox;
+	size_t size_in = CXL_EVENT_INT_POLICY_BASE_SIZE;
 	struct cxl_mbox_cmd mbox_cmd;
 	int rc;
 
-	*policy = (struct cxl_event_interrupt_policy) {
-		.info_settings = CXL_INT_MSI_MSIX,
-		.warn_settings = CXL_INT_MSI_MSIX,
-		.failure_settings = CXL_INT_MSI_MSIX,
-		.fatal_settings = CXL_INT_MSI_MSIX,
-	};
+	/* memory event policy is left if FW has control */
+	if (native_cxl) {
+		*policy = (struct cxl_event_interrupt_policy) {
+			.info_settings = CXL_INT_MSI_MSIX,
+			.warn_settings = CXL_INT_MSI_MSIX,
+			.failure_settings = CXL_INT_MSI_MSIX,
+			.fatal_settings = CXL_INT_MSI_MSIX,
+			.dcd_settings = 0,
+		};
+	}
+
+	if (cxl_dcd_supported(mds)) {
+		policy->dcd_settings = CXL_INT_MSI_MSIX;
+		size_in += sizeof(policy->dcd_settings);
+	}
 
 	mbox_cmd = (struct cxl_mbox_cmd) {
 		.opcode = CXL_MBOX_OP_SET_EVT_INT_POLICY,
 		.payload_in = policy,
-		.size_in = sizeof(*policy),
+		.size_in = size_in,
 	};
 
 	rc = cxl_internal_send_cmd(cxl_mbox, &mbox_cmd);
@@ -748,6 +759,30 @@ static int cxl_event_irqsetup(struct cxl_memdev_state *mds,
 	return 0;
 }
 
+static int cxl_irqsetup(struct cxl_memdev_state *mds,
+			struct cxl_event_interrupt_policy *policy,
+			bool native_cxl)
+{
+	struct cxl_dev_state *cxlds = &mds->cxlds;
+	int rc;
+
+	if (native_cxl) {
+		rc = cxl_event_irqsetup(mds, policy);
+		if (rc)
+			return rc;
+	}
+
+	if (cxl_dcd_supported(mds)) {
+		rc = cxl_event_req_irq(cxlds, policy->dcd_settings);
+		if (rc) {
+			dev_err(cxlds->dev, "Failed to get interrupt for DCD event log\n");
+			cxl_disable_dcd(mds);
+		}
+	}
+
+	return 0;
+}
+
 static bool cxl_event_int_is_fw(u8 setting)
 {
 	u8 mode = FIELD_GET(CXLDEV_EVENT_INT_MODE_MASK, setting);
@@ -773,18 +808,26 @@ static bool cxl_event_validate_mem_policy(struct cxl_memdev_state *mds,
 static int cxl_event_config(struct pci_host_bridge *host_bridge,
 			    struct cxl_memdev_state *mds, bool irq_avail)
 {
-	struct cxl_event_interrupt_policy policy;
+	struct cxl_event_interrupt_policy policy = { 0 };
+	bool native_cxl = host_bridge->native_cxl_error;
 	int rc;
 
 	/*
 	 * When BIOS maintains CXL error reporting control, it will process
 	 * event records.  Only one agent can do so.
+	 *
+	 * If BIOS has control of events and DCD is not supported skip event
+	 * configuration.
 	 */
-	if (!host_bridge->native_cxl_error)
+	if (!native_cxl && !cxl_dcd_supported(mds))
 		return 0;
 
 	if (!irq_avail) {
 		dev_info(mds->cxlds.dev, "No interrupt support, disable event processing.\n");
+		if (cxl_dcd_supported(mds)) {
+			dev_info(mds->cxlds.dev, "DCD requires interrupts, disable DCD\n");
+			cxl_disable_dcd(mds);
+		}
 		return 0;
 	}
 
@@ -792,10 +835,10 @@ static int cxl_event_config(struct pci_host_bridge *host_bridge,
 	if (rc)
 		return rc;
 
-	if (!cxl_event_validate_mem_policy(mds, &policy))
+	if (native_cxl && !cxl_event_validate_mem_policy(mds, &policy))
 		return -EBUSY;
 
-	rc = cxl_event_config_msgnums(mds, &policy);
+	rc = cxl_event_config_msgnums(mds, &policy, native_cxl);
 	if (rc)
 		return rc;
 
@@ -803,12 +846,16 @@ static int cxl_event_config(struct pci_host_bridge *host_bridge,
 	if (rc)
 		return rc;
 
-	rc = cxl_event_irqsetup(mds, &policy);
+	rc = cxl_irqsetup(mds, &policy, native_cxl);
 	if (rc)
 		return rc;
 
 	cxl_mem_get_event_records(mds, CXLDEV_EVENT_STATUS_ALL);
 
+	dev_dbg(mds->cxlds.dev, "Event config : %s DCD %s\n",
+		native_cxl ? "OS" : "BIOS",
+		cxl_dcd_supported(mds) ? "supported" : "not supported");
+
 	return 0;
 }
 

-- 
2.49.0


From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from mgamail.intel.com (mgamail.intel.com [192.198.163.7])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id A4C3518EFD4
	for <nvdimm@lists.linux.dev>; Sun, 13 Apr 2025 22:52:20 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=fail smtp.client-ip=192.198.163.7
ARC-Seal: i=2; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1744584742; cv=fail; b=B+H8JxjM3phy0cRjFku7RXEHBXovY+zpkwodTs3YNYDufXOr5xk7QtARJ1a4RcRzgtsPG7oIZHKUyJ0a5fTFTWKyUx+Wiqke6tfyu9XtweP10Vsf5o3v54ywvSe+4XWyNac6Yx1ZdqSFFIzPMnROeyJbN517u0IxVf6qLZl+G1M=
ARC-Message-Signature: i=2; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1744584742; c=relaxed/simple;
	bh=I3WlmoctCRsRu608KNgUHS/YZw7T8Cy+O3uuocH4P6Q=;
	h=From:Date:Subject:Content-Type:Message-ID:References:In-Reply-To:
	 To:CC:MIME-Version; b=NnqQuJ7ydOisBTGU1qKl68ZPb8JsFJMn0w7wnjplyf9DaxIiJUhxRNfZRqln1yjnFVXcDH7kb5GGOVfZA7Q5hUl+cghA99dJRgrsAa4wIXAf1kmQGzZixcjaOfoGaTPqFrUlIPCOX/1CQrw+4xjbZFMGp/m4WVgkkRXmQDDi80o=
ARC-Authentication-Results: i=2; smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=intel.com; spf=pass smtp.mailfrom=intel.com; dkim=pass (2048-bit key) header.d=intel.com header.i=@intel.com header.b=mJwfMipa; arc=fail smtp.client-ip=192.198.163.7
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=intel.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=intel.com
Authentication-Results: smtp.subspace.kernel.org;
	dkim=pass (2048-bit key) header.d=intel.com header.i=@intel.com header.b="mJwfMipa"
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1744584740; x=1776120740;
  h=from:date:subject:content-transfer-encoding:message-id:
   references:in-reply-to:to:cc:mime-version;
  bh=I3WlmoctCRsRu608KNgUHS/YZw7T8Cy+O3uuocH4P6Q=;
  b=mJwfMipa3q7jw13GcS53teSkrfjrMzG1PLBEmWJiexMlcvwsPtSXIS4J
   eRGDZYOv9VkmWV899WikAyP5cEqH/gJUWJSPddflPDQ4J1xNuvVkekXUa
   yChvGwjuTzx8JXITaj+56XsJlgfETq/9Y6FLeUaQN96VHXuFOmOZULwVu
   eQsArnFrP/djPP9MPyU5j9OciGXPFrVYyOHw/1mUV2NKKGEOZQJE0zmPS
   AhwbYCPQwKxvdhyXRih/GHd0CrU5cO5ppcM0MJvp5yaIYgkxFOB314wKF
   6WTdnuoQp6L4lxsb9KQBLA3UTuIaOG71BHLev2iFSDo+VD1wbsg0ScBNz
   A==;
X-CSE-ConnectionGUID: HNaoJMSyQ0OjufisRobgdg==
X-CSE-MsgGUID: O5cGHQPYTtOnarSPN7EYHA==
X-IronPort-AV: E=McAfee;i="6700,10204,11402"; a="71431128"
X-IronPort-AV: E=Sophos;i="6.15,211,1739865600"; 
   d="scan'208";a="71431128"
Received: from fmviesa005.fm.intel.com ([10.60.135.145])
  by fmvoesa101.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 13 Apr 2025 15:52:19 -0700
X-CSE-ConnectionGUID: cJFQ5mnFREyj02i9NpsGVQ==
X-CSE-MsgGUID: AGMRhiOMTUe88Ic8DWwUOw==
X-ExtLoop1: 1
X-IronPort-AV: E=Sophos;i="6.15,211,1739865600"; 
   d="scan'208";a="134405567"
Received: from orsmsx901.amr.corp.intel.com ([10.22.229.23])
  by fmviesa005.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 13 Apr 2025 15:52:19 -0700
Received: from ORSMSX901.amr.corp.intel.com (10.22.229.23) by
 ORSMSX901.amr.corp.intel.com (10.22.229.23) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.2.1544.14; Sun, 13 Apr 2025 15:52:18 -0700
Received: from ORSEDG602.ED.cps.intel.com (10.7.248.7) by
 ORSMSX901.amr.corp.intel.com (10.22.229.23) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.2.1544.14 via Frontend Transport; Sun, 13 Apr 2025 15:52:18 -0700
Received: from NAM10-MW2-obe.outbound.protection.outlook.com (104.47.55.43) by
 edgegateway.intel.com (134.134.137.103) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.44; Sun, 13 Apr 2025 15:52:18 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector10001; d=microsoft.com; cv=none;
 b=fpxlzGU5IcG9PLvzOTvNoBqP1EJwYuxViYM5NXhZ2xvTKM+Kujfp5DOoP2Wt/vvIdSYjWSemoBM1xvkU3y5oAsTgxaikjanDp7UQkq2wjNoZauGNgK0xh8jr4royjaHBcaUPCj7aZUjlfOPFyKeTOvIFiZcGbVhpiU156VPLH58tjvi9jVST6i8uwLP4sJKKNeeI2zmBnMjjJ9ACaEt6FHf2mj4qNC+SwMdn9rfLUwLq9kJXfJSwjcRR2vUANnvX9DvM60Rz6F8ItM+iXsn9vB1SG901312qUX+a6b+D3hlULQfi2ryrqgSQzy/fEuw65Ud/xfsNX4h1jr1/TAHJ5w==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector10001;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=jyAR64KNiC3ycVI/tr64P83Q9uWSXaiB1fBj4L9rC4k=;
 b=rfxKIEBQeDGGtNpslYzRX8FEuC1Ukp8QvG1wsYyzRidfqn6SBImBGvc2zMdzeDg6wcXxMLrvpcZV+Nf7EYXcXweoh7EAaeGqjd7TbDczey/cdaL30020JZgdysj7dcwhbbIDoR1DxkYC2pVgDP/AqMfedhRU/BiT67kdZ3d6rRU2zcgCGuTCTlniVSZzbgkXk8ch3YcdB05I1of04xw2avXSYsON3o2m632wDh/GgmcnmtmSKCJVW/wIBo1X3l2bRL168wKcnWagHuwK2eXt3+g+J1OLmJH7Hh+M8s8TzhzzZ4T2d/m04yyfEd1sreXH10ndQuOGpO8oYLlRs1BOEg==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from MW4PR11MB6739.namprd11.prod.outlook.com (2603:10b6:303:20b::19)
 by PH7PR11MB7003.namprd11.prod.outlook.com (2603:10b6:510:20a::16) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.8632.33; Sun, 13 Apr
 2025 22:52:05 +0000
Received: from MW4PR11MB6739.namprd11.prod.outlook.com
 ([fe80::a7ad:a6e8:fced:3f24]) by MW4PR11MB6739.namprd11.prod.outlook.com
 ([fe80::a7ad:a6e8:fced:3f24%4]) with mapi id 15.20.8606.033; Sun, 13 Apr 2025
 22:52:05 +0000
From: Ira Weiny <ira.weiny@intel.com>
Date: Sun, 13 Apr 2025 17:52:22 -0500
Subject: [PATCH v9 14/19] dax/bus: Factor out dev dax resize logic
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: 7bit
Message-ID: <20250413-dcd-type2-upstream-v9-14-1d4911a0b365@intel.com>
References: <20250413-dcd-type2-upstream-v9-0-1d4911a0b365@intel.com>
In-Reply-To: <20250413-dcd-type2-upstream-v9-0-1d4911a0b365@intel.com>
To: Dave Jiang <dave.jiang@intel.com>, Fan Ni <fan.ni@samsung.com>, "Jonathan
 Cameron" <Jonathan.Cameron@huawei.com>
CC: Dan Williams <dan.j.williams@intel.com>, Davidlohr Bueso
	<dave@stgolabs.net>, Alison Schofield <alison.schofield@intel.com>, "Vishal
 Verma" <vishal.l.verma@intel.com>, Ira Weiny <ira.weiny@intel.com>,
	<linux-cxl@vger.kernel.org>, <nvdimm@lists.linux.dev>,
	<linux-kernel@vger.kernel.org>
X-Mailer: b4 0.15-dev-c25d1
X-Developer-Signature: v=1; a=ed25519-sha256; t=1744584735; l=8758;
 i=ira.weiny@intel.com; s=20221211; h=from:subject:message-id;
 bh=I3WlmoctCRsRu608KNgUHS/YZw7T8Cy+O3uuocH4P6Q=;
 b=SZlCPR6IP2f3V11QT1z1FurtF22u7DLngSx2eSok0vdhz6XAvsfvGjBYrZJyn92y5KcIVMN9C
 nOQz0m2c+e8CivFJGOP3HPXBytKHHFfFZFUrKgMA+bdddXtBILVoFNJ
X-Developer-Key: i=ira.weiny@intel.com; a=ed25519;
 pk=noldbkG+Wp1qXRrrkfY1QJpDf7QsOEthbOT7vm0PqsE=
X-ClientProxiedBy: MW4PR03CA0227.namprd03.prod.outlook.com
 (2603:10b6:303:b9::22) To MW4PR11MB6739.namprd11.prod.outlook.com
 (2603:10b6:303:20b::19)
Precedence: bulk
X-Mailing-List: nvdimm@lists.linux.dev
List-Id: <nvdimm.lists.linux.dev>
List-Subscribe: <mailto:nvdimm+subscribe@lists.linux.dev>
List-Unsubscribe: <mailto:nvdimm+unsubscribe@lists.linux.dev>
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: MW4PR11MB6739:EE_|PH7PR11MB7003:EE_
X-MS-Office365-Filtering-Correlation-Id: b7297b40-7696-4093-ef03-08dd7addd014
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;ARA:13230040|366016|376014|1800799024;
X-Microsoft-Antispam-Message-Info: =?utf-8?B?VDc2amRVNG16Yk00bUw5Ynp0MGhWdTFCbDFpR1h6ZitKQzVoMUlydTE2U2xH?=
 =?utf-8?B?ZE9qa0NXM1dxN1hCV3UrclJUYVBia2NHRXhyMFpGWXB6Z0RNSUljcGtxL2Na?=
 =?utf-8?B?ak5oUGMzQVVwenVwT1I0MWVIdXN3aFZheWZpQXlyc0FTTENHQytFWFFDbWsv?=
 =?utf-8?B?cEI5S3JnVkE1SEZRRWhVTUZoNk9iMnJqRlMvQUNhOGEvMHJzeVptaVJ5WXJB?=
 =?utf-8?B?eFByUzF5MXhQR2tLRlhiWTlFT3cvclJmeXRTQnpkdklmVVEwOVlEYUUyeGRQ?=
 =?utf-8?B?SlYyaGdDVnZvcHZWdXBxeGgzYzNZQytRZTJNa1dXdjRTSjdwc2RvTVBjRE0y?=
 =?utf-8?B?bnIzVmE2SUFaMmdhWExCREZlQXlxWXY4MjE1SHNjdEEwbmtCQkpBTFY0UTdo?=
 =?utf-8?B?dTNmdHRSSnFOVjI3emN3Mmx6S1NhQXNQTHk1MEdaMDNFemxjQ2RVZDdvZlpH?=
 =?utf-8?B?YjBNSVNlVVRHenBnOVlLTUVHRkhBU3duZjZ4NEFQelVhSVR0MXZQS3lTYjc1?=
 =?utf-8?B?WnczcnA3RUdoN0ExNzFhUy9OVW51U3FHbWdldmJRWkZXOWozK2lTMHlxb0N5?=
 =?utf-8?B?YjdpbTFWT1diSlFYOVBobVlkNkdiMjVBSkdqNDFVd2FkR3BtSXRwUjhvRnZk?=
 =?utf-8?B?MmRVNzMrblAzTStsdFhGNXA1Nm1YQ0YvNGJqRlRFZnhzR0xEcG40SmVkdGl5?=
 =?utf-8?B?RnB4WHlTRHd6UnN4MkU0dGdpUlhnUHNyYlNwRXNiT3VVemFtVUhDZnJWNHlv?=
 =?utf-8?B?R3AybUoyZUpZNldYM3VKRVpjQVRtRWJxRDkzVzZDQmNOZnVZMzBYZmFkanlt?=
 =?utf-8?B?UGtzaVR1RUtXRDlwQ2FWQi9Ia3JHU0QreDFiWGhTbS9aeUt0a0tub2lqRTdr?=
 =?utf-8?B?WDcvcTB1YnVwdk9yNzFkZTY5dW9xb3VYcXd6VEdiRHg1amdmSERiYUJBUk5l?=
 =?utf-8?B?N3NJZWI1RDZYeU5TZ3BHMFFOckJsVkpPWlFEQk9tSjFRdDRFOGhlQXNqb1V6?=
 =?utf-8?B?b3VyeVlnZFJPckM0azRqODRmSktsM3k4Zk5Ub25nVUpDZ3p3T2ZwNE9SNjVt?=
 =?utf-8?B?Qi9OVnFRbU9SS1dXa3pIMll2RUJGeG5JRWtGZkUzUDZzT2JFUVJMOTU3L243?=
 =?utf-8?B?MkI5ZjlKZGh1bnd4RzFEZUhDZG5BbWU2NFZheGM5N0lGYTF1aGh3RXV4RlZ5?=
 =?utf-8?B?cWRNVGRlWnpJaUYzb2JjVjlVTlhQMlNmQ2tjcGdDSFRTeXNCc2drb1NWeTNr?=
 =?utf-8?B?L3dKUCtOUTFZWC85d09TaXUzQXE3a3UzakFLdXo1Nk0vSTRnVnFjZndURXVZ?=
 =?utf-8?B?S1I1alB1NkgzNzVBL010c0p0SGhFZ1Nod24wWjErRDRTNkZRcDREcjB5Y25P?=
 =?utf-8?B?UXpJNmY1RDZOV0JBanBoNTJ2VGFxamNhVjN1bVFHbkVta1JNa3NkU0NUNGxx?=
 =?utf-8?B?TnExMWxDQWRyTVZWYWRhUkZHa3p3R1JvQ1huMTFqR2tVTDZWVlZWV2pMWStZ?=
 =?utf-8?B?K1lTekdvZzE2bWIvcW1FL0N3YVluRUpSTnU2WXhTZGljR2tLUnZJUTgzeHVq?=
 =?utf-8?B?SFJFc3pZeHdycmUyWXo1d0NxbTF5QU5CcUtnVFBxMW9QVmdTMnQzelhJd3Mv?=
 =?utf-8?B?TUVPKzFHd1dNcGo3NjZYWWx0Y09CbHlvazJUOFJJTnk3Ty9HQ0syWnVHeUc3?=
 =?utf-8?B?bUpqT0JESElYbTUzaDNPZ1pCVFA2Q0IwNm9ZbW90VVJYZHlWNmVoRUxmZG1M?=
 =?utf-8?B?UWZ3MUNMdVJSbVdyS2hEOTllMDBlT05RcmlyWXkreDFVb2NLU0JVTkl6ei9G?=
 =?utf-8?B?bUVXb2NOc0hrdzV2U0NyWkxsZUxCN25Qc1lTbFZHKzh0NUUvbkdTTENkVUlN?=
 =?utf-8?B?YlVqSTNKOEIxeFM3bDJLS2JvNEZNRlVnSFBmZmdwS2tYOGx0ZGZ1bXJ6eXpZ?=
 =?utf-8?Q?wYWXY1moiiY=3D?=
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:MW4PR11MB6739.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230040)(366016)(376014)(1800799024);DIR:OUT;SFP:1101;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?utf-8?B?aVRWb3FJbUw0R1Awa3d2SG5VLzcrcU0rMWplc1FOTkUrWldXamxVUFlUQSsr?=
 =?utf-8?B?TjdiVXdNUlpaQ1grZlpFTzlDVGxRRVV1WnR2YkFnT1VUSlpUMisyVHQ5Znls?=
 =?utf-8?B?TUJaZWRZTHoxcmNJZExTM3NoTjhCTE00bTRSMUxkUXVpTlNHYllsaERGQ2ps?=
 =?utf-8?B?b3h2cjFKSmdaZnU1amxPVjZZWDRFTzRjS3dGdjZUUnl0TEt6ZmRKS0w1TVFu?=
 =?utf-8?B?dzJ5dUFvWkNmQ2VhOCtrVEdhc3hYSC8vK0cyc0xMRnZWa0NkendkT3dDcjhN?=
 =?utf-8?B?K3haRWUzQ3Q1TWVQZXpyUjV2K1NOcUkyOWloenBFRWxkZUxDR2Vmck9ESk5J?=
 =?utf-8?B?N1ArNS92MzV6SlkzYzNOVzNqZ0xrenhZYTBJeDIzRzRmL1RabXdCNGRJNVh0?=
 =?utf-8?B?WXR0RmVuODYzQm1HSC94OTg0RUl3b2VWaGNUMjRNNkE3OExiK3BJOWxCWWlD?=
 =?utf-8?B?NFE5MFVvNWhHVGVBYktDYU9YMFZqSXBZb3N6MmVtSUNtNEo2NWt2MkZGYWFH?=
 =?utf-8?B?OW5OaU5YTVB6TS9BaVVXNkdsWnJWcnBDcEFPZFZSTmx4aVNIdDVGQVJObDBO?=
 =?utf-8?B?RXkwQ01iQ1ZRT3NoVHkvQi9JL2MvVll4Z05vc2NTcGhTa2o0RGFScndJSml4?=
 =?utf-8?B?SEhMV0ZLc1lvVzgxQkdXYXdJUnlSQ2hzb2M5cVVwZ2w0K1FwYW5ISzc1cmE1?=
 =?utf-8?B?UWtYa2hvSHFVT0xSM3o0T2N1VXM4Vlc0YXc2c0U0MisreGRPc05JVmxURUUx?=
 =?utf-8?B?cTdGVUVEL0VNNEhUTXZCdU5IUm9FTnMxazZKMVZKWVFSME5DYlBUQUdYWVBN?=
 =?utf-8?B?dStoSFRvdjdLYlZwa2dWb1N5NWZBbkRNcmY1ZDJnTmx2UUwyYTlYRXhRalhR?=
 =?utf-8?B?Zm5yZERNTEVDNXhaTkhSKzlkN0U4OFBIT2tFRVBoWllhNm9hMDd6dEU2RHpO?=
 =?utf-8?B?WUxVZzBCc0NCenl5OG5zaXNmRXdsSzBONTl3WldLTnNlQzRKbWlGZ3p1cUxw?=
 =?utf-8?B?QytGdDZtdzlrSHZFaVRTZXFiUk9TcjZvQkpDdnduY3NBcFBwYTZ1SjcrblYv?=
 =?utf-8?B?TzNpTEE2cjFUeUJNdmxYaEtyMFRQMVNUdzRWU2tvM1ZHOC9QRjVUS0RZZUEr?=
 =?utf-8?B?RTVtNnZ6SWVDQ09aRFUyYUJEbXVHUkFwZC90Q2R3eVF3Tm16L0oyeU8vYnV2?=
 =?utf-8?B?MEJGZS94UnZLQktzeG1vNWsrTXA2dEp0SHRaOWNDaE14NDNxYXB6cWVVbGZu?=
 =?utf-8?B?YktnaTFkSmd2R0d3ZUhwM1pOUHd4Ty9iQVJ3dGkrbm9wVVlrTzRCa0tmQlFV?=
 =?utf-8?B?cG1mbWdNYlVyWG4xWFZMMXM5dXVEcUh5ZlQ3MHJRUXlWS045Y3FCUjRuQzF3?=
 =?utf-8?B?M2FVTmZmSUx6SDVOc1oxRWFPd0Qrc1NURnF0cVRqMGJIdG5RUEZRTWpzNXYv?=
 =?utf-8?B?ay83Q3lUM2FxOHZzdFBrM0ZNcnBTM0FLYjZZWjN4NHlrTjRJQ0lqY0MrakJF?=
 =?utf-8?B?ZEs3bW96ZXg4N1E3TUhPeGxaaTU5QTdEazhNS2RWVDJxUkkyR1FqSzlycUhT?=
 =?utf-8?B?WWVpbCtBZVRtRnRrZDFlaVhQOVNhbzZHdHpnVTVYZ0drNWR4TGFhY3NxZXhU?=
 =?utf-8?B?WkRKMjc3NFdYdzBscFFWdGhtYlFqajg4NGNiNHlhTVhKSWlLZU9XK0RLU2NG?=
 =?utf-8?B?cHFFTTZEQmFWbGFFZ2VRaEp5YlQrMXJSa2pBcjY4UEdSNVA0eXlEMVVkTnJ6?=
 =?utf-8?B?Y04rWno3Z3R5NzFjNFQ4U2VBR1dHbzg2a21NYUlwWlh5RzlCWHFUWVRXWlRr?=
 =?utf-8?B?SXNIL0x6dHJTMVMySWlZQkFMWkozK0N3bHZJUFRBSDZrakUyTXp0NlNGWnRH?=
 =?utf-8?B?eGQyUFZ2ZmZsUkJweWRUcmFpSGgwTTJ1R3h6WVlQa2dhZGNyb0NQRnV1MU9C?=
 =?utf-8?B?N1E2bS9lNXc1ZDVMSDZLSWNQUFd4clNiSitVVVBpY1BKbFlDTmp0TW5hLzlO?=
 =?utf-8?B?OFJmdS9wMTVjbHdpd2h2MWdPMkhuMG5TNTh2WG4zc1Q5Vk9sYlUxeVJpS3pH?=
 =?utf-8?B?UkRLaThvUGpTSFZpTVk0NjZqdUdwOEk0bWdaZWVLcURxTW9EWEtLaWxJcVdz?=
 =?utf-8?Q?/Tic0GqFiH7bPrC9ZbPbeKT2X?=
X-MS-Exchange-CrossTenant-Network-Message-Id: b7297b40-7696-4093-ef03-08dd7addd014
X-MS-Exchange-CrossTenant-AuthSource: MW4PR11MB6739.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 13 Apr 2025 22:52:05.6382
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: C0L1WF7ygDjoN7/gEPVm5cu6/8fIlUS5s8umbZDKjdGk/SLNbMjaYuHtMIviomwCEnSR59SKuTI3IhGTIHJeog==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: PH7PR11MB7003
X-OriginatorOrg: intel.com
Status: O
Content-Length: 8513
Lines: 247

Dynamic Capacity regions must limit dev dax resources to those areas
which have extents backing real memory.  Such DAX regions are dubbed
'sparse' regions.  In order to manage where memory is available four
alternatives were considered:

1) Create a single region resource child on region creation which
   reserves the entire region.  Then as extents are added punch holes in
   this reservation.  This requires new resource manipulation to punch
   the holes and still requires an additional iteration over the extent
   areas which may already have existing dev dax resources used.

2) Maintain an ordered xarray of extents which can be queried while
   processing the resize logic.  The issue is that existing region->res
   children may artificially limit the allocation size sent to
   alloc_dev_dax_range().  IE the resource children can't be directly
   used in the resize logic to find where space in the region is.  This
   also poses a problem of managing the available size in 2 places.

3) Maintain a separate resource tree with extents.  This option is the
   same as 2) but with the different data structure.  Most ideally there
   should be a unified representation of the resource tree not two places
   to look for space.

4) Create region resource children for each extent.  Manage the dax dev
   resize logic in the same way as before but use a region child
   (extent) resource as the parents to find space within each extent.

Option 4 can leverage the existing resize algorithm to find space within
the extents.  It manages the available space in a singular resource tree
which is less complicated for finding space.

In preparation for this change, factor out the dev_dax_resize logic.
For static regions use dax_region->res as the parent to find space for
the dax ranges.  Future patches will use the same algorithm with
individual extent resources as the parent.

Reviewed-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
Reviewed-by: Dave Jiang <dave.jiang@intel.com>
Signed-off-by: Ira Weiny <ira.weiny@intel.com>
---
 drivers/dax/bus.c | 130 +++++++++++++++++++++++++++++++++---------------------
 1 file changed, 80 insertions(+), 50 deletions(-)

diff --git a/drivers/dax/bus.c b/drivers/dax/bus.c
index d8cb5195a227..c25942a3d125 100644
--- a/drivers/dax/bus.c
+++ b/drivers/dax/bus.c
@@ -844,11 +844,9 @@ static int devm_register_dax_mapping(struct dev_dax *dev_dax, int range_id)
 	return 0;
 }
 
-static int alloc_dev_dax_range(struct dev_dax *dev_dax, u64 start,
-		resource_size_t size)
+static int alloc_dev_dax_range(struct resource *parent, struct dev_dax *dev_dax,
+			       u64 start, resource_size_t size)
 {
-	struct dax_region *dax_region = dev_dax->region;
-	struct resource *res = &dax_region->res;
 	struct device *dev = &dev_dax->dev;
 	struct dev_dax_range *ranges;
 	unsigned long pgoff = 0;
@@ -866,14 +864,14 @@ static int alloc_dev_dax_range(struct dev_dax *dev_dax, u64 start,
 		return 0;
 	}
 
-	alloc = __request_region(res, start, size, dev_name(dev), 0);
+	alloc = __request_region(parent, start, size, dev_name(dev), 0);
 	if (!alloc)
 		return -ENOMEM;
 
 	ranges = krealloc(dev_dax->ranges, sizeof(*ranges)
 			* (dev_dax->nr_range + 1), GFP_KERNEL);
 	if (!ranges) {
-		__release_region(res, alloc->start, resource_size(alloc));
+		__release_region(parent, alloc->start, resource_size(alloc));
 		return -ENOMEM;
 	}
 
@@ -1026,50 +1024,45 @@ static bool adjust_ok(struct dev_dax *dev_dax, struct resource *res)
 	return true;
 }
 
-static ssize_t dev_dax_resize(struct dax_region *dax_region,
-		struct dev_dax *dev_dax, resource_size_t size)
+/**
+ * dev_dax_resize_static - Expand the device into the unused portion of the
+ * region. This may involve adjusting the end of an existing resource, or
+ * allocating a new resource.
+ *
+ * @parent: parent resource to allocate this range in
+ * @dev_dax: DAX device to be expanded
+ * @to_alloc: amount of space to alloc; must be <= space available in @parent
+ *
+ * Return the amount of space allocated or -ERRNO on failure
+ */
+static ssize_t dev_dax_resize_static(struct resource *parent,
+				     struct dev_dax *dev_dax,
+				     resource_size_t to_alloc)
 {
-	resource_size_t avail = dax_region_avail_size(dax_region), to_alloc;
-	resource_size_t dev_size = dev_dax_size(dev_dax);
-	struct resource *region_res = &dax_region->res;
-	struct device *dev = &dev_dax->dev;
 	struct resource *res, *first;
-	resource_size_t alloc = 0;
 	int rc;
 
-	if (dev->driver)
-		return -EBUSY;
-	if (size == dev_size)
-		return 0;
-	if (size > dev_size && size - dev_size > avail)
-		return -ENOSPC;
-	if (size < dev_size)
-		return dev_dax_shrink(dev_dax, size);
-
-	to_alloc = size - dev_size;
-	if (dev_WARN_ONCE(dev, !alloc_is_aligned(dev_dax, to_alloc),
-			"resize of %pa misaligned\n", &to_alloc))
-		return -ENXIO;
-
-	/*
-	 * Expand the device into the unused portion of the region. This
-	 * may involve adjusting the end of an existing resource, or
-	 * allocating a new resource.
-	 */
-retry:
-	first = region_res->child;
-	if (!first)
-		return alloc_dev_dax_range(dev_dax, dax_region->res.start, to_alloc);
+	first = parent->child;
+	if (!first) {
+		rc = alloc_dev_dax_range(parent, dev_dax,
+					   parent->start, to_alloc);
+		if (rc)
+			return rc;
+		return to_alloc;
+	}
 
-	rc = -ENOSPC;
 	for (res = first; res; res = res->sibling) {
 		struct resource *next = res->sibling;
+		resource_size_t alloc;
 
 		/* space at the beginning of the region */
-		if (res == first && res->start > dax_region->res.start) {
-			alloc = min(res->start - dax_region->res.start, to_alloc);
-			rc = alloc_dev_dax_range(dev_dax, dax_region->res.start, alloc);
-			break;
+		if (res == first && res->start > parent->start) {
+			alloc = min(res->start - parent->start, to_alloc);
+			rc = alloc_dev_dax_range(parent, dev_dax,
+						 parent->start, alloc);
+			if (rc)
+				return rc;
+			return alloc;
 		}
 
 		alloc = 0;
@@ -1078,21 +1071,56 @@ static ssize_t dev_dax_resize(struct dax_region *dax_region,
 			alloc = min(next->start - (res->end + 1), to_alloc);
 
 		/* space at the end of the region */
-		if (!alloc && !next && res->end < region_res->end)
-			alloc = min(region_res->end - res->end, to_alloc);
+		if (!alloc && !next && res->end < parent->end)
+			alloc = min(parent->end - res->end, to_alloc);
 
 		if (!alloc)
 			continue;
 
 		if (adjust_ok(dev_dax, res)) {
 			rc = adjust_dev_dax_range(dev_dax, res, resource_size(res) + alloc);
-			break;
+			if (rc)
+				return rc;
+			return alloc;
 		}
-		rc = alloc_dev_dax_range(dev_dax, res->end + 1, alloc);
-		break;
+		rc = alloc_dev_dax_range(parent, dev_dax, res->end + 1, alloc);
+		if (rc)
+			return rc;
+		return alloc;
 	}
-	if (rc)
-		return rc;
+
+	/* available was already calculated and should never be an issue */
+	dev_WARN_ONCE(&dev_dax->dev, 1, "space not found?");
+	return 0;
+}
+
+static ssize_t dev_dax_resize(struct dax_region *dax_region,
+		struct dev_dax *dev_dax, resource_size_t size)
+{
+	resource_size_t avail = dax_region_avail_size(dax_region);
+	resource_size_t dev_size = dev_dax_size(dev_dax);
+	struct device *dev = &dev_dax->dev;
+	resource_size_t to_alloc;
+	resource_size_t alloc;
+
+	if (dev->driver)
+		return -EBUSY;
+	if (size == dev_size)
+		return 0;
+	if (size > dev_size && size - dev_size > avail)
+		return -ENOSPC;
+	if (size < dev_size)
+		return dev_dax_shrink(dev_dax, size);
+
+	to_alloc = size - dev_size;
+	if (dev_WARN_ONCE(dev, !alloc_is_aligned(dev_dax, to_alloc),
+			"resize of %pa misaligned\n", &to_alloc))
+		return -ENXIO;
+
+retry:
+	alloc = dev_dax_resize_static(&dax_region->res, dev_dax, to_alloc);
+	if (alloc <= 0)
+		return alloc;
 	to_alloc -= alloc;
 	if (to_alloc)
 		goto retry;
@@ -1198,7 +1226,8 @@ static ssize_t mapping_store(struct device *dev, struct device_attribute *attr,
 
 	to_alloc = range_len(&r);
 	if (alloc_is_aligned(dev_dax, to_alloc))
-		rc = alloc_dev_dax_range(dev_dax, r.start, to_alloc);
+		rc = alloc_dev_dax_range(&dax_region->res, dev_dax, r.start,
+					 to_alloc);
 	up_write(&dax_dev_rwsem);
 	up_write(&dax_region_rwsem);
 
@@ -1466,7 +1495,8 @@ static struct dev_dax *__devm_create_dev_dax(struct dev_dax_data *data)
 	device_initialize(dev);
 	dev_set_name(dev, "dax%d.%d", dax_region->id, dev_dax->id);
 
-	rc = alloc_dev_dax_range(dev_dax, dax_region->res.start, data->size);
+	rc = alloc_dev_dax_range(&dax_region->res, dev_dax, dax_region->res.start,
+				 data->size);
 	if (rc)
 		goto err_range;
 

-- 
2.49.0


From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from mgamail.intel.com (mgamail.intel.com [192.198.163.7])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id C65561FECAA
	for <nvdimm@lists.linux.dev>; Sun, 13 Apr 2025 22:52:19 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=fail smtp.client-ip=192.198.163.7
ARC-Seal: i=2; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1744584743; cv=fail; b=mQF3LXxLjxDkMgWXvLGKC9KpG3tqUpLNp28UZcftuncEJbJT4rZ/XM1aKzIx97DPHyugTuQoPtD6sDBRA+zLR7IjHau9c5A6NgK0KXvVHbYgqB4zenbm7+Fjd0NhkTuQdydvsGBJGe60xrf5++eFK9qUyhx1yGW8nmdmMfxs95A=
ARC-Message-Signature: i=2; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1744584743; c=relaxed/simple;
	bh=dCYaC5ZWrBF0vEquEYwJKxfuBnfC5MhdfQ924/0X7fs=;
	h=From:Date:Subject:Content-Type:Message-ID:References:In-Reply-To:
	 To:CC:MIME-Version; b=cnkIOAVv0AeZXxDRLqTQSVrdtC7qMaq1kBERgjt6BXnMnToE4ZWSDl5WfaV/SeU1sQpEwz7FcV0SvT8OKopKNNixBDRtQoqBwdyZp4fccm6Xyr4O2ZKHyvnLZxRumi58zYVAkSrpCFTr5VrW7TnMLDvdA7NwgpWgkSDBc/4Do/4=
ARC-Authentication-Results: i=2; smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=intel.com; spf=pass smtp.mailfrom=intel.com; dkim=pass (2048-bit key) header.d=intel.com header.i=@intel.com header.b=a8vdKp4z; arc=fail smtp.client-ip=192.198.163.7
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=intel.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=intel.com
Authentication-Results: smtp.subspace.kernel.org;
	dkim=pass (2048-bit key) header.d=intel.com header.i=@intel.com header.b="a8vdKp4z"
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1744584739; x=1776120739;
  h=from:date:subject:content-transfer-encoding:message-id:
   references:in-reply-to:to:cc:mime-version;
  bh=dCYaC5ZWrBF0vEquEYwJKxfuBnfC5MhdfQ924/0X7fs=;
  b=a8vdKp4zevryp/St1FC/dKOtWi1dGCe4gcqH+zJBjzTIc5PK/eOYlfGK
   51YH9w6rWHR+kmpBf21apxqCXfoic3Ww8RB7grKOna0YZ+Zl/Oh/g2Veh
   w9a2N9xJ1oObFj+xXaX08MOQ9y2Vd4+FRvaR06SvlO9tPopq40M6SSAHf
   RkaKBMwz2iiWcX6GXYSQ7CC0UrSCfLxNJjKV2taWMSqJDM4VfYmU/qDme
   HxMxGMU+BVlci2fH7DO+Q6HwWVligl7EQT3gGE/nbwQOGU7mZRbd24+Pv
   oTDHP00v6mF8hnYagj40ViiYNlZuJ+CwRgFYQu/j7eNrpvdt2+N3agWB0
   g==;
X-CSE-ConnectionGUID: BuNRbhaNQI65kzfIuRxV5w==
X-CSE-MsgGUID: L9ZvZL2mTGCUghFfXAqLqw==
X-IronPort-AV: E=McAfee;i="6700,10204,11402"; a="71431120"
X-IronPort-AV: E=Sophos;i="6.15,211,1739865600"; 
   d="scan'208";a="71431120"
Received: from fmviesa005.fm.intel.com ([10.60.135.145])
  by fmvoesa101.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 13 Apr 2025 15:52:19 -0700
X-CSE-ConnectionGUID: iGdH7j6pTMm1kr09iDUwog==
X-CSE-MsgGUID: 3RMnPZcBRQ2whXn3tcqVjw==
X-ExtLoop1: 1
X-IronPort-AV: E=Sophos;i="6.15,211,1739865600"; 
   d="scan'208";a="134405565"
Received: from orsmsx901.amr.corp.intel.com ([10.22.229.23])
  by fmviesa005.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 13 Apr 2025 15:52:19 -0700
Received: from ORSMSX901.amr.corp.intel.com (10.22.229.23) by
 ORSMSX901.amr.corp.intel.com (10.22.229.23) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.2.1544.14; Sun, 13 Apr 2025 15:52:18 -0700
Received: from ORSEDG602.ED.cps.intel.com (10.7.248.7) by
 ORSMSX901.amr.corp.intel.com (10.22.229.23) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.2.1544.14 via Frontend Transport; Sun, 13 Apr 2025 15:52:18 -0700
Received: from NAM10-MW2-obe.outbound.protection.outlook.com (104.47.55.43) by
 edgegateway.intel.com (134.134.137.103) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.44; Sun, 13 Apr 2025 15:52:18 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector10001; d=microsoft.com; cv=none;
 b=HZqrdEpxJjKtvuA0wKO25q9MA90BHPDMXLsTvgc/fiW1vyL5LtCQ6NCdj4KkSK6WTk+hqCAtQJ8SpQmAAc3EWfplbWVmAEYcyOMlJgikX7Wf0z4dFD0MhAEiYsedGECuR0dkx8unqH3EMXboZh7HLra7MoG99uAVIte1L00h/nerB5iSwpHAYa3MJq+yMuKcEQWj0RjQcnW/BV0DaPNgl4X0WeDCJ1RAGsosciVMpFH3mdMIQSUHK3oGThmXs/S2syNB+NxbB2MYI/6/wMWXvdhQb8mrdkWiyIAfD1kDZgUj95wg0h6jKGEUBRFYqt6XwZNAtn/mLhKtBc6EVn8yiQ==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector10001;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=ba2T0ZfLf8iYDHabMe8oJgPLPkgGNb9IiUzF9GEIk4M=;
 b=ZYTK2+kYFBYkruJqi29Hres6GAFpBYR1cXT0X+EAErLJcgBV4E6S90s5b7ZAeSnp3R4DaHM80H7h1J0VtSKwoCRF5YoSAGMnj3MF+tiE1v8tgUuJ3nxhgIL14zOOL3yhgpdpqtRMJwy+b7xRIuoFDY7dw8mHFzB7neILsyrR2MKGfrH77d93e5qh4TTHBO6g2Mkp3RQRnYfserHYjXGcg8zS4TmZ1v2VeIhhirdd5ySbI4wZb8WtmGHLoJAc6LZ1eN5vIkxZTM8YouSWcXcgEYCPL40urzFOfHLHwgTE68yV/IlHRdOyreGPCuJqG7pYnUoXgSATWThjmNQcwhaTgg==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from MW4PR11MB6739.namprd11.prod.outlook.com (2603:10b6:303:20b::19)
 by PH7PR11MB7003.namprd11.prod.outlook.com (2603:10b6:510:20a::16) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.8632.33; Sun, 13 Apr
 2025 22:52:02 +0000
Received: from MW4PR11MB6739.namprd11.prod.outlook.com
 ([fe80::a7ad:a6e8:fced:3f24]) by MW4PR11MB6739.namprd11.prod.outlook.com
 ([fe80::a7ad:a6e8:fced:3f24%4]) with mapi id 15.20.8606.033; Sun, 13 Apr 2025
 22:52:02 +0000
From: Ira Weiny <ira.weiny@intel.com>
Date: Sun, 13 Apr 2025 17:52:20 -0500
Subject: [PATCH v9 12/19] cxl/extent: Process dynamic partition events and
 realize region extents
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: 7bit
Message-ID: <20250413-dcd-type2-upstream-v9-12-1d4911a0b365@intel.com>
References: <20250413-dcd-type2-upstream-v9-0-1d4911a0b365@intel.com>
In-Reply-To: <20250413-dcd-type2-upstream-v9-0-1d4911a0b365@intel.com>
To: Dave Jiang <dave.jiang@intel.com>, Fan Ni <fan.ni@samsung.com>, "Jonathan
 Cameron" <Jonathan.Cameron@huawei.com>
CC: Dan Williams <dan.j.williams@intel.com>, Davidlohr Bueso
	<dave@stgolabs.net>, Alison Schofield <alison.schofield@intel.com>, "Vishal
 Verma" <vishal.l.verma@intel.com>, Ira Weiny <ira.weiny@intel.com>,
	<linux-cxl@vger.kernel.org>, <nvdimm@lists.linux.dev>,
	<linux-kernel@vger.kernel.org>, Li Ming <ming.li@zohomail.com>
X-Mailer: b4 0.15-dev-c25d1
X-Developer-Signature: v=1; a=ed25519-sha256; t=1744584735; l=35115;
 i=ira.weiny@intel.com; s=20221211; h=from:subject:message-id;
 bh=dCYaC5ZWrBF0vEquEYwJKxfuBnfC5MhdfQ924/0X7fs=;
 b=ewzwB3JiprOktVaqQTE2Z82vmmw0rqQfCZ2eIU1WE+uGQ4BmrippwoS+Ztw5us/NtfaSOrUnm
 7h3Kp8O/BsfAUG95z/9xzTnWAhARQbGQ3AaYZ+P0V7iuuvepLgyvxgZ
X-Developer-Key: i=ira.weiny@intel.com; a=ed25519;
 pk=noldbkG+Wp1qXRrrkfY1QJpDf7QsOEthbOT7vm0PqsE=
X-ClientProxiedBy: MW4PR03CA0227.namprd03.prod.outlook.com
 (2603:10b6:303:b9::22) To MW4PR11MB6739.namprd11.prod.outlook.com
 (2603:10b6:303:20b::19)
Precedence: bulk
X-Mailing-List: nvdimm@lists.linux.dev
List-Id: <nvdimm.lists.linux.dev>
List-Subscribe: <mailto:nvdimm+subscribe@lists.linux.dev>
List-Unsubscribe: <mailto:nvdimm+unsubscribe@lists.linux.dev>
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: MW4PR11MB6739:EE_|PH7PR11MB7003:EE_
X-MS-Office365-Filtering-Correlation-Id: 78094907-f15b-41e5-147b-08dd7addce29
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;ARA:13230040|366016|376014|1800799024;
X-Microsoft-Antispam-Message-Info: =?utf-8?B?RDM2dzR5eUJ4NWlpTFRFRFo0TnJteWtnR1ZUWGJmODRuT3U2NHErWkc3WXdk?=
 =?utf-8?B?NFdrTzI0YVdmbnJROUoyeUxXQmNEaCszOUtINCswYTBxRzlkRnRRaDQxcVhk?=
 =?utf-8?B?Ri9CSjVoa3hxbnZqdHZURWZpbXBKUmV5eFV3bG1yWHNmSEkxQTllRGl3Wm1r?=
 =?utf-8?B?b1BQU3E4Y0dHaHRrdTNONXNmeHAwTzFlOE9IbUhzd0tub28va3FOUG9GVEhR?=
 =?utf-8?B?YUtxam41a0QweEZ0bTVqc1Z3UmczL1J5NmtZaFNxUXRsSWlWVFArU2haSG5B?=
 =?utf-8?B?MG55MnRncGJUYko1eVZySmtMbWIvVUVMWi9yUWdLaE9lM2w3OWdBalJjY0hz?=
 =?utf-8?B?Q0c4Vm0rMjJGTmpsNnNad3FHeWRzcUpEM2xEUGlkbHF3bnV5cWc0dVM1azVB?=
 =?utf-8?B?b2pFRUNXV2wwWUZ5RjdNMnNBaUE1ZzVNdVZRbkFRZmJJeW9BSWRObTlkWGhE?=
 =?utf-8?B?ZUZxL0hobVlNcG1yKzFnbDNXcG55QzltYlIxbm1EVm1IUlJqU29pT0dqZXJo?=
 =?utf-8?B?VU5mZkQ0bmN1M2ZZQ1dHWnVaZkZTWGQyd0tPc0w5V1hGVW13dGU0OWNWMlBS?=
 =?utf-8?B?R1d1S0RvRzFINFFoVFpwd3BmZ0FWRGh4ZVdTaFAwOHBkMnNUZmloMFNFOTBk?=
 =?utf-8?B?Sk0rQXN1UDVSUFJUd085MnE5T3laMGRJdUYxeHRGYUFGeDdBN2pkemlHM2sv?=
 =?utf-8?B?MXFiMkZHOE8va0xkM1JXbk5XZmdQOWk0M1QwYWd1RHdmU2dTcXA4SFFtVDh4?=
 =?utf-8?B?V25HNTJpRDVXQXVsbGZObEkrR0Y4cWMzV1B6Z2lLZGxxMXo3RTRyMjlscHBK?=
 =?utf-8?B?QXlITE1TTTdaSEgrcW81N3FOSDB1Yk5mMGk2azdrT2xGejFVdkdVQlMreTNX?=
 =?utf-8?B?eHE1ZHo4bHVFWFh4RU1KSDkzYzI3Z0pTeDE0MjVFTkEzTmNvdjFLSlZPWFpB?=
 =?utf-8?B?TzRxK3FETldhd0l0RXJkZ3RmRGlXYUcxL3B6YkRZY21xcHpTNlB3QVJBRzJS?=
 =?utf-8?B?eXdSUzJUSWxhSDlHOVR5c0pjejJZRUh4dFpLWVRrT21ZbWJyRUEvem15M0Yy?=
 =?utf-8?B?L2VRV1o1U2tGWE1rb2R2WjhHT3lJWVQwL1Fzc25VYkw1TjlUQlEyNjRSOFcz?=
 =?utf-8?B?c0FhSTFMZDRKcEN1OHUwekhGcHVtTjJWQ0p4V0gvZ1ZJbXpnT2tnbUxtNEF0?=
 =?utf-8?B?RVVWSlBoZlBGZ1pvZXdjZUNYa2QvYXhhZVgxaC9hTWN2dUFJNG1DVHhnUVBx?=
 =?utf-8?B?NUtQdE91K0RRMUI5aTFQbTF1empPdWZ6K1VWd0lPN1pIalFvbDJtVFd6UGcr?=
 =?utf-8?B?dzdWU3V3SEpoc0lMU1BFYUJzalN4NCtBUlFhWDBtWFpQTkFnNzVoZUNDcjFM?=
 =?utf-8?B?QUNOaGE0RElhQm9EalI3QmR6WDRyaWZycGhNNTlMS3RTcWwyQkdjWDB6N3pB?=
 =?utf-8?B?YzFRYmV5VHpXVDIwWmUzeVpTcjdDWFZTbVEyUlZablBEUzNKMFZGQW5paXlh?=
 =?utf-8?B?cFhrckdxdXZ6WmUrQ3VTNExzZytpK0F6azE0Tzc2LzF0SE93aFRFQzl0V3Q4?=
 =?utf-8?B?bUlQK2J4Z0ozbUhvWWhRcGtzMmgweEo3ZGlnN3B2V28zcjlncXIzZjk0Q2pS?=
 =?utf-8?B?dzJYSW5tZEI4OUN6Q3FJWjB1YU9EeXJpRlNVY0hNY2lvbUtqNXdlNUR4YW93?=
 =?utf-8?B?dTdzWXlsVGJPUlh6aWV4d3lNUVRVd1RwMTRQY3dxTGZTT2prWFJYOUQ5bVE4?=
 =?utf-8?B?VnROTUZjdlZOa0Ntd0s0ZkVWY3Fhd0pDL2ZIaC9PMGFFZ2o1RjdPYkg2YXIv?=
 =?utf-8?B?cE5OWWJiaTlWVGtQc3FFYkdLZlJ2VjRGMnN0OGlOaUhRT2FoNTZTL3pCMWtq?=
 =?utf-8?B?cUcyb3lLSDNXcGVqQ25ueWlYTVJhNmxMeHBXb3Avd091TzZPYkJOc3VKamhM?=
 =?utf-8?Q?lHy7o4UXGkE=3D?=
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:MW4PR11MB6739.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230040)(366016)(376014)(1800799024);DIR:OUT;SFP:1101;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?utf-8?B?YVBZbnh3anpmMUJLTmpFY3cwM3VNQkpWRzcvYjdvZUpPSzAyTWtJYmdGKzJQ?=
 =?utf-8?B?Zk00WDVpOTRwdms5UDFSL29QdkhHMm1QT2UwN0pEbXFPOU02cVREUWkrRXRq?=
 =?utf-8?B?c28yS2NDSEJRaWk3L21leUY5K0cxS09oUTFJOGpoUlBUOVE0WVltT2JRdWRW?=
 =?utf-8?B?RHl0TGdzS2FncVJTbk1sODR4c0xMdGpBVXVhMHkybnlQOUN2UmlyTm1ycEJM?=
 =?utf-8?B?TVVWdmdTNWJaNGdKZ01KMXpxaXk5RTh4Tmw4Nm5kVjJlMWVZQUVvNzZla3JJ?=
 =?utf-8?B?cG5aekhaL3I5UU85ZlN3bDA0cmNKMlVVZVl0VWJ5MDZUR2YwZnpzK2hZalY1?=
 =?utf-8?B?T2FycVFham1KNWtQN1hLdnBDYTVXb2hqaFZ3RDdlbk9EOFFpNVhUY1hGeDNq?=
 =?utf-8?B?QkZWdTFhZE0wZkFuRVdlRWtIRTN3V0FGNUdheHFTRUM2VUhQRVVwbTRzTHJH?=
 =?utf-8?B?MktzdWltcjRrTWRNOFRXUUh0TlNpellHeUgyVWJYc0ZxWTJkazRwS1pIRTVp?=
 =?utf-8?B?elBkdWlpVThsei9uOUgvL3FrZDZpdUlyR1VBbkxFVkFiQ0Z5VVlPeEhFSjhp?=
 =?utf-8?B?NGE1c0hYZXdsNTFCM3J3SjRKYTJiUUM2dmF3MkNpVW5KNEcvQUxYRjVpVzRO?=
 =?utf-8?B?YUFkYjlBbysxendSNVQzUXNmQ0c4RHlkNUVxMFdFQjVtZWZVWVc0TFJMd0Ry?=
 =?utf-8?B?ankycWpmekpPMExIZDVob0pUN2hXSUVnVi9lV1JzMDBYT05oNU9GMVN5WFl6?=
 =?utf-8?B?bDc4OW56WjNrVURlc3JWWTZvQXRzYzE1Q3p1bXNwQS80R1Z0bXVET0FIeVZt?=
 =?utf-8?B?V25MbVluaktVTkIvMkNVWUNmYUVMSlVUREU4VS9CNjBIUGM4bWRjaGZ0dmlw?=
 =?utf-8?B?U2hPYVc2cFg2Qzh6d1F5UTFhMnFMdHJkanhQbjFCQ2dzQzd2MVhyU2J0UjZY?=
 =?utf-8?B?dTRuai8ycnM1MWYrZVFjQXgrZTd5Y0pTSCtLd0xoTzE2NE5aVkRwOTNZbEpX?=
 =?utf-8?B?VEt1dXNsQjYra29qR0hiTzBTZjA0djR4amtNZUxDSTI3QWhuQ1I1cDQ5N0Yx?=
 =?utf-8?B?MUhuYkc2WEh4cDZncmZmNmxQZ0J3TFlzZjU0dWUvekJUemZuU0QzWm9mYkV5?=
 =?utf-8?B?S0RVR2hHMUdhc0FZTDZPQUh3enVMMUNBbVpxSTZhZXpKakU4ZW5pNy9zcmpN?=
 =?utf-8?B?NlBCQmtpTXAyOE5nRktHd2JiRXZ4eUR6UVhYc0FOWDFydzJrWFJPWWVYekp2?=
 =?utf-8?B?a0xVMUN2T2kzY25DL0xPak5jUG5hM2FKTk5vdlhkWWMvL2lGcy9mQzNiQ3R0?=
 =?utf-8?B?MUtxTy9ncHpDVmtUNllRaWtmT21uQkpjREtRMnhuZW5yUCsxQVhCWk5ydDlM?=
 =?utf-8?B?WmxFQ1NJdzUwSG1Dc1dFTk93QndyTkdmSEs3anQ3QlcrdjFXSUFKbisxUllF?=
 =?utf-8?B?MWhHUStqVUtxSG9JRUZSTVFjSlNSODQ1ZG0veXVKTURweE9Xemd3eE0yTXVD?=
 =?utf-8?B?bXh5WDF5OVlCY0V4S0l3ak1LMnBCZEVnUjdXNldNS0s3ckwxbFNTYXRQUUtN?=
 =?utf-8?B?QlBEWHU4QlhGMUo1aS92WWR5bHVwdW11NVlsbFJFZG9rbkJJN2FBUk1xRjJO?=
 =?utf-8?B?cXVZb1gwVE56U2dwUDE3U1ltcWUwaVVxTDR6dWgvak5LUDA3K3BDaGovL3cr?=
 =?utf-8?B?Sk11ZGp2Z3I5azlhdlJoMlViR3UxUTM3aTBVZ3pTcXJMQVoxUXM4UFcwdzk0?=
 =?utf-8?B?ZXBuYURpMEFIVE11alhRNG9iZzVMTnJzRFRHUnRzZkQ0Yk9VQmRBYUkwQ2Y4?=
 =?utf-8?B?Nlg3aElFNzdtYjFGRjJMRUp6cEZGOWNSL1pPTWMvWHpnNGZiRzNwYnlKdThj?=
 =?utf-8?B?TXcwM1pjY3RUZ0dab3J5a0hxbnJUcTRTL3NidStDc1c5Tm12Q1A4VFM3dVBW?=
 =?utf-8?B?VE5WYTBYR1gwbUt4Q0tKaVltTHM4dEs2TXpwWTlSK2xRQW84TTJxczFFV2x5?=
 =?utf-8?B?dTlKS25vbXMxOXluRWtUdjBrand1d0diTU5NSDNFZnQzZEpZTXVTUlRodUlj?=
 =?utf-8?B?UU16STN3VTRJdnVXVmRZemtUeEJhNjlvbXhPM3lyYi8xS3Yyc2RPT2RLNXZO?=
 =?utf-8?Q?xd6VbfbCUWfQic15DO0t+2fLa?=
X-MS-Exchange-CrossTenant-Network-Message-Id: 78094907-f15b-41e5-147b-08dd7addce29
X-MS-Exchange-CrossTenant-AuthSource: MW4PR11MB6739.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 13 Apr 2025 22:52:02.4914
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: 48gQn+0XunOhVU+MqRSjub0KGHGKAfPj6ZMfWybXiTLlPYD31NrbC2qWhPBbQJVxVujBZfndmNZ2e/El4ay0tA==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: PH7PR11MB7003
X-OriginatorOrg: intel.com
Status: O
Content-Length: 33996
Lines: 1121

A dynamic capacity device (DCD) sends events to signal the host for
changes in the availability of Dynamic Capacity (DC) memory.  These
events contain extents describing a DPA range and meta data for memory
to be added or removed.  Events may be sent from the device at any time.

Three types of events can be signaled, Add, Release, and Force Release.

On add, the host may accept or reject the memory being offered.  If no
region exists, or the extent is invalid, the extent should be rejected.
Add extent events may be grouped by a 'more' bit which indicates those
extents should be processed as a group.

On remove, the host can delay the response until the host is safely not
using the memory.  If no region exists the release can be sent
immediately.  The host may also release extents (or partial extents) at
any time.  Thus the 'more' bit grouping of release events is of less
value and can be ignored in favor of sending multiple release capacity
responses for groups of release events.

Force removal is intended as a mechanism between the FM and the device
and intended only when the host is unresponsive, out of sync, or
otherwise broken.  Purposely ignore force removal events.

Regions are made up of one or more devices which may be surfacing memory
to the host.  Once all devices in a region have surfaced an extent the
region can expose a corresponding extent for the user to consume.
Without interleaving a device extent forms a 1:1 relationship with the
region extent.  Immediately surface a region extent upon getting a
device extent.

Per the specification the device is allowed to offer or remove extents
at any time.  However, anticipated use cases can expect extents to be
offered, accepted, and removed in well defined chunks.

Simplify extent tracking with the following restrictions.

	1) Flag for removal any extent which overlaps a requested
	   release range.
	2) Refuse the offer of extents which overlap already accepted
	   memory ranges.
	3) Accept again a range which has already been accepted by the
	   host.  Eating duplicates serves three purposes.
	   3a) This simplifies the code if the device should get out of
	       sync with the host.  And it should be safe to acknowledge
	       the extent again.
	   3b) This simplifies the code to process existing extents if
	       the extent list should change while the extent list is
	       being read.
	   3c) Duplicates for a given partition which are seen during a
	       race between the hardware surfacing an extent and the cxl
	       dax driver scanning for existing extents will be ignored.

	   NOTE: Processing existing extents is done in a later patch.

Management of the region extent devices must be synchronized with
potential uses of the memory within the DAX layer.  Create region extent
devices as children of the cxl_dax_region device such that the DAX
region driver can co-drive them and synchronize with the DAX layer.
Synchronization and management is handled in a subsequent patch.

Tag support within the DAX layer is not yet supported.  To maintain
compatibility with legacy DAX/region processing only tags with a value
of 0 are allowed.  This defines existing DAX devices as having a 0 tag
which makes the most logical sense as a default.

Process DCD events and create region devices.

Based on an original patch by Navneet Singh.

Reviewed-by: Dave Jiang <dave.jiang@intel.com>
Reviewed-by: Li Ming <ming.li@zohomail.com>
Reviewed-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
Signed-off-by: Ira Weiny <ira.weiny@intel.com>

---
Changes:
[iweiny: rebase]
[djbw: s/region/partition/]
[iweiny: Adapt to new partition arch]
[iweiny: s/tag/uuid/ throughout the code]
---
 drivers/cxl/core/Makefile |   2 +-
 drivers/cxl/core/core.h   |  13 ++
 drivers/cxl/core/extent.c | 366 ++++++++++++++++++++++++++++++++++++++++++++++
 drivers/cxl/core/mbox.c   | 292 +++++++++++++++++++++++++++++++++++-
 drivers/cxl/core/region.c |   3 +
 drivers/cxl/cxl.h         |  53 ++++++-
 drivers/cxl/cxlmem.h      |  27 ++++
 include/cxl/event.h       |  31 ++++
 tools/testing/cxl/Kbuild  |   3 +-
 9 files changed, 786 insertions(+), 4 deletions(-)

diff --git a/drivers/cxl/core/Makefile b/drivers/cxl/core/Makefile
index 086df97a0fcf..792ac799f39d 100644
--- a/drivers/cxl/core/Makefile
+++ b/drivers/cxl/core/Makefile
@@ -17,6 +17,6 @@ cxl_core-y += cdat.o
 cxl_core-y += ras.o
 cxl_core-y += acpi.o
 cxl_core-$(CONFIG_TRACING) += trace.o
-cxl_core-$(CONFIG_CXL_REGION) += region.o
+cxl_core-$(CONFIG_CXL_REGION) += region.o extent.o
 cxl_core-$(CONFIG_CXL_MCE) += mce.o
 cxl_core-$(CONFIG_CXL_FEATURES) += features.o
diff --git a/drivers/cxl/core/core.h b/drivers/cxl/core/core.h
index 76e23ec03fb4..1272be497926 100644
--- a/drivers/cxl/core/core.h
+++ b/drivers/cxl/core/core.h
@@ -45,12 +45,24 @@ struct cxl_region *cxl_dpa_to_region(const struct cxl_memdev *cxlmd, u64 dpa,
 u64 cxl_dpa_to_hpa(struct cxl_region *cxlr, const struct cxl_memdev *cxlmd,
 		   u64 dpa);
 
+int cxl_add_extent(struct cxl_memdev_state *mds, struct cxl_extent *extent);
+int cxl_rm_extent(struct cxl_memdev_state *mds, struct cxl_extent *extent);
 #else
 static inline u64 cxl_dpa_to_hpa(struct cxl_region *cxlr,
 				 const struct cxl_memdev *cxlmd, u64 dpa)
 {
 	return ULLONG_MAX;
 }
+static inline int cxl_add_extent(struct cxl_memdev_state *mds,
+				   struct cxl_extent *extent)
+{
+	return 0;
+}
+static inline int cxl_rm_extent(struct cxl_memdev_state *mds,
+				struct cxl_extent *extent)
+{
+	return 0;
+}
 static inline
 struct cxl_region *cxl_dpa_to_region(const struct cxl_memdev *cxlmd, u64 dpa,
 				     struct cxl_endpoint_decoder **cxled)
@@ -129,6 +141,7 @@ int cxl_update_hmat_access_coordinates(int nid, struct cxl_region *cxlr,
 bool cxl_need_node_perf_attrs_update(int nid);
 int cxl_port_get_switch_dport_bandwidth(struct cxl_port *port,
 					struct access_coordinate *c);
+void memdev_release_extent(struct cxl_memdev_state *mds, struct range *range);
 
 int cxl_ras_init(void);
 void cxl_ras_exit(void);
diff --git a/drivers/cxl/core/extent.c b/drivers/cxl/core/extent.c
new file mode 100644
index 000000000000..6df277caf974
--- /dev/null
+++ b/drivers/cxl/core/extent.c
@@ -0,0 +1,366 @@
+// SPDX-License-Identifier: GPL-2.0
+/*  Copyright(c) 2024 Intel Corporation. All rights reserved. */
+
+#include <linux/device.h>
+#include <cxl.h>
+
+#include "core.h"
+
+static void cxled_release_extent(struct cxl_endpoint_decoder *cxled,
+				 struct cxled_extent *ed_extent)
+{
+	struct cxl_memdev_state *mds = cxled_to_mds(cxled);
+	struct device *dev = &cxled->cxld.dev;
+
+	dev_dbg(dev, "Remove extent %pra (%pU)\n",
+		&ed_extent->dpa_range, &ed_extent->uuid);
+	memdev_release_extent(mds, &ed_extent->dpa_range);
+	kfree(ed_extent);
+}
+
+static void free_region_extent(struct region_extent *region_extent)
+{
+	struct cxled_extent *ed_extent;
+	unsigned long index;
+
+	/*
+	 * Remove from each endpoint decoder the extent which backs this region
+	 * extent
+	 */
+	xa_for_each(&region_extent->decoder_extents, index, ed_extent)
+		cxled_release_extent(ed_extent->cxled, ed_extent);
+	xa_destroy(&region_extent->decoder_extents);
+	ida_free(&region_extent->cxlr_dax->extent_ida, region_extent->dev.id);
+	kfree(region_extent);
+}
+
+static void region_extent_release(struct device *dev)
+{
+	struct region_extent *region_extent = to_region_extent(dev);
+
+	free_region_extent(region_extent);
+}
+
+static const struct device_type region_extent_type = {
+	.name = "extent",
+	.release = region_extent_release,
+};
+
+bool is_region_extent(struct device *dev)
+{
+	return dev->type == &region_extent_type;
+}
+EXPORT_SYMBOL_NS_GPL(is_region_extent, "CXL");
+
+static void region_extent_unregister(void *ext)
+{
+	struct region_extent *region_extent = ext;
+
+	dev_dbg(&region_extent->dev, "DAX region rm extent HPA %pra\n",
+		&region_extent->hpa_range);
+	device_unregister(&region_extent->dev);
+}
+
+static void region_rm_extent(struct region_extent *region_extent)
+{
+	struct device *region_dev = region_extent->dev.parent;
+
+	devm_release_action(region_dev, region_extent_unregister, region_extent);
+}
+
+static struct region_extent *
+alloc_region_extent(struct cxl_dax_region *cxlr_dax, struct range *hpa_range,
+		    uuid_t *uuid)
+{
+	int id;
+
+	struct region_extent *region_extent __free(kfree) =
+				kzalloc(sizeof(*region_extent), GFP_KERNEL);
+	if (!region_extent)
+		return ERR_PTR(-ENOMEM);
+
+	id = ida_alloc(&cxlr_dax->extent_ida, GFP_KERNEL);
+	if (id < 0)
+		return ERR_PTR(-ENOMEM);
+
+	region_extent->hpa_range = *hpa_range;
+	region_extent->cxlr_dax = cxlr_dax;
+	uuid_copy(&region_extent->uuid, uuid);
+	region_extent->dev.id = id;
+	xa_init(&region_extent->decoder_extents);
+	return no_free_ptr(region_extent);
+}
+
+static int online_region_extent(struct region_extent *region_extent)
+{
+	struct cxl_dax_region *cxlr_dax = region_extent->cxlr_dax;
+	struct device *dev = &region_extent->dev;
+	int rc;
+
+	device_initialize(dev);
+	device_set_pm_not_required(dev);
+	dev->parent = &cxlr_dax->dev;
+	dev->type = &region_extent_type;
+	rc = dev_set_name(dev, "extent%d.%d", cxlr_dax->cxlr->id, dev->id);
+	if (rc)
+		goto err;
+
+	rc = device_add(dev);
+	if (rc)
+		goto err;
+
+	dev_dbg(dev, "region extent HPA %pra\n", &region_extent->hpa_range);
+	return devm_add_action_or_reset(&cxlr_dax->dev, region_extent_unregister,
+					region_extent);
+
+err:
+	dev_err(&cxlr_dax->dev, "Failed to initialize region extent HPA %pra\n",
+		&region_extent->hpa_range);
+
+	put_device(dev);
+	return rc;
+}
+
+struct match_data {
+	struct cxl_endpoint_decoder *cxled;
+	struct range *new_range;
+};
+
+static int match_contains(struct device *dev, const void *data)
+{
+	struct region_extent *region_extent = to_region_extent(dev);
+	const struct match_data *md = data;
+	struct cxled_extent *entry;
+	unsigned long index;
+
+	if (!region_extent)
+		return 0;
+
+	xa_for_each(&region_extent->decoder_extents, index, entry) {
+		if (md->cxled == entry->cxled &&
+		    range_contains(&entry->dpa_range, md->new_range))
+			return 1;
+	}
+	return 0;
+}
+
+static bool extents_contain(struct cxl_dax_region *cxlr_dax,
+			    struct cxl_endpoint_decoder *cxled,
+			    struct range *new_range)
+{
+	struct match_data md = {
+		.cxled = cxled,
+		.new_range = new_range,
+	};
+
+	struct device *extent_device __free(put_device)
+			= device_find_child(&cxlr_dax->dev, &md, match_contains);
+	if (!extent_device)
+		return false;
+
+	return true;
+}
+
+static int match_overlaps(struct device *dev, const void *data)
+{
+	struct region_extent *region_extent = to_region_extent(dev);
+	const struct match_data *md = data;
+	struct cxled_extent *entry;
+	unsigned long index;
+
+	if (!region_extent)
+		return 0;
+
+	xa_for_each(&region_extent->decoder_extents, index, entry) {
+		if (md->cxled == entry->cxled &&
+		    range_overlaps(&entry->dpa_range, md->new_range))
+			return 1;
+	}
+
+	return 0;
+}
+
+static bool extents_overlap(struct cxl_dax_region *cxlr_dax,
+			    struct cxl_endpoint_decoder *cxled,
+			    struct range *new_range)
+{
+	struct match_data md = {
+		.cxled = cxled,
+		.new_range = new_range,
+	};
+
+	struct device *extent_device __free(put_device)
+			= device_find_child(&cxlr_dax->dev, &md, match_overlaps);
+	if (!extent_device)
+		return false;
+
+	return true;
+}
+
+static void calc_hpa_range(struct cxl_endpoint_decoder *cxled,
+			   struct cxl_dax_region *cxlr_dax,
+			   struct range *dpa_range,
+			   struct range *hpa_range)
+{
+	resource_size_t dpa_offset, hpa;
+
+	dpa_offset = dpa_range->start - cxled->dpa_res->start;
+	hpa = cxled->cxld.hpa_range.start + dpa_offset;
+
+	hpa_range->start = hpa - cxlr_dax->hpa_range.start;
+	hpa_range->end = hpa_range->start + range_len(dpa_range) - 1;
+}
+
+static int cxlr_rm_extent(struct device *dev, void *data)
+{
+	struct region_extent *region_extent = to_region_extent(dev);
+	struct range *region_hpa_range = data;
+
+	if (!region_extent)
+		return 0;
+
+	/*
+	 * Any extent which 'touches' the released range is removed.
+	 */
+	if (range_overlaps(region_hpa_range, &region_extent->hpa_range)) {
+		dev_dbg(dev, "Remove region extent HPA %pra\n",
+			&region_extent->hpa_range);
+		region_rm_extent(region_extent);
+	}
+	return 0;
+}
+
+int cxl_rm_extent(struct cxl_memdev_state *mds, struct cxl_extent *extent)
+{
+	u64 start_dpa = le64_to_cpu(extent->start_dpa);
+	struct cxl_memdev *cxlmd = mds->cxlds.cxlmd;
+	struct cxl_endpoint_decoder *cxled;
+	struct range hpa_range, dpa_range;
+	struct cxl_region *cxlr;
+
+	dpa_range = (struct range) {
+		.start = start_dpa,
+		.end = start_dpa + le64_to_cpu(extent->length) - 1,
+	};
+
+	guard(rwsem_read)(&cxl_region_rwsem);
+	cxlr = cxl_dpa_to_region(cxlmd, start_dpa, &cxled);
+	if (!cxlr) {
+		/*
+		 * No region can happen here for a few reasons:
+		 *
+		 * 1) Extents were accepted and the host crashed/rebooted
+		 *    leaving them in an accepted state.  On reboot the host
+		 *    has not yet created a region to own them.
+		 *
+		 * 2) Region destruction won the race with the device releasing
+		 *    all the extents.  Here the release will be a duplicate of
+		 *    the one sent via region destruction.
+		 *
+		 * 3) The device is confused and releasing extents for which no
+		 *    region ever existed.
+		 *
+		 * In all these cases make sure the device knows we are not
+		 * using this extent.
+		 */
+		memdev_release_extent(mds, &dpa_range);
+		return -ENXIO;
+	}
+
+	calc_hpa_range(cxled, cxlr->cxlr_dax, &dpa_range, &hpa_range);
+
+	/* Remove region extents which overlap */
+	return device_for_each_child(&cxlr->cxlr_dax->dev, &hpa_range,
+				     cxlr_rm_extent);
+}
+
+static int cxlr_add_extent(struct cxl_dax_region *cxlr_dax,
+			   struct cxl_endpoint_decoder *cxled,
+			   struct cxled_extent *ed_extent)
+{
+	struct region_extent *region_extent;
+	struct range hpa_range;
+	int rc;
+
+	calc_hpa_range(cxled, cxlr_dax, &ed_extent->dpa_range, &hpa_range);
+
+	region_extent = alloc_region_extent(cxlr_dax, &hpa_range, &ed_extent->uuid);
+	if (IS_ERR(region_extent))
+		return PTR_ERR(region_extent);
+
+	rc = xa_insert(&region_extent->decoder_extents, (unsigned long)ed_extent,
+		       ed_extent, GFP_KERNEL);
+	if (rc) {
+		free_region_extent(region_extent);
+		return rc;
+	}
+
+	/* device model handles freeing region_extent */
+	return online_region_extent(region_extent);
+}
+
+/* Callers are expected to ensure cxled has been attached to a region */
+int cxl_add_extent(struct cxl_memdev_state *mds, struct cxl_extent *extent)
+{
+	u64 start_dpa = le64_to_cpu(extent->start_dpa);
+	struct cxl_memdev *cxlmd = mds->cxlds.cxlmd;
+	struct cxl_endpoint_decoder *cxled;
+	struct range ed_range, ext_range;
+	struct cxl_dax_region *cxlr_dax;
+	struct cxled_extent *ed_extent;
+	struct cxl_region *cxlr;
+	struct device *dev;
+
+	ext_range = (struct range) {
+		.start = start_dpa,
+		.end = start_dpa + le64_to_cpu(extent->length) - 1,
+	};
+
+	guard(rwsem_read)(&cxl_region_rwsem);
+	cxlr = cxl_dpa_to_region(cxlmd, start_dpa, &cxled);
+	if (!cxlr)
+		return -ENXIO;
+
+	cxlr_dax = cxled->cxld.region->cxlr_dax;
+	dev = &cxled->cxld.dev;
+	ed_range = (struct range) {
+		.start = cxled->dpa_res->start,
+		.end = cxled->dpa_res->end,
+	};
+
+	dev_dbg(&cxled->cxld.dev, "Checking ED (%pr) for extent %pra\n",
+		cxled->dpa_res, &ext_range);
+
+	if (!range_contains(&ed_range, &ext_range)) {
+		dev_err_ratelimited(dev,
+				    "DC extent DPA %pra (%pU) is not fully in ED %pra\n",
+				    &ext_range, extent->uuid, &ed_range);
+		return -ENXIO;
+	}
+
+	/*
+	 * Allowing duplicates or extents which are already in an accepted
+	 * range simplifies extent processing, especially when dealing with the
+	 * cxl dax driver scanning for existing extents.
+	 */
+	if (extents_contain(cxlr_dax, cxled, &ext_range)) {
+		dev_warn_ratelimited(dev, "Extent %pra exists; accept again\n",
+				     &ext_range);
+		return 0;
+	}
+
+	if (extents_overlap(cxlr_dax, cxled, &ext_range))
+		return -ENXIO;
+
+	ed_extent = kzalloc(sizeof(*ed_extent), GFP_KERNEL);
+	if (!ed_extent)
+		return -ENOMEM;
+
+	ed_extent->cxled = cxled;
+	ed_extent->dpa_range = ext_range;
+	import_uuid(&ed_extent->uuid, extent->uuid);
+
+	dev_dbg(dev, "Add extent %pra (%pU)\n", &ed_extent->dpa_range, &ed_extent->uuid);
+
+	return cxlr_add_extent(cxlr_dax, cxled, ed_extent);
+}
diff --git a/drivers/cxl/core/mbox.c b/drivers/cxl/core/mbox.c
index b3dd119d166a..de01c6684530 100644
--- a/drivers/cxl/core/mbox.c
+++ b/drivers/cxl/core/mbox.c
@@ -930,6 +930,60 @@ int cxl_enumerate_cmds(struct cxl_memdev_state *mds)
 }
 EXPORT_SYMBOL_NS_GPL(cxl_enumerate_cmds, "CXL");
 
+static int cxl_validate_extent(struct cxl_memdev_state *mds,
+			       struct cxl_extent *extent)
+{
+	struct cxl_dev_state *cxlds = &mds->cxlds;
+	struct device *dev = mds->cxlds.dev;
+	u64 start, length;
+
+	start = le64_to_cpu(extent->start_dpa);
+	length = le64_to_cpu(extent->length);
+
+	struct range ext_range = (struct range){
+		.start = start,
+		.end = start + length - 1,
+	};
+
+	if (le16_to_cpu(extent->shared_extn_seq) != 0) {
+		dev_err_ratelimited(dev,
+				    "DC extent DPA %pra (%pU) can not be shared\n",
+				    &ext_range, extent->uuid);
+		return -ENXIO;
+	}
+
+	if (!uuid_is_null((const uuid_t *)extent->uuid)) {
+		dev_err_ratelimited(dev,
+				    "DC extent DPA %pra (%pU); tags not supported\n",
+				    &ext_range, extent->uuid);
+		return -ENXIO;
+	}
+
+	/* Extents must be within the DC partition boundary */
+	for (int i = 0; i < cxlds->nr_partitions; i++) {
+		struct cxl_dpa_partition *part = &cxlds->part[i];
+
+		if (part->mode != CXL_PARTMODE_DYNAMIC_RAM_A)
+			continue;
+
+		struct range partition_range = (struct range) {
+			.start = part->res.start,
+			.end = part->res.end,
+		};
+
+		if (range_contains(&partition_range, &ext_range)) {
+			dev_dbg(dev, "DC extent DPA %pra (DCR:%pra)(%pU)\n",
+				&ext_range, &partition_range, extent->uuid);
+			return 0;
+		}
+	}
+
+	dev_err_ratelimited(dev,
+			    "DC extent DPA %pra (%pU) is not in a valid DC partition\n",
+			    &ext_range, extent->uuid);
+	return -ENXIO;
+}
+
 void cxl_event_trace_record(const struct cxl_memdev *cxlmd,
 			    enum cxl_event_log_type type,
 			    enum cxl_event_type event_type,
@@ -1064,6 +1118,221 @@ static int cxl_clear_event_record(struct cxl_memdev_state *mds,
 	return rc;
 }
 
+static int send_one_response(struct cxl_mailbox *cxl_mbox,
+			     struct cxl_mbox_dc_response *response,
+			     int opcode, u32 extent_list_size, u8 flags)
+{
+	struct cxl_mbox_cmd mbox_cmd = (struct cxl_mbox_cmd) {
+		.opcode = opcode,
+		.size_in = struct_size(response, extent_list, extent_list_size),
+		.payload_in = response,
+	};
+
+	response->extent_list_size = cpu_to_le32(extent_list_size);
+	response->flags = flags;
+	return cxl_internal_send_cmd(cxl_mbox, &mbox_cmd);
+}
+
+static int cxl_send_dc_response(struct cxl_memdev_state *mds, int opcode,
+				struct xarray *extent_array, int cnt)
+{
+	struct cxl_mailbox *cxl_mbox = &mds->cxlds.cxl_mbox;
+	struct cxl_mbox_dc_response *p;
+	struct cxl_extent *extent;
+	unsigned long index;
+	u32 pl_index;
+
+	size_t pl_size = struct_size(p, extent_list, cnt);
+	u32 max_extents = cnt;
+
+	/* May have to use more bit on response. */
+	if (pl_size > cxl_mbox->payload_size) {
+		max_extents = (cxl_mbox->payload_size - sizeof(*p)) /
+			      sizeof(struct updated_extent_list);
+		pl_size = struct_size(p, extent_list, max_extents);
+	}
+
+	struct cxl_mbox_dc_response *response __free(kfree) =
+						kzalloc(pl_size, GFP_KERNEL);
+	if (!response)
+		return -ENOMEM;
+
+	if (cnt == 0)
+		return send_one_response(cxl_mbox, response, opcode, 0, 0);
+
+	pl_index = 0;
+	xa_for_each(extent_array, index, extent) {
+		response->extent_list[pl_index].dpa_start = extent->start_dpa;
+		response->extent_list[pl_index].length = extent->length;
+		pl_index++;
+
+		if (pl_index == max_extents) {
+			u8 flags = 0;
+			int rc;
+
+			if (pl_index < cnt)
+				flags |= CXL_DCD_EVENT_MORE;
+			rc = send_one_response(cxl_mbox, response, opcode,
+					       pl_index, flags);
+			if (rc)
+				return rc;
+			cnt -= pl_index;
+			pl_index = 0;
+		}
+	}
+
+	if (!pl_index) /* nothing more to do */
+		return 0;
+	return send_one_response(cxl_mbox, response, opcode, pl_index, 0);
+}
+
+void memdev_release_extent(struct cxl_memdev_state *mds, struct range *range)
+{
+	struct device *dev = mds->cxlds.dev;
+	struct xarray extent_list;
+
+	struct cxl_extent extent = {
+		.start_dpa = cpu_to_le64(range->start),
+		.length = cpu_to_le64(range_len(range)),
+	};
+
+	dev_dbg(dev, "Release response dpa %pra\n", &range);
+
+	xa_init(&extent_list);
+	if (xa_insert(&extent_list, 0, &extent, GFP_KERNEL)) {
+		dev_dbg(dev, "Failed to release %pra\n", &range);
+		goto destroy;
+	}
+
+	if (cxl_send_dc_response(mds, CXL_MBOX_OP_RELEASE_DC, &extent_list, 1))
+		dev_dbg(dev, "Failed to release %pra\n", &range);
+
+destroy:
+	xa_destroy(&extent_list);
+}
+
+static int validate_add_extent(struct cxl_memdev_state *mds,
+			       struct cxl_extent *extent)
+{
+	int rc;
+
+	rc = cxl_validate_extent(mds, extent);
+	if (rc)
+		return rc;
+
+	return cxl_add_extent(mds, extent);
+}
+
+static int cxl_add_pending(struct cxl_memdev_state *mds)
+{
+	struct device *dev = mds->cxlds.dev;
+	struct cxl_extent *extent;
+	unsigned long cnt = 0;
+	unsigned long index;
+	int rc;
+
+	xa_for_each(&mds->pending_extents, index, extent) {
+		if (validate_add_extent(mds, extent)) {
+			/*
+			 * Any extents which are to be rejected are omitted from
+			 * the response.  An empty response means all are
+			 * rejected.
+			 */
+			dev_dbg(dev, "unconsumed DC extent DPA:%#llx LEN:%#llx\n",
+				le64_to_cpu(extent->start_dpa),
+				le64_to_cpu(extent->length));
+			xa_erase(&mds->pending_extents, index);
+			kfree(extent);
+			continue;
+		}
+		cnt++;
+	}
+	rc = cxl_send_dc_response(mds, CXL_MBOX_OP_ADD_DC_RESPONSE,
+				  &mds->pending_extents, cnt);
+	xa_for_each(&mds->pending_extents, index, extent) {
+		xa_erase(&mds->pending_extents, index);
+		kfree(extent);
+	}
+	return rc;
+}
+
+static int handle_add_event(struct cxl_memdev_state *mds,
+			    struct cxl_event_dcd *event)
+{
+	struct device *dev = mds->cxlds.dev;
+	struct cxl_extent *extent;
+
+	extent = kmemdup(&event->extent, sizeof(*extent), GFP_KERNEL);
+	if (!extent)
+		return -ENOMEM;
+
+	if (xa_insert(&mds->pending_extents, (unsigned long)extent, extent,
+		      GFP_KERNEL)) {
+		kfree(extent);
+		return -ENOMEM;
+	}
+
+	if (event->flags & CXL_DCD_EVENT_MORE) {
+		dev_dbg(dev, "more bit set; delay the surfacing of extent\n");
+		return 0;
+	}
+
+	/* extents are removed and free'ed in cxl_add_pending() */
+	return cxl_add_pending(mds);
+}
+
+static char *cxl_dcd_evt_type_str(u8 type)
+{
+	switch (type) {
+	case DCD_ADD_CAPACITY:
+		return "add";
+	case DCD_RELEASE_CAPACITY:
+		return "release";
+	case DCD_FORCED_CAPACITY_RELEASE:
+		return "force release";
+	default:
+		break;
+	}
+
+	return "<unknown>";
+}
+
+static void cxl_handle_dcd_event_records(struct cxl_memdev_state *mds,
+					struct cxl_event_record_raw *raw_rec)
+{
+	struct cxl_event_dcd *event = &raw_rec->event.dcd;
+	struct cxl_extent *extent = &event->extent;
+	struct device *dev = mds->cxlds.dev;
+	uuid_t *id = &raw_rec->id;
+	int rc;
+
+	if (!uuid_equal(id, &CXL_EVENT_DC_EVENT_UUID))
+		return;
+
+	dev_dbg(dev, "DCD event %s : DPA:%#llx LEN:%#llx\n",
+		cxl_dcd_evt_type_str(event->event_type),
+		le64_to_cpu(extent->start_dpa), le64_to_cpu(extent->length));
+
+	switch (event->event_type) {
+	case DCD_ADD_CAPACITY:
+		rc = handle_add_event(mds, event);
+		break;
+	case DCD_RELEASE_CAPACITY:
+		rc = cxl_rm_extent(mds, &event->extent);
+		break;
+	case DCD_FORCED_CAPACITY_RELEASE:
+		dev_err_ratelimited(dev, "Forced release event ignored.\n");
+		rc = 0;
+		break;
+	default:
+		rc = -EINVAL;
+		break;
+	}
+
+	if (rc)
+		dev_err_ratelimited(dev, "dcd event failed: %d\n", rc);
+}
+
 static void cxl_mem_get_records_log(struct cxl_memdev_state *mds,
 				    enum cxl_event_log_type type)
 {
@@ -1100,9 +1369,13 @@ static void cxl_mem_get_records_log(struct cxl_memdev_state *mds,
 		if (!nr_rec)
 			break;
 
-		for (i = 0; i < nr_rec; i++)
+		for (i = 0; i < nr_rec; i++) {
 			__cxl_event_trace_record(cxlmd, type,
 						 &payload->records[i]);
+			if (type == CXL_EVENT_TYPE_DCD)
+				cxl_handle_dcd_event_records(mds,
+							&payload->records[i]);
+		}
 
 		if (payload->flags & CXL_GET_EVENT_FLAG_OVERFLOW)
 			trace_cxl_overflow(cxlmd, type, payload);
@@ -1134,6 +1407,8 @@ void cxl_mem_get_event_records(struct cxl_memdev_state *mds, u32 status)
 {
 	dev_dbg(mds->cxlds.dev, "Reading event logs: %x\n", status);
 
+	if (cxl_dcd_supported(mds) && (status & CXLDEV_EVENT_STATUS_DCD))
+		cxl_mem_get_records_log(mds, CXL_EVENT_TYPE_DCD);
 	if (status & CXLDEV_EVENT_STATUS_FATAL)
 		cxl_mem_get_records_log(mds, CXL_EVENT_TYPE_FATAL);
 	if (status & CXLDEV_EVENT_STATUS_FAIL)
@@ -1709,6 +1984,17 @@ int cxl_mailbox_init(struct cxl_mailbox *cxl_mbox, struct device *host)
 }
 EXPORT_SYMBOL_NS_GPL(cxl_mailbox_init, "CXL");
 
+static void clear_pending_extents(void *_mds)
+{
+	struct cxl_memdev_state *mds = _mds;
+	struct cxl_extent *extent;
+	unsigned long index;
+
+	xa_for_each(&mds->pending_extents, index, extent)
+		kfree(extent);
+	xa_destroy(&mds->pending_extents);
+}
+
 struct cxl_memdev_state *cxl_memdev_state_create(struct device *dev)
 {
 	struct cxl_memdev_state *mds;
@@ -1726,6 +2012,10 @@ struct cxl_memdev_state *cxl_memdev_state_create(struct device *dev)
 	mds->cxlds.cxl_mbox.host = dev;
 	mds->cxlds.reg_map.resource = CXL_RESOURCE_NONE;
 	mds->cxlds.type = CXL_DEVTYPE_CLASSMEM;
+	xa_init(&mds->pending_extents);
+	rc = devm_add_action_or_reset(dev, clear_pending_extents, mds);
+	if (rc)
+		return ERR_PTR(rc);
 
 	rc = devm_cxl_register_mce_notifier(dev, &mds->mce_notifier);
 	if (rc == -EOPNOTSUPP)
diff --git a/drivers/cxl/core/region.c b/drivers/cxl/core/region.c
index 9c573e8d6ed7..3106df6f3636 100644
--- a/drivers/cxl/core/region.c
+++ b/drivers/cxl/core/region.c
@@ -3048,6 +3048,7 @@ static void cxl_dax_region_release(struct device *dev)
 {
 	struct cxl_dax_region *cxlr_dax = to_cxl_dax_region(dev);
 
+	ida_destroy(&cxlr_dax->extent_ida);
 	kfree(cxlr_dax);
 }
 
@@ -3097,6 +3098,8 @@ static struct cxl_dax_region *cxl_dax_region_alloc(struct cxl_region *cxlr)
 
 	dev = &cxlr_dax->dev;
 	cxlr_dax->cxlr = cxlr;
+	cxlr->cxlr_dax = cxlr_dax;
+	ida_init(&cxlr_dax->extent_ida);
 	device_initialize(dev);
 	lockdep_set_class(&dev->mutex, &cxl_dax_region_key);
 	device_set_pm_not_required(dev);
diff --git a/drivers/cxl/cxl.h b/drivers/cxl/cxl.h
index 4bb0ff4d8f5f..d027432b1572 100644
--- a/drivers/cxl/cxl.h
+++ b/drivers/cxl/cxl.h
@@ -11,6 +11,8 @@
 #include <linux/log2.h>
 #include <linux/node.h>
 #include <linux/io.h>
+#include <linux/xarray.h>
+#include <cxl/event.h>
 
 extern const struct nvdimm_security_ops *cxl_security_ops;
 
@@ -169,11 +171,13 @@ static inline int ways_to_eiw(unsigned int ways, u8 *eiw)
 #define CXLDEV_EVENT_STATUS_WARN		BIT(1)
 #define CXLDEV_EVENT_STATUS_FAIL		BIT(2)
 #define CXLDEV_EVENT_STATUS_FATAL		BIT(3)
+#define CXLDEV_EVENT_STATUS_DCD			BIT(4)
 
 #define CXLDEV_EVENT_STATUS_ALL (CXLDEV_EVENT_STATUS_INFO |	\
 				 CXLDEV_EVENT_STATUS_WARN |	\
 				 CXLDEV_EVENT_STATUS_FAIL |	\
-				 CXLDEV_EVENT_STATUS_FATAL)
+				 CXLDEV_EVENT_STATUS_FATAL |	\
+				 CXLDEV_EVENT_STATUS_DCD)
 
 /* CXL rev 3.0 section 8.2.9.2.4; Table 8-52 */
 #define CXLDEV_EVENT_INT_MODE_MASK	GENMASK(1, 0)
@@ -381,6 +385,18 @@ enum cxl_decoder_state {
 	CXL_DECODER_STATE_AUTO,
 };
 
+/**
+ * struct cxled_extent - Extent within an endpoint decoder
+ * @cxled: Reference to the endpoint decoder
+ * @dpa_range: DPA range this extent covers within the decoder
+ * @uuid: uuid from device for this extent
+ */
+struct cxled_extent {
+	struct cxl_endpoint_decoder *cxled;
+	struct range dpa_range;
+	uuid_t uuid;
+};
+
 /**
  * struct cxl_endpoint_decoder - Endpoint  / SPA to DPA decoder
  * @cxld: base cxl_decoder_object
@@ -512,6 +528,7 @@ enum cxl_partition_mode {
  * @type: Endpoint decoder target type
  * @cxl_nvb: nvdimm bridge for coordinating @cxlr_pmem setup / shutdown
  * @cxlr_pmem: (for pmem regions) cached copy of the nvdimm bridge
+ * @cxlr_dax: (for DC regions) cached copy of CXL DAX bridge
  * @flags: Region state flags
  * @params: active + config params for the region
  * @coord: QoS access coordinates for the region
@@ -525,6 +542,7 @@ struct cxl_region {
 	enum cxl_decoder_type type;
 	struct cxl_nvdimm_bridge *cxl_nvb;
 	struct cxl_pmem_region *cxlr_pmem;
+	struct cxl_dax_region *cxlr_dax;
 	unsigned long flags;
 	struct cxl_region_params params;
 	struct access_coordinate coord[ACCESS_COORDINATE_MAX];
@@ -566,12 +584,45 @@ struct cxl_pmem_region {
 	struct cxl_pmem_region_mapping mapping[];
 };
 
+/* See CXL 3.1 8.2.9.2.1.6 */
+enum dc_event {
+	DCD_ADD_CAPACITY,
+	DCD_RELEASE_CAPACITY,
+	DCD_FORCED_CAPACITY_RELEASE,
+	DCD_REGION_CONFIGURATION_UPDATED,
+};
+
 struct cxl_dax_region {
 	struct device dev;
 	struct cxl_region *cxlr;
 	struct range hpa_range;
+	struct ida extent_ida;
 };
 
+/**
+ * struct region_extent - CXL DAX region extent
+ * @dev: device representing this extent
+ * @cxlr_dax: back reference to parent region device
+ * @hpa_range: HPA range of this extent
+ * @uuid: uuid of the extent
+ * @decoder_extents: Endpoint decoder extents which make up this region extent
+ */
+struct region_extent {
+	struct device dev;
+	struct cxl_dax_region *cxlr_dax;
+	struct range hpa_range;
+	uuid_t uuid;
+	struct xarray decoder_extents;
+};
+
+bool is_region_extent(struct device *dev);
+static inline struct region_extent *to_region_extent(struct device *dev)
+{
+	if (!is_region_extent(dev))
+		return NULL;
+	return container_of(dev, struct region_extent, dev);
+}
+
 /**
  * struct cxl_port - logical collection of upstream port devices and
  *		     downstream port devices to construct a CXL memory
diff --git a/drivers/cxl/cxlmem.h b/drivers/cxl/cxlmem.h
index 34a606c5ead0..63a38e449454 100644
--- a/drivers/cxl/cxlmem.h
+++ b/drivers/cxl/cxlmem.h
@@ -7,6 +7,7 @@
 #include <linux/cdev.h>
 #include <linux/uuid.h>
 #include <linux/node.h>
+#include <linux/xarray.h>
 #include <cxl/event.h>
 #include <cxl/mailbox.h>
 #include "cxl.h"
@@ -487,6 +488,7 @@ static inline struct cxl_dev_state *mbox_to_cxlds(struct cxl_mailbox *cxl_mbox)
  * @active_volatile_bytes: sum of hard + soft volatile
  * @active_persistent_bytes: sum of hard + soft persistent
  * @dcd_supported: all DCD commands are supported
+ * @pending_extents: array of extents pending during more bit processing
  * @event: event log driver state
  * @poison: poison driver state info
  * @security: security driver state info
@@ -507,6 +509,7 @@ struct cxl_memdev_state {
 	u64 active_volatile_bytes;
 	u64 active_persistent_bytes;
 	bool dcd_supported;
+	struct xarray pending_extents;
 
 	struct cxl_event_state event;
 	struct cxl_poison_state poison;
@@ -582,6 +585,21 @@ enum cxl_opcode {
 	UUID_INIT(0x5e1819d9, 0x11a9, 0x400c, 0x81, 0x1f, 0xd6, 0x07, 0x19,     \
 		  0x40, 0x3d, 0x86)
 
+/*
+ * Add Dynamic Capacity Response
+ * CXL rev 3.1 section 8.2.9.9.9.3; Table 8-168 & Table 8-169
+ */
+struct cxl_mbox_dc_response {
+	__le32 extent_list_size;
+	u8 flags;
+	u8 reserved[3];
+	struct updated_extent_list {
+		__le64 dpa_start;
+		__le64 length;
+		u8 reserved[8];
+	} __packed extent_list[];
+} __packed;
+
 struct cxl_mbox_get_supported_logs {
 	__le16 entries;
 	u8 rsvd[6];
@@ -644,6 +662,14 @@ struct cxl_mbox_identify {
 	UUID_INIT(0xfe927475, 0xdd59, 0x4339, 0xa5, 0x86, 0x79, 0xba, 0xb1, \
 		  0x13, 0xb7, 0x74)
 
+/*
+ * Dynamic Capacity Event Record
+ * CXL rev 3.1 section 8.2.9.2.1; Table 8-43
+ */
+#define CXL_EVENT_DC_EVENT_UUID                                             \
+	UUID_INIT(0xca95afa7, 0xf183, 0x4018, 0x8c, 0x2f, 0x95, 0x26, 0x8e, \
+		  0x10, 0x1a, 0x2a)
+
 /*
  * Get Event Records output payload
  * CXL rev 3.0 section 8.2.9.2.2; Table 8-50
@@ -669,6 +695,7 @@ enum cxl_event_log_type {
 	CXL_EVENT_TYPE_WARN,
 	CXL_EVENT_TYPE_FAIL,
 	CXL_EVENT_TYPE_FATAL,
+	CXL_EVENT_TYPE_DCD,
 	CXL_EVENT_TYPE_MAX
 };
 
diff --git a/include/cxl/event.h b/include/cxl/event.h
index f9ae1796da85..0c159eac4337 100644
--- a/include/cxl/event.h
+++ b/include/cxl/event.h
@@ -108,11 +108,42 @@ struct cxl_event_mem_module {
 	u8 reserved[0x2a];
 } __packed;
 
+/*
+ * CXL rev 3.1 section 8.2.9.2.1.6; Table 8-51
+ */
+struct cxl_extent {
+	__le64 start_dpa;
+	__le64 length;
+	u8 uuid[UUID_SIZE];
+	__le16 shared_extn_seq;
+	u8 reserved[0x6];
+} __packed;
+
+/*
+ * Dynamic Capacity Event Record
+ * CXL rev 3.1 section 8.2.9.2.1.6; Table 8-50
+ */
+#define CXL_DCD_EVENT_MORE			BIT(0)
+struct cxl_event_dcd {
+	struct cxl_event_record_hdr hdr;
+	u8 event_type;
+	u8 validity_flags;
+	__le16 host_id;
+	u8 partition_index;
+	u8 flags;
+	u8 reserved1[0x2];
+	struct cxl_extent extent;
+	u8 reserved2[0x18];
+	__le32 num_avail_extents;
+	__le32 num_avail_tags;
+} __packed;
+
 union cxl_event {
 	struct cxl_event_generic generic;
 	struct cxl_event_gen_media gen_media;
 	struct cxl_event_dram dram;
 	struct cxl_event_mem_module mem_module;
+	struct cxl_event_dcd dcd;
 	/* dram & gen_media event header */
 	struct cxl_event_media_hdr media_hdr;
 } __packed;
diff --git a/tools/testing/cxl/Kbuild b/tools/testing/cxl/Kbuild
index 387f3df8b988..916f2b30e2f3 100644
--- a/tools/testing/cxl/Kbuild
+++ b/tools/testing/cxl/Kbuild
@@ -64,7 +64,8 @@ cxl_core-y += $(CXL_CORE_SRC)/cdat.o
 cxl_core-y += $(CXL_CORE_SRC)/ras.o
 cxl_core-y += $(CXL_CORE_SRC)/acpi.o
 cxl_core-$(CONFIG_TRACING) += $(CXL_CORE_SRC)/trace.o
-cxl_core-$(CONFIG_CXL_REGION) += $(CXL_CORE_SRC)/region.o
+cxl_core-$(CONFIG_CXL_REGION) += $(CXL_CORE_SRC)/region.o \
+				 $(CXL_CORE_SRC)/extent.o
 cxl_core-$(CONFIG_CXL_MCE) += $(CXL_CORE_SRC)/mce.o
 cxl_core-$(CONFIG_CXL_FEATURES) += $(CXL_CORE_SRC)/features.o
 cxl_core-y += config_check.o

-- 
2.49.0


From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from mgamail.intel.com (mgamail.intel.com [192.198.163.18])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id F2EED1A5B89
	for <nvdimm@lists.linux.dev>; Sun, 13 Apr 2025 22:52:21 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=fail smtp.client-ip=192.198.163.18
ARC-Seal: i=2; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1744584744; cv=fail; b=q6O8NPszz2tH8RIoIElwewk2Rwp3WCPcX+K/65g+P2iLwa6syal5yH0yDqGwkhOaJPUm1XCmDbo4CdRqnrVtUCiPmQhaQJYFGX7kBCv8QqFzsht30du4qezeFsdeNqcYhGXVCGeZKRQ8wl2L6tbN1Yfs1sKyco+aFVhRaPnxsN4=
ARC-Message-Signature: i=2; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1744584744; c=relaxed/simple;
	bh=ObXjYpSXhyIOJclFZabMVwT7Iw3oZ5eWVtgb3/GUyCU=;
	h=From:Date:Subject:Content-Type:Message-ID:References:In-Reply-To:
	 To:CC:MIME-Version; b=Mh1O3g0ejq4P+vPd/bXDzvftJI4E8kPDRU2BKKnjtVTsKrEqZncDP1q7vgwOqyHMVI5RMt2gpLhaD1ePiM3LFMwv/Jz8qNms9dbzPmirpiVfHWhFOu0s2JzoYZ2mIH9QxEUuo33HYtTlEmyDAHZovdr4rZTg6luS2omvt8VpjdQ=
ARC-Authentication-Results: i=2; smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=intel.com; spf=pass smtp.mailfrom=intel.com; dkim=pass (2048-bit key) header.d=intel.com header.i=@intel.com header.b=heGP9f7o; arc=fail smtp.client-ip=192.198.163.18
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=intel.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=intel.com
Authentication-Results: smtp.subspace.kernel.org;
	dkim=pass (2048-bit key) header.d=intel.com header.i=@intel.com header.b="heGP9f7o"
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1744584742; x=1776120742;
  h=from:date:subject:content-transfer-encoding:message-id:
   references:in-reply-to:to:cc:mime-version;
  bh=ObXjYpSXhyIOJclFZabMVwT7Iw3oZ5eWVtgb3/GUyCU=;
  b=heGP9f7oul1v85wN0FHpMAvhgHKcBsryqOAQ5cgIL5hd7fcE330FRYzI
   3H9AUx9b0eEhvlXqtPloe+fRATzGv8zp2cJNLawDOJzmtgVup/EOdeO6u
   bs5dTtzPMbtE6eKKPi4D08Wy17Z9aETWw5vLy8YwXf9Hof3knAVz6Duju
   ZALGz1NDhF+atlWLk31w/aNaoDTIkqI2KZvRTauz6k30g2GRZMrp3k+gM
   UoyizCV90Kdp/nkSVfgPHE7iSvzsyz0Esb3tZrpOm5u7Gdb62NcaYtCMD
   tTY8JTpXyjnYs9kfyMGLorRWIJUzNBztbIAIt1qdG2migX3IGuYWEuVII
   w==;
X-CSE-ConnectionGUID: zwbzGrVmTK+OLbrkY6Ia6g==
X-CSE-MsgGUID: /G6KWr+iSb+MyPv2xkmPxA==
X-IronPort-AV: E=McAfee;i="6700,10204,11402"; a="45280945"
X-IronPort-AV: E=Sophos;i="6.15,211,1739865600"; 
   d="scan'208";a="45280945"
Received: from fmviesa007.fm.intel.com ([10.60.135.147])
  by fmvoesa112.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 13 Apr 2025 15:52:21 -0700
X-CSE-ConnectionGUID: 16kwmHiDQC6UNkrmnfJrhQ==
X-CSE-MsgGUID: CRdSWK5pSWi/agsQajn9RA==
X-ExtLoop1: 1
X-IronPort-AV: E=Sophos;i="6.15,211,1739865600"; 
   d="scan'208";a="129657624"
Received: from orsmsx903.amr.corp.intel.com ([10.22.229.25])
  by fmviesa007.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 13 Apr 2025 15:52:21 -0700
Received: from ORSMSX901.amr.corp.intel.com (10.22.229.23) by
 ORSMSX903.amr.corp.intel.com (10.22.229.25) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.2.1544.14; Sun, 13 Apr 2025 15:52:20 -0700
Received: from orsedg603.ED.cps.intel.com (10.7.248.4) by
 ORSMSX901.amr.corp.intel.com (10.22.229.23) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.2.1544.14 via Frontend Transport; Sun, 13 Apr 2025 15:52:20 -0700
Received: from NAM04-BN8-obe.outbound.protection.outlook.com (104.47.74.48) by
 edgegateway.intel.com (134.134.137.100) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.44; Sun, 13 Apr 2025 15:52:20 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector10001; d=microsoft.com; cv=none;
 b=keMmtVMywCKOCDsuiNgbnq+gsDFcJo8UEkPouXWK3dC5Gv3EmBnJ0MhohN5M1V5ii2J5u3Z0Oa25dYwsKJsXXYFU2taetWPVQhDnnV9zLnOpWc+BCtv5VHHVkid/2V3IvfNjoUo9WLzFde9nPAWzCCTcvMxrh5ZahgpdVMGl0dEelVqND9zZPmlcdDQd703x1NfYTopDTPG4Xu/AZHdJPAEF2wT94kwCpBeoKAIJfNlg7Exr/JOUgJ36ea6fOzLzaCnJhY8syeFE3cpqu3Aq5elYAQ/BvDo6xjswCtMMIcJpEUnbwUbA5sRPPFlwZyTzsPcQunZBeiQdjj08MWZb6A==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector10001;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=Rnp5qmlW0f1okaqStrG2jxKpSYTSKZide7t8m+Fd8ww=;
 b=gV78LOJbqc+uXBxEalRuNG1xa4o/vReZkA3KH0iaNEcI2D9DdCcaBRP4i65mLT3qKXcJOw2nOzWYehKwm6RNujTR1jfuPnfel+i9hpSRyvMySdwPmrccOJOqJForiJo9aJlyQhsH0IqeW0If9D3kAbzrQEbBYvIqe0+i/nw6xKXNBj191P7EU+JkSfNM+cm0wDKZmQWOPVJ6EtsZMwx2K2LU1VjdNDj44SthXkbjadM1zoU89PMKeUlu1XIaFPcVbYOV1L0yZ+dLKO74H1th/z4rEETRyn/kNPmHwRxi7v+MNFrVrQ/WDYNYM1tUrTSV/+mSw8vrhskBQojibIHdbw==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from MW4PR11MB6739.namprd11.prod.outlook.com (2603:10b6:303:20b::19)
 by DM4PR11MB6042.namprd11.prod.outlook.com (2603:10b6:8:61::18) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.8632.28; Sun, 13 Apr
 2025 22:51:44 +0000
Received: from MW4PR11MB6739.namprd11.prod.outlook.com
 ([fe80::a7ad:a6e8:fced:3f24]) by MW4PR11MB6739.namprd11.prod.outlook.com
 ([fe80::a7ad:a6e8:fced:3f24%4]) with mapi id 15.20.8606.033; Sun, 13 Apr 2025
 22:51:43 +0000
From: Ira Weiny <ira.weiny@intel.com>
Date: Sun, 13 Apr 2025 17:52:09 -0500
Subject: [PATCH v9 01/19] cxl/mbox: Flag support for Dynamic Capacity
 Devices (DCD)
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: 7bit
Message-ID: <20250413-dcd-type2-upstream-v9-1-1d4911a0b365@intel.com>
References: <20250413-dcd-type2-upstream-v9-0-1d4911a0b365@intel.com>
In-Reply-To: <20250413-dcd-type2-upstream-v9-0-1d4911a0b365@intel.com>
To: Dave Jiang <dave.jiang@intel.com>, Fan Ni <fan.ni@samsung.com>, "Jonathan
 Cameron" <Jonathan.Cameron@huawei.com>
CC: Dan Williams <dan.j.williams@intel.com>, Davidlohr Bueso
	<dave@stgolabs.net>, Alison Schofield <alison.schofield@intel.com>, "Vishal
 Verma" <vishal.l.verma@intel.com>, Ira Weiny <ira.weiny@intel.com>,
	<linux-cxl@vger.kernel.org>, <nvdimm@lists.linux.dev>,
	<linux-kernel@vger.kernel.org>
X-Mailer: b4 0.15-dev-c25d1
X-Developer-Signature: v=1; a=ed25519-sha256; t=1744584735; l=4586;
 i=ira.weiny@intel.com; s=20221211; h=from:subject:message-id;
 bh=ObXjYpSXhyIOJclFZabMVwT7Iw3oZ5eWVtgb3/GUyCU=;
 b=2CkaSSQAtgE6kCVfvIHhyyHvMDIIb4PkrgLRXi9PTyvh6B5OOscV117iFWBWpzulQYXQ15+ZB
 TLulNVfBTcJAn/0JcJ3cT3iGXIzqAZRZ7GQBpjinDbm3LUrrtKt0G4d
X-Developer-Key: i=ira.weiny@intel.com; a=ed25519;
 pk=noldbkG+Wp1qXRrrkfY1QJpDf7QsOEthbOT7vm0PqsE=
X-ClientProxiedBy: MW4PR03CA0227.namprd03.prod.outlook.com
 (2603:10b6:303:b9::22) To MW4PR11MB6739.namprd11.prod.outlook.com
 (2603:10b6:303:20b::19)
Precedence: bulk
X-Mailing-List: nvdimm@lists.linux.dev
List-Id: <nvdimm.lists.linux.dev>
List-Subscribe: <mailto:nvdimm+subscribe@lists.linux.dev>
List-Unsubscribe: <mailto:nvdimm+unsubscribe@lists.linux.dev>
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: MW4PR11MB6739:EE_|DM4PR11MB6042:EE_
X-MS-Office365-Filtering-Correlation-Id: 21404f0d-096c-4e56-bda3-08dd7addc322
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;ARA:13230040|376014|1800799024|366016;
X-Microsoft-Antispam-Message-Info: =?utf-8?B?empBWlhQRE1CQkdmbzBHY3dpUjl0VmhiMTNLUUhWcHUrekFuRktHaCtBbWVY?=
 =?utf-8?B?RVFsNFVtZFU1dzBMZTJRVkYyL1EwMmdpTXpyZmhQcnNOUFBWQ29GMm96dlJS?=
 =?utf-8?B?MmpCZzR5S0laTFhHWE15VytaVFdCY2JVWUs2OVU2UWIwSHk3dE0zSG5SdUpB?=
 =?utf-8?B?U1QrajhhYUtWekgzSkptL1g1cHRWTEl6aXlIbmRlQkp3VG1PQ0ZXRGd0R0Zs?=
 =?utf-8?B?OS9FNnF5Yy9lTDV6d0tFVHAwT3pKRy9rN00zanZBc2JGZGI4QWtpZDRzR2tk?=
 =?utf-8?B?RE1GcFlnR1dOL0pZU0hqYnp5cm5jVzFaZEZvcGVJVWk2b05vYTllZGE3WUty?=
 =?utf-8?B?Zm1jdkpCc1ByY2VqcWtqVTRiODhQZ2lURW1UZGM0WUozZnJ5aHRQZGd1QVB5?=
 =?utf-8?B?dWFuTWRCbnBNNS94Y3VPclUxZWw1eXBCaTNBdEJpZ0F5SW5sN3o1YkNXbTF0?=
 =?utf-8?B?a2Q5NTVWT1lBa2ttWk1wWnhlMjc1Nk9IM21RQngvNHpZU2dRZHd0amVsM2I4?=
 =?utf-8?B?TW8rSVhFbXMra1dicHA2ejYrU3R3QnhBcGZLdFhLbDNsM0xsdkZNcHhNWVJK?=
 =?utf-8?B?a2l1RWdIZE5vekVKbGRlSHNpRTA0c0t5ZTNpa1lBU3ZqenBWZEVqQ241aXlH?=
 =?utf-8?B?eUVuQlAyRHVhdi9uU3hiZWVGS043ZTBBcDdoVEhNMXdUYTAxc3ljcis5d0xw?=
 =?utf-8?B?LzgwN2VVRnJpVjIxaVE1V0ppU3ZIYVJNY3E0NVdhclJWSitKQ3pkVnhvMEVF?=
 =?utf-8?B?SGNaRmc5L0ExR01FcGxFcjN1M0dzM0hvVHFBWi9QMTFOZUllNEkvcmFFY3pr?=
 =?utf-8?B?L3k2V1A3dDRTN1pFL3BiQjN0TTJRVko4Y1pUaUpmcmp0REtoeXVuM3RmcERu?=
 =?utf-8?B?UDUxa01UWjBndXFQeVBndllxUTg1cFlBTC84bE56bWh0RVdwMEhRSXFUdndw?=
 =?utf-8?B?SUVmYWVKUjJ4dmUwTFc4MVJzZlZYY1JEakplcC9uQW5oNk4yaytqTElGMzVP?=
 =?utf-8?B?bUl6OWFPb1lVRHo1Ymk5NFhsK1dIZmI3ZDJJMnRKeDBMRkZqd0F5b2lwd1c4?=
 =?utf-8?B?TWhWZWQwOVVYbHNzUkpaMFo1bVk5VVNhYVBHVXZBWEVnY3NJQTc0dDBSR1Ux?=
 =?utf-8?B?K0NLVVNPNFhpRGdlYVRGajlldWo4bG9tS1l6MWpaRXhDSnZvYWw2TDZCSGsz?=
 =?utf-8?B?Z3h0YlBFaGd5S2pOVFJuN3VDUlFUUWtQb09Ub0daTnJKT0gzMkE2UURtMnM0?=
 =?utf-8?B?M2N5Z1FxenV2cEpySTFpVnRyL3JKR1Y0SVp2QUdSWUtQWStWN0tldEowY0ZR?=
 =?utf-8?B?YUxVMFVQN0lrVndmWUNWcnVHR1l4ZlNLS3RUNVVKUS93eEpmZE56OE1MRllU?=
 =?utf-8?B?V2ZrRG83cUxwN1VmbUxBd1V6Szc5djQvYjhKVU92MDcrMm56TmlMd2ZCWnpD?=
 =?utf-8?B?TGJKSHFESC9aK0FlbStMdjhIOW9VYTFCWHdFNjdzd0FXdkVpbkJUdGUwb2py?=
 =?utf-8?B?VnhXNERVaFJBRHRXNlpYc1RUNDVHUURpYW1aVU83RGRhd1VSMkhvVDR5Zk5V?=
 =?utf-8?B?UnpJUng2cmRYajlwZE9KSHhaMlVJS2hmYisvVVVyVGQ3a1JNQ3NlczNHSU9B?=
 =?utf-8?B?UGNyeGNMRWs2bkZKcDFaKzJWTC8xQ3VnVExtejhieFdnSUpDNjVBMUdoM3Vv?=
 =?utf-8?B?cWMyRUpWLzVleEtzM25VRG9qdWxMOFlQNnUySWROcDNoSGxLOHpvTEpIOHRG?=
 =?utf-8?B?SDVrSHRSOCtXOUwxeHZkY2Yxb3BLYlVJNlZGK01VdTZRKytiZm5HMWoydGs5?=
 =?utf-8?B?L3lBVWZjdUI2aDJSNG1PV2l2dXk0S1NHVERvcC9WeUpNM2w4aUo4U0k3ejdY?=
 =?utf-8?B?UnBoaDI3dk9KQWtINzd0MDc1ZVpPU3R0cnZ3d2s1dm9ObTBQcmxBZjk5Q1Ay?=
 =?utf-8?Q?OoHUrFbrR6Y=3D?=
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:MW4PR11MB6739.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230040)(376014)(1800799024)(366016);DIR:OUT;SFP:1101;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?utf-8?B?VGkzeTJCbVVYemY3UjhlekZSbmlHbVJCZkgrNzdmWXpkTFYxUjNhb1huV2hE?=
 =?utf-8?B?VGFGcmZUU0MxWncveXlQNzFUQkR1UTdaaERCbndoNDMrNHB3dzFyNXdoSXRt?=
 =?utf-8?B?Z3ZLdEM3UHZ3T0YrazEzWGpLVzdjM21LK2hXczVXVEorTXNzdGtFYUtLMDd6?=
 =?utf-8?B?V0hrdllFTFdVNzR6ZEpRemFPNmxhWCtBNEI3K1lUYlpaQ2NacmhVOFFvaHhW?=
 =?utf-8?B?QzcvVmFJM3dPWndQNmRLUzl1UTcvZHltVDBhTHlCSnNUUE1MaGRQeXhVYVdL?=
 =?utf-8?B?cjRoNVlseFB6Y3g5OE5CZDhvMllXSGJDYVppTVliTVBvNlBtTmxsa2dLdlNT?=
 =?utf-8?B?ZFBCeXJ5bnMzWFlOcnhDSXZwYmZJKzE5ajEyeGdianhuaU9qaEFTRzhDclk4?=
 =?utf-8?B?THFiTXdVY1IxQTRZQ0lwdENWYUVSR1FFcndPSWk0dzNpREFqeTRyMHdCandV?=
 =?utf-8?B?K3NZRlJXak84ZnJFWG1KUTZBQllOYmpuU29zZm1jZGUySlFTMjRTUkkrZXA3?=
 =?utf-8?B?dnMyWUJIM2tySGNZZGduSjNiaGF3bTFyWVNWVWkxYUFqN0tGZHJBWHhpdSsx?=
 =?utf-8?B?WEw5Mi9UTzJZQW5uVW1KYURUNm9iUnZYbEhvUkRGS1pZaDFDZ3Zwa0JIeExB?=
 =?utf-8?B?VmhCVExVN2tiTExpWUxkWW1oR2NXSStzUGxTNTN5VDhaNDU5NFJmZE54aVJ5?=
 =?utf-8?B?Nzh3QThoU3dWUE5FTkdNejB6Z2tVOEE0TUFvSnIyWURCK1ptRjlyeXVhcy9O?=
 =?utf-8?B?dWk3NzdxODI1UTVKZUgyL21VTHd3SkhCQXNHdzRTRi9VdzlzaWF3MWxOU1Yw?=
 =?utf-8?B?ZjN4SHBTMlRhRkJKL1BjNS9ROHh2dUFFdWVhQ21Ga01XZ0dWK2IwdzRKdVZ0?=
 =?utf-8?B?SXZ2d2JWUkpXNGVzcG5UUDFzTjJyZmh2eHlnNDF3MHJYYnF4dmVhcDNvTHdT?=
 =?utf-8?B?QnR5YWlmanJ0VFl0eGE1YVZIdHlZdC9RbFlzVFI4MzhLUWVFRWNUdUc4a05H?=
 =?utf-8?B?YjI3TmFlSG1BeCsrcjlZZkxXTm1uN1lRKzBPU2JvNldDUzhGSk5HSnR1MHlH?=
 =?utf-8?B?a0hORzRvRWgvTXVFdkowRTY5YTFBdUZ3UWxudGtkdmRiaEdsdkRMTDRBTnkz?=
 =?utf-8?B?eWpFQnloNWp6dDM3OTlSbGN4M2x6eGNjaWVzdkZ4dVFBTkZGd3dxZ0NTbldi?=
 =?utf-8?B?Z1ZmQXZKa0lJbDhXcWlhRUxVNzRhSzVsZDM1aHcvOFBHODZrRUJmUFVMZlRl?=
 =?utf-8?B?cHNKK2ptcTY1d1BmLzFzb2hpOCtFcThoUGtBTjJvTVNKWFVIRHFNcDZFZGt2?=
 =?utf-8?B?Nm9qS29ycW1NOXRxRlNlZU1ydnRwcGJVT1RhTkNWZzlzTUZFdUY0SkdZcmVB?=
 =?utf-8?B?Z29ZN3RqVE44YUt5d0tHQkpSN3VrbFVPa0lEdWtmbTR2MmNPeHR6NU1vTU9o?=
 =?utf-8?B?S2hLeXJMbVNNMk1JNWpQM1Q2YSt2WlF4OUcwSHlwbGhZYVUyTTI4V1RKOVcr?=
 =?utf-8?B?YVFnTDV2VEEvQndRT3lqY0NNNXBUR0dBL3BVWitKdS9CdklPOU8wSzY5c1lj?=
 =?utf-8?B?MDVqZG4ydnQ2TTVIU0xFQVJ2M3lDT0JxMk5jUE5vNWNQS3RmK3EzUE5sQ21L?=
 =?utf-8?B?eitGRTVnUi9aTUJod0lKR3diQ1M0YUkwMXVxVXhKQ3kxbjB3TUplbG9TZytr?=
 =?utf-8?B?RjFJdElEM25TYVhIZDMrbDZiWFYzb0d1d3FtbFFUMzdkS1RraTgxWnNBWENQ?=
 =?utf-8?B?NHRYcWFVVUZCbXVzLzhrYkl3Umx2T0QrNWIvKzV4ZER3c21sTC9ROW54N0Ew?=
 =?utf-8?B?Z3EzYUQwWGxFaDdkTklqZVgzUCsrSzdvNHpZSXR1WDZ0Y2w0WkVrQTNIM2NX?=
 =?utf-8?B?VklJU0dTNkducHB0VmdodTFBQUpIZFlHcWROKzNxRXdOckhRREROK2lFRXln?=
 =?utf-8?B?SDJUTkQrTzhuS1NFc0dsYmcwYUZiT3JoU3NSblVKeStTMjRuS0k3cWpDc1M3?=
 =?utf-8?B?MGlKclo3VnIyYm1tdWR0elU0ekdSL3BIL25oazZxOG5LWWh5VjNjV2VoQ01x?=
 =?utf-8?B?bzFxVjErbXJ5UHN4dllWMUwva1pSNW4yY2RCaDh0MDlBRDVYenBmTzNZTStr?=
 =?utf-8?Q?PcBQKZ4TYtCUvhlyp9XBL3GrE?=
X-MS-Exchange-CrossTenant-Network-Message-Id: 21404f0d-096c-4e56-bda3-08dd7addc322
X-MS-Exchange-CrossTenant-AuthSource: MW4PR11MB6739.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 13 Apr 2025 22:51:43.9083
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: 3DTvJt7lzTMXsv5u+7CPJkCiXHKbu1G0+/zYed5TkaqxDo/u8TByoTtjv/mCxapPQNXBg51pRI0e+tJEjAl37Q==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: DM4PR11MB6042
X-OriginatorOrg: intel.com
Status: O
Content-Length: 4439
Lines: 149

Per the CXL 3.1 specification software must check the Command Effects
Log (CEL) for dynamic capacity command support.

Detect support for the DCD commands while reading the CEL, including:

	Get DC Config
	Get DC Extent List
	Add DC Response
	Release DC

Based on an original patch by Navneet Singh.

Signed-off-by: Ira Weiny <ira.weiny@intel.com>

---
Changes:
[iweiny: rebased]
[iweiny: remove tags]
[djbw: remove dcd_cmds bitmask from mds]
---
 drivers/cxl/core/mbox.c | 44 ++++++++++++++++++++++++++++++++++++++++++++
 drivers/cxl/cxlmem.h    | 15 +++++++++++++++
 2 files changed, 59 insertions(+)

diff --git a/drivers/cxl/core/mbox.c b/drivers/cxl/core/mbox.c
index d72764056ce6..58d378400a4b 100644
--- a/drivers/cxl/core/mbox.c
+++ b/drivers/cxl/core/mbox.c
@@ -165,6 +165,43 @@ static void cxl_set_security_cmd_enabled(struct cxl_security_state *security,
 	}
 }
 
+static bool cxl_is_dcd_command(u16 opcode)
+{
+#define CXL_MBOX_OP_DCD_CMDS 0x48
+
+	return (opcode >> 8) == CXL_MBOX_OP_DCD_CMDS;
+}
+
+static void cxl_set_dcd_cmd_enabled(struct cxl_memdev_state *mds, u16 opcode,
+				    unsigned long *cmd_mask)
+{
+	switch (opcode) {
+	case CXL_MBOX_OP_GET_DC_CONFIG:
+		set_bit(CXL_DCD_ENABLED_GET_CONFIG, cmd_mask);
+		break;
+	case CXL_MBOX_OP_GET_DC_EXTENT_LIST:
+		set_bit(CXL_DCD_ENABLED_GET_EXTENT_LIST, cmd_mask);
+		break;
+	case CXL_MBOX_OP_ADD_DC_RESPONSE:
+		set_bit(CXL_DCD_ENABLED_ADD_RESPONSE, cmd_mask);
+		break;
+	case CXL_MBOX_OP_RELEASE_DC:
+		set_bit(CXL_DCD_ENABLED_RELEASE, cmd_mask);
+		break;
+	default:
+		break;
+	}
+}
+
+static bool cxl_verify_dcd_cmds(struct cxl_memdev_state *mds, unsigned long *cmds_seen)
+{
+	DECLARE_BITMAP(all_cmds, CXL_DCD_ENABLED_MAX);
+	DECLARE_BITMAP(dst, CXL_DCD_ENABLED_MAX);
+
+	bitmap_fill(all_cmds, CXL_DCD_ENABLED_MAX);
+	return bitmap_and(dst, cmds_seen, all_cmds, CXL_DCD_ENABLED_MAX);
+}
+
 static bool cxl_is_poison_command(u16 opcode)
 {
 #define CXL_MBOX_OP_POISON_CMDS 0x43
@@ -750,6 +787,7 @@ static void cxl_walk_cel(struct cxl_memdev_state *mds, size_t size, u8 *cel)
 	struct cxl_mailbox *cxl_mbox = &mds->cxlds.cxl_mbox;
 	struct cxl_cel_entry *cel_entry;
 	const int cel_entries = size / sizeof(*cel_entry);
+	DECLARE_BITMAP(dcd_cmds, CXL_DCD_ENABLED_MAX);
 	struct device *dev = mds->cxlds.dev;
 	int i, ro_cmds = 0, wr_cmds = 0;
 
@@ -778,11 +816,17 @@ static void cxl_walk_cel(struct cxl_memdev_state *mds, size_t size, u8 *cel)
 			enabled++;
 		}
 
+		if (cxl_is_dcd_command(opcode)) {
+			cxl_set_dcd_cmd_enabled(mds, opcode, dcd_cmds);
+			enabled++;
+		}
+
 		dev_dbg(dev, "Opcode 0x%04x %s\n", opcode,
 			enabled ? "enabled" : "unsupported by driver");
 	}
 
 	set_features_cap(cxl_mbox, ro_cmds, wr_cmds);
+	mds->dcd_supported = cxl_verify_dcd_cmds(mds, dcd_cmds);
 }
 
 static struct cxl_mbox_get_supported_logs *cxl_get_gsl(struct cxl_memdev_state *mds)
diff --git a/drivers/cxl/cxlmem.h b/drivers/cxl/cxlmem.h
index 3ec6b906371b..394a776954f4 100644
--- a/drivers/cxl/cxlmem.h
+++ b/drivers/cxl/cxlmem.h
@@ -216,6 +216,15 @@ struct cxl_event_state {
 	struct mutex log_lock;
 };
 
+/* Device enabled DCD commands */
+enum dcd_cmd_enabled_bits {
+	CXL_DCD_ENABLED_GET_CONFIG,
+	CXL_DCD_ENABLED_GET_EXTENT_LIST,
+	CXL_DCD_ENABLED_ADD_RESPONSE,
+	CXL_DCD_ENABLED_RELEASE,
+	CXL_DCD_ENABLED_MAX
+};
+
 /* Device enabled poison commands */
 enum poison_cmd_enabled_bits {
 	CXL_POISON_ENABLED_LIST,
@@ -472,6 +481,7 @@ static inline struct cxl_dev_state *mbox_to_cxlds(struct cxl_mailbox *cxl_mbox)
  * @partition_align_bytes: alignment size for partition-able capacity
  * @active_volatile_bytes: sum of hard + soft volatile
  * @active_persistent_bytes: sum of hard + soft persistent
+ * @dcd_supported: all DCD commands are supported
  * @event: event log driver state
  * @poison: poison driver state info
  * @security: security driver state info
@@ -491,6 +501,7 @@ struct cxl_memdev_state {
 	u64 partition_align_bytes;
 	u64 active_volatile_bytes;
 	u64 active_persistent_bytes;
+	bool dcd_supported;
 
 	struct cxl_event_state event;
 	struct cxl_poison_state poison;
@@ -551,6 +562,10 @@ enum cxl_opcode {
 	CXL_MBOX_OP_UNLOCK		= 0x4503,
 	CXL_MBOX_OP_FREEZE_SECURITY	= 0x4504,
 	CXL_MBOX_OP_PASSPHRASE_SECURE_ERASE	= 0x4505,
+	CXL_MBOX_OP_GET_DC_CONFIG	= 0x4800,
+	CXL_MBOX_OP_GET_DC_EXTENT_LIST	= 0x4801,
+	CXL_MBOX_OP_ADD_DC_RESPONSE	= 0x4802,
+	CXL_MBOX_OP_RELEASE_DC		= 0x4803,
 	CXL_MBOX_OP_MAX			= 0x10000
 };
 

-- 
2.49.0


From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from mgamail.intel.com (mgamail.intel.com [192.198.163.7])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id A13FA1C860E
	for <nvdimm@lists.linux.dev>; Sun, 13 Apr 2025 22:52:22 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=fail smtp.client-ip=192.198.163.7
ARC-Seal: i=2; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1744584744; cv=fail; b=RJ2eMktrICYDlYK75IJN+IZfLbDsbI7rJ78cvZ1pGDO37/+BNNGzdCTKi6H2gYxgi4qk47x5wNDyMblkdxTRF4/7M8IHLpTST67tzHIONX8S6ZghWWyHpd9nM8EtSQHFgrBKaoWVyAK/nDIGzxr7OUwaFAmAHTjOWE8rRF1BCbM=
ARC-Message-Signature: i=2; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1744584744; c=relaxed/simple;
	bh=dbpnUt0Rj32jPB+ZTtMa+10bARM2SLtI6QbpS09VtA4=;
	h=From:Date:Subject:Content-Type:Message-ID:References:In-Reply-To:
	 To:CC:MIME-Version; b=LI9YBL0Xm3gnjr+TB2kH2BN8cQ1aIoo/k6wZ1xc07rD0Ww1F4H/wpIEvKZIPNG4hSKPDFU4hoDtcmQvRKcAjVYWo3Ar9C1BfuEfeFPYyEIjCFlvjZm/59yHaTQ1/mwyRcFocxk0VfQ1np/Pke1XN4yv3SuojJ0fbN5qN5sybmdE=
ARC-Authentication-Results: i=2; smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=intel.com; spf=pass smtp.mailfrom=intel.com; dkim=pass (2048-bit key) header.d=intel.com header.i=@intel.com header.b=GJYc0G8V; arc=fail smtp.client-ip=192.198.163.7
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=intel.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=intel.com
Authentication-Results: smtp.subspace.kernel.org;
	dkim=pass (2048-bit key) header.d=intel.com header.i=@intel.com header.b="GJYc0G8V"
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1744584742; x=1776120742;
  h=from:date:subject:content-transfer-encoding:message-id:
   references:in-reply-to:to:cc:mime-version;
  bh=dbpnUt0Rj32jPB+ZTtMa+10bARM2SLtI6QbpS09VtA4=;
  b=GJYc0G8Vn31qDmzTRX1gjW3/oRORbCrDpA8SxIRLdcUtweUqCGJ2qW2d
   YbuwOtCTxINDVnRebqZldpk+XmlrW2YOXRnCwI2OMCMO+BU7H/XEeTxDI
   m4K1vdLwd3cGqIXXiryF/+eySdtWJgbB4sPigbMSdgFT5vNJz6gJ5V4Il
   ld5HTXZooyL+2PCtUWmfeU6ywkLgqip8ahDRpJSm6cC3n+KoDx9TZvYwo
   tDdiCpMiFb6sl6jLK2n+tni1gAkoVpmIkCNoJlyo3KBBaI/d4DACiPw9F
   BuWlz12YCGHEyx2iFk7hzhYysQzbNJE2gCWrPB40az1EGFnqAHUamqAoc
   g==;
X-CSE-ConnectionGUID: d2L/evoRQnKASEo0IMTwbw==
X-CSE-MsgGUID: G1ru5EZeQ3iEzIF/3y+9Cg==
X-IronPort-AV: E=McAfee;i="6700,10204,11402"; a="71431138"
X-IronPort-AV: E=Sophos;i="6.15,211,1739865600"; 
   d="scan'208";a="71431138"
Received: from fmviesa005.fm.intel.com ([10.60.135.145])
  by fmvoesa101.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 13 Apr 2025 15:52:20 -0700
X-CSE-ConnectionGUID: QGOhIkznRJiD28s1okWoEA==
X-CSE-MsgGUID: f8EH6ZhjSjGuw8Fi6920eA==
X-ExtLoop1: 1
X-IronPort-AV: E=Sophos;i="6.15,211,1739865600"; 
   d="scan'208";a="134405570"
Received: from orsmsx901.amr.corp.intel.com ([10.22.229.23])
  by fmviesa005.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 13 Apr 2025 15:52:21 -0700
Received: from ORSMSX901.amr.corp.intel.com (10.22.229.23) by
 ORSMSX901.amr.corp.intel.com (10.22.229.23) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.2.1544.14; Sun, 13 Apr 2025 15:52:20 -0700
Received: from ORSEDG602.ED.cps.intel.com (10.7.248.7) by
 ORSMSX901.amr.corp.intel.com (10.22.229.23) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.2.1544.14 via Frontend Transport; Sun, 13 Apr 2025 15:52:20 -0700
Received: from NAM10-MW2-obe.outbound.protection.outlook.com (104.47.55.43) by
 edgegateway.intel.com (134.134.137.103) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.44; Sun, 13 Apr 2025 15:52:19 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector10001; d=microsoft.com; cv=none;
 b=LdHooYh1JpyfT8w0EiR6oyCluqFXITWnC20fw1Ol+/8kLpwP7TsFAe4zAVsiLvbGOc/oor+Xi8FWNgnVmjEDHJ+mEg0D3ziYKlohjMiwUZqB+cjZnW3qdRkfEaJZhyuXp0SyJsD/e1eJjeWHts7X8lq4vlPpUWTQNuFDA0ETns0PF4i9lmZf+ut04SbrSALvwiGSsNjsuV5htkAyr5cDVQOaImwgJyvQQUqQnbHsGBR4HntlAVGCQlmQEkiqpRNX7wCkhn1EpD6z6kjf+JGRq7cOLwTDJhwgHBweG2Bquz8IwTQzN0VPILQs/lOZuCUIU6O0HLB37Dne0c4emKHyoQ==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector10001;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=wNoAbBBYNS2LHiqzwRXuIEpkmfzCc69lB2/JkZ8R22g=;
 b=NekB3uZiYnJh9pjEKc4rnOaiVonv5oyAT1bQSCafD++ZLOxBAiZgCHqA5/9uSsDpX57QBASXnHFHW59YB2yww435NrBD7RWtux4n58dpVNeCW6ncaON9XMfRURpTsN6/MqzWesmOOmjUrLyCX+j0heDl6owPwhX0G3ZB0orolfJc20R8TjdSVLSwaglvWyCG+3d3mho54Qh3kfDYIRZDaNPZs+SU5MjhG6hFBiuCsnQnFOU7ocD7ABAcWEaxuFVYUzn14V6mQ9ISHlaN+DRGaLfZFZ9pYN/PYmc7UIDKDaA9Vtb+Sqit7g7Vkg1e0zFhxVrUQjMnLOGuSg6j1FyETQ==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from MW4PR11MB6739.namprd11.prod.outlook.com (2603:10b6:303:20b::19)
 by PH7PR11MB7003.namprd11.prod.outlook.com (2603:10b6:510:20a::16) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.8632.33; Sun, 13 Apr
 2025 22:52:09 +0000
Received: from MW4PR11MB6739.namprd11.prod.outlook.com
 ([fe80::a7ad:a6e8:fced:3f24]) by MW4PR11MB6739.namprd11.prod.outlook.com
 ([fe80::a7ad:a6e8:fced:3f24%4]) with mapi id 15.20.8606.033; Sun, 13 Apr 2025
 22:52:09 +0000
From: Ira Weiny <ira.weiny@intel.com>
Date: Sun, 13 Apr 2025 17:52:24 -0500
Subject: [PATCH v9 16/19] cxl/region: Read existing extents on region
 creation
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: 7bit
Message-ID: <20250413-dcd-type2-upstream-v9-16-1d4911a0b365@intel.com>
References: <20250413-dcd-type2-upstream-v9-0-1d4911a0b365@intel.com>
In-Reply-To: <20250413-dcd-type2-upstream-v9-0-1d4911a0b365@intel.com>
To: Dave Jiang <dave.jiang@intel.com>, Fan Ni <fan.ni@samsung.com>, "Jonathan
 Cameron" <Jonathan.Cameron@huawei.com>
CC: Dan Williams <dan.j.williams@intel.com>, Davidlohr Bueso
	<dave@stgolabs.net>, Alison Schofield <alison.schofield@intel.com>, "Vishal
 Verma" <vishal.l.verma@intel.com>, Ira Weiny <ira.weiny@intel.com>,
	<linux-cxl@vger.kernel.org>, <nvdimm@lists.linux.dev>,
	<linux-kernel@vger.kernel.org>
X-Mailer: b4 0.15-dev-c25d1
X-Developer-Signature: v=1; a=ed25519-sha256; t=1744584735; l=8457;
 i=ira.weiny@intel.com; s=20221211; h=from:subject:message-id;
 bh=dbpnUt0Rj32jPB+ZTtMa+10bARM2SLtI6QbpS09VtA4=;
 b=70LGskBUS72k14zEP1Njc047eMZ4tEAL0gJfSp2jak5WU2AlIXmrrUYBAsAkY9W4FefcUPLLg
 2SacYrWNvLpAk1H9F7j78oUDfgSc1+GfOT/QkEwP4WDjJWW7AndDprC
X-Developer-Key: i=ira.weiny@intel.com; a=ed25519;
 pk=noldbkG+Wp1qXRrrkfY1QJpDf7QsOEthbOT7vm0PqsE=
X-ClientProxiedBy: MW4PR03CA0227.namprd03.prod.outlook.com
 (2603:10b6:303:b9::22) To MW4PR11MB6739.namprd11.prod.outlook.com
 (2603:10b6:303:20b::19)
Precedence: bulk
X-Mailing-List: nvdimm@lists.linux.dev
List-Id: <nvdimm.lists.linux.dev>
List-Subscribe: <mailto:nvdimm+subscribe@lists.linux.dev>
List-Unsubscribe: <mailto:nvdimm+unsubscribe@lists.linux.dev>
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: MW4PR11MB6739:EE_|PH7PR11MB7003:EE_
X-MS-Office365-Filtering-Correlation-Id: e84c113a-2d07-40ec-c33e-08dd7addd229
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;ARA:13230040|366016|376014|1800799024|7053199007;
X-Microsoft-Antispam-Message-Info: =?utf-8?B?Q2tycUM2SlpNMVlPOU9aMTNrbUEraStxSkUzYVB0WUI2UThqaThWcU41L3hN?=
 =?utf-8?B?WGQ3SnFKNFc5NGdYUjMxYThKUmxaanFmS2ZicFBJcjhkSWtLSmMzak1XemZy?=
 =?utf-8?B?bzdSZGM5TGNVNlhkME41aDhWSTF6bnFwaU42cnJlYnFDY0d6N3hEaDFqMit2?=
 =?utf-8?B?d3NQN3RITm5UV0g4dk5IOHp5M1JWSkdwQmc1NXlsUHBIaUptR3lRY0l1UXd6?=
 =?utf-8?B?NCtocXozbHJvNkRmQlJoMnN1OEJKWE51TXVmcExXMmwyR2s3eFZMVDFKcHlv?=
 =?utf-8?B?ZEhFSXNIMk5aQnpTR3pZbGpadkJJUXAxNG01MC8wT01MNmtyNldrckNwSUVl?=
 =?utf-8?B?NzhIYmZ4Y0crRTlyWkZKVnNUWjhGQWFDcUhScEFvS2x1Z1R3S0Q5SzRMWFBY?=
 =?utf-8?B?WVhCZTFnNGREcitrNmhvZGtOYlRnUkt3SGhoU0RZemQzUXo1cEJqNVRlbmRk?=
 =?utf-8?B?WWJZZzhUNmd6bFdZdm9ucDF3TytqSnBGdjI4TS8vb0UxK1VZa2RhSVZTRHZC?=
 =?utf-8?B?Q0c4OXZlRzZjMURySmJpTXhQeXhFTkV4NnpPejBjQ0hxZXRQOHl3aFRkbkxV?=
 =?utf-8?B?VTd6aGROc2Y2aS9lWHcvUGNheWVlZ2tES2F0SWg0M3hNK2o5OUJha1NBQ0Ev?=
 =?utf-8?B?cnNkZlpEZ2VWdXVwOXNtcWtaVWRNT1F1SXUydUpxbzRaRU1sZ2poeTZ0cTFX?=
 =?utf-8?B?SFZIejAvWkd6TnlHQ3l5RCs3N2NhSXBlRHhlME5XSG1hbEVWaFNsNEZwYXdF?=
 =?utf-8?B?Vyt1RTQrTlJYYmlTdHBkeWJiblR4dG05azhtTTF1T21SK3N2U00vcFIwaHlH?=
 =?utf-8?B?d2FGYUFKa3Z4ZC8wQlpiSGdWQldGMGMwL2lTUElwOTMxSWRBNVl4d2ZIRXMv?=
 =?utf-8?B?R2NHSWdzQXJubzhpYldUTHNXREFpb3FldkZtUzhIcXdYVXNVOG9mZ2ptTklN?=
 =?utf-8?B?R3hYdXA0WjVJSnZpUUg2S3ZUa2JhV3hxS0RnZ2d5RDVENVc5aW4vM08zQUxN?=
 =?utf-8?B?cHI4aFhwUUZjSHdmNklEWnRzTm5jM3NLdkZSSVRJdjlUajlaRUpGQnN6Mk14?=
 =?utf-8?B?aGJpb3BUTnNGQ1lYZ0xoZkw1RlhlbTJpMHU3K0UvU3B5SkM0N2o4aUJ1U3Z0?=
 =?utf-8?B?aFhITnBhc1F6dWkxaXhlSkZ5V2Zwby82KzFVdnJKbVpRazlZY3ZSeVhJTk85?=
 =?utf-8?B?VW01MmNCbXF6aFRSRTlPKzhvU0RmdGVDc2dDSUJHSHROSDRRWnc4MmJPV056?=
 =?utf-8?B?K0lPUFdsS1k0WURpVjBYSHliWGF0SGdha01PcWRBSjZPdjhFdHlRVnZySUJI?=
 =?utf-8?B?Zldsdzl6ZVEwWStzQ3ZvV2hFY2JubTdFVUdOVGNsWnI5bnB4ZzNmQU1OU1VO?=
 =?utf-8?B?ZFh3SmQ5aFA0MWZKMEdPbDFwK0dOb2lDTWM3bHFTRjhQVTR0RWhESXNKeXIr?=
 =?utf-8?B?a215Q2ZMTkVmQW5jeHNNaWpOSThycWVmL0VkdU4xWkVVT255cTRMZnl4cHFw?=
 =?utf-8?B?LzVXWk5UL2lKdHo4b0QrNnNDcndwQXQyb0Q4czRiRnVCVSs5ajk1elVFN0Uw?=
 =?utf-8?B?VDJzWjZuUGZORE5selcyVHhIQ1JnVTBNUGdmK1Fmb0NOamxuT0I2ak4xVDFQ?=
 =?utf-8?B?N1JQcTAvMHZvSEFLOFVpcThkZE5pR0FkN0d6R0p0YlFBY2wyL3NvYmNtR0Qw?=
 =?utf-8?B?Q05IQ21LN1VScVVNTDRyZC90QUNyNlh5VWpqNFdyRTdQNG12d2NrTUs1dTVv?=
 =?utf-8?B?OFNYUHlwaThOR0M5cko3Q2NSL3c2YVQveEVKcGZoR3lpOEkxckNULzk2dzFU?=
 =?utf-8?B?VkZ0bzlmbVpyeE4rNDBkYjJ5MmpvbXNhQ2ZHbGhra1pFS2tGeVBZVEtDMGMw?=
 =?utf-8?B?MVY1WWNpdFR2NEtEeDBRak84VmYreE8rOERtQVJJRWZ1R2c9PQ==?=
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:MW4PR11MB6739.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230040)(366016)(376014)(1800799024)(7053199007);DIR:OUT;SFP:1101;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?utf-8?B?N2hJcVpxSlNUK1U5Mlk5bjRpNDRmamp0WXdFOWEyNXQ4SUJSMjR4ZGJnb2g0?=
 =?utf-8?B?dkJuNUg4VEc3bG03eFBNaXpnM2EwOURnYnZMRXRNbVpqY3VoeWpnR29UTEpj?=
 =?utf-8?B?RzYrRGhXTWVnVmNaN3dtZzNZMGJlSDg0SUl4NWV6a001Rno1dlhGWW1lSFpj?=
 =?utf-8?B?b2VwVVpJNHptdnBaeEtIYVdiL1lWUnBGMkJJQmFjQjVzMGl1RzFxbUViRzNJ?=
 =?utf-8?B?YVlZcUV0MjBQOVhaVlFTS3RWaXpiSi9oZ2tEeDNwSThtSi9qUFk3QlhxRWpy?=
 =?utf-8?B?cXhMbFVxdE5MUjZyVFhldkN6Nm5od3EraW9HUktkdTBCTW02TkhUZmlNSG4w?=
 =?utf-8?B?V2JZYTZWamhxNzFwOWxvMm5adldZRlFUYlorOWJXc3BBN0MwdzJzR3UyQjF5?=
 =?utf-8?B?WGRTUmxzZDYwSXZFTFBZUG5WcXlZdzA1c21UeTBwYnNzdExhQVI2MFhNUUlu?=
 =?utf-8?B?VnZQbzEzQ1BHbmdiZGxnMHZRYmZnM1oyWnNxdDVxdFU4NGNuZERZa0FsZlVp?=
 =?utf-8?B?NzNOUmlZZUVLNDUwUlBua2pPSjJwVnhkS0pyM3d3QjMrZFRmb3pUU2hsM2Vx?=
 =?utf-8?B?QWdNZmhjckZjR1BYZlpjSyt6Y0ptNHBCMEJNMEJ2M1hzR0RQVHJWa2RzSlJr?=
 =?utf-8?B?SUNDRkkyTVBlOUlaRnhXSy9VUFJPaEVHS2xaYzdlL21vYWZIZ0hSM2dpVEpK?=
 =?utf-8?B?aTFKektCRXRJWU5CRjQxSDczWDJGQ29UaHBJL0lvZjJPTFRhWWxTOFZjalJk?=
 =?utf-8?B?K1V5QWFmKzdyUHFtWldKSTVjUG1PcnNFUmRieXJRUGRBZE1qbTF1cFVtT01y?=
 =?utf-8?B?cUZJbEhOa3BTdnY0OUE5aHF2NGdRVUJwMjhnbjdaWGlPSUdSQVZkOWIvaXdY?=
 =?utf-8?B?YkpaYmkrYTJZendFck9kK25sMlVUelVHdkFvUEtlVFlmbGJKMlVHRFRSdGMw?=
 =?utf-8?B?NUlycHNYd29wbzRndVlxNEx3VEFjMDQxdnN2S0lUT25ncW4ySzFUdllVckht?=
 =?utf-8?B?dWdEZm5OVkZsTUxGb0gxNmZYNk1rbm5Ia3k0YUVSbDVzbC9NaktoVWt1ZFJh?=
 =?utf-8?B?bFNWaXdqQkw2aUVhZzBrOHR2YzkvYjRwelZIeHdCek53SUovNEJpZlR0UGVP?=
 =?utf-8?B?VTRNV0ZWUmY0ZnhyM2RhSDA5REZrNTVRVkoxNTdNQmNTb0hpYnc5VTBlUGFP?=
 =?utf-8?B?eVpKQndhaVg3cW51QVNRemM4SkRud1dIWmlSK1psNDVsVDZRRjdmRm1iYkZB?=
 =?utf-8?B?ZStwR2NQSGVlV0VyQ2FvSThkT2xuOGNscExqNjFOTSs3RWM5ejlSS2p0L242?=
 =?utf-8?B?N1lnTnhLcUVYOElUdjNpQ2pEb1FLWWMxcllTT0RySEtNd3JDcVdPZnlyWkU2?=
 =?utf-8?B?eTJCRElHM00wUWpJeUMySFA2K1pzWHpBSTd2WDFkalYyYnVab2Q1SGhBbmhk?=
 =?utf-8?B?WndOTU9PenlubjdvQmw3TkdVRjIvZkxsanFJaU9wTG85K3FPYW1EbzQ5cGhj?=
 =?utf-8?B?d1VIV1NpVU43UjV4aXdRYnUyRHhHbzVPYTJhVndaOW5zZVZ4NCtheGRCZDhI?=
 =?utf-8?B?Zm9xdFBoZERuTGpvbUt1N0dGb0dsNWpuYXprQ3IvUjV4ZEJ1RTJUSFdPbElz?=
 =?utf-8?B?ak8vRXF4OGF2NTgwN1UwTDlhMWVRR1d6OHBFb2p2TnVkamJKQ3ZJZVF5MGRa?=
 =?utf-8?B?VndvZmpSSCtFNmxYTnFtYkduSkhVNzdQU0lMbXNQdEs0TnRsUktQbXllNENO?=
 =?utf-8?B?OHZlaytVbzUzT3hJM0M4NWh3OTM2MHZrRWNCa0xDOTdacHA5ejdvWHhtWG5Z?=
 =?utf-8?B?SzhpMEN1NTBabnNyZkRwM256VHZVR0NaQ1p0blNpdklmNTZPRVNyRk8xU2Rl?=
 =?utf-8?B?dFFEUHQzUWJCOFVpR0loWHdoU0Z4YXBDazFTNHNyS0lXVFVtb2c5L0dnRmlr?=
 =?utf-8?B?ZXExK3JKYng3SWw3bnFvWnZOLzRZNkhBbVNjRGpKbVV6eVZ6QlVUYUNNMjlZ?=
 =?utf-8?B?cCt4SEZhb3J3L3VkTVFtbVR1RFJ6cE5ieGViSzg2S3BrdVNNNndOekJIazZZ?=
 =?utf-8?B?WUZzUnpmVVkyMFk2dGttNVBpV2ZQN0JLSGxVYkhJNTJubTFnWUZGdDc3MWFS?=
 =?utf-8?Q?GG3yzjp9l7NTbu4W4dwrcC0vd?=
X-MS-Exchange-CrossTenant-Network-Message-Id: e84c113a-2d07-40ec-c33e-08dd7addd229
X-MS-Exchange-CrossTenant-AuthSource: MW4PR11MB6739.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 13 Apr 2025 22:52:09.2099
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: 9SwpEwJbiZKm8gFKf9HBl0LfA8NclD6Fy4yMdD2qe3q9xKLlG5XoOFZLiWfH5SW3ehEDhp2R8jquq+CHGahIhA==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: PH7PR11MB7003
X-OriginatorOrg: intel.com
Status: O
Content-Length: 8203
Lines: 256

Dynamic capacity device extents may be left in an accepted state on a
device due to an unexpected host crash.  In this case it is expected
that the creation of a new region on top of a DC partition can read
those extents and surface them for continued use.

Once all endpoint decoders are part of a region and the region is being
realized, a read of the 'devices extent list' can reveal these
previously accepted extents.

CXL r3.1 specifies the mailbox call Get Dynamic Capacity Extent List for
this purpose.  The call returns all the extents for all dynamic capacity
partitions.  If the fabric manager is adding extents to any DCD
partition, the extent list for the recovered region may change.  In this
case the query must retry.  Upon retry the query could encounter extents
which were accepted on a previous list query.  Adding such extents is
ignored without error because they are entirely within a previous
accepted extent.  Instead warn on this case to allow for differentiating
bad devices from this normal condition.

Latch any errors to be bubbled up to ensure notification to the user
even if individual errors are rate limited or otherwise ignored.

The scan for existing extents races with the dax_cxl driver.  This is
synchronized through the region device lock.  Extents which are found
after the driver has loaded will surface through the normal notification
path while extents seen prior to the driver are read during driver load.

Based on an original patch by Navneet Singh.

Reviewed-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
Reviewed-by: Fan Ni <fan.ni@samsung.com>
Signed-off-by: Ira Weiny <ira.weiny@intel.com>

---
Changes:
[0day: fix extent count in GetExtent input payload]
[iweiny: minor clean ups]
[iweiny: Adjust for partition arch]
---
 drivers/cxl/core/core.h   |   1 +
 drivers/cxl/core/mbox.c   | 109 ++++++++++++++++++++++++++++++++++++++++++++++
 drivers/cxl/core/region.c |  25 +++++++++++
 drivers/cxl/cxlmem.h      |  21 +++++++++
 4 files changed, 156 insertions(+)

diff --git a/drivers/cxl/core/core.h b/drivers/cxl/core/core.h
index 027dd1504d77..e06a46fec217 100644
--- a/drivers/cxl/core/core.h
+++ b/drivers/cxl/core/core.h
@@ -22,6 +22,7 @@ cxled_to_mds(struct cxl_endpoint_decoder *cxled)
 	return container_of(cxlds, struct cxl_memdev_state, cxlds);
 }
 
+int cxl_process_extent_list(struct cxl_endpoint_decoder *cxled);
 int cxl_region_invalidate_memregion(struct cxl_region *cxlr);
 
 #ifdef CONFIG_CXL_REGION
diff --git a/drivers/cxl/core/mbox.c b/drivers/cxl/core/mbox.c
index de01c6684530..8af3a4173b99 100644
--- a/drivers/cxl/core/mbox.c
+++ b/drivers/cxl/core/mbox.c
@@ -1737,6 +1737,115 @@ int cxl_dev_dc_identify(struct cxl_mailbox *mbox,
 }
 EXPORT_SYMBOL_NS_GPL(cxl_dev_dc_identify, "CXL");
 
+/* Return -EAGAIN if the extent list changes while reading */
+static int __cxl_process_extent_list(struct cxl_endpoint_decoder *cxled)
+{
+	u32 current_index, total_read, total_expected, initial_gen_num;
+	struct cxl_memdev_state *mds = cxled_to_mds(cxled);
+	struct cxl_mailbox *cxl_mbox = &mds->cxlds.cxl_mbox;
+	struct device *dev = mds->cxlds.dev;
+	struct cxl_mbox_cmd mbox_cmd;
+	u32 max_extent_count;
+	int latched_rc = 0;
+	bool first = true;
+
+	struct cxl_mbox_get_extent_out *extents __free(kvfree) =
+				kvmalloc(cxl_mbox->payload_size, GFP_KERNEL);
+	if (!extents)
+		return -ENOMEM;
+
+	total_read = 0;
+	current_index = 0;
+	total_expected = 0;
+	max_extent_count = (cxl_mbox->payload_size - sizeof(*extents)) /
+				sizeof(struct cxl_extent);
+	do {
+		u32 nr_returned, current_total, current_gen_num;
+		struct cxl_mbox_get_extent_in get_extent;
+		int rc;
+
+		get_extent = (struct cxl_mbox_get_extent_in) {
+			.extent_cnt = cpu_to_le32(max(max_extent_count,
+						  total_expected - current_index)),
+			.start_extent_index = cpu_to_le32(current_index),
+		};
+
+		mbox_cmd = (struct cxl_mbox_cmd) {
+			.opcode = CXL_MBOX_OP_GET_DC_EXTENT_LIST,
+			.payload_in = &get_extent,
+			.size_in = sizeof(get_extent),
+			.size_out = cxl_mbox->payload_size,
+			.payload_out = extents,
+			.min_out = 1,
+		};
+
+		rc = cxl_internal_send_cmd(cxl_mbox, &mbox_cmd);
+		if (rc < 0)
+			return rc;
+
+		/* Save initial data */
+		if (first) {
+			total_expected = le32_to_cpu(extents->total_extent_count);
+			initial_gen_num = le32_to_cpu(extents->generation_num);
+			first = false;
+		}
+
+		nr_returned = le32_to_cpu(extents->returned_extent_count);
+		total_read += nr_returned;
+		current_total = le32_to_cpu(extents->total_extent_count);
+		current_gen_num = le32_to_cpu(extents->generation_num);
+
+		dev_dbg(dev, "Got extent list %d-%d of %d generation Num:%d\n",
+			current_index, total_read - 1, current_total, current_gen_num);
+
+		if (current_gen_num != initial_gen_num || total_expected != current_total) {
+			dev_warn(dev, "Extent list change detected; gen %u != %u : cnt %u != %u\n",
+				 current_gen_num, initial_gen_num,
+				 total_expected, current_total);
+			return -EAGAIN;
+		}
+
+		for (int i = 0; i < nr_returned ; i++) {
+			struct cxl_extent *extent = &extents->extent[i];
+
+			dev_dbg(dev, "Processing extent %d/%d\n",
+				current_index + i, total_expected);
+
+			rc = validate_add_extent(mds, extent);
+			if (rc)
+				latched_rc = rc;
+		}
+
+		current_index += nr_returned;
+	} while (total_expected > total_read);
+
+	return latched_rc;
+}
+
+#define CXL_READ_EXTENT_LIST_RETRY 10
+
+/**
+ * cxl_process_extent_list() - Read existing extents
+ * @cxled: Endpoint decoder which is part of a region
+ *
+ * Issue the Get Dynamic Capacity Extent List command to the device
+ * and add existing extents if found.
+ *
+ * A retry of 10 is somewhat arbitrary, however, extent changes should be
+ * relatively rare while bringing up a region.  So 10 should be plenty.
+ */
+int cxl_process_extent_list(struct cxl_endpoint_decoder *cxled)
+{
+	int retry = CXL_READ_EXTENT_LIST_RETRY;
+	int rc;
+
+	do {
+		rc = __cxl_process_extent_list(cxled);
+	} while (rc == -EAGAIN && retry--);
+
+	return rc;
+}
+
 static void add_part(struct cxl_dpa_info *info, u64 start, u64 size, enum cxl_partition_mode mode)
 {
 	int i = info->nr_partitions;
diff --git a/drivers/cxl/core/region.c b/drivers/cxl/core/region.c
index eeabc5a6b18a..a43b43972bae 100644
--- a/drivers/cxl/core/region.c
+++ b/drivers/cxl/core/region.c
@@ -3196,6 +3196,26 @@ static int devm_cxl_add_pmem_region(struct cxl_region *cxlr)
 	return rc;
 }
 
+static int cxlr_add_existing_extents(struct cxl_region *cxlr)
+{
+	struct cxl_region_params *p = &cxlr->params;
+	int i, latched_rc = 0;
+
+	for (i = 0; i < p->nr_targets; i++) {
+		struct device *dev = &p->targets[i]->cxld.dev;
+		int rc;
+
+		rc = cxl_process_extent_list(p->targets[i]);
+		if (rc) {
+			dev_err(dev, "Existing extent processing failed %d\n",
+				rc);
+			latched_rc = rc;
+		}
+	}
+
+	return latched_rc;
+}
+
 static void cxlr_dax_unregister(void *_cxlr_dax)
 {
 	struct cxl_dax_region *cxlr_dax = _cxlr_dax;
@@ -3231,6 +3251,11 @@ static int devm_cxl_add_dax_region(struct cxl_region *cxlr)
 	dev_dbg(&cxlr->dev, "%s: register %s\n", dev_name(dev->parent),
 		dev_name(dev));
 
+	if (cxlr->mode == CXL_PARTMODE_DYNAMIC_RAM_A)
+		if (cxlr_add_existing_extents(cxlr))
+			dev_err(&cxlr->dev, "Existing extent processing failed %d\n",
+				rc);
+
 	return devm_add_action_or_reset(&cxlr->dev, cxlr_dax_unregister,
 					cxlr_dax);
 err:
diff --git a/drivers/cxl/cxlmem.h b/drivers/cxl/cxlmem.h
index 63a38e449454..f80f70549c0b 100644
--- a/drivers/cxl/cxlmem.h
+++ b/drivers/cxl/cxlmem.h
@@ -600,6 +600,27 @@ struct cxl_mbox_dc_response {
 	} __packed extent_list[];
 } __packed;
 
+/*
+ * Get Dynamic Capacity Extent List; Input Payload
+ * CXL rev 3.1 section 8.2.9.9.9.2; Table 8-166
+ */
+struct cxl_mbox_get_extent_in {
+	__le32 extent_cnt;
+	__le32 start_extent_index;
+} __packed;
+
+/*
+ * Get Dynamic Capacity Extent List; Output Payload
+ * CXL rev 3.1 section 8.2.9.9.9.2; Table 8-167
+ */
+struct cxl_mbox_get_extent_out {
+	__le32 returned_extent_count;
+	__le32 total_extent_count;
+	__le32 generation_num;
+	u8 rsvd[4];
+	struct cxl_extent extent[];
+} __packed;
+
 struct cxl_mbox_get_supported_logs {
 	__le16 entries;
 	u8 rsvd[6];

-- 
2.49.0


From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from mgamail.intel.com (mgamail.intel.com [192.198.163.7])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id 864CD1E3761
	for <nvdimm@lists.linux.dev>; Sun, 13 Apr 2025 22:52:23 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=fail smtp.client-ip=192.198.163.7
ARC-Seal: i=2; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1744584745; cv=fail; b=nUT3sI2zIQ5w0aTqB+4zFloFsZATGtzNKdkw+0kVp+itpfX5WgBtkYDIQI+/VjrZoMIAo9PktoklP8tU4Ggx53YVHIzoXMO9qtfE2un3KM+ldJ47gA6IdHM+8mzpPajtd/lZp+WJ0TdUg/g8llVJRXH5X6Y00Fq8A09AGedPrEA=
ARC-Message-Signature: i=2; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1744584745; c=relaxed/simple;
	bh=aPQ2lOD5FZgte//V4Fn7ZiP0+wnZl/4oLYzAK/mFmrY=;
	h=From:Date:Subject:Content-Type:Message-ID:References:In-Reply-To:
	 To:CC:MIME-Version; b=KxEi5AoIWmhvWfB8KM8x/MdqJ6P2uBRdtE3Er3l9gf+S7tfgGqqbRj55o8ZZ6Tiqas5n2/mLWJW9f56Ud4IKYOSYHr1r7CuDlGsmpoXFxzOmE412GWUjp+eeDxfQ1+/t/OUT/KlZsIe4syOrugdOBOQSR0ZZeApAh814g7kHV1A=
ARC-Authentication-Results: i=2; smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=intel.com; spf=pass smtp.mailfrom=intel.com; dkim=pass (2048-bit key) header.d=intel.com header.i=@intel.com header.b=OGPcYGN1; arc=fail smtp.client-ip=192.198.163.7
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=intel.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=intel.com
Authentication-Results: smtp.subspace.kernel.org;
	dkim=pass (2048-bit key) header.d=intel.com header.i=@intel.com header.b="OGPcYGN1"
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1744584743; x=1776120743;
  h=from:date:subject:content-transfer-encoding:message-id:
   references:in-reply-to:to:cc:mime-version;
  bh=aPQ2lOD5FZgte//V4Fn7ZiP0+wnZl/4oLYzAK/mFmrY=;
  b=OGPcYGN1ZfX43HBqsj0kV4l5G8fvY8MrQ3fDWrFJcPIDQqjJjj4vcA6n
   VkUkn+4flZaYS54fdytrKVwDrt9LgQWk2iRYN9/WnaZsFJJUjGYgrs13T
   Xo53VsWEI1ak38U74NHs8QikeVg0BEK0c3UpQl/wRuOJBU+HZ+62SFcaE
   ayv7eTeZhhr0v5BYYCTyKp+bMxjAKvRQ0kqo91no1OqDffoPRbg0NpPOb
   GsU//aEsfhhb1v+8MzU+9KgZlZCpNuSsU5DTMXmDjTw2zCuBXtUdJFdVt
   5HeuPaQNP5yiFh8tjIWfJdXsY2EXPmxqMzx2FnDNcl9Df62eZEmNTdqbS
   Q==;
X-CSE-ConnectionGUID: WqJPtTuaSTi4NISi8TF3bQ==
X-CSE-MsgGUID: X22zmqQeSXSYwPOYtOO/Sw==
X-IronPort-AV: E=McAfee;i="6700,10204,11402"; a="71431143"
X-IronPort-AV: E=Sophos;i="6.15,211,1739865600"; 
   d="scan'208";a="71431143"
Received: from fmviesa005.fm.intel.com ([10.60.135.145])
  by fmvoesa101.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 13 Apr 2025 15:52:21 -0700
X-CSE-ConnectionGUID: c9bybS/FR/+oSZj1Jn00Cg==
X-CSE-MsgGUID: blq2GIj7Tvu9Lxji5nAteQ==
X-ExtLoop1: 1
X-IronPort-AV: E=Sophos;i="6.15,211,1739865600"; 
   d="scan'208";a="134405572"
Received: from orsmsx901.amr.corp.intel.com ([10.22.229.23])
  by fmviesa005.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 13 Apr 2025 15:52:21 -0700
Received: from ORSMSX901.amr.corp.intel.com (10.22.229.23) by
 ORSMSX901.amr.corp.intel.com (10.22.229.23) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.2.1544.14; Sun, 13 Apr 2025 15:52:20 -0700
Received: from ORSEDG602.ED.cps.intel.com (10.7.248.7) by
 ORSMSX901.amr.corp.intel.com (10.22.229.23) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.2.1544.14 via Frontend Transport; Sun, 13 Apr 2025 15:52:20 -0700
Received: from NAM10-MW2-obe.outbound.protection.outlook.com (104.47.55.43) by
 edgegateway.intel.com (134.134.137.103) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.44; Sun, 13 Apr 2025 15:52:20 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector10001; d=microsoft.com; cv=none;
 b=nwMAU3Zff3b9XMbFxV9gmsB/9QZqvSLb6+/cVEVEHXNY48TLL4FPq7Vl7kHW/MqnTJ9VIaAjAqPcN+54++FxwdudZrOuhsGNF4xiq4hUXC8N1ENJ7FtpJ8df7rbZQGeJaXWmxDYiuwqjUXdo+bqSpcG34hZHoXqZWROMDmOk1PthNb0XfLwGDok7vS3nM6K3G6TazD4drkfyfKf2GdPwhWO2oSBWD+E6fE7PwvSlGqgtk34Mbl6WyuRkaJ8uczdDay1lAqo6V0/cPzg6weFIJ+IwnEUgVSi5LWFSkCfkhYZSZO2J7QwN0N5irkuguG5HgUT7DzYMH4mmFgg03RWx2Q==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector10001;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=KFSfKXdaijHdUR2EX8XUxITwaBLjdOOX4vtm8g6BPfA=;
 b=mI3Z47dOseu8TcHkGqt/6zxoMq4AlhCfMKtva4VMXc4VuPkplkwYeXOXwiMYY9+AleGNkz0dXIY6KJBBfDEOWBbt/PEhqrnXy2DepwhnXvt/UvotvFN764jLBVOCM/YbC8uuy4nK2o+RaPw6EGawLZQPICQmO1JHtwhMYExDqKvEADWSkXPTNxJKUc8BJ6vYxzbrL6y+Zorj9kPGuasJ2H7q3k+k4AuRiNkpgCqTt9R5yjpaKFfIHaRLW9G3OoS015NWWFzv6FBZq8kkyc2Xkr/GCa/bHaUnRlvVlJniNRZA5kfRWUDnTGYy1xD5NnKZeVxdzZ1m1r6v/ZAB0u4ZRQ==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from MW4PR11MB6739.namprd11.prod.outlook.com (2603:10b6:303:20b::19)
 by PH7PR11MB7003.namprd11.prod.outlook.com (2603:10b6:510:20a::16) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.8632.33; Sun, 13 Apr
 2025 22:52:10 +0000
Received: from MW4PR11MB6739.namprd11.prod.outlook.com
 ([fe80::a7ad:a6e8:fced:3f24]) by MW4PR11MB6739.namprd11.prod.outlook.com
 ([fe80::a7ad:a6e8:fced:3f24%4]) with mapi id 15.20.8606.033; Sun, 13 Apr 2025
 22:52:10 +0000
From: Ira Weiny <ira.weiny@intel.com>
Date: Sun, 13 Apr 2025 17:52:25 -0500
Subject: [PATCH v9 17/19] cxl/mem: Trace Dynamic capacity Event Record
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: 7bit
Message-ID: <20250413-dcd-type2-upstream-v9-17-1d4911a0b365@intel.com>
References: <20250413-dcd-type2-upstream-v9-0-1d4911a0b365@intel.com>
In-Reply-To: <20250413-dcd-type2-upstream-v9-0-1d4911a0b365@intel.com>
To: Dave Jiang <dave.jiang@intel.com>, Fan Ni <fan.ni@samsung.com>, "Jonathan
 Cameron" <Jonathan.Cameron@huawei.com>
CC: Dan Williams <dan.j.williams@intel.com>, Davidlohr Bueso
	<dave@stgolabs.net>, Alison Schofield <alison.schofield@intel.com>, "Vishal
 Verma" <vishal.l.verma@intel.com>, Ira Weiny <ira.weiny@intel.com>,
	<linux-cxl@vger.kernel.org>, <nvdimm@lists.linux.dev>,
	<linux-kernel@vger.kernel.org>
X-Mailer: b4 0.15-dev-c25d1
X-Developer-Signature: v=1; a=ed25519-sha256; t=1744584735; l=3493;
 i=ira.weiny@intel.com; s=20221211; h=from:subject:message-id;
 bh=aPQ2lOD5FZgte//V4Fn7ZiP0+wnZl/4oLYzAK/mFmrY=;
 b=k8Fdmu2rZNvNMh7qXVZD4E1W4tdqS8wxeoYskhYO5Th92GdtLTQFn2XPde1mfzC8hCpOtvPp2
 dQ//+GOxzbPDtNEqeP1qRDNxewxFwkDEJKt5QDpqPhDWSYOs9UnQhM/
X-Developer-Key: i=ira.weiny@intel.com; a=ed25519;
 pk=noldbkG+Wp1qXRrrkfY1QJpDf7QsOEthbOT7vm0PqsE=
X-ClientProxiedBy: MW4PR03CA0227.namprd03.prod.outlook.com
 (2603:10b6:303:b9::22) To MW4PR11MB6739.namprd11.prod.outlook.com
 (2603:10b6:303:20b::19)
Precedence: bulk
X-Mailing-List: nvdimm@lists.linux.dev
List-Id: <nvdimm.lists.linux.dev>
List-Subscribe: <mailto:nvdimm+subscribe@lists.linux.dev>
List-Unsubscribe: <mailto:nvdimm+unsubscribe@lists.linux.dev>
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: MW4PR11MB6739:EE_|PH7PR11MB7003:EE_
X-MS-Office365-Filtering-Correlation-Id: a4449e40-e3a4-4dbb-a319-08dd7addd321
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;ARA:13230040|366016|376014|1800799024|7053199007;
X-Microsoft-Antispam-Message-Info: =?utf-8?B?M0FDZmF4cHk3STdEaXpPSkxsVGxyaUZlczRBOFQvUThhSjRrd2Izcko5YWln?=
 =?utf-8?B?R0UxZm1pNExEWVBaMjRmemg1RUZCbnp4M1l3dUxMdlJZUFVZUFJBSGtjVTJS?=
 =?utf-8?B?Yk9XMW9qU3EySUxhaDhFeDcrTTNMWjd6dEJKczdmTmUvM1gvSVdwOFBpU1NQ?=
 =?utf-8?B?cWxCOXRHekphSElSSkxiOW1vSS8rbGk3dmxhY2VnZzZHb0NlcnhrTlZHZXVV?=
 =?utf-8?B?YXZOWVBMSHNkTUN4akZoOWpybVEzSlZhQkc3QkE1VDIySDUrOUNRWHlScHFj?=
 =?utf-8?B?andva2szZkFwN0NZcm1vdTFjblNXMElLLzAxbUtBcUN2cyt5aEs5R0JlM1dl?=
 =?utf-8?B?L0FvWlVIOTE3YkZpUDgwTkFSaGF6aWp3dHNTanJNTHloWVhEK3dWVG55b3J2?=
 =?utf-8?B?YVd1UDlWcEg2dXc0blFJR1VaOUs4dVBNSzFxNUxIdno1SHNpaURNRUNnUWdD?=
 =?utf-8?B?SjM3ckdMWWl5NkZDUmdnN0ErdStNNUVmQXgwWnd1Znh6WUx3dHNCK2JkM0ty?=
 =?utf-8?B?NVZqMXZUd25LTzQ5ZHVFSVVwQUVoNXRoU3cyRHJJVXJsRk1EbEplbVBUK2Iz?=
 =?utf-8?B?dWRMM2NLVE9QaFQxRG1zeTRYZEgrRndTN1JZcHhCaXBldEptRWhiak12eUd0?=
 =?utf-8?B?M3BOWWtDQW1QbmlJTkIwdEhKU01wdTZhK2ZCblN0cVAxZGpqUDdhd053SXBQ?=
 =?utf-8?B?TEYxM0pOVWhubXJtQnNZQXVTSG9HcnhFSXFzMWtuOEdpMU1rYnF0R1oyNDJo?=
 =?utf-8?B?NW96dk56cENSNHVYYkNBNThiKytXWmdNeW9jaTNnb0w4ZG1VUTQwd0FPZWt5?=
 =?utf-8?B?Rjd4ZEY1NkFsL3FlcjVYdzFIRk1MSVUwWVhBc2V3Q0ppazVTNVlnUHJaOU01?=
 =?utf-8?B?ZHliSjJKMExZekhJbW5YK0V4dUFhNlByVkNIOVJZM3J5cnhhR3JWcDdmTWRr?=
 =?utf-8?B?QlJFZDFrZ0xtZUZpYldvaUNsaVBaTDc3OWFvdi9iMGlXejU5SGVpL0JFaEZB?=
 =?utf-8?B?U2MwSk96dkZENFlzY1FyekV2UnM3OW1VSW0rYWk3S3NVOUtVK3JLVFB1YjJn?=
 =?utf-8?B?MGhGamdxRmFJWTJjVXJaa1MvanR3eFVVelBnUjNzKzRMdVl4RXRmRnFXcFEw?=
 =?utf-8?B?VVBaY054bG9scHJoeW1SUGhia1ZrdEphVDVLUENQejNIRm5BaUJwMklJQmJS?=
 =?utf-8?B?WjFIVlU5bkROQWlaTlh1alRZQ1JEWUphNWNIb1JaTG1kalZqQ3BYdDBBa0th?=
 =?utf-8?B?RmVWSURrcnFIbSsrcXQvWWYzeG1GRXVhcjQ3QWljdVh6eW5wWmh3c0tvQklz?=
 =?utf-8?B?UEo4clN6b21QMkVvVGhJS0pqcTFNS0dOeU9id1NhVjJ0aCtpY1U4eG4vSEhh?=
 =?utf-8?B?R3p1VmQ0eWhCTmRQLzdpU3pwNGZJa1Y4RStKalBEMDZEc0UwMUUvYkxJOUdi?=
 =?utf-8?B?TGF1NlB4MG9tdjJieXZtTUF1Q2xRUk84N1JoUE1MS1I1em9laXlRZHRwYjUw?=
 =?utf-8?B?LzF0WHkvVE1CRnB0MHNaZUdKb29BY1pYMzUyMVpZUElQM1BZbEVuVDUrRHEr?=
 =?utf-8?B?Z2pQb0dSSW8zcGxqVTZwNXdYaWVJTFNNREJPdERKdUVpUm5NSGx2T2lzSlE0?=
 =?utf-8?B?dTJWd1RvVjJ4cUkwUTBWL2tNSFN1K3dVQ2wvMW8ydFB2ZEpXM3FGZUtueEZO?=
 =?utf-8?B?ck4wbTlrMkxiOEdvNEU3VU5zSWdVQXhaOTgvS2laVlZhc2N2VzR4Vnh2M1VZ?=
 =?utf-8?B?M1VUUUpGNlVxWjQ3aDU2YmRuYmI5em9pQ2xVNElJVGsvNC9JcEozK3JYZ0xZ?=
 =?utf-8?B?K3RDVzMzWEhDdDhSZ3NPY1lkRXhWcm45YlVnbUs0QzlROFJsTHdpRGMxZGpx?=
 =?utf-8?B?SGxkakxpVmxPZDN3Skh1aDAyQTczOGt4NEoyUXU5eFpHdG96RkJGUnJRdHcr?=
 =?utf-8?Q?tPJjRp4DXhk=3D?=
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:MW4PR11MB6739.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230040)(366016)(376014)(1800799024)(7053199007);DIR:OUT;SFP:1101;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?utf-8?B?d1NNTmdFcVphZWhYN3ZXNDB6clZsOC9PeWpEZ3F4Zm9QSUZlZDFqaGFuSGVT?=
 =?utf-8?B?RGM4Y3NDVHZ0TEY4dFEzeDQ0TUs4ZUR2SW5sT1F6MVcrTFY5RUp4UEU4dFRt?=
 =?utf-8?B?YlRXTkI4QzJTb3BpdDVXVDcvR2FBYlhtVUF3ZEQ5c0tYdlJCMytQZ1dkaVps?=
 =?utf-8?B?MnlhMDV5bmJJNDBUdTl0eW1xZzV2K1RFNG50VHVUZVhZWFBubE1yWm9hUEMz?=
 =?utf-8?B?QXp1MUFUVUdjbzA2Zm1OT1FjeFVTZ0ZycStRMUExWnp1dGZEakhmNktjSXFw?=
 =?utf-8?B?bTBUTElQcnFhUTNhc1VGbFlPVk5nYW14blU3M3U3dFEvTGd6SVovRFZjclM1?=
 =?utf-8?B?VXFTYXlGK1NGb1JOL2VLQm0rZnBqZlNJb0wvOU5nNC9ZM0FsL3ZiaUVyUk1Z?=
 =?utf-8?B?cFhRcXhvVnVXN3BXWkVmUGdPVFA5VldPT3V2N2h0clZjczBpdlJIbHJiNVNv?=
 =?utf-8?B?Q2R2VTdGZk5ObG5kRU1WYkJ0NTk5Tm5HZHh3dkJvOUN4UEhldTNWZ2ovU3Zy?=
 =?utf-8?B?Z2o1Ti9BNDRlT0RIV2pEZUNDcW4zcjg4dHJTQjFXTHVwdmplN2hrSVBvYWpN?=
 =?utf-8?B?VEw4cDdmUzhGc1ZNcHlnMkRtZXU2VjRraXZCSndQK0praHFyc1ZubUJpNkhR?=
 =?utf-8?B?ZW8wakJGWjBiZ0hpMnlCdG4rR3JEQ0xBTUZnWUR2V28xUDNrUTE0QUR5WkpD?=
 =?utf-8?B?bEJvc3dHQTNaNC9CRTZwZ3c0ZDIxNlgzTk9FdGV3R0F6aUgvTWpvWFRRQkJ4?=
 =?utf-8?B?VXMzMkhYTXFFbko0M2lDclRGSENUZDN0cjhiR1FVWFl2T0NzaiswWUxoZFdG?=
 =?utf-8?B?SFpCR28zbk1uTnB2c0xJWkxza2hWdEFBTldLOUVkZ1RReHd4V1diSW0rZmZ1?=
 =?utf-8?B?Z1FPTUFkNXJtZDJpYkV6a0haM1BDOVFOOUEyL3dMeWl2cGpUVTgwcnpXTGlH?=
 =?utf-8?B?d1hFZU8wWlhFaUFLL2p3MTJKZG5wKzg4LzVIanJRbzBtbTVEVllJdldpSGQ0?=
 =?utf-8?B?ZEJWM3Fjdk5kdmhlR2M1eU9rYkF6OXYyTHB5bUtkc2QyN3UzcXRJeTlIZDlT?=
 =?utf-8?B?Rko3akhPNEpmQlRuVzlVeWN6WVlPMlVOdVdnTmdyTnBpUTRHZzdBWG9oK3Fs?=
 =?utf-8?B?bWUvLzhSVi9LMGlQSmdwcjVUQXZGeW5WWU1OYit3eUFCZHRpMHZyUnNKM01z?=
 =?utf-8?B?MVZRU0dvczVVVlBDVnRIR2NiUzZuVWN1VXVSNDNQR3VxSEh3SHByMDUwcy9q?=
 =?utf-8?B?ZWg0dllWRGVwajIxbng5aGp1akVUaWp6ZTVsVjNYNkJXY2tGdE8yYTBYSEtY?=
 =?utf-8?B?dk50TVJLLzBxU2JTTUpraGZrdXl1bjVvZ0JFaC9PRlI2T0VVVk4yZStOWkNz?=
 =?utf-8?B?NHNQdWgyTGF4NnVmRDZvN3ZieWZUUUI1WFlpSUxPd1lab1FNZzdhNmNHaXJU?=
 =?utf-8?B?dW90MmlXdGtSdXRjNW1KeUU5MlY5b1IzYkJKeGZBRXZkS0h1bzB4N1pXa0ti?=
 =?utf-8?B?eHREUERXNWJQSlo4ZHpmaHE5UnZmTjlOU2tOSTY2REE0L0Rmc1dLNjcrMWpl?=
 =?utf-8?B?U1pjcEJ2SHJNYlhVM0p3azZ1eklmQmVRd2txOG5yWmpXU0NLalNlcTBOVGNQ?=
 =?utf-8?B?V0NqTmtnd3VKNVlCak52anNzZUc0Z1ZjZWVNb0VLZ2xPc3o5dU4wZUtyblRl?=
 =?utf-8?B?ODMrUjZ1QTF5OFU1UDR4SGpEM2VBY0hrQlZLVHY5bzJHbkZoWVl3YWNhaTVN?=
 =?utf-8?B?NmVqcWNmZ294Nm1XSm9xMWdJcThDUzJXQU9COE5mUmVPR0xLQ25vOENwV0dx?=
 =?utf-8?B?UlNKaTQzOGpPcTBLV2YwU1hWbnh2Q1JMK3pxVHRoME00NU8rNllUSllheGlm?=
 =?utf-8?B?TjQvM29HYUkyUzVHVDc2WlNQYmVDaEVYdkVSbDlkV29ST1lBb1JTS2JrZlBa?=
 =?utf-8?B?OVBXVFE3bVY5Q2RoM3hwM1Zud29veTVqQzRKSjY0V2xGRTNqd3ZsOFRSamhK?=
 =?utf-8?B?TkFWSXpmZHZPeVp5YVRaVlhMZXhIL1JwL1ZxL2FMZ0dVdEQ1YWN2ZEl1QmE3?=
 =?utf-8?B?ZGFVY2F5bkJBZUVKblRkTmtRd1FqQjVPbjhwT2pDSVRFREpZeEZHSUtJdGQy?=
 =?utf-8?Q?ypu8Nv3yRas5gTdb0F2e5HE9E?=
X-MS-Exchange-CrossTenant-Network-Message-Id: a4449e40-e3a4-4dbb-a319-08dd7addd321
X-MS-Exchange-CrossTenant-AuthSource: MW4PR11MB6739.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 13 Apr 2025 22:52:10.7614
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: qYTw3yC1BBPZV9xkSDLOy1gc62cTbg0L5P/i9KJA+gQn7KVhGaW6Au9Cud8zJQSwsqkRKl0m61LU+um7OauvJg==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: PH7PR11MB7003
X-OriginatorOrg: intel.com
Status: O
Content-Length: 3379
Lines: 116

CXL rev 3.1 section 8.2.9.2.1 adds the Dynamic Capacity Event Records.
User space can use trace events for debugging of DC capacity changes.

Add DC trace points to the trace log.

Based on an original patch by Navneet Singh.

Reviewed-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
Reviewed-by: Dave Jiang <dave.jiang@intel.com>
Reviewed-by: Fan Ni <fan.ni@samsung.com>
Signed-off-by: Ira Weiny <ira.weiny@intel.com>

---
Changes:
[djbw: s/region/partition/]
[iweiny: s/tag/uuid/]
---
 drivers/cxl/core/mbox.c  |  4 +++
 drivers/cxl/core/trace.h | 65 ++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 69 insertions(+)

diff --git a/drivers/cxl/core/mbox.c b/drivers/cxl/core/mbox.c
index 8af3a4173b99..891a213ce7be 100644
--- a/drivers/cxl/core/mbox.c
+++ b/drivers/cxl/core/mbox.c
@@ -1043,6 +1043,10 @@ static void __cxl_event_trace_record(const struct cxl_memdev *cxlmd,
 		ev_type = CXL_CPER_EVENT_DRAM;
 	else if (uuid_equal(uuid, &CXL_EVENT_MEM_MODULE_UUID))
 		ev_type = CXL_CPER_EVENT_MEM_MODULE;
+	else if (uuid_equal(uuid, &CXL_EVENT_DC_EVENT_UUID)) {
+		trace_cxl_dynamic_capacity(cxlmd, type, &record->event.dcd);
+		return;
+	}
 
 	cxl_event_trace_record(cxlmd, type, ev_type, uuid, &record->event);
 }
diff --git a/drivers/cxl/core/trace.h b/drivers/cxl/core/trace.h
index 25ebfbc1616c..384017259970 100644
--- a/drivers/cxl/core/trace.h
+++ b/drivers/cxl/core/trace.h
@@ -978,6 +978,71 @@ TRACE_EVENT(cxl_poison,
 	)
 );
 
+/*
+ * Dynamic Capacity Event Record - DER
+ *
+ * CXL rev 3.1 section 8.2.9.2.1.6 Table 8-50
+ */
+
+#define CXL_DC_ADD_CAPACITY			0x00
+#define CXL_DC_REL_CAPACITY			0x01
+#define CXL_DC_FORCED_REL_CAPACITY		0x02
+#define CXL_DC_REG_CONF_UPDATED			0x03
+#define show_dc_evt_type(type)	__print_symbolic(type,		\
+	{ CXL_DC_ADD_CAPACITY,	"Add capacity"},		\
+	{ CXL_DC_REL_CAPACITY,	"Release capacity"},		\
+	{ CXL_DC_FORCED_REL_CAPACITY,	"Forced capacity release"},	\
+	{ CXL_DC_REG_CONF_UPDATED,	"Region Configuration Updated"	} \
+)
+
+TRACE_EVENT(cxl_dynamic_capacity,
+
+	TP_PROTO(const struct cxl_memdev *cxlmd, enum cxl_event_log_type log,
+		 struct cxl_event_dcd *rec),
+
+	TP_ARGS(cxlmd, log, rec),
+
+	TP_STRUCT__entry(
+		CXL_EVT_TP_entry
+
+		/* Dynamic capacity Event */
+		__field(u8, event_type)
+		__field(u16, hostid)
+		__field(u8, partition_id)
+		__field(u64, dpa_start)
+		__field(u64, length)
+		__array(u8, uuid, UUID_SIZE)
+		__field(u16, sh_extent_seq)
+	),
+
+	TP_fast_assign(
+		CXL_EVT_TP_fast_assign(cxlmd, log, rec->hdr);
+
+		/* Dynamic_capacity Event */
+		__entry->event_type = rec->event_type;
+
+		/* DCD event record data */
+		__entry->hostid = le16_to_cpu(rec->host_id);
+		__entry->partition_id = rec->partition_index;
+		__entry->dpa_start = le64_to_cpu(rec->extent.start_dpa);
+		__entry->length = le64_to_cpu(rec->extent.length);
+		memcpy(__entry->uuid, &rec->extent.uuid, UUID_SIZE);
+		__entry->sh_extent_seq = le16_to_cpu(rec->extent.shared_extn_seq);
+	),
+
+	CXL_EVT_TP_printk("event_type='%s' host_id='%d' partition_id='%d' " \
+		"starting_dpa=%llx length=%llx tag=%pU " \
+		"shared_extent_sequence=%d",
+		show_dc_evt_type(__entry->event_type),
+		__entry->hostid,
+		__entry->partition_id,
+		__entry->dpa_start,
+		__entry->length,
+		__entry->uuid,
+		__entry->sh_extent_seq
+	)
+);
+
 #endif /* _CXL_EVENTS_H */
 
 #define TRACE_INCLUDE_FILE trace

-- 
2.49.0


From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from mgamail.intel.com (mgamail.intel.com [192.198.163.7])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id EC9F41A5B85
	for <nvdimm@lists.linux.dev>; Sun, 13 Apr 2025 22:52:21 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=fail smtp.client-ip=192.198.163.7
ARC-Seal: i=2; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1744584746; cv=fail; b=Y0m9jXLLXKZJ1yb30AtZf+3+Ln+Roz2bNhs0+hQN3PddUaO+VjgsgXMOVlQgJZW3+rYZ9V1CUBXV406rNvLl/wFWDXhYcl8ObhM5ndG4tPdPFGmae78c/khWd8G/+ecxuS9AKU3DzJ4AQYzQxbyRDZ3oxm4maTraIQxAk2KuG3c=
ARC-Message-Signature: i=2; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1744584746; c=relaxed/simple;
	bh=YpHLE0FN1k1Z9JdxdTPtJN/f7uJ44Q/rHM2lVf7j/Bk=;
	h=From:Date:Subject:Content-Type:Message-ID:References:In-Reply-To:
	 To:CC:MIME-Version; b=BtJcbrWR6IC5YMCh3kyK+yLCDmiqTHPLprqiC/0TLcGJw301N8oA4CNwuCKf3jgKkiJTlqdiw8jAyB9HKYVK1e68IPBVyyrXNn0u5PoHq/Y8UMsC262BHvLccUIydEdf4mYsBuCkyC7mzDEQZSH7EafTU7k+cErcQ3NV7GW93d0=
ARC-Authentication-Results: i=2; smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=intel.com; spf=pass smtp.mailfrom=intel.com; dkim=pass (2048-bit key) header.d=intel.com header.i=@intel.com header.b=BNqZYJmd; arc=fail smtp.client-ip=192.198.163.7
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=intel.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=intel.com
Authentication-Results: smtp.subspace.kernel.org;
	dkim=pass (2048-bit key) header.d=intel.com header.i=@intel.com header.b="BNqZYJmd"
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1744584742; x=1776120742;
  h=from:date:subject:content-transfer-encoding:message-id:
   references:in-reply-to:to:cc:mime-version;
  bh=YpHLE0FN1k1Z9JdxdTPtJN/f7uJ44Q/rHM2lVf7j/Bk=;
  b=BNqZYJmdjlvw5ecBlC1WTEwYdcajNJ+QcAmODnmyWzUbY3BY0lKg95iu
   G4cm4ECtyOq1EHgJoUXsR0F9gRiLraUzkNA2Yy2CLlq7BYZqOJyqBe/ne
   os0rok+nWwvD/w0+m7Bj8Qat/a2YykBsozfad9zQh2ZV8nKJPI0D0Wc+F
   WjepRp7HYrW05MNf6dDPtSWDRz7CYLrSrJfosgOECtRted9uPhufUp3iS
   8ibFFJhmCTCqDLXyqZJZQ9cp7VkpvY4Vto79NX182nT5By/AhnX/bL8WE
   L+qjclej/+ElkhUxmGZpNCvgqBdTIla1u6+DEOODSCy5zeFg62RWh1P53
   Q==;
X-CSE-ConnectionGUID: 9md0sIugRw2S/KUQc6V/Vw==
X-CSE-MsgGUID: MiBhGGpjSuurbUuS1sYPcQ==
X-IronPort-AV: E=McAfee;i="6700,10204,11402"; a="71431133"
X-IronPort-AV: E=Sophos;i="6.15,211,1739865600"; 
   d="scan'208";a="71431133"
Received: from fmviesa005.fm.intel.com ([10.60.135.145])
  by fmvoesa101.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 13 Apr 2025 15:52:20 -0700
X-CSE-ConnectionGUID: 0odosYkAQUWvdJfiPQxaXw==
X-CSE-MsgGUID: 8gWCtrdFSfeXaAD5DVL8qg==
X-ExtLoop1: 1
X-IronPort-AV: E=Sophos;i="6.15,211,1739865600"; 
   d="scan'208";a="134405569"
Received: from orsmsx901.amr.corp.intel.com ([10.22.229.23])
  by fmviesa005.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 13 Apr 2025 15:52:20 -0700
Received: from ORSMSX901.amr.corp.intel.com (10.22.229.23) by
 ORSMSX901.amr.corp.intel.com (10.22.229.23) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.2.1544.14; Sun, 13 Apr 2025 15:52:19 -0700
Received: from ORSEDG602.ED.cps.intel.com (10.7.248.7) by
 ORSMSX901.amr.corp.intel.com (10.22.229.23) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.2.1544.14 via Frontend Transport; Sun, 13 Apr 2025 15:52:19 -0700
Received: from NAM10-MW2-obe.outbound.protection.outlook.com (104.47.55.43) by
 edgegateway.intel.com (134.134.137.103) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.44; Sun, 13 Apr 2025 15:52:19 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector10001; d=microsoft.com; cv=none;
 b=RzEm3Y/tjECJNYGRzuB/WlY6ju5pz21KTxFYaULBhqPqwiTMprdNLsAyN5pwkYcHR1fkHA8MZLOpwb6bGaqr6EGWUlvlQHeoFs7icvCaPBEbCLtMrGySv5h1nWErLAR5Luky67LKunDIVp10P0wuo75hNXvNX77COuh/5mG7MAM9VC2CAHB6UVwBuDmC7bzvYqfluf4pH4n/CRkYFOQjstgpJ/JQmLQaNvjC6cVdu/AcfAH2GVs+0P/sqP2HfJVHumccwRFsGoIoyYiOlN9vqCm2IdB3QcHol+6IT1GVV84R6aGFrLr/y1dQeKduOyxWHmF4e/Vgf1Le/GxoU9YHjA==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector10001;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=XRcH1hlq1+QlfAeeyAqjDhwx1fs/vkBOfIBaucUZuys=;
 b=ERFaKyw3KZbxg9zCW2JA5haoUWJGfhBTpeJhNewvY3D6glrQAc2Y2G6IpwbVufPIgVZQ0tXrBUjkE9in3Ygg7Y4uZ6RYKc5CRIak4hc/SqpsnutMXKgJybeOEbJsdjIF4Ec6OKkmk41dwv0ac0GdQypsOX1XT0/mLjiD/MLKEfrnWfHLfv/+xtz4wwP3pB0AHZ/E2Brd/lYO13VarcbJaAj0rglEhVt0wa7DQve+9rLDsdnyN7f9xgSMF3SFF9e4g2SMHeyu+LEtKp0KGvkAWRZrMYIsWgfuK+XaMoUNuEyPjlMP2TUWxAg/Uc2HUSVFIZXqbK//L3SWJBxUd+sZfg==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from MW4PR11MB6739.namprd11.prod.outlook.com (2603:10b6:303:20b::19)
 by PH7PR11MB7003.namprd11.prod.outlook.com (2603:10b6:510:20a::16) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.8632.33; Sun, 13 Apr
 2025 22:52:07 +0000
Received: from MW4PR11MB6739.namprd11.prod.outlook.com
 ([fe80::a7ad:a6e8:fced:3f24]) by MW4PR11MB6739.namprd11.prod.outlook.com
 ([fe80::a7ad:a6e8:fced:3f24%4]) with mapi id 15.20.8606.033; Sun, 13 Apr 2025
 22:52:07 +0000
From: Ira Weiny <ira.weiny@intel.com>
Date: Sun, 13 Apr 2025 17:52:23 -0500
Subject: [PATCH v9 15/19] dax/region: Create resources on sparse DAX
 regions
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: 7bit
Message-ID: <20250413-dcd-type2-upstream-v9-15-1d4911a0b365@intel.com>
References: <20250413-dcd-type2-upstream-v9-0-1d4911a0b365@intel.com>
In-Reply-To: <20250413-dcd-type2-upstream-v9-0-1d4911a0b365@intel.com>
To: Dave Jiang <dave.jiang@intel.com>, Fan Ni <fan.ni@samsung.com>, "Jonathan
 Cameron" <Jonathan.Cameron@huawei.com>
CC: Dan Williams <dan.j.williams@intel.com>, Davidlohr Bueso
	<dave@stgolabs.net>, Alison Schofield <alison.schofield@intel.com>, "Vishal
 Verma" <vishal.l.verma@intel.com>, Ira Weiny <ira.weiny@intel.com>,
	<linux-cxl@vger.kernel.org>, <nvdimm@lists.linux.dev>,
	<linux-kernel@vger.kernel.org>
X-Mailer: b4 0.15-dev-c25d1
X-Developer-Signature: v=1; a=ed25519-sha256; t=1744584735; l=29379;
 i=ira.weiny@intel.com; s=20221211; h=from:subject:message-id;
 bh=YpHLE0FN1k1Z9JdxdTPtJN/f7uJ44Q/rHM2lVf7j/Bk=;
 b=k/yUghpVT/FSxdfIS8LZxy+Q5S8lQQ082S2i3PUvR6yby79FqvoYhhODCbL31YpqeR6F69P/p
 NJN/Ic5/jt0ALFQ4H47FCt2mVOx/NmEAkUEbv9CYTD4eTn5Fhv90oMa
X-Developer-Key: i=ira.weiny@intel.com; a=ed25519;
 pk=noldbkG+Wp1qXRrrkfY1QJpDf7QsOEthbOT7vm0PqsE=
X-ClientProxiedBy: MW4PR03CA0227.namprd03.prod.outlook.com
 (2603:10b6:303:b9::22) To MW4PR11MB6739.namprd11.prod.outlook.com
 (2603:10b6:303:20b::19)
Precedence: bulk
X-Mailing-List: nvdimm@lists.linux.dev
List-Id: <nvdimm.lists.linux.dev>
List-Subscribe: <mailto:nvdimm+subscribe@lists.linux.dev>
List-Unsubscribe: <mailto:nvdimm+unsubscribe@lists.linux.dev>
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: MW4PR11MB6739:EE_|PH7PR11MB7003:EE_
X-MS-Office365-Filtering-Correlation-Id: 03dc5a8a-60d2-456a-fd17-08dd7addd11d
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;ARA:13230040|366016|376014|1800799024;
X-Microsoft-Antispam-Message-Info: =?utf-8?B?SlI4RWNvVDdrWU1WZGxGeHR3bXdEV1pqaVpxS2ZpQmx5U3cxVytxcHR2S2VP?=
 =?utf-8?B?d0E5YU85NVVNMmRrS0JZeHlCakxHSkdKcG1lYWlUU1A1Wlg3YWlSazNRVGRM?=
 =?utf-8?B?dlpPTEZBRzBSZVZlYzVUdDc1SGM4eWh6YnZKY0gvYjhNVktteGFDUTR2cnJU?=
 =?utf-8?B?dnExV3FiMU9oaW1LVDJJWU9Ia3lxM3VmWXQ3Wkx4c0xyWG1iN29lSkdmaUly?=
 =?utf-8?B?U2dWNGF2UXNhKzJSdEw5Q25pNnlJRGZ6TnNuNG9kNWU5QjZLVU9qOXRGdjRu?=
 =?utf-8?B?OXVwaVptcWphSnU4d0owTTcxczE0WlJoTys3WlhhZmFvRkxYVEVNZDlVdzNs?=
 =?utf-8?B?R3RxMkF2UWFyYWdmcGJuZnlDUURJSXRIa3RvdVlHK1I4KzgwSDJhelRxWUEr?=
 =?utf-8?B?czRFSExJV21YUzdmVUNCZDBBaTk0OGJGeS84S1czaVhPcWcyWTh6aXY3NHd1?=
 =?utf-8?B?Y1ZrL1B3MzRmbXBDdEd4bElYYnJqNVNEN0xhUUI1Z1pkTU4vd29EdHZXRStL?=
 =?utf-8?B?U3l6MTZVMVJFcExoRkhPQi9iZ1JzamlkbnZPNVBvRWRvRVZ2V2xzempQbkRO?=
 =?utf-8?B?ZjNNTkZGdXZ5WlhaREk2Z3BVb0o4Qy9pUGx3VE9mK3NiSWIwNTErYU1JbW1o?=
 =?utf-8?B?VVBuMmlIQWtaenhPTHlsSTNHTWRiYXdXZDFZS0NiR2lKUVNEOG9QMDZtYW9C?=
 =?utf-8?B?QkxPSlh2Sk5JVlltWXAvRUhReGJWV0RUMkJhbEhxL2xWY0JDcnNRZEhKNHlw?=
 =?utf-8?B?ckNPdU5neXM5cFFZQ3NNbytPM1pORDNhWEJjVU1vZWtaVnEycGhZdkM3a1FC?=
 =?utf-8?B?alFVbjhGWnRYZW0rYmRoNVdkQzEzZ0QvblRBWjJXelFNd2Y5WjJiRFMweGov?=
 =?utf-8?B?R0xqY21PUHE5ZFp3V0J4QXRqTFhvMGtXR2FrNkJGWVpIOHA5MHBmaXErYW1m?=
 =?utf-8?B?YzBkQ1hNYkJEWndNWmpTb1BFQ25na2xUZXRoNVJkRW1Td202QVZtRTQ3cFE4?=
 =?utf-8?B?RnB5TnNtRW8yUy95NlFhM05DTmR6ZEx2KzJlU0FwVjNGeFlwZFlPbmc3Vm1X?=
 =?utf-8?B?ejVUNkZEWnhGcGc3S3lMdG9tM1RLUjdWRWVjNjMwRThtR1dReWRkMm8vMHdT?=
 =?utf-8?B?YVZaUXpNQm9TYWU4S0NDNk00RkxPeVR5djIxZ2tqSE1ZQmJvSVcwVllDWEVs?=
 =?utf-8?B?b2kxQ0VtWU5LVTlWeGdRdmI3ejlwVEVNOGlFb2huelV5blJjSEhsZmIzdTRq?=
 =?utf-8?B?UW5uVWpvVzhlWUJJRHZkZUdpZzVkUXlJRW1POExySHNIVStFS2pQOUdCanU5?=
 =?utf-8?B?MzNYQ1NRa3p5SEZYQjlkUWVrZTRoK0tkQjJDSVBnZ0NrcDFjZU55UmJVeWkz?=
 =?utf-8?B?VmtBenFoWWpsRmsxRkMydU9DdHJCU1lEUGdZVGpOaFZsMnVMbmZxZ0haVXR4?=
 =?utf-8?B?MU9YUTJuSUNyY0g4akl0dnh1SWdnY3huQzM3dGdKN0orN2hDRUlmVXo5L0w0?=
 =?utf-8?B?ZlRDRmpzMXRpd3lzQThhQnlQR3Nmc25GbHNCeFpqbFU1cnR2WmFOZTVaQUpl?=
 =?utf-8?B?dDRCSW9sT08yZi8vNFRGb3QxTzFaeVhEenEzMjB0SFpSbVZXRXdiNGNXZUxZ?=
 =?utf-8?B?bDlJMmpxaXdia1lGc1VoZDV0Y0JOK0hENTBnMy9qL0xCZmJxSm9hbDhteCty?=
 =?utf-8?B?anF5Q2YzcTlHRk11LythdEVRczdVYmwvbjEvUmc1MTkzdW5oaTJTRkorMHVx?=
 =?utf-8?B?dEVmVWlQZzcxakgrQXRCcFNBZk93OTZMVEtCTnA4akRpR0JycWp3WlEwZ0Z4?=
 =?utf-8?B?S2t2SElMY1FIdytydExHK29hMGg2dDdoWW1xUG0xOWpnUUFEMGprS3BzMGJI?=
 =?utf-8?B?dU1rcFpWTnVudU1sWEZ3QTJWVkpqWDdDMzBiSVpDSlJtREZnMGs1eXBDR2ds?=
 =?utf-8?Q?SNBqtwnfZWA=3D?=
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:MW4PR11MB6739.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230040)(366016)(376014)(1800799024);DIR:OUT;SFP:1101;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?utf-8?B?dWZkV0N6WEZMREJsejZKUWtPUHpzWmhQNWlUajNBMFRRNkJ0VmJzY2tHcHEv?=
 =?utf-8?B?QlhZVDh6eTZkSFkvdWNLUFpHWGhqOHJ2bHpQZWtyVEZlZTF5NDNrTHdaWG9E?=
 =?utf-8?B?dGlqVjhnSFl1eWk2aFFrY2hpSDhzOHp2aGlvMzI5b0xtVVRlSkNDL0ZjWXNU?=
 =?utf-8?B?Q2xmNm5XNGN4NGZUZWlib1dHOEFrMWZUaTErcW5QRTVLaEloOXMvb2NIdGR3?=
 =?utf-8?B?SkVYanNUNlR1VEJBUnBJWTBJekdxYm5nVmNIWEppQklqZDVhSEFtNnBJL3Z3?=
 =?utf-8?B?VGhZRFVvT3dFMDRJams2dFYxS2hVcWRDMXBrTG1Lbzd1UE9jaXNtZW1sL1lz?=
 =?utf-8?B?cVFDOUt5THc3VVcxYXlzSW0wZStQa2JVcGl6R21FNCtWNHViNXNuU3dIclFm?=
 =?utf-8?B?cmFUbHZSZUpSSWU5RHdQVmVTZTEzMnBoWEpEQlIvTk5yUE1FVWRQTGFITks5?=
 =?utf-8?B?V3hLZ2FaaDZrWmJQWGVveGZpZjNzU2Jaa2JBNXFCM0JPL2VWWE9Qb3NmNUlU?=
 =?utf-8?B?ckZDR0hjbDBiNVIyT28xUCs5b1FqS0tJM212dlFZbFdxZmxEMlFWMmEwZm12?=
 =?utf-8?B?eFRNMFByYTU3YnpjT1BuUVExOGRxUWx1NkZ1Y2d6c1ozWExmcy9KYWlEL04w?=
 =?utf-8?B?YXhDUERiYzRpUXYycnJGeFpyMmY1SzJRTTdvWldOeFNtaEswVU53YWNDRnhM?=
 =?utf-8?B?Q1V3Y0FURXM4TU9aL0tzTUhsZENJQnc3VXVybk03VTBMd2N4RGwzOFN3dXdS?=
 =?utf-8?B?UE1sUDQzejMyVE81enBIS3N2SnZQaTQwZW5PUHJiWCsvSmtKSUZ2Nk1XK1Ir?=
 =?utf-8?B?RUNJSFYwRWtJWGNTd0tscjgydW1jZWVmWGxwdnYxa1hIOVNuWk1rWnNMdisr?=
 =?utf-8?B?MU5Rd1BqbTFOQWs1UGFCL1M4V01mdThTYTJRdkN1bUtIVThvQUQwUEF5bFgz?=
 =?utf-8?B?Ri9pN3FqZWNhMnU3TVd0amJ3VzhoODRnejFYejZlaVNhZVZmSHdlTUpLRHBj?=
 =?utf-8?B?bGdPQnlLd3BheTQ5M0I5OVQ4ejlyUVM2TWZkRThQK3hqM0lKS244S3I5ZE1a?=
 =?utf-8?B?M3dGSFQ3a0hlem84aFZodmU4NjMrRlpReHZzU0Zmdjc5TlNvWXVpaU55UTJU?=
 =?utf-8?B?SWpnam9yeXlSUFZycjFLYlJVdEpoWDZ0S283VmZwODhDdW9TaklBRDlSVHZk?=
 =?utf-8?B?a2NyWUs1NjI0ZWNvSnc5aWpSRDBDTjcvYkJJQk1XT3VqYm5LWHR3c1hXM1lK?=
 =?utf-8?B?aDVSR0tuTkVqRUlUY1M0bEJTQm0rSGNLMkdTS1UxWFhqRjRyN29ycHNLNG8r?=
 =?utf-8?B?dXJucEc0Rzh4bFlMNXlzcEFwV2hjOHhsSTkvdG1oWDdHZXJ4WEpIdEdjVE5K?=
 =?utf-8?B?ME9jT1A1TVljcW4vY2tETEZaMWhzbmpZRkttaVd1ckRpb1phZEc2S0Q0aElO?=
 =?utf-8?B?RFNTQ0U5ZlNKa2xlUGtzTk9PaGRnUkFFNkZZVGQ1eEpSMDN3amRURmZhQm4r?=
 =?utf-8?B?NEc3c0xYeEdOL1hxZHlISDBYak5nQlFNOXBpaU9BaWs3TDYydFh6NDBVbGJt?=
 =?utf-8?B?SGFwNHp6OUYxSXJZR080VEFZQ3ZtK0FqWHp5WC94OFJRbHVhNm4vd2RMWDRl?=
 =?utf-8?B?Tmc0VjVWemQxQmtmYlpROU9CWDFPaGlHQndRbmdOTmJwWG93UHkxSlVXdGlQ?=
 =?utf-8?B?WCtGdUpabUcxTWlPdm5PQVRaMjA4NEFzS2NwVGFkK2N4TlVreE9sNTBhUGwr?=
 =?utf-8?B?T1dOaVBCNWFNNVpwV0VlNXFWSzB3TmViam5GTk9xdHRjYzI3RXRsUERBcWVm?=
 =?utf-8?B?dzdBMkVxZTlwWnVLWk1lYVc5VjNsTHNNRkhLYXV5R1pvV0E4NTNjbmZRWCti?=
 =?utf-8?B?ak5WeGNFU1VjL3p3QVlMYTVyeERhbHhRNzNxQ2wxZGlhTERUWWRlZlBjMFdw?=
 =?utf-8?B?aXp0ZHdCUkxGT2FBQzhJUlc1T1ZrdXRhR1VyaGV3VUI3KzFIUFk0VTZDU2wr?=
 =?utf-8?B?VFMyczg4SGp5N1VzckNnOVd6UUVLYmRJS0pjWGpubE1xbENQQmxWOW16WGtQ?=
 =?utf-8?B?OGVjZzh5OS9FekNUNDV4R2hManM3bS9lSUFiTjM3YzFYcUR6MDM4UEVQVW1F?=
 =?utf-8?Q?FZVkZ5jUZjrG/VGRaA7eD1sbU?=
X-MS-Exchange-CrossTenant-Network-Message-Id: 03dc5a8a-60d2-456a-fd17-08dd7addd11d
X-MS-Exchange-CrossTenant-AuthSource: MW4PR11MB6739.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 13 Apr 2025 22:52:07.5027
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: xJzjVKews76ExOKtU9a0AfPekF38jO09MaY+ooT8PYsbYmqWvjWPYRvIqdMvoEeam3wLPonrY22my9e3MHeXxA==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: PH7PR11MB7003
X-OriginatorOrg: intel.com
Status: O
Content-Length: 28492
Lines: 889

DAX regions which map dynamic capacity partitions require that memory be
allowed to come and go.  Recall sparse regions were created for this
purpose.  Now that extents can be realized within DAX regions the DAX
region driver can start tracking sub-resource information.

The tight relationship between DAX region operations and extent
operations require memory changes to be controlled synchronously with
the user of the region.  Synchronize through the dax_region_rwsem and by
having the region driver drive both the region device as well as the
extent sub-devices.

Recall requests to remove extents can happen at any time and that a host
is not obligated to release the memory until it is not being used.  If
an extent is not used allow a release response.

When extents are eligible for release.  No mappings exist but data may
reside in caches not yet written to the device.  Call
cxl_region_invalidate_memregion() to write back data to the device prior
to signaling the release complete.

Speculative writes after a release may dirty the cache such that a read
from a newly surfaced extent may not come from the device.  Call
cxl_region_invalidate_memregion() prior to bringing a new extent online
to ensure the cache is marked invalid.

While these invalidate calls are inefficient they are the best we can do
to ensure cache consistency without back invalidate.  Furthermore this
should occur infrequently with sufficiently large extents that real work
loads should not be impacted much.

The DAX layer has no need for the details of the CXL memory extent
devices.  Expose extents to the DAX layer as device children of the DAX
region device.  A single callback from the driver aids the DAX layer to
determine if the child device is an extent.  The DAX layer also
registers a devres function to automatically clean up when the device is
removed from the region.

There is a race between extents being surfaced and the dax_cxl driver
being loaded.  Synchronizes the driver during probe by scanning for
existing extents while under the device lock.

Respond to extent notifications.  Manage the DAX region resource tree
based on the extents lifetime.  Return the status of remove
notifications to lower layers such that it can manage the hardware
appropriately.

Based on an original patch by Navneet Singh.

Reviewed-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
Signed-off-by: Ira Weiny <ira.weiny@intel.com>

---
Changes:
[iweiny: convert range prints to %pra]
---
 drivers/cxl/core/core.h   |   2 +
 drivers/cxl/core/extent.c |  83 ++++++++++++++--
 drivers/cxl/core/region.c |   2 +-
 drivers/cxl/cxl.h         |   6 ++
 drivers/dax/bus.c         | 246 +++++++++++++++++++++++++++++++++++++++++-----
 drivers/dax/bus.h         |   3 +-
 drivers/dax/cxl.c         |  61 +++++++++++-
 drivers/dax/dax-private.h |  40 ++++++++
 drivers/dax/hmem/hmem.c   |   2 +-
 drivers/dax/pmem.c        |   2 +-
 include/linux/ioport.h    |   3 +
 11 files changed, 411 insertions(+), 39 deletions(-)

diff --git a/drivers/cxl/core/core.h b/drivers/cxl/core/core.h
index 1272be497926..027dd1504d77 100644
--- a/drivers/cxl/core/core.h
+++ b/drivers/cxl/core/core.h
@@ -22,6 +22,8 @@ cxled_to_mds(struct cxl_endpoint_decoder *cxled)
 	return container_of(cxlds, struct cxl_memdev_state, cxlds);
 }
 
+int cxl_region_invalidate_memregion(struct cxl_region *cxlr);
+
 #ifdef CONFIG_CXL_REGION
 extern struct device_attribute dev_attr_create_pmem_region;
 extern struct device_attribute dev_attr_create_ram_region;
diff --git a/drivers/cxl/core/extent.c b/drivers/cxl/core/extent.c
index 3fb20cd7afc8..4dc0dec486f6 100644
--- a/drivers/cxl/core/extent.c
+++ b/drivers/cxl/core/extent.c
@@ -116,6 +116,12 @@ static void region_extent_unregister(void *ext)
 
 	dev_dbg(&region_extent->dev, "DAX region rm extent HPA %pra\n",
 		&region_extent->hpa_range);
+	/*
+	 * Extent is not in use or an error has occur.  No mappings
+	 * exist at this point.  Write and invalidate caches to ensure
+	 * the device has all data prior to final release.
+	 */
+	cxl_region_invalidate_memregion(region_extent->cxlr_dax->cxlr);
 	device_unregister(&region_extent->dev);
 }
 
@@ -269,20 +275,65 @@ static void calc_hpa_range(struct cxl_endpoint_decoder *cxled,
 	hpa_range->end = hpa_range->start + range_len(dpa_range) - 1;
 }
 
+static int cxlr_notify_extent(struct cxl_region *cxlr, enum dc_event event,
+			      struct region_extent *region_extent)
+{
+	struct device *dev = &cxlr->cxlr_dax->dev;
+	struct cxl_notify_data notify_data;
+	struct cxl_driver *driver;
+
+	dev_dbg(dev, "Trying notify: type %d HPA %pra\n", event,
+		&region_extent->hpa_range);
+
+	guard(device)(dev);
+
+	/*
+	 * The lack of a driver indicates a notification has failed.  No user
+	 * space coordination was possible.
+	 */
+	if (!dev->driver)
+		return 0;
+	driver = to_cxl_drv(dev->driver);
+	if (!driver->notify)
+		return 0;
+
+	notify_data = (struct cxl_notify_data) {
+		.event = event,
+		.region_extent = region_extent,
+	};
+
+	dev_dbg(dev, "Notify: type %d HPA %pra\n", event,
+		&region_extent->hpa_range);
+	return driver->notify(dev, &notify_data);
+}
+
+struct rm_data {
+	struct cxl_region *cxlr;
+	struct range *range;
+};
+
 static int cxlr_rm_extent(struct device *dev, void *data)
 {
 	struct region_extent *region_extent = to_region_extent(dev);
-	struct range *region_hpa_range = data;
+	struct rm_data *rm_data = data;
+	int rc;
 
 	if (!region_extent)
 		return 0;
 
 	/*
-	 * Any extent which 'touches' the released range is removed.
+	 * Any extent which 'touches' the released range is attempted to be
+	 * removed.
 	 */
-	if (range_overlaps(region_hpa_range, &region_extent->hpa_range)) {
+	if (range_overlaps(rm_data->range, &region_extent->hpa_range)) {
+		struct cxl_region *cxlr = rm_data->cxlr;
+
 		dev_dbg(dev, "Remove region extent HPA %pra\n",
 			&region_extent->hpa_range);
+		rc = cxlr_notify_extent(cxlr, DCD_RELEASE_CAPACITY, region_extent);
+		if (rc == -EBUSY)
+			return 0;
+
 		region_rm_extent(region_extent);
 	}
 	return 0;
@@ -327,8 +378,13 @@ int cxl_rm_extent(struct cxl_memdev_state *mds, struct cxl_extent *extent)
 
 	calc_hpa_range(cxled, cxlr->cxlr_dax, &dpa_range, &hpa_range);
 
+	struct rm_data rm_data = {
+		.cxlr = cxlr,
+		.range = &hpa_range,
+	};
+
 	/* Remove region extents which overlap */
-	return device_for_each_child(&cxlr->cxlr_dax->dev, &hpa_range,
+	return device_for_each_child(&cxlr->cxlr_dax->dev, &rm_data,
 				     cxlr_rm_extent);
 }
 
@@ -353,8 +409,23 @@ static int cxlr_add_extent(struct cxl_dax_region *cxlr_dax,
 		return rc;
 	}
 
-	/* device model handles freeing region_extent */
-	return online_region_extent(region_extent);
+	/* Ensure caches are clean prior onlining */
+	cxl_region_invalidate_memregion(cxlr_dax->cxlr);
+
+	rc = online_region_extent(region_extent);
+	/* device model handled freeing region_extent */
+	if (rc)
+		return rc;
+
+	rc = cxlr_notify_extent(cxlr_dax->cxlr, DCD_ADD_CAPACITY, region_extent);
+	/*
+	 * The region device was briefly live but DAX layer ensures it was not
+	 * used
+	 */
+	if (rc)
+		region_rm_extent(region_extent);
+
+	return rc;
 }
 
 /* Callers are expected to ensure cxled has been attached to a region */
diff --git a/drivers/cxl/core/region.c b/drivers/cxl/core/region.c
index 3106df6f3636..eeabc5a6b18a 100644
--- a/drivers/cxl/core/region.c
+++ b/drivers/cxl/core/region.c
@@ -223,7 +223,7 @@ static struct cxl_region_ref *cxl_rr_load(struct cxl_port *port,
 	return xa_load(&port->regions, (unsigned long)cxlr);
 }
 
-static int cxl_region_invalidate_memregion(struct cxl_region *cxlr)
+int cxl_region_invalidate_memregion(struct cxl_region *cxlr)
 {
 	if (!cpu_cache_has_invalidate_memregion()) {
 		if (IS_ENABLED(CONFIG_CXL_REGION_INVALIDATION_TEST)) {
diff --git a/drivers/cxl/cxl.h b/drivers/cxl/cxl.h
index d027432b1572..a14b33eca1d0 100644
--- a/drivers/cxl/cxl.h
+++ b/drivers/cxl/cxl.h
@@ -867,10 +867,16 @@ bool is_cxl_region(struct device *dev);
 
 extern struct bus_type cxl_bus_type;
 
+struct cxl_notify_data {
+	enum dc_event event;
+	struct region_extent *region_extent;
+};
+
 struct cxl_driver {
 	const char *name;
 	int (*probe)(struct device *dev);
 	void (*remove)(struct device *dev);
+	int (*notify)(struct device *dev, struct cxl_notify_data *notify_data);
 	struct device_driver drv;
 	int id;
 };
diff --git a/drivers/dax/bus.c b/drivers/dax/bus.c
index c25942a3d125..45573d077b5a 100644
--- a/drivers/dax/bus.c
+++ b/drivers/dax/bus.c
@@ -183,6 +183,93 @@ static bool is_sparse(struct dax_region *dax_region)
 	return (dax_region->res.flags & IORESOURCE_DAX_SPARSE_CAP) != 0;
 }
 
+static void __dax_release_resource(struct dax_resource *dax_resource)
+{
+	struct dax_region *dax_region = dax_resource->region;
+
+	lockdep_assert_held_write(&dax_region_rwsem);
+	dev_dbg(dax_region->dev, "Extent release resource %pr\n",
+		dax_resource->res);
+	if (dax_resource->res)
+		__release_region(&dax_region->res, dax_resource->res->start,
+				 resource_size(dax_resource->res));
+	dax_resource->res = NULL;
+}
+
+static void dax_release_resource(void *res)
+{
+	struct dax_resource *dax_resource = res;
+
+	guard(rwsem_write)(&dax_region_rwsem);
+	__dax_release_resource(dax_resource);
+	kfree(dax_resource);
+}
+
+int dax_region_add_resource(struct dax_region *dax_region,
+			    struct device *device,
+			    resource_size_t start, resource_size_t length)
+{
+	struct resource *new_resource;
+	int rc;
+
+	struct dax_resource *dax_resource __free(kfree) =
+				kzalloc(sizeof(*dax_resource), GFP_KERNEL);
+	if (!dax_resource)
+		return -ENOMEM;
+
+	guard(rwsem_write)(&dax_region_rwsem);
+
+	dev_dbg(dax_region->dev, "DAX region resource %pr\n", &dax_region->res);
+	new_resource = __request_region(&dax_region->res, start, length, "extent", 0);
+	if (!new_resource) {
+		dev_err(dax_region->dev, "Failed to add region s:%pa l:%pa\n",
+			&start, &length);
+		return -ENOSPC;
+	}
+
+	dev_dbg(dax_region->dev, "add resource %pr\n", new_resource);
+	dax_resource->region = dax_region;
+	dax_resource->res = new_resource;
+
+	/*
+	 * open code devm_add_action_or_reset() to avoid recursive write lock
+	 * of dax_region_rwsem in the error case.
+	 */
+	rc = devm_add_action(device, dax_release_resource, dax_resource);
+	if (rc) {
+		__dax_release_resource(dax_resource);
+		return rc;
+	}
+
+	dev_set_drvdata(device, no_free_ptr(dax_resource));
+	return 0;
+}
+EXPORT_SYMBOL_GPL(dax_region_add_resource);
+
+int dax_region_rm_resource(struct dax_region *dax_region,
+			   struct device *dev)
+{
+	struct dax_resource *dax_resource;
+
+	guard(rwsem_write)(&dax_region_rwsem);
+
+	dax_resource = dev_get_drvdata(dev);
+	if (!dax_resource)
+		return 0;
+
+	if (dax_resource->use_cnt)
+		return -EBUSY;
+
+	/*
+	 * release the resource under dax_region_rwsem to avoid races with
+	 * users trying to use the extent
+	 */
+	__dax_release_resource(dax_resource);
+	dev_set_drvdata(dev, NULL);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(dax_region_rm_resource);
+
 bool static_dev_dax(struct dev_dax *dev_dax)
 {
 	return is_static(dev_dax->region);
@@ -296,19 +383,41 @@ static ssize_t region_align_show(struct device *dev,
 static struct device_attribute dev_attr_region_align =
 		__ATTR(align, 0400, region_align_show, NULL);
 
+resource_size_t
+dax_avail_size(struct resource *dax_resource)
+{
+	resource_size_t rc;
+	struct resource *used_res;
+
+	rc = resource_size(dax_resource);
+	for_each_child_resource(dax_resource, used_res)
+		rc -= resource_size(used_res);
+	return rc;
+}
+EXPORT_SYMBOL_GPL(dax_avail_size);
+
 #define for_each_dax_region_resource(dax_region, res) \
 	for (res = (dax_region)->res.child; res; res = res->sibling)
 
 static unsigned long long dax_region_avail_size(struct dax_region *dax_region)
 {
-	resource_size_t size = resource_size(&dax_region->res);
+	resource_size_t size;
 	struct resource *res;
 
 	lockdep_assert_held(&dax_region_rwsem);
 
-	if (is_sparse(dax_region))
-		return 0;
+	if (is_sparse(dax_region)) {
+		/*
+		 * Children of a sparse region represent available space not
+		 * used space.
+		 */
+		size = 0;
+		for_each_dax_region_resource(dax_region, res)
+			size += dax_avail_size(res);
+		return size;
+	}
 
+	size = resource_size(&dax_region->res);
 	for_each_dax_region_resource(dax_region, res)
 		size -= resource_size(res);
 	return size;
@@ -449,15 +558,26 @@ EXPORT_SYMBOL_GPL(kill_dev_dax);
 static void trim_dev_dax_range(struct dev_dax *dev_dax)
 {
 	int i = dev_dax->nr_range - 1;
-	struct range *range = &dev_dax->ranges[i].range;
+	struct dev_dax_range *dev_range = &dev_dax->ranges[i];
+	struct range *range = &dev_range->range;
 	struct dax_region *dax_region = dev_dax->region;
+	struct resource *res = &dax_region->res;
 
 	lockdep_assert_held_write(&dax_region_rwsem);
 	dev_dbg(&dev_dax->dev, "delete range[%d]: %#llx:%#llx\n", i,
 		(unsigned long long)range->start,
 		(unsigned long long)range->end);
 
-	__release_region(&dax_region->res, range->start, range_len(range));
+	if (dev_range->dax_resource) {
+		res = dev_range->dax_resource->res;
+		dev_dbg(&dev_dax->dev, "Trim sparse extent %pr\n", res);
+	}
+
+	__release_region(res, range->start, range_len(range));
+
+	if (dev_range->dax_resource)
+		dev_range->dax_resource->use_cnt--;
+
 	if (--dev_dax->nr_range == 0) {
 		kfree(dev_dax->ranges);
 		dev_dax->ranges = NULL;
@@ -640,7 +760,7 @@ static void dax_region_unregister(void *region)
 
 struct dax_region *alloc_dax_region(struct device *parent, int region_id,
 		struct range *range, int target_node, unsigned int align,
-		unsigned long flags)
+		unsigned long flags, struct dax_sparse_ops *sparse_ops)
 {
 	struct dax_region *dax_region;
 
@@ -658,12 +778,16 @@ struct dax_region *alloc_dax_region(struct device *parent, int region_id,
 			|| !IS_ALIGNED(range_len(range), align))
 		return NULL;
 
+	if (!sparse_ops && (flags & IORESOURCE_DAX_SPARSE_CAP))
+		return NULL;
+
 	dax_region = kzalloc(sizeof(*dax_region), GFP_KERNEL);
 	if (!dax_region)
 		return NULL;
 
 	dev_set_drvdata(parent, dax_region);
 	kref_init(&dax_region->kref);
+	dax_region->sparse_ops = sparse_ops;
 	dax_region->id = region_id;
 	dax_region->align = align;
 	dax_region->dev = parent;
@@ -845,7 +969,8 @@ static int devm_register_dax_mapping(struct dev_dax *dev_dax, int range_id)
 }
 
 static int alloc_dev_dax_range(struct resource *parent, struct dev_dax *dev_dax,
-			       u64 start, resource_size_t size)
+			       u64 start, resource_size_t size,
+			       struct dax_resource *dax_resource)
 {
 	struct device *dev = &dev_dax->dev;
 	struct dev_dax_range *ranges;
@@ -884,6 +1009,7 @@ static int alloc_dev_dax_range(struct resource *parent, struct dev_dax *dev_dax,
 			.start = alloc->start,
 			.end = alloc->end,
 		},
+		.dax_resource = dax_resource,
 	};
 
 	dev_dbg(dev, "alloc range[%d]: %pa:%pa\n", dev_dax->nr_range - 1,
@@ -966,7 +1092,8 @@ static int dev_dax_shrink(struct dev_dax *dev_dax, resource_size_t size)
 	int i;
 
 	for (i = dev_dax->nr_range - 1; i >= 0; i--) {
-		struct range *range = &dev_dax->ranges[i].range;
+		struct dev_dax_range *dev_range = &dev_dax->ranges[i];
+		struct range *range = &dev_range->range;
 		struct dax_mapping *mapping = dev_dax->ranges[i].mapping;
 		struct resource *adjust = NULL, *res;
 		resource_size_t shrink;
@@ -982,12 +1109,21 @@ static int dev_dax_shrink(struct dev_dax *dev_dax, resource_size_t size)
 			continue;
 		}
 
-		for_each_dax_region_resource(dax_region, res)
-			if (strcmp(res->name, dev_name(dev)) == 0
-					&& res->start == range->start) {
-				adjust = res;
-				break;
-			}
+		if (dev_range->dax_resource) {
+			for_each_child_resource(dev_range->dax_resource->res, res)
+				if (strcmp(res->name, dev_name(dev)) == 0
+						&& res->start == range->start) {
+					adjust = res;
+					break;
+				}
+		} else {
+			for_each_dax_region_resource(dax_region, res)
+				if (strcmp(res->name, dev_name(dev)) == 0
+						&& res->start == range->start) {
+					adjust = res;
+					break;
+				}
+		}
 
 		if (dev_WARN_ONCE(dev, !adjust || i != dev_dax->nr_range - 1,
 					"failed to find matching resource\n"))
@@ -1025,19 +1161,21 @@ static bool adjust_ok(struct dev_dax *dev_dax, struct resource *res)
 }
 
 /**
- * dev_dax_resize_static - Expand the device into the unused portion of the
- * region. This may involve adjusting the end of an existing resource, or
- * allocating a new resource.
+ * __dev_dax_resize - Expand the device into the unused portion of the region.
+ * This may involve adjusting the end of an existing resource, or allocating a
+ * new resource.
  *
  * @parent: parent resource to allocate this range in
  * @dev_dax: DAX device to be expanded
  * @to_alloc: amount of space to alloc; must be <= space available in @parent
+ * @dax_resource: if sparse; the parent resource
  *
  * Return the amount of space allocated or -ERRNO on failure
  */
-static ssize_t dev_dax_resize_static(struct resource *parent,
-				     struct dev_dax *dev_dax,
-				     resource_size_t to_alloc)
+static ssize_t __dev_dax_resize(struct resource *parent,
+				struct dev_dax *dev_dax,
+				resource_size_t to_alloc,
+				struct dax_resource *dax_resource)
 {
 	struct resource *res, *first;
 	int rc;
@@ -1045,7 +1183,8 @@ static ssize_t dev_dax_resize_static(struct resource *parent,
 	first = parent->child;
 	if (!first) {
 		rc = alloc_dev_dax_range(parent, dev_dax,
-					   parent->start, to_alloc);
+					   parent->start, to_alloc,
+					   dax_resource);
 		if (rc)
 			return rc;
 		return to_alloc;
@@ -1059,7 +1198,8 @@ static ssize_t dev_dax_resize_static(struct resource *parent,
 		if (res == first && res->start > parent->start) {
 			alloc = min(res->start - parent->start, to_alloc);
 			rc = alloc_dev_dax_range(parent, dev_dax,
-						 parent->start, alloc);
+						 parent->start, alloc,
+						 dax_resource);
 			if (rc)
 				return rc;
 			return alloc;
@@ -1083,7 +1223,8 @@ static ssize_t dev_dax_resize_static(struct resource *parent,
 				return rc;
 			return alloc;
 		}
-		rc = alloc_dev_dax_range(parent, dev_dax, res->end + 1, alloc);
+		rc = alloc_dev_dax_range(parent, dev_dax, res->end + 1, alloc,
+					 dax_resource);
 		if (rc)
 			return rc;
 		return alloc;
@@ -1094,6 +1235,51 @@ static ssize_t dev_dax_resize_static(struct resource *parent,
 	return 0;
 }
 
+static ssize_t dev_dax_resize_static(struct dax_region *dax_region,
+				     struct dev_dax *dev_dax,
+				     resource_size_t to_alloc)
+{
+	return __dev_dax_resize(&dax_region->res, dev_dax, to_alloc, NULL);
+}
+
+static int find_free_extent(struct device *dev, const void *data)
+{
+	const struct dax_region *dax_region = data;
+	struct dax_resource *dax_resource;
+
+	if (!dax_region->sparse_ops->is_extent(dev))
+		return 0;
+
+	dax_resource = dev_get_drvdata(dev);
+	if (!dax_resource || !dax_avail_size(dax_resource->res))
+		return 0;
+	return 1;
+}
+
+static ssize_t dev_dax_resize_sparse(struct dax_region *dax_region,
+				     struct dev_dax *dev_dax,
+				     resource_size_t to_alloc)
+{
+	struct dax_resource *dax_resource;
+	ssize_t alloc;
+
+	struct device *extent_dev __free(put_device) =
+			device_find_child(dax_region->dev, dax_region,
+					  find_free_extent);
+	if (!extent_dev)
+		return 0;
+
+	dax_resource = dev_get_drvdata(extent_dev);
+	if (!dax_resource)
+		return 0;
+
+	to_alloc = min(dax_avail_size(dax_resource->res), to_alloc);
+	alloc = __dev_dax_resize(dax_resource->res, dev_dax, to_alloc, dax_resource);
+	if (alloc > 0)
+		dax_resource->use_cnt++;
+	return alloc;
+}
+
 static ssize_t dev_dax_resize(struct dax_region *dax_region,
 		struct dev_dax *dev_dax, resource_size_t size)
 {
@@ -1118,7 +1304,10 @@ static ssize_t dev_dax_resize(struct dax_region *dax_region,
 		return -ENXIO;
 
 retry:
-	alloc = dev_dax_resize_static(&dax_region->res, dev_dax, to_alloc);
+	if (is_sparse(dax_region))
+		alloc = dev_dax_resize_sparse(dax_region, dev_dax, to_alloc);
+	else
+		alloc = dev_dax_resize_static(dax_region, dev_dax, to_alloc);
 	if (alloc <= 0)
 		return alloc;
 	to_alloc -= alloc;
@@ -1227,7 +1416,7 @@ static ssize_t mapping_store(struct device *dev, struct device_attribute *attr,
 	to_alloc = range_len(&r);
 	if (alloc_is_aligned(dev_dax, to_alloc))
 		rc = alloc_dev_dax_range(&dax_region->res, dev_dax, r.start,
-					 to_alloc);
+					 to_alloc, NULL);
 	up_write(&dax_dev_rwsem);
 	up_write(&dax_region_rwsem);
 
@@ -1466,6 +1655,11 @@ static struct dev_dax *__devm_create_dev_dax(struct dev_dax_data *data)
 	struct device *dev;
 	int rc;
 
+	if (is_sparse(dax_region) && data->size) {
+		dev_err(parent, "Sparse DAX region devices must be created initially with 0 size");
+		return ERR_PTR(-EINVAL);
+	}
+
 	dev_dax = kzalloc(sizeof(*dev_dax), GFP_KERNEL);
 	if (!dev_dax)
 		return ERR_PTR(-ENOMEM);
@@ -1496,7 +1690,7 @@ static struct dev_dax *__devm_create_dev_dax(struct dev_dax_data *data)
 	dev_set_name(dev, "dax%d.%d", dax_region->id, dev_dax->id);
 
 	rc = alloc_dev_dax_range(&dax_region->res, dev_dax, dax_region->res.start,
-				 data->size);
+				 data->size, NULL);
 	if (rc)
 		goto err_range;
 
diff --git a/drivers/dax/bus.h b/drivers/dax/bus.h
index 783bfeef42cc..ae5029ea6047 100644
--- a/drivers/dax/bus.h
+++ b/drivers/dax/bus.h
@@ -9,6 +9,7 @@ struct dev_dax;
 struct resource;
 struct dax_device;
 struct dax_region;
+struct dax_sparse_ops;
 
 /* dax bus specific ioresource flags */
 #define IORESOURCE_DAX_STATIC BIT(0)
@@ -17,7 +18,7 @@ struct dax_region;
 
 struct dax_region *alloc_dax_region(struct device *parent, int region_id,
 		struct range *range, int target_node, unsigned int align,
-		unsigned long flags);
+		unsigned long flags, struct dax_sparse_ops *sparse_ops);
 
 struct dev_dax_data {
 	struct dax_region *dax_region;
diff --git a/drivers/dax/cxl.c b/drivers/dax/cxl.c
index 88b051cea755..011bd1dc7691 100644
--- a/drivers/dax/cxl.c
+++ b/drivers/dax/cxl.c
@@ -5,6 +5,57 @@
 
 #include "../cxl/cxl.h"
 #include "bus.h"
+#include "dax-private.h"
+
+static int __cxl_dax_add_resource(struct dax_region *dax_region,
+				  struct region_extent *region_extent)
+{
+	struct device *dev = &region_extent->dev;
+	resource_size_t start, length;
+
+	start = dax_region->res.start + region_extent->hpa_range.start;
+	length = range_len(&region_extent->hpa_range);
+	return dax_region_add_resource(dax_region, dev, start, length);
+}
+
+static int cxl_dax_add_resource(struct device *dev, void *data)
+{
+	struct dax_region *dax_region = data;
+	struct region_extent *region_extent;
+
+	region_extent = to_region_extent(dev);
+	if (!region_extent)
+		return 0;
+
+	dev_dbg(dax_region->dev, "Adding resource HPA %pra\n",
+		&region_extent->hpa_range);
+
+	return __cxl_dax_add_resource(dax_region, region_extent);
+}
+
+static int cxl_dax_region_notify(struct device *dev,
+				 struct cxl_notify_data *notify_data)
+{
+	struct cxl_dax_region *cxlr_dax = to_cxl_dax_region(dev);
+	struct dax_region *dax_region = dev_get_drvdata(dev);
+	struct region_extent *region_extent = notify_data->region_extent;
+
+	switch (notify_data->event) {
+	case DCD_ADD_CAPACITY:
+		return __cxl_dax_add_resource(dax_region, region_extent);
+	case DCD_RELEASE_CAPACITY:
+		return dax_region_rm_resource(dax_region, &region_extent->dev);
+	case DCD_FORCED_CAPACITY_RELEASE:
+	default:
+		dev_err(&cxlr_dax->dev, "Unknown DC event %d\n",
+			notify_data->event);
+		return -ENXIO;
+	}
+}
+
+struct dax_sparse_ops sparse_ops = {
+	.is_extent = is_region_extent,
+};
 
 static int cxl_dax_region_probe(struct device *dev)
 {
@@ -24,15 +75,18 @@ static int cxl_dax_region_probe(struct device *dev)
 		flags |= IORESOURCE_DAX_SPARSE_CAP;
 
 	dax_region = alloc_dax_region(dev, cxlr->id, &cxlr_dax->hpa_range, nid,
-				      PMD_SIZE, flags);
+				      PMD_SIZE, flags, &sparse_ops);
 	if (!dax_region)
 		return -ENOMEM;
 
-	if (cxlr->mode == CXL_PARTMODE_DYNAMIC_RAM_A)
+	if (cxlr->mode == CXL_PARTMODE_DYNAMIC_RAM_A) {
+		device_for_each_child(&cxlr_dax->dev, dax_region,
+				      cxl_dax_add_resource);
 		/* Add empty seed dax device */
 		dev_size = 0;
-	else
+	} else {
 		dev_size = range_len(&cxlr_dax->hpa_range);
+	}
 
 	data = (struct dev_dax_data) {
 		.dax_region = dax_region,
@@ -47,6 +101,7 @@ static int cxl_dax_region_probe(struct device *dev)
 static struct cxl_driver cxl_dax_region_driver = {
 	.name = "cxl_dax_region",
 	.probe = cxl_dax_region_probe,
+	.notify = cxl_dax_region_notify,
 	.id = CXL_DEVICE_DAX_REGION,
 	.drv = {
 		.suppress_bind_attrs = true,
diff --git a/drivers/dax/dax-private.h b/drivers/dax/dax-private.h
index 0867115aeef2..39fb587561f8 100644
--- a/drivers/dax/dax-private.h
+++ b/drivers/dax/dax-private.h
@@ -16,6 +16,14 @@ struct inode *dax_inode(struct dax_device *dax_dev);
 int dax_bus_init(void);
 void dax_bus_exit(void);
 
+/**
+ * struct dax_sparse_ops - Operations for sparse regions
+ * @is_extent: return if the device is an extent
+ */
+struct dax_sparse_ops {
+	bool (*is_extent)(struct device *dev);
+};
+
 /**
  * struct dax_region - mapping infrastructure for dax devices
  * @id: kernel-wide unique region for a memory range
@@ -27,6 +35,7 @@ void dax_bus_exit(void);
  * @res: resource tree to track instance allocations
  * @seed: allow userspace to find the first unbound seed device
  * @youngest: allow userspace to find the most recently created device
+ * @sparse_ops: operations required for sparse regions
  */
 struct dax_region {
 	int id;
@@ -38,6 +47,7 @@ struct dax_region {
 	struct resource res;
 	struct device *seed;
 	struct device *youngest;
+	struct dax_sparse_ops *sparse_ops;
 };
 
 /**
@@ -57,11 +67,13 @@ struct dax_mapping {
  * @pgoff: page offset
  * @range: resource-span
  * @mapping: reference to the dax_mapping for this range
+ * @dax_resource: if not NULL; dax sparse resource containing this range
  */
 struct dev_dax_range {
 	unsigned long pgoff;
 	struct range range;
 	struct dax_mapping *mapping;
+	struct dax_resource *dax_resource;
 };
 
 /**
@@ -100,6 +112,34 @@ struct dev_dax {
  */
 void run_dax(struct dax_device *dax_dev);
 
+/**
+ * struct dax_resource - For sparse regions; an active resource
+ * @region: dax_region this resources is in
+ * @res: resource
+ * @use_cnt: count the number of uses of this resource
+ *
+ * Changes to the dax_region and the dax_resources within it are protected by
+ * dax_region_rwsem
+ *
+ * dax_resource's are not intended to be used outside the dax layer.
+ */
+struct dax_resource {
+	struct dax_region *region;
+	struct resource *res;
+	unsigned int use_cnt;
+};
+
+/*
+ * Similar to run_dax() dax_region_{add,rm}_resource() and dax_avail_size() are
+ * exported but are not intended to be generic operations outside the dax
+ * subsystem.  They are only generic between the dax layer and the dax drivers.
+ */
+int dax_region_add_resource(struct dax_region *dax_region, struct device *dev,
+			    resource_size_t start, resource_size_t length);
+int dax_region_rm_resource(struct dax_region *dax_region,
+			   struct device *dev);
+resource_size_t dax_avail_size(struct resource *dax_resource);
+
 static inline struct dev_dax *to_dev_dax(struct device *dev)
 {
 	return container_of(dev, struct dev_dax, dev);
diff --git a/drivers/dax/hmem/hmem.c b/drivers/dax/hmem/hmem.c
index 5e7c53f18491..0eea65052874 100644
--- a/drivers/dax/hmem/hmem.c
+++ b/drivers/dax/hmem/hmem.c
@@ -28,7 +28,7 @@ static int dax_hmem_probe(struct platform_device *pdev)
 
 	mri = dev->platform_data;
 	dax_region = alloc_dax_region(dev, pdev->id, &mri->range,
-				      mri->target_node, PMD_SIZE, flags);
+				      mri->target_node, PMD_SIZE, flags, NULL);
 	if (!dax_region)
 		return -ENOMEM;
 
diff --git a/drivers/dax/pmem.c b/drivers/dax/pmem.c
index c8ebf4e281f2..f927e855f240 100644
--- a/drivers/dax/pmem.c
+++ b/drivers/dax/pmem.c
@@ -54,7 +54,7 @@ static struct dev_dax *__dax_pmem_probe(struct device *dev)
 	range.start += offset;
 	dax_region = alloc_dax_region(dev, region_id, &range,
 			nd_region->target_node, le32_to_cpu(pfn_sb->align),
-			IORESOURCE_DAX_STATIC);
+			IORESOURCE_DAX_STATIC, NULL);
 	if (!dax_region)
 		return ERR_PTR(-ENOMEM);
 
diff --git a/include/linux/ioport.h b/include/linux/ioport.h
index e8b2d6aa4013..a97bb3d936a7 100644
--- a/include/linux/ioport.h
+++ b/include/linux/ioport.h
@@ -27,6 +27,9 @@ struct resource {
 	struct resource *parent, *sibling, *child;
 };
 
+#define for_each_child_resource(parent, res) \
+	for (res = (parent)->child; res; res = res->sibling)
+
 /*
  * IO resources have these defined flags.
  *

-- 
2.49.0


From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from mgamail.intel.com (mgamail.intel.com [192.198.163.18])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id 048A41FECBA
	for <nvdimm@lists.linux.dev>; Sun, 13 Apr 2025 22:52:24 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=fail smtp.client-ip=192.198.163.18
ARC-Seal: i=2; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1744584747; cv=fail; b=WHKFreBLdzoSsaNh5+u8O377q554SFjvT3IZqKGBo//FbHQBafaz2ZHGb7qmoSyUdHy73PEB4aGTN7in4VQPsfPTUBBuUwCJvR+Xq23KvwwkqLNGBEtc3FbmL5gXoVyQNWIg9C9hUqtR2FMlWTt/Uvgi0BJJIv0K52UjgcFKghA=
ARC-Message-Signature: i=2; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1744584747; c=relaxed/simple;
	bh=wkudF2XNTcQS8VPUDMQ571w4CvWff5yrKjJtNZtBW2s=;
	h=From:Date:Subject:Content-Type:Message-ID:References:In-Reply-To:
	 To:CC:MIME-Version; b=U3szl7pzePmDN7/w4+C7EPUPiYCSprx0nL5B8mzga6Kdfi50DkrtZnQuahKCYikuIKpWyrbyokjjXO0cOrFqVQpqyTZRjkL8z32mSxq8cTVVOw8Rhj9fxj1am/Q4+6xgxlpH7KP2WvVyjk8bdMWZzNhLgW0H63yxEkB2TuRRMlg=
ARC-Authentication-Results: i=2; smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=intel.com; spf=pass smtp.mailfrom=intel.com; dkim=pass (2048-bit key) header.d=intel.com header.i=@intel.com header.b=DUBXH5ca; arc=fail smtp.client-ip=192.198.163.18
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=intel.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=intel.com
Authentication-Results: smtp.subspace.kernel.org;
	dkim=pass (2048-bit key) header.d=intel.com header.i=@intel.com header.b="DUBXH5ca"
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1744584745; x=1776120745;
  h=from:date:subject:content-transfer-encoding:message-id:
   references:in-reply-to:to:cc:mime-version;
  bh=wkudF2XNTcQS8VPUDMQ571w4CvWff5yrKjJtNZtBW2s=;
  b=DUBXH5cai9lmW2iG6HcWGmdk6toSJwz4DBH+QHvYDNe7kUe0uhMwjfmw
   Ae4pSN2CUMm1358NW1N7LQ1LyKkuXWKlr6Y0ARGZntpQk1JJzTSrhGk8L
   oUvRk/3Oapqdd9ijtnWQhB/2uxycLxSiur6zySJbxsxOMEPQG1CgpZ3X+
   /9Z2ZGHb/9jIc0sJRQz8vxepphK3eoy11+npJWWpJaUT3VjHt6JEhAFi5
   oze5+7Qv3WC9HQglaRhQrZTebbrsg9eKxf9fQZaus2n03G34bldum52X4
   ZdeDYijAXQHkQejCPEegtV8gGmefUU39edKE9EIO51lb/jr43AazE/sfD
   g==;
X-CSE-ConnectionGUID: 8bsd7F2gTyCeUGD6amR0yQ==
X-CSE-MsgGUID: 1ZA9Oq36TbKcoXKJ5HWqdA==
X-IronPort-AV: E=McAfee;i="6700,10204,11402"; a="45280947"
X-IronPort-AV: E=Sophos;i="6.15,211,1739865600"; 
   d="scan'208";a="45280947"
Received: from fmviesa007.fm.intel.com ([10.60.135.147])
  by fmvoesa112.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 13 Apr 2025 15:52:22 -0700
X-CSE-ConnectionGUID: 63yr2e9gTqqcH3hTpgEfDw==
X-CSE-MsgGUID: /cihgiucQ8W8OupWJpRtgg==
X-ExtLoop1: 1
X-IronPort-AV: E=Sophos;i="6.15,211,1739865600"; 
   d="scan'208";a="129657627"
Received: from orsmsx902.amr.corp.intel.com ([10.22.229.24])
  by fmviesa007.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 13 Apr 2025 15:52:22 -0700
Received: from ORSMSX901.amr.corp.intel.com (10.22.229.23) by
 ORSMSX902.amr.corp.intel.com (10.22.229.24) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.2.1544.14; Sun, 13 Apr 2025 15:52:21 -0700
Received: from orsedg603.ED.cps.intel.com (10.7.248.4) by
 ORSMSX901.amr.corp.intel.com (10.22.229.23) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.2.1544.14 via Frontend Transport; Sun, 13 Apr 2025 15:52:21 -0700
Received: from NAM04-BN8-obe.outbound.protection.outlook.com (104.47.74.48) by
 edgegateway.intel.com (134.134.137.100) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.44; Sun, 13 Apr 2025 15:52:20 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector10001; d=microsoft.com; cv=none;
 b=WaEqpOAEbVU9uT/MCZX+XZ0VJKOIoVg5TugwxWSDMkuZpAimSXRmDbtGw64BWAxMWzpbMX5sLkNht73POhbxOUw8uliHhRfzUeZPAoJuPxyRl+rZmQK2eMgAgUaSGAJ+r0NCQBZ/wgmUgkJNhmTTaPiVOWdvqWXuSk7AktlLSvHpl1GHG06Fv29m8/TrZDVJbzE/RFxNNUgvh6oc222Ar0PlQbYZqWfT7fxmO/Bhaksez6jE4wcsn4H+6ih8DdgoNhfp7AMFE821Q0Uq/EZngptpCU5oqbSQTGczjLijeRExVJ6rstvkeNrHcQzrRKg2Jua0WjupC+5FkIjXgKavIQ==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector10001;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=xHChTg9LEV/qJAb1pJTzHBnMQyur4fyxjR7vjkIpdhk=;
 b=IBJelhyhXSOjQcUVOngq8tQEm2FT8+jx1RsGZAglEXIcQYTBc453ETWaG3yQGzmTZcvsrdNZ9Za52ih1eDfLgMr7/ARXhgxcLT7Nrl+JZyKASoPIKdzBvLYDypUvrOHt40kw+CrbFEiZlHnewMXU/9D5s8SmjNuM3+VJA+OpTSon+3cEsACInz3YokPd/J8f8BuHCiMHrUy+nFNWZMq3hILKluwOrcgWv3d8WEt1EarU9ffNrD6C70nmPINZ6etzfoLoDMQoWhI94JgH28Y16ukKCulEvOBt08omRrxAEN3Xk9conjWcDa5drIe/DWQ5bVGoWAFoYpJElyzfkjCRcQ==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from MW4PR11MB6739.namprd11.prod.outlook.com (2603:10b6:303:20b::19)
 by DM4PR11MB6042.namprd11.prod.outlook.com (2603:10b6:8:61::18) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.8632.28; Sun, 13 Apr
 2025 22:52:00 +0000
Received: from MW4PR11MB6739.namprd11.prod.outlook.com
 ([fe80::a7ad:a6e8:fced:3f24]) by MW4PR11MB6739.namprd11.prod.outlook.com
 ([fe80::a7ad:a6e8:fced:3f24%4]) with mapi id 15.20.8606.033; Sun, 13 Apr 2025
 22:52:00 +0000
From: Ira Weiny <ira.weiny@intel.com>
Date: Sun, 13 Apr 2025 17:52:19 -0500
Subject: [PATCH v9 11/19] cxl/core: Return endpoint decoder information
 from region search
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: 7bit
Message-ID: <20250413-dcd-type2-upstream-v9-11-1d4911a0b365@intel.com>
References: <20250413-dcd-type2-upstream-v9-0-1d4911a0b365@intel.com>
In-Reply-To: <20250413-dcd-type2-upstream-v9-0-1d4911a0b365@intel.com>
To: Dave Jiang <dave.jiang@intel.com>, Fan Ni <fan.ni@samsung.com>, "Jonathan
 Cameron" <Jonathan.Cameron@huawei.com>
CC: Dan Williams <dan.j.williams@intel.com>, Davidlohr Bueso
	<dave@stgolabs.net>, Alison Schofield <alison.schofield@intel.com>, "Vishal
 Verma" <vishal.l.verma@intel.com>, Ira Weiny <ira.weiny@intel.com>,
	<linux-cxl@vger.kernel.org>, <nvdimm@lists.linux.dev>,
	<linux-kernel@vger.kernel.org>, Li Ming <ming.li@zohomail.com>
X-Mailer: b4 0.15-dev-c25d1
X-Developer-Signature: v=1; a=ed25519-sha256; t=1744584735; l=4478;
 i=ira.weiny@intel.com; s=20221211; h=from:subject:message-id;
 bh=wkudF2XNTcQS8VPUDMQ571w4CvWff5yrKjJtNZtBW2s=;
 b=qhzG4PaAzvVurrvwp6PNMi09MOnwGo2di6304YuKuEHO3itK6l3RaQvXu6NjdjeEvBwwQzhxv
 4ZGYHmnYlMJAkvmhyDnvAe+Kx2gnwgxxb71xVol0j6jm5WWesbpJ9TU
X-Developer-Key: i=ira.weiny@intel.com; a=ed25519;
 pk=noldbkG+Wp1qXRrrkfY1QJpDf7QsOEthbOT7vm0PqsE=
X-ClientProxiedBy: MW4PR03CA0227.namprd03.prod.outlook.com
 (2603:10b6:303:b9::22) To MW4PR11MB6739.namprd11.prod.outlook.com
 (2603:10b6:303:20b::19)
Precedence: bulk
X-Mailing-List: nvdimm@lists.linux.dev
List-Id: <nvdimm.lists.linux.dev>
List-Subscribe: <mailto:nvdimm+subscribe@lists.linux.dev>
List-Unsubscribe: <mailto:nvdimm+unsubscribe@lists.linux.dev>
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: MW4PR11MB6739:EE_|DM4PR11MB6042:EE_
X-MS-Office365-Filtering-Correlation-Id: d89e3e88-eafe-4c1d-c85f-08dd7addcd11
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;ARA:13230040|376014|1800799024|366016|7053199007;
X-Microsoft-Antispam-Message-Info: =?utf-8?B?UTdnWWI3NnNNL0QyVktseGxWRWk2RDhPQWpiMzlmUXNpV1REUk1Bc3BsNG5a?=
 =?utf-8?B?d3M2YWIyUDE3dDBjc2FDMzBRRkw2aGpiVjcxRkk5REFpdFBxQ0xuK1ZKNklw?=
 =?utf-8?B?dytYaWhUQm1CU05DRExZT2dOSDZqcmFEdUd6eXBRZHByaEJEMFBBNStSek5q?=
 =?utf-8?B?UElTRXFxK2hVWlJaSy9rNkxlNllRVTlOSzFsaGhGcWRMaEJFM1QxdWNkMzYy?=
 =?utf-8?B?OUZDRGxGejU2MkZNaGhsaVJ2Ylk1ZHVveTFKdTkzQ2Z0cXFHNjRJVVJiWUlj?=
 =?utf-8?B?WUlRTm5vQVNMVFdUbzRpVG1SVWRxUVFIdDVDRE9UQUtlaE9CenUwb2s4WDRi?=
 =?utf-8?B?UzhLa09nT29BeEpDbHB2d2NOMXRtanpqYUhwMmp6enRuem0xWWlvOHhEY0Rr?=
 =?utf-8?B?bjZlYUt4TnVsbk9waUVtZW9zc3pzTVpUMkRyVzQ1R1EyMGRRT1hwRWtFTWRO?=
 =?utf-8?B?ZnhlQkZia0JHd1RSNGUvd2FUK2NaSVRvTnNjcjUvM3BRN0NYQXVXNllFakFh?=
 =?utf-8?B?ZngwdTZBSWdhdlQ5ZCtFMkZlQmtmZzN3T0QrSWxzK1U5MkVYUThZRWttN3dy?=
 =?utf-8?B?V2dyS3RxYzdpWDFrODFkdjRncDhPU2I4N2s1MnoxNlJpaVdyeVhJdXBndmhW?=
 =?utf-8?B?Z2lSZHdvWVkrdTFrV0xlMXpzbVFHeW1RZ0g4MkFhVGZnSlJ5UFdUUFltODhY?=
 =?utf-8?B?cERvdVhJekRtZkN2a2k3b2hCbU5ETHFoTjRlaEFJZ25WamlQcGl6TTlsZG54?=
 =?utf-8?B?eFhUNW1SaUZRRm1PS3IvVUcxT3RqaHhEUG42ckRFQUNZRFplVzZMdGFCV05v?=
 =?utf-8?B?ZGp4dnF1Yi96VGliRnI0OXUzNFdVSFBQR09yWlJrWExBdjIzQkRXSko5WmhQ?=
 =?utf-8?B?aXNBUU5keGxhY3JhQjFaOFp1MzFUbjBXdGMvRW1ZdTFMSzVpcC9YWG9sYlF5?=
 =?utf-8?B?end2MkhYcjhyZjhmV1FMalNqNGFvWDJnditHcEVqUDZUSG1GNHVzYS9kYzhD?=
 =?utf-8?B?cTM2YjUwNGJjUWxQV2wrVWNMN0hkeEpkZ0cwWmZIQ2w4MkVjc3FucmpBY1lW?=
 =?utf-8?B?MUc5aEtmSElHRnlsS3RWb3hVOTh2UzVrQ2dPTnNJcUZ2cHNPQmZQWkx4ZEUw?=
 =?utf-8?B?VmFsTkZSd1ZFZ0YrZkhIRHRabCtRL0JOc3pSVitTQ2cyOUQzeitlZ0xsT2Qz?=
 =?utf-8?B?OTV3dU1WNWlhNmZzNWs1QlVKVjVuZ2RrMjNNT2NWcEFFWWhLM2Y3RVFiczVw?=
 =?utf-8?B?bVBva1JqM3pkN2lxZTdxWitRN3VZdjZsWmNMY0lJbnFZRmRhTzVMaGh3ZUJn?=
 =?utf-8?B?STdQUXJ0RndjUTc4ODJQbUZhVXJ1SzdCNXh1dE5pOXk1Z3FlYnpFcHZkdkJq?=
 =?utf-8?B?OUdyRmpIVllNYnkvS0VadldBZEQwK3Z3LzZGdzIvZ2d0MURKa2JMNU9hMHN2?=
 =?utf-8?B?Ry9vRXpDTU14Q2t4MXNMT3BUbEdMUHZIbU5kQkFqWEk5Y05DckJ5am5RdzV0?=
 =?utf-8?B?Z3JLb1VlZTZ3QXNQUm95bDB5aEE4eFYyTGZkd25HRXRFWEFjaGRtcjJVMldG?=
 =?utf-8?B?ZWVkcVBXWXJMMDhUZWZ3c1kxWWJpQ2UxK3ZTRnRVWjhKSGJBcERTc3JuVXVS?=
 =?utf-8?B?bXpQSzJ2ZitDRHhWZVdXQ1N3WDduUFdZNWZVRjJMOXFMdUF3amo4aVZRV0po?=
 =?utf-8?B?SUdpbkZnZksxdXNxcVp1NWRheTNmK1pyZFRqMUlNQXN3SzNtNGJmbFA2YjVF?=
 =?utf-8?B?Y0krMFhNQ1RVL3ZJZ3ZHbWE2Q29jcWlxaDVmRWF0RGxlcVRpbGpwVjByM1h4?=
 =?utf-8?B?SjAyR085TXYrUFBBNXJ4WEJhOHB1a0lvTlN5K1lVZzk4OWo1MEVpTWdLZkVG?=
 =?utf-8?B?b25iYTZ3V002UldURWZCY3M5OGVBNEc3ZHdlTVJQQlhRamVmcHlKZDZEem0v?=
 =?utf-8?Q?h8X33D9SQbU=3D?=
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:MW4PR11MB6739.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230040)(376014)(1800799024)(366016)(7053199007);DIR:OUT;SFP:1101;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?utf-8?B?UFRGMzRJUTdNRWdBZmVPTldBNWV6Rmt4TndYV3QyMjRNa1J6TjBKZnFOK1FD?=
 =?utf-8?B?OFp2bEFzdC9UMzBhTVNYZ01KM2dtanN0YXl1ME10MDIrWGprVjRvekZoNGEr?=
 =?utf-8?B?anZQZlp5S0ZVTXlGOFpZREkrZEQzTkVmQk5XYmd6Mm12OTVtWCt5NTEyd2xw?=
 =?utf-8?B?YitLMjRST05ZQnRpS3JxbUdRbFpZd1RDajZ3bU5wdHczaEJkbStqREZyTWRo?=
 =?utf-8?B?eVl6cUUrRDc0dlBFVXFwaEI0WVgzcmIzV0o5b1l3MzB5SE1ISXlTVGw1bDJw?=
 =?utf-8?B?Wk5ncHlTY3k3SVBtMTQ2R04wS0FOUFU2d2Z3Mmc5eEUzSC90K3I0c2JxSDZ2?=
 =?utf-8?B?aXNwaTlJL21XQWpoZmpLb1hmMXRBd0dsN3VlaUZRZHhBckcrd3h5bm8yQVQr?=
 =?utf-8?B?UllwTmJReHJWd3RJZksxS29QVjBmTFhHaTJ6eUZnOGlYNW5ETTY4cVU5eTgw?=
 =?utf-8?B?Ui9tbFdJeDFiWVVDK1RzUlZhZGZtODQ1VU04anVGVkdUeUZ5eVh3a1Vhcmx5?=
 =?utf-8?B?WkU0UG1tS1NUN3VNZk4rU3lxUkZaRlFHOUFmdnNOY1pmZkNjODVTb0dIcnM2?=
 =?utf-8?B?bno2MHA3RmJSM2JacE9WNWd0ZVJMTXlRT01ieGZlcTlESm5lcTV1S1VWRVJV?=
 =?utf-8?B?QTFtTDBnaUdEYzQ0Z0hWcWc1WGxHUkNkQUlaeTJKeVpLKzJWTjBiaXpFSUtU?=
 =?utf-8?B?RHMxdjBsTFJtZFRPa00wSGlYUlJxUlMzMGozZEdlaTRUYmt1WU5SRXFxZmZy?=
 =?utf-8?B?elNkY3JyTjFIcHJaWWJqS3Qzemthc3NTRDRFNHArdlZ5SzJ1QVMwUmdnd09P?=
 =?utf-8?B?Wnp3L0Fzd0tlbXZjRWIrMG1CN0tBMXZOT2V6R29BTzlQdC9GaUcrTzl5NkVS?=
 =?utf-8?B?SWUweWFGS3Uyb3MvZGJ1RHZOQUptWlZsajNwdWs5L0QrMENYQ2N1VHNCQmJR?=
 =?utf-8?B?WkNSaVlSQUhxSGhWNVA3aVRQSE01Mk42RGlIM0JxSXBWMEJaeXRqaDNPVFMz?=
 =?utf-8?B?QldQQjhPbjRFeU1abHA4aFZSRlB2T3RsK2VGaXlBKzd1RnRNZ05MZXBaZHRX?=
 =?utf-8?B?ZVp4eTMzN2VlTU1PL2FjNlRzeUVmV3V4cVNzNGNmYnhwd3czVzJPZFhCdzBu?=
 =?utf-8?B?RDVIZERTTlZZMy9GNDR2MnJlS3hnRUlEdTFvcEdXcU0wTUtNM1dYeHU0c25U?=
 =?utf-8?B?S0FwY3VjbmtHT3lIVi9PT2VvTWk3Y0dLb2RXVUFjODdYa1NzU3REWjZpeXRP?=
 =?utf-8?B?TTNrVmdaUi9rMStYQlVubmJaTXhhTTlyTGVMVHRFcUJNY1pObXdTV1c1K0x2?=
 =?utf-8?B?UStrWGZhMmlQNnRjZW45Z0JkMkIrSC9lSjJzRWY4NVkyWU1uZm5CYkY4Z2c0?=
 =?utf-8?B?M3FQakRjZlQ1amtrbUJ1c1FkbHFraEtTY1c1aXFPeFhWd0tHOXZFUUVUVDVq?=
 =?utf-8?B?eC9NZlRESllHZmxSelpYbVZ4enJoUGk5M1RCdU5wRlZodDRaaTIzYkJZM0tm?=
 =?utf-8?B?R2FvZmhaMXM1d0NLcEg4QlhuT0JCUmNUeXhnOFVjdXBGMEYzcFBHbnVqWTFL?=
 =?utf-8?B?VXRZNVN2VXJReS9QeEs1ZVFkNVkvUUZnd05CSVRWVGJHcDVMMXJ5TUxXbU1i?=
 =?utf-8?B?bURFUksrS0NicFdsRGVsMi9aSU9hUVNVMStpSUw4NWhpdWw0ZDloSUtkRnY3?=
 =?utf-8?B?c0VmSWdSdmo3dlRjSmV3STl4VEpXOWpiRjBldWlobU5OZUVKVjdNMkZ4M2Jt?=
 =?utf-8?B?eGl5S3hMOGxWeC9JM2puaUxldTZNcGhsVG1uT29UbDU0QkVXNFJ5eXJDQkw4?=
 =?utf-8?B?M2h2UllxZGJ1Sm50RGVaQURPS3BxWFFBTTBmdUEvdEd4WEhqOEdvTG9RVjBW?=
 =?utf-8?B?cGJJSGk4Rm9VL2s5aTBQeit4dUp1VTJMUGRrdUY4aU90d3QzVDUvOWpRSit1?=
 =?utf-8?B?c1lYSDJqZXF3MHgxM21xVERmZ2Vnb0ttK1plRHpWSUlPL1dMcFprcDM4NUJ6?=
 =?utf-8?B?d1ZKOVZXZHVoc1ZjNkNlblJ6L1dZYWV0c3FQa3RQdDRPaUg5VW5abWhuL1JJ?=
 =?utf-8?B?ZnBPSWdhb3FSQS91eFBwa2hKMUpKRlg0eFkzSzNsYnMzRmIrMTVMUXV3TWJG?=
 =?utf-8?Q?6grNKALy5IZCH9a89Go4scNgy?=
X-MS-Exchange-CrossTenant-Network-Message-Id: d89e3e88-eafe-4c1d-c85f-08dd7addcd11
X-MS-Exchange-CrossTenant-AuthSource: MW4PR11MB6739.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 13 Apr 2025 22:52:00.6300
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: 0jQckqDImRY5pMabHSSwuD9R8CB/bEhYKrCQFvsUvCtaCyJgncQRbC6uB2Hn3BhmW+2YhukkjTIrR6p2YBKgOQ==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: DM4PR11MB6042
X-OriginatorOrg: intel.com
Status: O
Content-Length: 4354
Lines: 126

cxl_dpa_to_region() finds the region from a <DPA, device> tuple.
The search involves finding the device endpoint decoder as well.

Dynamic capacity extent processing uses the endpoint decoder HPA
information to calculate the HPA offset.  In addition, well behaved
extents should be contained within an endpoint decoder.

Return the endpoint decoder found to be used in subsequent DCD code.

Reviewed-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
Reviewed-by: Fan Ni <fan.ni@samsung.com>
Reviewed-by: Dave Jiang <dave.jiang@intel.com>
Reviewed-by: Li Ming <ming.li@zohomail.com>
Reviewed-by: Alison Schofield <alison.schofield@intel.com>
Signed-off-by: Ira Weiny <ira.weiny@intel.com>

---
Changes:
[iweiny: rebase]
---
 drivers/cxl/core/core.h   | 6 ++++--
 drivers/cxl/core/mbox.c   | 2 +-
 drivers/cxl/core/memdev.c | 4 ++--
 drivers/cxl/core/region.c | 8 +++++++-
 4 files changed, 14 insertions(+), 6 deletions(-)

diff --git a/drivers/cxl/core/core.h b/drivers/cxl/core/core.h
index 08facbc2d270..76e23ec03fb4 100644
--- a/drivers/cxl/core/core.h
+++ b/drivers/cxl/core/core.h
@@ -40,7 +40,8 @@ void cxl_decoder_kill_region(struct cxl_endpoint_decoder *cxled);
 int cxl_region_init(void);
 void cxl_region_exit(void);
 int cxl_get_poison_by_endpoint(struct cxl_port *port);
-struct cxl_region *cxl_dpa_to_region(const struct cxl_memdev *cxlmd, u64 dpa);
+struct cxl_region *cxl_dpa_to_region(const struct cxl_memdev *cxlmd, u64 dpa,
+				     struct cxl_endpoint_decoder **cxled);
 u64 cxl_dpa_to_hpa(struct cxl_region *cxlr, const struct cxl_memdev *cxlmd,
 		   u64 dpa);
 
@@ -51,7 +52,8 @@ static inline u64 cxl_dpa_to_hpa(struct cxl_region *cxlr,
 	return ULLONG_MAX;
 }
 static inline
-struct cxl_region *cxl_dpa_to_region(const struct cxl_memdev *cxlmd, u64 dpa)
+struct cxl_region *cxl_dpa_to_region(const struct cxl_memdev *cxlmd, u64 dpa,
+				     struct cxl_endpoint_decoder **cxled)
 {
 	return NULL;
 }
diff --git a/drivers/cxl/core/mbox.c b/drivers/cxl/core/mbox.c
index c589d8a330bb..b3dd119d166a 100644
--- a/drivers/cxl/core/mbox.c
+++ b/drivers/cxl/core/mbox.c
@@ -957,7 +957,7 @@ void cxl_event_trace_record(const struct cxl_memdev *cxlmd,
 		guard(rwsem_read)(&cxl_dpa_rwsem);
 
 		dpa = le64_to_cpu(evt->media_hdr.phys_addr) & CXL_DPA_MASK;
-		cxlr = cxl_dpa_to_region(cxlmd, dpa);
+		cxlr = cxl_dpa_to_region(cxlmd, dpa, NULL);
 		if (cxlr) {
 			u64 cache_size = cxlr->params.cache_size;
 
diff --git a/drivers/cxl/core/memdev.c b/drivers/cxl/core/memdev.c
index 063a14c1973a..d3555d1f13c6 100644
--- a/drivers/cxl/core/memdev.c
+++ b/drivers/cxl/core/memdev.c
@@ -320,7 +320,7 @@ int cxl_inject_poison(struct cxl_memdev *cxlmd, u64 dpa)
 	if (rc)
 		goto out;
 
-	cxlr = cxl_dpa_to_region(cxlmd, dpa);
+	cxlr = cxl_dpa_to_region(cxlmd, dpa, NULL);
 	if (cxlr)
 		dev_warn_once(cxl_mbox->host,
 			      "poison inject dpa:%#llx region: %s\n", dpa,
@@ -384,7 +384,7 @@ int cxl_clear_poison(struct cxl_memdev *cxlmd, u64 dpa)
 	if (rc)
 		goto out;
 
-	cxlr = cxl_dpa_to_region(cxlmd, dpa);
+	cxlr = cxl_dpa_to_region(cxlmd, dpa, NULL);
 	if (cxlr)
 		dev_warn_once(cxl_mbox->host,
 			      "poison clear dpa:%#llx region: %s\n", dpa,
diff --git a/drivers/cxl/core/region.c b/drivers/cxl/core/region.c
index 716d33140ee8..9c573e8d6ed7 100644
--- a/drivers/cxl/core/region.c
+++ b/drivers/cxl/core/region.c
@@ -2839,6 +2839,7 @@ int cxl_get_poison_by_endpoint(struct cxl_port *port)
 struct cxl_dpa_to_region_context {
 	struct cxl_region *cxlr;
 	u64 dpa;
+	struct cxl_endpoint_decoder *cxled;
 };
 
 static int __cxl_dpa_to_region(struct device *dev, void *arg)
@@ -2872,11 +2873,13 @@ static int __cxl_dpa_to_region(struct device *dev, void *arg)
 			dev_name(dev));
 
 	ctx->cxlr = cxlr;
+	ctx->cxled = cxled;
 
 	return 1;
 }
 
-struct cxl_region *cxl_dpa_to_region(const struct cxl_memdev *cxlmd, u64 dpa)
+struct cxl_region *cxl_dpa_to_region(const struct cxl_memdev *cxlmd, u64 dpa,
+				     struct cxl_endpoint_decoder **cxled)
 {
 	struct cxl_dpa_to_region_context ctx;
 	struct cxl_port *port;
@@ -2888,6 +2891,9 @@ struct cxl_region *cxl_dpa_to_region(const struct cxl_memdev *cxlmd, u64 dpa)
 	if (port && is_cxl_endpoint(port) && cxl_num_decoders_committed(port))
 		device_for_each_child(&port->dev, &ctx, __cxl_dpa_to_region);
 
+	if (cxled)
+		*cxled = ctx.cxled;
+
 	return ctx.cxlr;
 }
 

-- 
2.49.0


From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from mgamail.intel.com (mgamail.intel.com [192.198.163.18])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id 7B7B51F3FEB
	for <nvdimm@lists.linux.dev>; Sun, 13 Apr 2025 22:52:35 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=fail smtp.client-ip=192.198.163.18
ARC-Seal: i=2; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1744584757; cv=fail; b=EiwpNkwmz5eH/ITVhWLW5ihsmofNb2bNxqEp364LvyxZeiG3tWFGWYRZ7We7G0CgGlTN2i2c+hyVR7MbT7jRPTowmhyX3iL9xySvvtGfPZtLnoadJadgPXUJpbXW6dWBP9lmrI7OUF+pCJ0DqAwjBQUyYOtDKQFZEwwAM1b4qRQ=
ARC-Message-Signature: i=2; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1744584757; c=relaxed/simple;
	bh=4QxktrWxnejqz2TUfcmWO6HRceAt1/3c56ZBgEUdUaI=;
	h=From:Date:Subject:Content-Type:Message-ID:References:In-Reply-To:
	 To:CC:MIME-Version; b=DmVYoSBFlnqtZNJhjhrBs4sHz8g254EuFgW+3X1J40VPDgbB9UV3fknu6wp/SBrt+2EqhfwHlaL69jCedxRiltrjw35FQo3w0HAI8sp5+s8NN17cWJC22+0C4N/matvg/D7NuRCsdZ1U7E7i1ux4tQadILkn1Rr6d/6nwGgp63E=
ARC-Authentication-Results: i=2; smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=intel.com; spf=pass smtp.mailfrom=intel.com; dkim=pass (2048-bit key) header.d=intel.com header.i=@intel.com header.b=gzCWUHOo; arc=fail smtp.client-ip=192.198.163.18
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=intel.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=intel.com
Authentication-Results: smtp.subspace.kernel.org;
	dkim=pass (2048-bit key) header.d=intel.com header.i=@intel.com header.b="gzCWUHOo"
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1744584756; x=1776120756;
  h=from:date:subject:content-transfer-encoding:message-id:
   references:in-reply-to:to:cc:mime-version;
  bh=4QxktrWxnejqz2TUfcmWO6HRceAt1/3c56ZBgEUdUaI=;
  b=gzCWUHOo9wYeIXeBMvuOMzBpZ7lv6UWdJTZHKxZ0oWz8KgeXA3bcMxnr
   5hOUslJJn4Oc1MLHNKrlsAaBbC3xB2z5MwWlTsZ2wMF7WHHKiEViu9uso
   RMGHoDSZfTry6mkeYnoNBVGL9IDGKbZhtAqVSA/Y0TymZoAzvu9BLtAcq
   4K9eM1PkkorPEs6LSzprdbav5Nl0PFuIHhRskettpd/5yJ4wczaDPdgbA
   lveI8q4h+aeBtoyoB3vlV3xJe+Mhi0PEVZ+94Cid60RZdxTH+x+kDFWdT
   xy3HRFhZf39a2CMxPmtCr8vAwcuRtekLKX53z8TXkfv1tsGXsSiyu4zvj
   A==;
X-CSE-ConnectionGUID: 8g+T8kqoRHCDx9cnBQjkng==
X-CSE-MsgGUID: RAM0OeLTRPi9k9SfW59zoQ==
X-IronPort-AV: E=McAfee;i="6700,10204,11402"; a="45280960"
X-IronPort-AV: E=Sophos;i="6.15,211,1739865600"; 
   d="scan'208";a="45280960"
Received: from fmviesa007.fm.intel.com ([10.60.135.147])
  by fmvoesa112.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 13 Apr 2025 15:52:35 -0700
X-CSE-ConnectionGUID: hucgneI/QBy8+4zmjQaRCw==
X-CSE-MsgGUID: 42k62g37RrK55hw3QiNPzA==
X-ExtLoop1: 1
X-IronPort-AV: E=Sophos;i="6.15,211,1739865600"; 
   d="scan'208";a="129657634"
Received: from orsmsx902.amr.corp.intel.com ([10.22.229.24])
  by fmviesa007.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 13 Apr 2025 15:52:35 -0700
Received: from ORSMSX901.amr.corp.intel.com (10.22.229.23) by
 ORSMSX902.amr.corp.intel.com (10.22.229.24) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.2.1544.14; Sun, 13 Apr 2025 15:52:34 -0700
Received: from orsedg603.ED.cps.intel.com (10.7.248.4) by
 ORSMSX901.amr.corp.intel.com (10.22.229.23) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.2.1544.14 via Frontend Transport; Sun, 13 Apr 2025 15:52:34 -0700
Received: from NAM02-SN1-obe.outbound.protection.outlook.com (104.47.57.44) by
 edgegateway.intel.com (134.134.137.100) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.44; Sun, 13 Apr 2025 15:52:33 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector10001; d=microsoft.com; cv=none;
 b=pa2G21XfKcJlz/lYAe7jXxcoEBrGy+x6wRpJ2eTHZZHWkYb8ftLIkj8QaYFC9wQQHUb+TAK9fUtGm+UZ8nyNo+0KIbYpBm4bLF2Wa2eeWEeSrBAdesR9DjQ2Gg4+MLVVbJh84qLXEshow+iOTfXTE1U0MwJSN1xhXea5iI9KDfiI2lts4e+iApiTMG6cJh50pj4IVEooiydw/XVG8hSC7DSc1L+rrqTe+sqY4HM/fGmiFiXPSmn49+JC3QsQRJdrV/6lsT59F6g1rDfyKUFqPmnQEX+KpnCCyX/dE2lCd+jos3gcTglMkUNV9bbuy3Akn1RM18DehMZFsyeQAG4KEg==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector10001;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=MvYgRMhAktNXF4t/3pfUAOXXg8C+qZBgHgfffXR6mRU=;
 b=oLGmzMkDhxuJRsxN22dijTAcd+1BV5bSF97qISlJRnmAezbYOFYl9eQ25HSr+htClXSKh+XB6ZxLp17oGErknFK8a1zL7nscXUDlAjsRpuaR5TMulwA2TfRCGDiI7jNLDoP6K4CzDiXuTE0p1TWgKPskUZqX9/c3BmWo1vYuaOtIbzW/xZxYJynuY1X5PVb8vkDqYB8choKDnCTfgzHiZsDTYpW5X6w2eddFRhhqRoFdYHsuuSCdXxcfRy7neiDoGzlGzGHX+t5lv2uQPJS7jh4/qbgqD6M3afnl1YjHPK/5z5jNJqsp+FFipT9efqoDfdAqdcUz5oOE9UzpB9rMog==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from MW4PR11MB6739.namprd11.prod.outlook.com (2603:10b6:303:20b::19)
 by PH7PR11MB7003.namprd11.prod.outlook.com (2603:10b6:510:20a::16) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.8632.33; Sun, 13 Apr
 2025 22:52:04 +0000
Received: from MW4PR11MB6739.namprd11.prod.outlook.com
 ([fe80::a7ad:a6e8:fced:3f24]) by MW4PR11MB6739.namprd11.prod.outlook.com
 ([fe80::a7ad:a6e8:fced:3f24%4]) with mapi id 15.20.8606.033; Sun, 13 Apr 2025
 22:52:04 +0000
From: Ira Weiny <ira.weiny@intel.com>
Date: Sun, 13 Apr 2025 17:52:21 -0500
Subject: [PATCH v9 13/19] cxl/region/extent: Expose region extent
 information in sysfs
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: 7bit
Message-ID: <20250413-dcd-type2-upstream-v9-13-1d4911a0b365@intel.com>
References: <20250413-dcd-type2-upstream-v9-0-1d4911a0b365@intel.com>
In-Reply-To: <20250413-dcd-type2-upstream-v9-0-1d4911a0b365@intel.com>
To: Dave Jiang <dave.jiang@intel.com>, Fan Ni <fan.ni@samsung.com>, "Jonathan
 Cameron" <Jonathan.Cameron@huawei.com>
CC: Dan Williams <dan.j.williams@intel.com>, Davidlohr Bueso
	<dave@stgolabs.net>, Alison Schofield <alison.schofield@intel.com>, "Vishal
 Verma" <vishal.l.verma@intel.com>, Ira Weiny <ira.weiny@intel.com>,
	<linux-cxl@vger.kernel.org>, <nvdimm@lists.linux.dev>,
	<linux-kernel@vger.kernel.org>
X-Mailer: b4 0.15-dev-c25d1
X-Developer-Signature: v=1; a=ed25519-sha256; t=1744584735; l=4964;
 i=ira.weiny@intel.com; s=20221211; h=from:subject:message-id;
 bh=4QxktrWxnejqz2TUfcmWO6HRceAt1/3c56ZBgEUdUaI=;
 b=KXsGvbveT4s3jlccnLfPtcpIne+PH6RDv1qMtHp9JjK0/d5oC6VwfYnbnUeflSx+a8NH3ma80
 338X1M1ZU7mCB8fIijUF6yGiBMv2LLb6V6KkQqxWnWE7f7mHaSathc1
X-Developer-Key: i=ira.weiny@intel.com; a=ed25519;
 pk=noldbkG+Wp1qXRrrkfY1QJpDf7QsOEthbOT7vm0PqsE=
X-ClientProxiedBy: MW4PR03CA0227.namprd03.prod.outlook.com
 (2603:10b6:303:b9::22) To MW4PR11MB6739.namprd11.prod.outlook.com
 (2603:10b6:303:20b::19)
Precedence: bulk
X-Mailing-List: nvdimm@lists.linux.dev
List-Id: <nvdimm.lists.linux.dev>
List-Subscribe: <mailto:nvdimm+subscribe@lists.linux.dev>
List-Unsubscribe: <mailto:nvdimm+unsubscribe@lists.linux.dev>
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: MW4PR11MB6739:EE_|PH7PR11MB7003:EE_
X-MS-Office365-Filtering-Correlation-Id: 434ae3cb-3d29-4c63-ebd5-08dd7addcf28
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;ARA:13230040|366016|376014|1800799024|7053199007;
X-Microsoft-Antispam-Message-Info: =?utf-8?B?WGw2elVjY3M4c1VrbUZ1YWJBTVRDODJtT1ZHZVFYQjVpaU9ENFFYZlZYZUVO?=
 =?utf-8?B?WTVlbTdhRER4dTA3T1NNVW9OUnZ2Ti9GTVRlV0lULzBoZW9RbC9ucnIxOEpa?=
 =?utf-8?B?YXNCaks2YmhIcjkxaE5JdTlINVJWZmIzeElIUWZ0TGlPdEpZakgxTVZmTTlh?=
 =?utf-8?B?ajF0a0NxTUNmSjFNKzNRNGFpUmNjUjhnemE2WXJBcUJGNVgxb052RVN6ejhW?=
 =?utf-8?B?TmdQRExhalFrVkFVUVFFeFdwWGpFTmIvSnl3MUtPUVRMZC9XS2pLdFhjNGFu?=
 =?utf-8?B?WWRTUlMwZVl4ZldrYXFJY2J0bXdiakVBSitSMjBDNzRRcTVBb0VBOE9UTDBx?=
 =?utf-8?B?d3ZneGpHM1o1dUVyNXVEZ0lQT3Mrd1hqREhNWCtkRGhoSnpxS1kyQ0Fjb1c1?=
 =?utf-8?B?akxwY0NyMFBuTC8wOWtqRU9NU3NWa3BoTkxxVzZha0I1ZzJIc2ZZaGlQcUdB?=
 =?utf-8?B?dFhLYm0vNFUvcWFYejQ4VWZxR3VtWnZQc3hpZ1lWUlo3Wm9IR2RlMXlvQUM1?=
 =?utf-8?B?REt6V251Ukd1TjB1aFBFdTFDTmp0L3NUKzVqaThucE4yVElwMUQvSE9aRnlL?=
 =?utf-8?B?YU94NnRIZFRVejY3YzBlYjE0REo1NWxBNkVVSk9MK1FIWkFFaHM4QWdrY0Yv?=
 =?utf-8?B?UE5kZHg5UkE2NCtBRnU1eDR0eXYzT2lZWjlGSUR1cUN0N1pRNUdwcVplcWZt?=
 =?utf-8?B?UkJKWm1zbjVBcmFKUlFSUHFEL3ZMUUNYaHRZaExscCtEU1Y0c3VVMFNock9M?=
 =?utf-8?B?UTM1eEFuK3RCZ0F2c1BIbFZzRXVOVDRyaG9TbWczM3FXSkU3WkMzNG0rVWVZ?=
 =?utf-8?B?TGxEMVdYVTBXRzJkZk5xVm9KY0UzYzZIV3JjVnVsd3psQ05GT2JMeXlVVG1R?=
 =?utf-8?B?dWZRL21SN2tMRjM0L1ZFb2toZzhobStOR1Zad3RkWHNUSjZMLzlYUnhDQlBT?=
 =?utf-8?B?TE5YaWNjRGZUMlNYSW1GTkxXUEFEODhWM0sra01sUXpvV0VWVUw4ZlJINkY4?=
 =?utf-8?B?NjZOSG9WOXNKWlNNakhQaElTS244K2lsMUVBT2JRY283QTgvL2RoenhrWUZU?=
 =?utf-8?B?ajR3N1ZqaW9NYitBWFpFUEZ2eEtNWE9NSDI0THVlNkJVeWJpcFB2OXd1clcr?=
 =?utf-8?B?Y3dXWVltOTQvNlB6TndwdXNHSkh5MUhYTlBIRjM2S2l3SVlnbjFQVVMzc1R2?=
 =?utf-8?B?eis1TGhGNEdCNU1GTFY5aTFnZTU2aFpWZXY3VVdoSGx5Ni83bzk1KzlWYTVF?=
 =?utf-8?B?MjFPYTVjSWhhaWdmWmtoR2IxUTZ0c3RYeXE0eFpqaDBSRGZndXhaQVN5aEJI?=
 =?utf-8?B?eWgvSnlLbG5UcDZhWVMvdVZrTzR4ZVZkV2kzWnNXUGl6cTNyaEx1ejRDQ0No?=
 =?utf-8?B?ZzUwK1pmN1hNWVd1NGw3QnJCcUF3SnI1RnNQdGw1SHBYZC9Bc3ErOE5HSktz?=
 =?utf-8?B?ajZlRENuRy9zeEc5dUp4RzFTcWZhaXpOb2xFcmZYS05aQVFidFNjNm5WUnEy?=
 =?utf-8?B?dVBtbEt5Q0hOamNhbjduY2QwSEVZUXNXN2J6eGdTRkJFUFFzYjgrWmhpcUd0?=
 =?utf-8?B?c3krUGhzSGppV1BFcDBXNXpYQ05QeDBRVUQwemNaVmtjWXNFZDRaM2pHWjg4?=
 =?utf-8?B?MEhJSGRkWmQ3K2tLMmRvSzVqaVdmNVM3bUxON0Z2Vis2VzNkVnpJSUdsSExt?=
 =?utf-8?B?OEk0ckdIOUtYL2ZNZkdGZ0RaYUkrVVdXZURCcmhOTXhWSWd5UmZvOTV5MWJZ?=
 =?utf-8?B?TzlhSXh1SmJHT2UySmVZWEJESGxuOWJkQ3ZUOHRGemtqNk1HMzl0VlNGUkta?=
 =?utf-8?B?ZjJFRHA3Wml3eUxHa0o2eG42RUdrRUhQbkY1TVB5VnRZaWVkNDVseHA3cFkw?=
 =?utf-8?B?VTNzcXBUYkpSSTVybVFkMkhiZmpZeDhoQWFpTU0wTlpEbGFndTU3TUN6T3FX?=
 =?utf-8?Q?ZtaG0xIk2ZQ=3D?=
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:MW4PR11MB6739.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230040)(366016)(376014)(1800799024)(7053199007);DIR:OUT;SFP:1101;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?utf-8?B?TEtVbW1NaUg5Z2U1VDh4Tmc3UnR0OFpKR2M0czhnWlV3dzlGYTdLQ3I1WHNL?=
 =?utf-8?B?RTFCc0tCbENNb255WVZVSUM4a3JSNDFhdjRSeWhrM2krRVh0Kzc0OERGb2py?=
 =?utf-8?B?Qk1td1J5Y21RYWFNdXVkZU9vOEU5Q2dOM2JIakRsQUh3dk4xVGhVMFk3QlE4?=
 =?utf-8?B?NzUvM0kvZ0lLblU5eitXYjdZaW9EZ0x0ODByTHk3L0Z1dmNFazMraXVWRFJa?=
 =?utf-8?B?VHJiN0x6RzhwOEQ2UUJKZk5nR1FPaU1tUktMS1pwZkJyNCtKRlQwZU1MWlox?=
 =?utf-8?B?WHNzUnJLL3RiMkZUMzRUMzcwWXdhYmV3c2dNcWpSTWo5bTRMRWNJeEZQaTJE?=
 =?utf-8?B?RHFObnQ4dVFxWjhPeEtPNkFsQUMwN3p0NWRIbkcvQzJMblNsUFgzdC9uUzdP?=
 =?utf-8?B?c3FJVVNaZmFsMzR5OVNXK2NiM2Zka1lMc0xTRzVVVGttWDBWMk84S1owS2hO?=
 =?utf-8?B?ZGxVc3lRVTBSTTFqbnVNMU4zNGlGeHVwUE5UbjhIK25CaC9iNmFvVGZSbkpV?=
 =?utf-8?B?RzhINlpEV2trTzh6YnVjRWwxeDUxTnROWnhPWmVJNWwzOHhOQTgxdDR5cExW?=
 =?utf-8?B?ZXBnWVBzTnFEcGNiWkRHSjJmUnNZOGpUZjZDb2NqU1htWTBaMlVvcEdlOVhN?=
 =?utf-8?B?TXoya1FZYUlTelg4Kyt5clJhVWFsMjFqUWI0dmxkQ25qU1Y2bFBHMzg5T0Vr?=
 =?utf-8?B?YmYrN25wemdYaW83SkxERGFwekhLSm5Qc3ZDVjROZURNVDFVMVNRdGk5V09v?=
 =?utf-8?B?RFNDZnBLa2IwbTdHdmhXb1p3elYxNzJ1ZkdUdGFyaWgxU3I4dUV5TGYzbVMw?=
 =?utf-8?B?a08rYTh5V1VmSkp6bXh3QUpXdDI4SGRoemxjSGRoSFdsRTJyNnlaV3p5S3NH?=
 =?utf-8?B?VDZqdmdFazRtOHdtM0ViMWJhYlMzK3dDekJ5eGpzbEQ4QTlSVGlNeVR4TjY3?=
 =?utf-8?B?T294M1Z1aWpubG0wbXpvR0pkOThnQ2pnWEcwcldRaVJSN2hTbExlUHBQUE1R?=
 =?utf-8?B?dFFScTlUR1IvQTd3U1NvSDhiaXVBaTYzK2wzeTlKWVo5S1BpU244NDFpd0da?=
 =?utf-8?B?WVNrMVZDaE5uZ0dnNWRUU3pBa2dmZ2RyQmFrdURycE0wV2FTV1puS3dNWGw1?=
 =?utf-8?B?eVVFMWxLYTZFbWd3M2dQWmlvaTBIRDBvRDR3SFovczdwR2FGS0wyYkpLblZx?=
 =?utf-8?B?czkyQWFNcElwMk1XV3dSdXRsRXFVaU11UzBJbHJpWjluYmFmanhjK09wcUph?=
 =?utf-8?B?TGdMdkRFZnZMTjJSeDVDOFdQWjhvM3gvRUlmRlVDMEdJQW9tV2taVWJSZ1lh?=
 =?utf-8?B?OGlucEJqS3laWk1hekV5bC9aMnpLTWNwdnZDcy93N0VlQTlxVlo2K0FhZW53?=
 =?utf-8?B?cWM2cWJ2VlZTU0NXNHVQdFBTU1Bvd0dXcmRha3lPNTRjL014aElhL3g2UmNY?=
 =?utf-8?B?cWN5Ri9UbEtGSXNEWlJTNFJuZ0tXL0Nubk5zbVIyVXN6NEZSbTJZTGNJYW52?=
 =?utf-8?B?L29idFpYVWN1NmxYWmJkVEozQ2diU05telhqYmtJc1E2NlpKbDJOSmYra3I3?=
 =?utf-8?B?NkhNYUNkYjZnM1JseGhVUVR2SmpLNWg4SXZZNk41V2E1Qkd4ZEJzZVVWcjUy?=
 =?utf-8?B?Z1h4emZ2dk5nemNhMExxZ0gzZ1BqN1J0VnIvaUZ4YzhTVitJS2I0OC9ka3dv?=
 =?utf-8?B?ZC92SmxqVnZBNW1XNzdZeFJ6R0RXcHFwSXR4Nlp2VEtBbnk0V3BDWkFJTzEx?=
 =?utf-8?B?cm1kUWprV3dvN3lvTnYwWTdOSVJFWWduS1VkVjQ2dkhrdkNLaWxFQ2p1OFpu?=
 =?utf-8?B?RWZTSExvY1FRTzFEcWlHdHUraVV2b2Q4MzUvOTdBQU9LVm1TYUZrRmFiVUg5?=
 =?utf-8?B?K1g1ekR4dEIzam5aeFdQcXN4MitBNzRBQ3RRWG1hYUNXbkY2dlMyZDdQa25K?=
 =?utf-8?B?cUNpTVdlNXpnRFNrNzBudCsxUGxzb2s5UWF2WTZDc1lMRXI0cXlzY3FKdXQx?=
 =?utf-8?B?WmZtNjF0VzlTMDkvd1NSNGthaTZhMEZoNElJQVFySWFwdS81eEl5T2szSzNR?=
 =?utf-8?B?K3BtYTljRjJyVThiblRwK3hKMFdvZis5S2IycUZVVndtZXZyVEU1QitReVY5?=
 =?utf-8?Q?8awORSq61wSnwAN+0VXOF8v+h?=
X-MS-Exchange-CrossTenant-Network-Message-Id: 434ae3cb-3d29-4c63-ebd5-08dd7addcf28
X-MS-Exchange-CrossTenant-AuthSource: MW4PR11MB6739.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 13 Apr 2025 22:52:04.0304
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: 0rCIlEwUDPezvvAkC8bcyapHq1+fOHAk+9iBIzRE0fxCZQm16TwgyxPcNeJdfsG1v1Z3DYniFRHO6sZ4B+bZtg==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: PH7PR11MB7003
X-OriginatorOrg: intel.com
Status: RO
Content-Length: 4814
Lines: 152

Extent information can be helpful to the user to coordinate memory usage
with the external orchestrator and FM.

Expose the details of region extents by creating the following
sysfs entries.

        /sys/bus/cxl/devices/dax_regionX/extentX.Y
        /sys/bus/cxl/devices/dax_regionX/extentX.Y/offset
        /sys/bus/cxl/devices/dax_regionX/extentX.Y/length
        /sys/bus/cxl/devices/dax_regionX/extentX.Y/tag

Based on an original patch by Navneet Singh.

Reviewed-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
Reviewed-by: Fan Ni <fan.ni@samsung.com>
Tested-by: Fan Ni <fan.ni@samsung.com>
Signed-off-by: Ira Weiny <ira.weiny@intel.com>

---
Changes:
[iweiny: rebase]
[iweiny: s/tag/uuid/ throughout the code]
[iweiny: update sysfs docs to 2025]
---
 Documentation/ABI/testing/sysfs-bus-cxl | 36 ++++++++++++++++++++
 drivers/cxl/core/extent.c               | 58 +++++++++++++++++++++++++++++++++
 2 files changed, 94 insertions(+)

diff --git a/Documentation/ABI/testing/sysfs-bus-cxl b/Documentation/ABI/testing/sysfs-bus-cxl
index 2e26d95ac66f..6e9d60baf546 100644
--- a/Documentation/ABI/testing/sysfs-bus-cxl
+++ b/Documentation/ABI/testing/sysfs-bus-cxl
@@ -639,3 +639,39 @@ Description:
 		The count is persistent across power loss and wraps back to 0
 		upon overflow. If this file is not present, the device does not
 		have the necessary support for dirty tracking.
+
+
+What:		/sys/bus/cxl/devices/dax_regionX/extentX.Y/offset
+Date:		May, 2025
+KernelVersion:	v6.16
+Contact:	linux-cxl@vger.kernel.org
+Description:
+		(RO) [For Dynamic Capacity regions only] Users can use the
+		extent information to create DAX devices on specific extents.
+		This is done by creating and destroying DAX devices in specific
+		sequences and looking at the mappings created.  Extent offset
+		within the region.
+
+
+What:		/sys/bus/cxl/devices/dax_regionX/extentX.Y/length
+Date:		May, 2025
+KernelVersion:	v6.16
+Contact:	linux-cxl@vger.kernel.org
+Description:
+		(RO) [For Dynamic Capacity regions only] Users can use the
+		extent information to create DAX devices on specific extents.
+		This is done by creating and destroying DAX devices in specific
+		sequences and looking at the mappings created.  Extent length
+		within the region.
+
+
+What:		/sys/bus/cxl/devices/dax_regionX/extentX.Y/uuid
+Date:		May, 2025
+KernelVersion:	v6.16
+Contact:	linux-cxl@vger.kernel.org
+Description:
+		(RO) [For Dynamic Capacity regions only] Users can use the
+		extent information to create DAX devices on specific extents.
+		This is done by creating and destroying DAX devices in specific
+		sequences and looking at the mappings created.  UUID of this
+		extent.
diff --git a/drivers/cxl/core/extent.c b/drivers/cxl/core/extent.c
index 6df277caf974..3fb20cd7afc8 100644
--- a/drivers/cxl/core/extent.c
+++ b/drivers/cxl/core/extent.c
@@ -6,6 +6,63 @@
 
 #include "core.h"
 
+static ssize_t offset_show(struct device *dev, struct device_attribute *attr,
+			   char *buf)
+{
+	struct region_extent *region_extent = to_region_extent(dev);
+
+	return sysfs_emit(buf, "%#llx\n", region_extent->hpa_range.start);
+}
+static DEVICE_ATTR_RO(offset);
+
+static ssize_t length_show(struct device *dev, struct device_attribute *attr,
+			   char *buf)
+{
+	struct region_extent *region_extent = to_region_extent(dev);
+	u64 length = range_len(&region_extent->hpa_range);
+
+	return sysfs_emit(buf, "%#llx\n", length);
+}
+static DEVICE_ATTR_RO(length);
+
+static ssize_t uuid_show(struct device *dev, struct device_attribute *attr,
+			 char *buf)
+{
+	struct region_extent *region_extent = to_region_extent(dev);
+
+	return sysfs_emit(buf, "%pUb\n", &region_extent->uuid);
+}
+static DEVICE_ATTR_RO(uuid);
+
+static struct attribute *region_extent_attrs[] = {
+	&dev_attr_offset.attr,
+	&dev_attr_length.attr,
+	&dev_attr_uuid.attr,
+	NULL
+};
+
+static uuid_t empty_uuid = { 0 };
+
+static umode_t region_extent_visible(struct kobject *kobj,
+				     struct attribute *a, int n)
+{
+	struct device *dev = kobj_to_dev(kobj);
+	struct region_extent *region_extent = to_region_extent(dev);
+
+	if (a == &dev_attr_uuid.attr &&
+	    uuid_equal(&region_extent->uuid, &empty_uuid))
+		return 0;
+
+	return a->mode;
+}
+
+static const struct attribute_group region_extent_attribute_group = {
+	.attrs = region_extent_attrs,
+	.is_visible = region_extent_visible,
+};
+
+__ATTRIBUTE_GROUPS(region_extent_attribute);
+
 static void cxled_release_extent(struct cxl_endpoint_decoder *cxled,
 				 struct cxled_extent *ed_extent)
 {
@@ -44,6 +101,7 @@ static void region_extent_release(struct device *dev)
 static const struct device_type region_extent_type = {
 	.name = "extent",
 	.release = region_extent_release,
+	.groups = region_extent_attribute_groups,
 };
 
 bool is_region_extent(struct device *dev)

-- 
2.49.0


From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from mgamail.intel.com (mgamail.intel.com [192.198.163.18])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id 71D1F20F081
	for <nvdimm@lists.linux.dev>; Sun, 13 Apr 2025 22:52:37 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=fail smtp.client-ip=192.198.163.18
ARC-Seal: i=2; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1744584759; cv=fail; b=b7XZt5knskk3AY0z8xS5icob4ig39P4FHQURQ426WMjT6sJmlEam/t3OeZnm25s7egxIE+do4chE+AYS//AL17rGeCHhOsqDRQ0EaWURvCWGgo9Ebk3GCVEdyaxGCqdkYXUmFoEr6V09nPOThszsvi7GpinkEV4ab//CJtAjm3g=
ARC-Message-Signature: i=2; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1744584759; c=relaxed/simple;
	bh=hIzly7Huia2oFq0h25HsM1O8AIHB+uENrUA+sLPFMr8=;
	h=From:Date:Subject:Content-Type:Message-ID:References:In-Reply-To:
	 To:CC:MIME-Version; b=m9OVFa2F6gk5/vB68+5sY25C992Ojac18u9Fa2IMTjw+xed3+Xe6Ib+x3U+N7W/Dz7ysEhHDDs0yZC/+Md3HKENkNfRhl9oxL5JyR3AjK6ygSfxLdRPBCHJ6iL/guBl9B9SqoNZT6RNfNBTzRhtt32b7H3pUm/RNGi1ForLAIQ0=
ARC-Authentication-Results: i=2; smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=intel.com; spf=pass smtp.mailfrom=intel.com; dkim=pass (2048-bit key) header.d=intel.com header.i=@intel.com header.b=ZXPAOmXy; arc=fail smtp.client-ip=192.198.163.18
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=intel.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=intel.com
Authentication-Results: smtp.subspace.kernel.org;
	dkim=pass (2048-bit key) header.d=intel.com header.i=@intel.com header.b="ZXPAOmXy"
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1744584758; x=1776120758;
  h=from:date:subject:content-transfer-encoding:message-id:
   references:in-reply-to:to:cc:mime-version;
  bh=hIzly7Huia2oFq0h25HsM1O8AIHB+uENrUA+sLPFMr8=;
  b=ZXPAOmXyBkcz01K3A0ywjHp/w40fyERRFn0UaTUCu5sCnW8SYKEyFoWq
   yeyStHYSWYvPY1PexYWej5SRtemydUmlq8KAmjHY4A0azOIzMmQlcjO6a
   Zfmkvgv5YMmxqL0jXWR7SKiYGAdEYuWRUls+sc/Ns6b3akq8gNJTmZSxj
   I5yEiRiLwI1rlXCglBkoEU/d4gHGDYonKX1velyLXGzSh19Si4VP+YNS6
   Bm+rCXgN/LwB3goA5+1v3C1RC+b+A/bz4ggb+piCkCWX9ehci0tYp5gqR
   L+22CSOxpT4JH+nmQNpgqlAv26aRGH9wX4BRC0xShaucH7aRmHXZyTtcy
   Q==;
X-CSE-ConnectionGUID: mM3HhavFSjCqnBbcWIijrQ==
X-CSE-MsgGUID: 9HF1OwZ5RPa6tjipgfH2/A==
X-IronPort-AV: E=McAfee;i="6700,10204,11402"; a="45280971"
X-IronPort-AV: E=Sophos;i="6.15,211,1739865600"; 
   d="scan'208";a="45280971"
Received: from fmviesa007.fm.intel.com ([10.60.135.147])
  by fmvoesa112.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 13 Apr 2025 15:52:37 -0700
X-CSE-ConnectionGUID: 3NXhHjWVT9ykHcVjpKcyBw==
X-CSE-MsgGUID: OF3/jx1rT7+eL1hkcNEzkA==
X-ExtLoop1: 1
X-IronPort-AV: E=Sophos;i="6.15,211,1739865600"; 
   d="scan'208";a="129657636"
Received: from orsmsx902.amr.corp.intel.com ([10.22.229.24])
  by fmviesa007.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 13 Apr 2025 15:52:37 -0700
Received: from ORSMSX901.amr.corp.intel.com (10.22.229.23) by
 ORSMSX902.amr.corp.intel.com (10.22.229.24) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.2.1544.14; Sun, 13 Apr 2025 15:52:36 -0700
Received: from orsedg603.ED.cps.intel.com (10.7.248.4) by
 ORSMSX901.amr.corp.intel.com (10.22.229.23) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.2.1544.14 via Frontend Transport; Sun, 13 Apr 2025 15:52:36 -0700
Received: from NAM02-SN1-obe.outbound.protection.outlook.com (104.47.57.44) by
 edgegateway.intel.com (134.134.137.100) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.44; Sun, 13 Apr 2025 15:52:35 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector10001; d=microsoft.com; cv=none;
 b=MK+u93b3Rji4AgMikp6ENX6Au4cRzs3ZzoVuZbP8cdyMd5kPaw7ux27GmoTe/NdQABOBRUZlYMnIesaADb9RsKfPH8+d/LQd7qx74dfANbwdE3eKF9268z32cxdQ2Yxngi7oV6V7LCaAi6R5/NfuBHXqL52aLr8nY+ep7JpaxlhC4eY3IorUiTQMcsTg5nIfEF7cVBfNPCUO1gZS9ezkrTkrtIBgiH2SsqITY76p+Djmr/i3JjMImHFm2ufIN/ThTrL5/5ef67d22Y1MiTZTpXoYX4hYqKeDavA1VSWCPx/0NscOAKInO4cpHap3dGdBQeN9DDicNNsMLozSr2b2RQ==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector10001;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=zNDIWhxO6Oq0+ekZCjsNilh5/+781UpnrG4oEYvajM4=;
 b=oVx0pn2Eh9pCCR4Ds47ykeCaWews/GHIgqlzXnE7CxFf/I8i0X1b3wI2uXSP9w/7p4QT3Gl16KyTA2DKyjTH9Z6aV2o3z3Dv8ILeNl8HLywlxpzUaMAvB3Hp+MhIIk9y2dmdtZQ3SHQgmpgnMdHca77bEsE4uj4QZQh+BNvOUZpNXTtM6GIKuGwtHRwsThVakpmNcDLJSh+p7InUVM7C8wljlqknCUThwigpdQKyONzxP9xX/ue17VxkIKr1kMnTuHmD1Q47qEvBez4y9eRRX54mQzKrPj3m8rRYyAWqwI4Eed7l2WtjYx7uhdXliqpTqc/e1IWOIwLUvxDY2vakig==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from MW4PR11MB6739.namprd11.prod.outlook.com (2603:10b6:303:20b::19)
 by PH7PR11MB7003.namprd11.prod.outlook.com (2603:10b6:510:20a::16) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.8632.33; Sun, 13 Apr
 2025 22:52:12 +0000
Received: from MW4PR11MB6739.namprd11.prod.outlook.com
 ([fe80::a7ad:a6e8:fced:3f24]) by MW4PR11MB6739.namprd11.prod.outlook.com
 ([fe80::a7ad:a6e8:fced:3f24%4]) with mapi id 15.20.8606.033; Sun, 13 Apr 2025
 22:52:12 +0000
From: Ira Weiny <ira.weiny@intel.com>
Date: Sun, 13 Apr 2025 17:52:26 -0500
Subject: [PATCH v9 18/19] tools/testing/cxl: Make event logs dynamic
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: 7bit
Message-ID: <20250413-dcd-type2-upstream-v9-18-1d4911a0b365@intel.com>
References: <20250413-dcd-type2-upstream-v9-0-1d4911a0b365@intel.com>
In-Reply-To: <20250413-dcd-type2-upstream-v9-0-1d4911a0b365@intel.com>
To: Dave Jiang <dave.jiang@intel.com>, Fan Ni <fan.ni@samsung.com>, "Jonathan
 Cameron" <Jonathan.Cameron@huawei.com>
CC: Dan Williams <dan.j.williams@intel.com>, Davidlohr Bueso
	<dave@stgolabs.net>, Alison Schofield <alison.schofield@intel.com>, "Vishal
 Verma" <vishal.l.verma@intel.com>, Ira Weiny <ira.weiny@intel.com>,
	<linux-cxl@vger.kernel.org>, <nvdimm@lists.linux.dev>,
	<linux-kernel@vger.kernel.org>
X-Mailer: b4 0.15-dev-c25d1
X-Developer-Signature: v=1; a=ed25519-sha256; t=1744584735; l=15739;
 i=ira.weiny@intel.com; s=20221211; h=from:subject:message-id;
 bh=hIzly7Huia2oFq0h25HsM1O8AIHB+uENrUA+sLPFMr8=;
 b=qpQkHpLuBE/2dAlhrUlSTLqrdxOrBEnFofzVUxY1p4gvHMRQH8V5CQTE1T7WkoNyRwDkIGx5k
 8k2ldon1HX8B8v5vWbPzhgPiHnVFeWtN5qX1ArR8P9Xe++yTahE/EA1
X-Developer-Key: i=ira.weiny@intel.com; a=ed25519;
 pk=noldbkG+Wp1qXRrrkfY1QJpDf7QsOEthbOT7vm0PqsE=
X-ClientProxiedBy: MW4PR03CA0227.namprd03.prod.outlook.com
 (2603:10b6:303:b9::22) To MW4PR11MB6739.namprd11.prod.outlook.com
 (2603:10b6:303:20b::19)
Precedence: bulk
X-Mailing-List: nvdimm@lists.linux.dev
List-Id: <nvdimm.lists.linux.dev>
List-Subscribe: <mailto:nvdimm+subscribe@lists.linux.dev>
List-Unsubscribe: <mailto:nvdimm+unsubscribe@lists.linux.dev>
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: MW4PR11MB6739:EE_|PH7PR11MB7003:EE_
X-MS-Office365-Filtering-Correlation-Id: 0a124e87-aaa0-43df-a72d-08dd7addd42b
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;ARA:13230040|366016|376014|1800799024;
X-Microsoft-Antispam-Message-Info: =?utf-8?B?dlBMbjloUGVPNCtZdXdIblE1STh2RG54RE4vNFNtZTlDNHQrRlZSbVFzeDJK?=
 =?utf-8?B?WjR0ekJBeDExYVNjTjE1aldONVN4cWZtVUV0dzh1amlqV1J2M0lnS3h6M0NT?=
 =?utf-8?B?dnM5akNtaXdyNmkvWmNPWVBtT2l4endTYTRNYWRUcEFUNHNLaHNSeXBPcUFa?=
 =?utf-8?B?Q0YyYllnMXI0TzBMdi8yZEhaa2V3Y3BoL1hJNVpjbWV2ckxoNThrZExzT2hU?=
 =?utf-8?B?cGZDVEF5UXpuYkFRTlk0MEVMMDB3dHFRd0l4ci9NcWt6dmFxUWNBUXBuR2dE?=
 =?utf-8?B?NStkTlpQTEJjbXMrTGN2MTM2SmxiMDBvSm5TMEptRDZodUVVbXV3QnNpVW5u?=
 =?utf-8?B?RFRRcmJjMm9ObFJDU1RGekJwc000SEFwaFlLZVJ6WnRNZGJqbmZOYVUreWdC?=
 =?utf-8?B?dWx3enNZbzlkR05xbHovanpja0luMjR3U0llWHRBcGxoYkg3WFFwVFdxL09P?=
 =?utf-8?B?YVFubmpaZ25QRTJWYjF2SUlvSENpeGtJaFVQUzVlZ3BQU3RwRmp6a04yUXEy?=
 =?utf-8?B?TlhTU25kV0JmSXVzMy9BUXlWQmYxTGZsem9jQitEMXVlMmFqVTg2dkxlMDg5?=
 =?utf-8?B?ZzlPUHFwN2VVajV3Q1hDWDQ1cUR0akdSb05vVEZVYi9FakxqTDdEc0dQcWlH?=
 =?utf-8?B?UWNSRk1zQllZK1FyTXZDKzhKbjVDNXpFR3RhQlYzeCtUdUhvdzJ1THhqczYv?=
 =?utf-8?B?TG5CNlRsV0RoYnlwN0xHMTFOeTd3SFRRbE56dVVCNFp5dVV2c3VObXpHN1h4?=
 =?utf-8?B?aXlsR2JJNTEwa1FxeDJ4Q2oxWE5kYWJjSnBjaWxPZ2NIeFdacVhpRU5kZEJ0?=
 =?utf-8?B?NG90L21MRnBkL0lKcEY2VzdOSTErbVg4UWVkMDJHbGZzUko1N0dTK2p2Vzlw?=
 =?utf-8?B?MmVWdXBBWmljSUlRS243cnRmZytwZG5CQjZvb1N2QjYya3RnU0U5ekVsRWxa?=
 =?utf-8?B?UGZMcXpaaFFrSE9XSDZWOEdHSEN1cDNUekVZMWlzQWg5ak1QV0YzUFh1QSs0?=
 =?utf-8?B?KzRzdWdXekVNaXErTEJqNHJjWnhaNTBBTmpUY0NlVi9IazhYQnNTM1FLM2dl?=
 =?utf-8?B?L1FBMGlJUHp1dEpaMDRUNUdWTU1hMmpWU3BVNkc3ZlVuZlorVTY1ZVdGYWVq?=
 =?utf-8?B?ZWcxRFZCaU85TjJxZ3BuanJYNmJCTjhPOHpYZzMzT3JEVGNISkREMEhWNHlM?=
 =?utf-8?B?SW5ONGhkcmUxanVHeVRzc0hwTmpTVDd6dlRkK25vYmNVMlYxV0VZWHVOUTRu?=
 =?utf-8?B?M3MwZ3lpYWtMYVBnTWlTUUJ3cmJJUVhlR3QvV3B3ZmZZVlpKWWt1V0NkZjZP?=
 =?utf-8?B?UUVFYU4wQ0tYZEMyQ2VGTVA3eDR2VjBIUG0yZzY5NUY3R3gydFNBYmQvdWZi?=
 =?utf-8?B?Z0lwaXB2RitnU1IyZjZpa1ZzR21qSlg3VkpsRk1Na2FBZVN3a0hyaVJBMnJn?=
 =?utf-8?B?MG81Y0h1VEh4azBSWkhPakFWMG92THhGaVdnUXFNek1HSTFRa1V3UTR0Z25D?=
 =?utf-8?B?cERzVDIxbUR5NU1sMWJlY1VoOFNXaGg2ZDZHMmJUUWF3dkY0dFRIdVBJRk40?=
 =?utf-8?B?dkg1RERpckFCWTQwQmtzdDJyMTZZa0ZFajljS1dYWTlsbGoyWm9yMUNLeXFO?=
 =?utf-8?B?dERXeFU2R1pHMzR2VkJnbC9ITEFGb0FxVEQ5aGhGVnk2Q3JoQzRJSUxlNGRs?=
 =?utf-8?B?OFVuSG5qYjAxUUNwR0FUN0w5dldhUkU1STVLcFZVa1drd0R4Y3NPRGZXc3dk?=
 =?utf-8?B?K0p2cFAzSTZKa3dUa2hybC9venNvbExiZW43a2NFVTc1K0YzZlIvcXJqQTFJ?=
 =?utf-8?B?eSthQzV0S04wN0tMOE5HQWhRSnZSZWwvdGNqQll0ZW1vRzRSVGhSMWxqdmlo?=
 =?utf-8?B?Nk1Bb3hGSWppY1BWck9jSk1Nb0lMRE00TnZ4MExwYU9ING1sWFB3VHNkUnBI?=
 =?utf-8?Q?LwF76e4GgaU=3D?=
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:MW4PR11MB6739.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230040)(366016)(376014)(1800799024);DIR:OUT;SFP:1101;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?utf-8?B?aDdUS2hPU3VTUWJ2c3Z3VlMxMTB2QllPZmVXczJqUXFjNkVhazZsYUhvNFJY?=
 =?utf-8?B?dXN1THMvakZ0TzhrbHIwTW5EeCtQejdLQVdLWU5aMWJtcmx0TEppUlVsTUl6?=
 =?utf-8?B?ZzV6UWI1dDFoeWRyOURCb0NNd3IvVEhZQStuYjlJODBLN0dyT2MxZlRlVlhJ?=
 =?utf-8?B?UHRHYVVCMXhZSXY4d1Ewc0pKMjNwSDlwdXNqNE5DWU10T1Vlcm1NNDA2R0Rk?=
 =?utf-8?B?NkY3QXJNMTJiK0NQZk95SjZvdWxHQjI4TnNYNFBjM05YQjRDVkVldklPWEFU?=
 =?utf-8?B?L2d6ekQrdExySzNrejMxTDNTbFNuRG8ycFByTDBibnNCZGZkT3MrdTE5RFND?=
 =?utf-8?B?QzR1bmExazd5Z3BINTdxdWxHRnJrM0dDZFRoOGNNZ1ViQi9vd0JnMXp3cHJw?=
 =?utf-8?B?U3JsR2t5SXZmTkFEcEMvR0JHT0lwS2lxKzRMNFNvRGIwQ0Vib1JIYXlaQklE?=
 =?utf-8?B?V3JXREEwNTFBU3BlQXgxdzBQWnJxRkVVbngvdTdQWm9jM3Q4dlRaNHBOeExS?=
 =?utf-8?B?eVZKSWdGcEt1QnhCSDBzODAzY081UTV1YnFack9mRU1lLzdEZTN1cWtsRDh3?=
 =?utf-8?B?dHFJbjBvbzhzM0k1N2g3bGF6RTZUUkppL3NQUlFrQ1E2eWNQUGZVdzUxeUlk?=
 =?utf-8?B?VVY3dnZrUXg3cWhnZjIzUWQyM2R1Z202S1hoZ2pweEZrd2hscHMxQlRkayt4?=
 =?utf-8?B?TnpBakgxTlVoMnpPZnFKN2JNaGJQdTZ5SHd3TzlIbi83VDNkK2syQm5wV0tD?=
 =?utf-8?B?Q0lyTUMwemZSMWhDTE5Fakx1alRad1ZTeXU5SDBidVc4TUN3M1NFVEhNVHFO?=
 =?utf-8?B?ZkVzNWFBcjBpRVF0Sy9kUHAvUmRNQzl1anovVGlEcGtiRWJsRmpnMHRzOGV1?=
 =?utf-8?B?bGUvaGlUV0xVdGwwRkwzRTJSenJzOUIyM3FJM2Z1c3QyNTZnNUJvUW9Zc2o5?=
 =?utf-8?B?Q2JjanZmVkFjbnR4TTlmY1Y2c1BkUmh5a09GaEdRZVN0VkhzS09ISG11MGhL?=
 =?utf-8?B?TlJTVTlBV1d2Y2VFb1YrWmtZcUJRR0RXSW1rOVZSbWMrTDUrUW9CWDJBVG1q?=
 =?utf-8?B?eFVabGd4L3VNdS9kUTBNak9uTHpLOC9JaVR3UVRzVkZYK0VDZm1CNDFKQ3Q2?=
 =?utf-8?B?dHByY3VEa2tPQUdzYmgzd0VJSkdOdFJYckFYc1dBdmJiOWtXcTZBK0c3dmtq?=
 =?utf-8?B?TUFWWDFMZExUbVNXbmNvU21naTdXTENZQjlJVWpMMEVWOUQzczBQOHIvQytN?=
 =?utf-8?B?REZOU29CeUhpVEhDcmN4NzgzMmpFVHJ6eHVyVVFjVlh5ZHdSLzZ0cUtBYnJB?=
 =?utf-8?B?VGJ3bTFpUXZoVnViMUVsN1lDa3JPeXBuSU55ZUxzTVFDdXMyWXI0UnRvSndo?=
 =?utf-8?B?MlF2ZUpWOVJZOG5VbzJwdzBNSDhEcElYTWhqWkZKaklkekNjenFyVDE5a0Rs?=
 =?utf-8?B?QmdxUldJVmE5MVlKNldzU2pkc1NYQ3FNZzVUbXA4dWdGSWN0cytOeEpBS1Z2?=
 =?utf-8?B?amNsaGh0TG42L0pQQ1BublVSSXgzc000a2VQd1o2WW5lM0Z3NVFqSW1OU0xZ?=
 =?utf-8?B?QlJhM2xzSHdvYzllSkhpM1QwalZUeXppdXltbllYUzdOcXBJamw3MmdZR1RC?=
 =?utf-8?B?NVRaNWsxeXFSY3JRUnZ0eTJ6d05yMzFKN0JHUkxZN0VTK3I0TElPMGo0dXNx?=
 =?utf-8?B?bnE4Qi9ldU15T2YvS0tTS2tMZk5FT1Q0eVNiaFBMNkhnRlFDVEJHVE5SZFRz?=
 =?utf-8?B?WkRaWmprNE9qWDArV0Z0anhzT2ZVK05IWElxZXVaT0tFQUsxcFFrOE5zWFRa?=
 =?utf-8?B?dHFEM2pTMVgvRDhCVmYyWUh4TUkzK2sxTzNnaVZrWHV4TVMwZEliTkgzNUpT?=
 =?utf-8?B?UU1xd1hyTVN0MDJzRTNOWnNQUnp1aGtZaFo3ekNua3JBaC95b0VGbkNQYTdq?=
 =?utf-8?B?Sy9uTjQ0NTVLUVRnTTJJbENRYUlDV3JUSDFSMDRnS0t0QmFSaDE0L3hGNTU4?=
 =?utf-8?B?ZjBDY0JXc29tbWw3REhUS0hSTjJCeHVoRWJzZDByNlltV1FLUnFzL1A5NnM0?=
 =?utf-8?B?cjZHTFh5L3R2UWRCUUZmbno0S3Q4RFpOYm9WQ1RWVk1Na0g2RjhFd3JHa3Jk?=
 =?utf-8?Q?VqFQHYJgF30XRCl5FWVZzh848?=
X-MS-Exchange-CrossTenant-Network-Message-Id: 0a124e87-aaa0-43df-a72d-08dd7addd42b
X-MS-Exchange-CrossTenant-AuthSource: MW4PR11MB6739.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 13 Apr 2025 22:52:12.5974
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: 1EIAslxKlp+yIFy6Tr0DqWm1oYAjhht0I2aJq7x15uGrKvUiJA/CltdeAaDzaG+3CoRJDOvZV8yPMyzPWbs1Eg==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: PH7PR11MB7003
X-OriginatorOrg: intel.com
Status: RO
Content-Length: 15301
Lines: 440

The event logs test was created as static arrays as an easy way to mock
events.  Dynamic Capacity Device (DCD) test support requires events be
generated dynamically when extents are created or destroyed.

The current event log test has specific checks for the number of events
seen including log overflow.

Modify mock event logs to be dynamically allocated.  Adjust array size
and mock event entry data to match the output expected by the existing
event test.

Use the static event data to create the dynamic events in the new logs
without inventing complex event injection for the previous tests.

Simplify log processing by using the event log array index as the
handle.  Add a lock to manage concurrency required when user space is
allowed to control DCD extents

Reviewed-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
Reviewed-by: Dave Jiang <dave.jiang@intel.com>
Signed-off-by: Ira Weiny <ira.weiny@intel.com>

---
Changes:
[iweiny: rebase to 6.15-rc1]
---
 tools/testing/cxl/test/mem.c | 268 ++++++++++++++++++++++++++-----------------
 1 file changed, 162 insertions(+), 106 deletions(-)

diff --git a/tools/testing/cxl/test/mem.c b/tools/testing/cxl/test/mem.c
index f2957a3e36fe..a71a72966de1 100644
--- a/tools/testing/cxl/test/mem.c
+++ b/tools/testing/cxl/test/mem.c
@@ -142,18 +142,26 @@ static struct {
 
 #define PASS_TRY_LIMIT 3
 
-#define CXL_TEST_EVENT_CNT_MAX 15
+#define CXL_TEST_EVENT_CNT_MAX 16
+/* 1 extra slot to accommodate that handles can't be 0 */
+#define CXL_TEST_EVENT_ARRAY_SIZE (CXL_TEST_EVENT_CNT_MAX + 1)
 
 /* Set a number of events to return at a time for simulation.  */
 #define CXL_TEST_EVENT_RET_MAX 4
 
+/*
+ * @last_handle: last handle (index) to have an entry stored
+ * @current_handle: current handle (index) to be returned to the user on get_event
+ * @nr_overflow: number of events added past the log size
+ * @lock: protect these state variables
+ * @events: array of pending events to be returned.
+ */
 struct mock_event_log {
-	u16 clear_idx;
-	u16 cur_idx;
-	u16 nr_events;
+	u16 last_handle;
+	u16 current_handle;
 	u16 nr_overflow;
-	u16 overflow_reset;
-	struct cxl_event_record_raw *events[CXL_TEST_EVENT_CNT_MAX];
+	rwlock_t lock;
+	struct cxl_event_record_raw *events[CXL_TEST_EVENT_ARRAY_SIZE];
 };
 
 struct mock_event_store {
@@ -194,56 +202,65 @@ static struct mock_event_log *event_find_log(struct device *dev, int log_type)
 	return &mdata->mes.mock_logs[log_type];
 }
 
-static struct cxl_event_record_raw *event_get_current(struct mock_event_log *log)
-{
-	return log->events[log->cur_idx];
-}
-
-static void event_reset_log(struct mock_event_log *log)
-{
-	log->cur_idx = 0;
-	log->clear_idx = 0;
-	log->nr_overflow = log->overflow_reset;
-}
-
 /* Handle can never be 0 use 1 based indexing for handle */
-static u16 event_get_clear_handle(struct mock_event_log *log)
+static u16 event_inc_handle(u16 handle)
 {
-	return log->clear_idx + 1;
+	handle = (handle + 1) % CXL_TEST_EVENT_ARRAY_SIZE;
+	if (handle == 0)
+		handle = 1;
+	return handle;
 }
 
-/* Handle can never be 0 use 1 based indexing for handle */
-static __le16 event_get_cur_event_handle(struct mock_event_log *log)
-{
-	u16 cur_handle = log->cur_idx + 1;
-
-	return cpu_to_le16(cur_handle);
-}
-
-static bool event_log_empty(struct mock_event_log *log)
-{
-	return log->cur_idx == log->nr_events;
-}
-
-static void mes_add_event(struct mock_event_store *mes,
+/* Add the event or free it on overflow */
+static void mes_add_event(struct cxl_mockmem_data *mdata,
 			  enum cxl_event_log_type log_type,
 			  struct cxl_event_record_raw *event)
 {
+	struct device *dev = mdata->mds->cxlds.dev;
 	struct mock_event_log *log;
 
 	if (WARN_ON(log_type >= CXL_EVENT_TYPE_MAX))
 		return;
 
-	log = &mes->mock_logs[log_type];
+	log = &mdata->mes.mock_logs[log_type];
+
+	guard(write_lock)(&log->lock);
 
-	if ((log->nr_events + 1) > CXL_TEST_EVENT_CNT_MAX) {
+	dev_dbg(dev, "Add log %d cur %d last %d\n",
+		log_type, log->current_handle, log->last_handle);
+
+	/* Check next buffer */
+	if (event_inc_handle(log->last_handle) == log->current_handle) {
 		log->nr_overflow++;
-		log->overflow_reset = log->nr_overflow;
+		dev_dbg(dev, "Overflowing log %d nr %d\n",
+			log_type, log->nr_overflow);
+		devm_kfree(dev, event);
 		return;
 	}
 
-	log->events[log->nr_events] = event;
-	log->nr_events++;
+	dev_dbg(dev, "Log %d; handle %u\n", log_type, log->last_handle);
+	event->event.generic.hdr.handle = cpu_to_le16(log->last_handle);
+	log->events[log->last_handle] = event;
+	log->last_handle = event_inc_handle(log->last_handle);
+}
+
+static void mes_del_event(struct device *dev,
+			  struct mock_event_log *log,
+			  u16 handle)
+{
+	struct cxl_event_record_raw *record;
+
+	lockdep_assert(lockdep_is_held(&log->lock));
+
+	dev_dbg(dev, "Clearing event %u; record %u\n",
+		handle, log->current_handle);
+	record = log->events[handle];
+	if (!record)
+		dev_err(dev, "Mock event index %u empty?\n", handle);
+
+	log->events[handle] = NULL;
+	log->current_handle = event_inc_handle(log->current_handle);
+	devm_kfree(dev, record);
 }
 
 /*
@@ -256,7 +273,7 @@ static int mock_get_event(struct device *dev, struct cxl_mbox_cmd *cmd)
 {
 	struct cxl_get_event_payload *pl;
 	struct mock_event_log *log;
-	u16 nr_overflow;
+	u16 handle;
 	u8 log_type;
 	int i;
 
@@ -277,29 +294,38 @@ static int mock_get_event(struct device *dev, struct cxl_mbox_cmd *cmd)
 	memset(cmd->payload_out, 0, struct_size(pl, records, 0));
 
 	log = event_find_log(dev, log_type);
-	if (!log || event_log_empty(log))
+	if (!log)
 		return 0;
 
 	pl = cmd->payload_out;
 
-	for (i = 0; i < ret_limit && !event_log_empty(log); i++) {
-		memcpy(&pl->records[i], event_get_current(log),
-		       sizeof(pl->records[i]));
-		pl->records[i].event.generic.hdr.handle =
-				event_get_cur_event_handle(log);
-		log->cur_idx++;
+	guard(read_lock)(&log->lock);
+
+	handle = log->current_handle;
+	dev_dbg(dev, "Get log %d handle %u last %u\n",
+		log_type, handle, log->last_handle);
+	for (i = 0; i < ret_limit && handle != log->last_handle;
+	     i++, handle = event_inc_handle(handle)) {
+		struct cxl_event_record_raw *cur;
+
+		cur = log->events[handle];
+		dev_dbg(dev, "Sending event log %d handle %d idx %u\n",
+			log_type, le16_to_cpu(cur->event.generic.hdr.handle),
+			handle);
+		memcpy(&pl->records[i], cur, sizeof(pl->records[i]));
+		pl->records[i].event.generic.hdr.handle = cpu_to_le16(handle);
 	}
 
 	cmd->size_out = struct_size(pl, records, i);
 	pl->record_count = cpu_to_le16(i);
-	if (!event_log_empty(log))
+	if (handle != log->last_handle)
 		pl->flags |= CXL_GET_EVENT_FLAG_MORE_RECORDS;
 
 	if (log->nr_overflow) {
 		u64 ns;
 
 		pl->flags |= CXL_GET_EVENT_FLAG_OVERFLOW;
-		pl->overflow_err_count = cpu_to_le16(nr_overflow);
+		pl->overflow_err_count = cpu_to_le16(log->nr_overflow);
 		ns = ktime_get_real_ns();
 		ns -= 5000000000; /* 5s ago */
 		pl->first_overflow_timestamp = cpu_to_le64(ns);
@@ -314,8 +340,8 @@ static int mock_get_event(struct device *dev, struct cxl_mbox_cmd *cmd)
 static int mock_clear_event(struct device *dev, struct cxl_mbox_cmd *cmd)
 {
 	struct cxl_mbox_clear_event_payload *pl = cmd->payload_in;
-	struct mock_event_log *log;
 	u8 log_type = pl->event_log;
+	struct mock_event_log *log;
 	u16 handle;
 	int nr;
 
@@ -326,23 +352,20 @@ static int mock_clear_event(struct device *dev, struct cxl_mbox_cmd *cmd)
 	if (!log)
 		return 0; /* No mock data in this log */
 
-	/*
-	 * This check is technically not invalid per the specification AFAICS.
-	 * (The host could 'guess' handles and clear them in order).
-	 * However, this is not good behavior for the host so test it.
-	 */
-	if (log->clear_idx + pl->nr_recs > log->cur_idx) {
-		dev_err(dev,
-			"Attempting to clear more events than returned!\n");
-		return -EINVAL;
-	}
+	guard(write_lock)(&log->lock);
 
 	/* Check handle order prior to clearing events */
-	for (nr = 0, handle = event_get_clear_handle(log);
-	     nr < pl->nr_recs;
-	     nr++, handle++) {
+	handle = log->current_handle;
+	for (nr = 0; nr < pl->nr_recs && handle != log->last_handle;
+	     nr++, handle = event_inc_handle(handle)) {
+
+		dev_dbg(dev, "Checking clear of %d handle %u plhandle %u\n",
+			log_type, handle,
+			le16_to_cpu(pl->handles[nr]));
+
 		if (handle != le16_to_cpu(pl->handles[nr])) {
-			dev_err(dev, "Clearing events out of order\n");
+			dev_err(dev, "Clearing events out of order %u %u\n",
+				handle, le16_to_cpu(pl->handles[nr]));
 			return -EINVAL;
 		}
 	}
@@ -351,25 +374,12 @@ static int mock_clear_event(struct device *dev, struct cxl_mbox_cmd *cmd)
 		log->nr_overflow = 0;
 
 	/* Clear events */
-	log->clear_idx += pl->nr_recs;
-	return 0;
-}
-
-static void cxl_mock_event_trigger(struct device *dev)
-{
-	struct cxl_mockmem_data *mdata = dev_get_drvdata(dev);
-	struct mock_event_store *mes = &mdata->mes;
-	int i;
+	for (nr = 0; nr < pl->nr_recs; nr++)
+		mes_del_event(dev, log, le16_to_cpu(pl->handles[nr]));
+	dev_dbg(dev, "Delete log %d cur %d last %d\n",
+		log_type, log->current_handle, log->last_handle);
 
-	for (i = CXL_EVENT_TYPE_INFO; i < CXL_EVENT_TYPE_MAX; i++) {
-		struct mock_event_log *log;
-
-		log = event_find_log(dev, i);
-		if (log)
-			event_reset_log(log);
-	}
-
-	cxl_mem_get_event_records(mdata->mds, mes->ev_status);
+	return 0;
 }
 
 struct cxl_event_record_raw maint_needed = {
@@ -510,8 +520,27 @@ static int mock_set_timestamp(struct cxl_dev_state *cxlds,
 	return 0;
 }
 
-static void cxl_mock_add_event_logs(struct mock_event_store *mes)
+/* Create a dynamically allocated event out of a statically defined event. */
+static void add_event_from_static(struct cxl_mockmem_data *mdata,
+				  enum cxl_event_log_type log_type,
+				  struct cxl_event_record_raw *raw)
+{
+	struct device *dev = mdata->mds->cxlds.dev;
+	struct cxl_event_record_raw *rec;
+
+	rec = devm_kmemdup(dev, raw, sizeof(*rec), GFP_KERNEL);
+	if (!rec) {
+		dev_err(dev, "Failed to alloc event for log\n");
+		return;
+	}
+	mes_add_event(mdata, log_type, rec);
+}
+
+static void cxl_mock_add_event_logs(struct cxl_mockmem_data *mdata)
 {
+	struct mock_event_store *mes = &mdata->mes;
+	struct device *dev = mdata->mds->cxlds.dev;
+
 	put_unaligned_le16(CXL_GMER_VALID_CHANNEL | CXL_GMER_VALID_RANK |
 			   CXL_GMER_VALID_COMPONENT | CXL_GMER_VALID_COMPONENT_ID_FORMAT,
 			   &gen_media.rec.media_hdr.validity_flags);
@@ -524,43 +553,60 @@ static void cxl_mock_add_event_logs(struct mock_event_store *mes)
 	put_unaligned_le16(CXL_MMER_VALID_COMPONENT | CXL_MMER_VALID_COMPONENT_ID_FORMAT,
 			   &mem_module.rec.validity_flags);
 
-	mes_add_event(mes, CXL_EVENT_TYPE_INFO, &maint_needed);
-	mes_add_event(mes, CXL_EVENT_TYPE_INFO,
+	dev_dbg(dev, "Generating fake event logs %d\n",
+		CXL_EVENT_TYPE_INFO);
+	add_event_from_static(mdata, CXL_EVENT_TYPE_INFO, &maint_needed);
+	add_event_from_static(mdata, CXL_EVENT_TYPE_INFO,
 		      (struct cxl_event_record_raw *)&gen_media);
-	mes_add_event(mes, CXL_EVENT_TYPE_INFO,
+	add_event_from_static(mdata, CXL_EVENT_TYPE_INFO,
 		      (struct cxl_event_record_raw *)&mem_module);
 	mes->ev_status |= CXLDEV_EVENT_STATUS_INFO;
 
-	mes_add_event(mes, CXL_EVENT_TYPE_FAIL, &maint_needed);
-	mes_add_event(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
-	mes_add_event(mes, CXL_EVENT_TYPE_FAIL,
+	dev_dbg(dev, "Generating fake event logs %d\n",
+		CXL_EVENT_TYPE_FAIL);
+	add_event_from_static(mdata, CXL_EVENT_TYPE_FAIL, &maint_needed);
+	add_event_from_static(mdata, CXL_EVENT_TYPE_FAIL,
+		      (struct cxl_event_record_raw *)&mem_module);
+	add_event_from_static(mdata, CXL_EVENT_TYPE_FAIL, &hardware_replace);
+	add_event_from_static(mdata, CXL_EVENT_TYPE_FAIL,
 		      (struct cxl_event_record_raw *)&dram);
-	mes_add_event(mes, CXL_EVENT_TYPE_FAIL,
+	add_event_from_static(mdata, CXL_EVENT_TYPE_FAIL,
 		      (struct cxl_event_record_raw *)&gen_media);
-	mes_add_event(mes, CXL_EVENT_TYPE_FAIL,
+	add_event_from_static(mdata, CXL_EVENT_TYPE_FAIL,
 		      (struct cxl_event_record_raw *)&mem_module);
-	mes_add_event(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
-	mes_add_event(mes, CXL_EVENT_TYPE_FAIL,
+	add_event_from_static(mdata, CXL_EVENT_TYPE_FAIL, &hardware_replace);
+	add_event_from_static(mdata, CXL_EVENT_TYPE_FAIL,
 		      (struct cxl_event_record_raw *)&dram);
 	/* Overflow this log */
-	mes_add_event(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
-	mes_add_event(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
-	mes_add_event(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
-	mes_add_event(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
-	mes_add_event(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
-	mes_add_event(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
-	mes_add_event(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
-	mes_add_event(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
-	mes_add_event(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
-	mes_add_event(mes, CXL_EVENT_TYPE_FAIL, &hardware_replace);
+	add_event_from_static(mdata, CXL_EVENT_TYPE_FAIL, &hardware_replace);
+	add_event_from_static(mdata, CXL_EVENT_TYPE_FAIL, &hardware_replace);
+	add_event_from_static(mdata, CXL_EVENT_TYPE_FAIL, &hardware_replace);
+	add_event_from_static(mdata, CXL_EVENT_TYPE_FAIL, &hardware_replace);
+	add_event_from_static(mdata, CXL_EVENT_TYPE_FAIL, &hardware_replace);
+	add_event_from_static(mdata, CXL_EVENT_TYPE_FAIL, &hardware_replace);
+	add_event_from_static(mdata, CXL_EVENT_TYPE_FAIL, &hardware_replace);
+	add_event_from_static(mdata, CXL_EVENT_TYPE_FAIL, &hardware_replace);
+	add_event_from_static(mdata, CXL_EVENT_TYPE_FAIL, &hardware_replace);
+	add_event_from_static(mdata, CXL_EVENT_TYPE_FAIL, &hardware_replace);
 	mes->ev_status |= CXLDEV_EVENT_STATUS_FAIL;
 
-	mes_add_event(mes, CXL_EVENT_TYPE_FATAL, &hardware_replace);
-	mes_add_event(mes, CXL_EVENT_TYPE_FATAL,
+	dev_dbg(dev, "Generating fake event logs %d\n",
+		CXL_EVENT_TYPE_FATAL);
+	add_event_from_static(mdata, CXL_EVENT_TYPE_FATAL, &hardware_replace);
+	add_event_from_static(mdata, CXL_EVENT_TYPE_FATAL,
 		      (struct cxl_event_record_raw *)&dram);
 	mes->ev_status |= CXLDEV_EVENT_STATUS_FATAL;
 }
 
+static void cxl_mock_event_trigger(struct device *dev)
+{
+	struct cxl_mockmem_data *mdata = dev_get_drvdata(dev);
+	struct mock_event_store *mes = &mdata->mes;
+
+	cxl_mock_add_event_logs(mdata);
+	cxl_mem_get_event_records(mdata->mds, mes->ev_status);
+}
+
 static int mock_gsl(struct cxl_mbox_cmd *cmd)
 {
 	if (cmd->size_out < sizeof(mock_gsl_payload))
@@ -1685,6 +1731,14 @@ static void cxl_mock_test_feat_init(struct cxl_mockmem_data *mdata)
 	mdata->test_feat.data = cpu_to_le32(0xdeadbeef);
 }
 
+static void init_event_log(struct mock_event_log *log)
+{
+	rwlock_init(&log->lock);
+	/* Handle can never be 0 use 1 based indexing for handle */
+	log->current_handle = 1;
+	log->last_handle = 1;
+}
+
 static int cxl_mock_mem_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
@@ -1766,7 +1820,9 @@ static int cxl_mock_mem_probe(struct platform_device *pdev)
 	if (rc)
 		dev_dbg(dev, "No CXL Features discovered\n");
 
-	cxl_mock_add_event_logs(&mdata->mes);
+	for (int i = 0; i < CXL_EVENT_TYPE_MAX; i++)
+		init_event_log(&mdata->mes.mock_logs[i]);
+	cxl_mock_add_event_logs(mdata);
 
 	cxlmd = devm_cxl_add_memdev(&pdev->dev, cxlds);
 	if (IS_ERR(cxlmd))

-- 
2.49.0


From mboxrd@z Thu Jan  1 00:00:00 1970
Received: from mgamail.intel.com (mgamail.intel.com [192.198.163.18])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id 826271A314E
	for <nvdimm@lists.linux.dev>; Sun, 13 Apr 2025 22:52:36 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=fail smtp.client-ip=192.198.163.18
ARC-Seal: i=2; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1744584759; cv=fail; b=pos7dUR5FRetVbOpdLZoG3/bCFK5OcOUHscylsfaq/IIwfN8RybXImzHCd8+c+QjHAs5jYMlLYfPbPJtlpDgWyd0j5AR5ernr6rIiVGaLqkrCPV/WWQqFZUKEYZY4puObvQX8EHreQp4nQjJDS8Pr0u734DylsdmvoubskagOBE=
ARC-Message-Signature: i=2; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1744584759; c=relaxed/simple;
	bh=wHMVv6tL4QfxMTR8qMmB+pCG/N575jfvmo5YYo0K9xY=;
	h=From:Date:Subject:Content-Type:Message-ID:References:In-Reply-To:
	 To:CC:MIME-Version; b=cKTK9skHLjPwubW/+n3S3h24bUK1T82jwUn8D1M/VxjxbdKGNAIWF+k3d07n1QPpcm9ppLkE0Bq9VaYJm0xhisFlCCXxtBfFrCslCmKKmRgd1zr/Rpi+lSynGGyJysjdBSGXLmQ+VzYzUCdtL0YYKyqMcBQGnvrRvsAXxTQEq60=
ARC-Authentication-Results: i=2; smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=intel.com; spf=pass smtp.mailfrom=intel.com; dkim=pass (2048-bit key) header.d=intel.com header.i=@intel.com header.b=HPugc1yl; arc=fail smtp.client-ip=192.198.163.18
Authentication-Results: smtp.subspace.kernel.org; dmarc=pass (p=none dis=none) header.from=intel.com
Authentication-Results: smtp.subspace.kernel.org; spf=pass smtp.mailfrom=intel.com
Authentication-Results: smtp.subspace.kernel.org;
	dkim=pass (2048-bit key) header.d=intel.com header.i=@intel.com header.b="HPugc1yl"
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
  d=intel.com; i=@intel.com; q=dns/txt; s=Intel;
  t=1744584757; x=1776120757;
  h=from:date:subject:content-transfer-encoding:message-id:
   references:in-reply-to:to:cc:mime-version;
  bh=wHMVv6tL4QfxMTR8qMmB+pCG/N575jfvmo5YYo0K9xY=;
  b=HPugc1ylEzxnhuOoBctrGQ7LBunfX21GtBl8cJKg4tTiTvslQayZMPgH
   saKzKSqU7tLbjr35kbJ+p1c/ede9rxWAfD2mukRkLhWO7NC+ZlVVGvImz
   Rnb8kMFK8JIEYWQGhirsbrqBCnLwtzS2qwTayQsy9Ci7joKp5nYbu+7lJ
   wLAdgk3CLly0hkz5vUdxC3j5cRSVZDNSF9IWAP89LVtJgj/8B0v6P2DSH
   HBDnd8sCtvp4ou+qildDHf/IMsiWMOA1OdIMT+RzxyxNzXcO242BvQ4ak
   KbKzci3XMwLufAXd9qm4WNsphsxk0PuNH5v6uBycW8uhYenjxJqCHLKOw
   A==;
X-CSE-ConnectionGUID: L1exXZI0Qn+FIRmh9uthRg==
X-CSE-MsgGUID: U14AMLJ1Q4CVDei31heLzg==
X-IronPort-AV: E=McAfee;i="6700,10204,11402"; a="45280966"
X-IronPort-AV: E=Sophos;i="6.15,211,1739865600"; 
   d="scan'208";a="45280966"
Received: from fmviesa007.fm.intel.com ([10.60.135.147])
  by fmvoesa112.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 13 Apr 2025 15:52:36 -0700
X-CSE-ConnectionGUID: o7R247WxT/Wm5SM001gjTg==
X-CSE-MsgGUID: u1yOuR2GQ1aK8M7st7UCTA==
X-ExtLoop1: 1
X-IronPort-AV: E=Sophos;i="6.15,211,1739865600"; 
   d="scan'208";a="129657635"
Received: from orsmsx902.amr.corp.intel.com ([10.22.229.24])
  by fmviesa007.fm.intel.com with ESMTP/TLS/ECDHE-RSA-AES256-GCM-SHA384; 13 Apr 2025 15:52:36 -0700
Received: from ORSMSX901.amr.corp.intel.com (10.22.229.23) by
 ORSMSX902.amr.corp.intel.com (10.22.229.24) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.2.1544.14; Sun, 13 Apr 2025 15:52:35 -0700
Received: from orsedg603.ED.cps.intel.com (10.7.248.4) by
 ORSMSX901.amr.corp.intel.com (10.22.229.23) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.2.1544.14 via Frontend Transport; Sun, 13 Apr 2025 15:52:35 -0700
Received: from NAM02-SN1-obe.outbound.protection.outlook.com (104.47.57.44) by
 edgegateway.intel.com (134.134.137.100) with Microsoft SMTP Server
 (version=TLS1_2, cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id
 15.1.2507.44; Sun, 13 Apr 2025 15:52:34 -0700
ARC-Seal: i=1; a=rsa-sha256; s=arcselector10001; d=microsoft.com; cv=none;
 b=h9zHSybtzuUf6yYMpirbERwz6ZLqtBbYZvKYmQdWS49xATYQikoq7/6HouGFT/ueT8+TnZpKRa4G4EsC5qEIdEnCHNpMD0HVmDQ0t1v+NdJxxvuU1YkS3nThkbR07onndcu8TsPEBszKd/pHFmZYVeGvomOSReAv5PlmW584KGOZb+y8uuU8A7jVFy2ff4NGwdXxLtnPxV1t9ty/536lo4fHcT/tGK5uZ9eE2NUvJX5RmtjvW8z23uVpAIHpcBpsOjlxXqF0C0mPmszrxdW5qmxW4QV/TX5248ImK7ypELVBz5kYQBdGpFBmk8ac+tg5Y2OdElpxLOkRUdERdVr5YA==
ARC-Message-Signature: i=1; a=rsa-sha256; c=relaxed/relaxed; d=microsoft.com;
 s=arcselector10001;
 h=From:Date:Subject:Message-ID:Content-Type:MIME-Version:X-MS-Exchange-AntiSpam-MessageData-ChunkCount:X-MS-Exchange-AntiSpam-MessageData-0:X-MS-Exchange-AntiSpam-MessageData-1;
 bh=DxjHic46EGVica6+xsSexw+RIXWnwKQtDZaXL+uUKYI=;
 b=tjJ9XFk9WqT9IUfo5NElho/FHD0ju/lfSOiknd0DK8nRW8XM7eEyyrHoj8uC2vZe5uSoaqcOj8O50xBXQ0Bwv9rymMk/ZwFzTejeYUo2Z9ytupi+2K0unrIkNsIGaokIQg3hAf3XRoLEcfKvaNy/AyphsuGbW3OXwj7/BYwSFAzfzbDkBbheVIMJl7WPR3gUqX2CNzuKd35yPt4PCDNFveQ3PILR4gsK2xDk6ssS8yrERc+Ox7fMl+40SkPMy2oWFu8/LYmVlUPLRAF+F6PBSBLOGoAv736NioTteEEAJWazIbLda7Y3PUlrDbsuBOsYfeAMmwp88OntVQkITHwkcA==
ARC-Authentication-Results: i=1; mx.microsoft.com 1; spf=pass
 smtp.mailfrom=intel.com; dmarc=pass action=none header.from=intel.com;
 dkim=pass header.d=intel.com; arc=none
Authentication-Results: dkim=none (message not signed)
 header.d=none;dmarc=none action=none header.from=intel.com;
Received: from MW4PR11MB6739.namprd11.prod.outlook.com (2603:10b6:303:20b::19)
 by PH7PR11MB7003.namprd11.prod.outlook.com (2603:10b6:510:20a::16) with
 Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384) id 15.20.8632.33; Sun, 13 Apr
 2025 22:52:14 +0000
Received: from MW4PR11MB6739.namprd11.prod.outlook.com
 ([fe80::a7ad:a6e8:fced:3f24]) by MW4PR11MB6739.namprd11.prod.outlook.com
 ([fe80::a7ad:a6e8:fced:3f24%4]) with mapi id 15.20.8606.033; Sun, 13 Apr 2025
 22:52:14 +0000
From: Ira Weiny <ira.weiny@intel.com>
Date: Sun, 13 Apr 2025 17:52:27 -0500
Subject: [PATCH v9 19/19] tools/testing/cxl: Add DC Regions to mock mem
 data
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: 7bit
Message-ID: <20250413-dcd-type2-upstream-v9-19-1d4911a0b365@intel.com>
References: <20250413-dcd-type2-upstream-v9-0-1d4911a0b365@intel.com>
In-Reply-To: <20250413-dcd-type2-upstream-v9-0-1d4911a0b365@intel.com>
To: Dave Jiang <dave.jiang@intel.com>, Fan Ni <fan.ni@samsung.com>, "Jonathan
 Cameron" <Jonathan.Cameron@huawei.com>
CC: Dan Williams <dan.j.williams@intel.com>, Davidlohr Bueso
	<dave@stgolabs.net>, Alison Schofield <alison.schofield@intel.com>, "Vishal
 Verma" <vishal.l.verma@intel.com>, Ira Weiny <ira.weiny@intel.com>,
	<linux-cxl@vger.kernel.org>, <nvdimm@lists.linux.dev>,
	<linux-kernel@vger.kernel.org>
X-Mailer: b4 0.15-dev-c25d1
X-Developer-Signature: v=1; a=ed25519-sha256; t=1744584735; l=24753;
 i=ira.weiny@intel.com; s=20221211; h=from:subject:message-id;
 bh=wHMVv6tL4QfxMTR8qMmB+pCG/N575jfvmo5YYo0K9xY=;
 b=DOc2lTVyHjID6tyGD8eW/iq+KW9krVGXgzdgNV3Z5RxYkzav+D9Xat2LtZVixYJ8J3I00wMD4
 4PfhTkqhfC+DGsjJ/sQG1gQQbMLCGSyzr0wKUm5gTRMh9QQHdAx6lmq
X-Developer-Key: i=ira.weiny@intel.com; a=ed25519;
 pk=noldbkG+Wp1qXRrrkfY1QJpDf7QsOEthbOT7vm0PqsE=
X-ClientProxiedBy: MW4PR03CA0227.namprd03.prod.outlook.com
 (2603:10b6:303:b9::22) To MW4PR11MB6739.namprd11.prod.outlook.com
 (2603:10b6:303:20b::19)
Precedence: bulk
X-Mailing-List: nvdimm@lists.linux.dev
List-Id: <nvdimm.lists.linux.dev>
List-Subscribe: <mailto:nvdimm+subscribe@lists.linux.dev>
List-Unsubscribe: <mailto:nvdimm+unsubscribe@lists.linux.dev>
MIME-Version: 1.0
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: MW4PR11MB6739:EE_|PH7PR11MB7003:EE_
X-MS-Office365-Filtering-Correlation-Id: 16ec98af-ac4b-466e-1458-08dd7addd553
X-MS-Exchange-SenderADCheck: 1
X-MS-Exchange-AntiSpam-Relay: 0
X-Microsoft-Antispam: BCL:0;ARA:13230040|366016|376014|1800799024;
X-Microsoft-Antispam-Message-Info: =?utf-8?B?eW11SERrcTVOT0FFWEx1QlRHbGlObC96MWMzcktXQXFtZWZjVWVuR3JrK3l5?=
 =?utf-8?B?Q3lETUF1RlEreDNpWllMM2VCUlljMHBnZlN3VjJkYWVZK0xxNnpRM2VLdVZF?=
 =?utf-8?B?aU1LRjFmazgxNHgwZVVFaUZvd0lXQzNmK2o0RTJnaDJ6eDgzQU5CaXBpWENr?=
 =?utf-8?B?VzNvTXo5RmkyYlpwcmdsam82eFRwRWdXYnVGdWpSdURhc2w3MGM1aDFTcUIz?=
 =?utf-8?B?YXc0LzZFLzhELzhGQXF2LzBKMHEvK29KcHI3SDdSZ3ZzT3J3aGpUMklpWC9X?=
 =?utf-8?B?NHgwMUk5V1g1K1R2S2RxMTdVb2xZT1VJVnM3aHlGSFRjRWxzUlNHcUlpVHhQ?=
 =?utf-8?B?OWlRU05wUk84OXZreXdWMDB6L3RFNDB0MnFzUm1Fdks0c0U2SDNoYjByRndU?=
 =?utf-8?B?bzJxU0tNME5XVU1HM1JRcUQwTWNDaHFLU0N5NGdGRzQrbW5RMllsWUcwS0NK?=
 =?utf-8?B?Tld6WHdLN2hvQjFHZ0drbkQzT21GNEhabHpTN0w3TlBkSlpXQ3lGL2d1aG5I?=
 =?utf-8?B?MXNiMDZsK2V3bHorMXdtM1ExWFBjdG5qaFZ3azZHVlFkODc2YVFmc1E1U1E3?=
 =?utf-8?B?SUNzN2FCUGRqQVA1YmxtdGgveVVaUExzMnIxMzdxbkNiUVQrYUpveUEvK2Fj?=
 =?utf-8?B?ZEdPVzdlUS9Wb2ZoV29SNElzTW1NRi80alAxc1gvOW5FSTcvaGxtRHAyMVpR?=
 =?utf-8?B?RUcvNjhZbVNwWnFhV1o5aEJmWUNtZ3g5Q3VuSnNhUjFZdkU0VWgxK2h5QWZF?=
 =?utf-8?B?S1hVeVd5TTY0ZFgyWlNPZkptK1dESWVGaWt2eEJIQUF0OC9XOUZMajdZcTh3?=
 =?utf-8?B?N1pYQUNhWllGVk1LM3VBNThiM0M4bFhzcFlFQWRXY2d3SUc3QjVTbytpYm1R?=
 =?utf-8?B?MFFyUVN4OHFNUFpRYmE1aE5DUitoSDJ4OCtKcXBmaDg3ZHdRQXRaaG5YTzFG?=
 =?utf-8?B?WVlXZ3RJQW5zOXZXRndNaFlhemZLUHlzbjJNam9Xam5BV1FYYTZMN0MvSll1?=
 =?utf-8?B?N1grTS9VWXNxL2trYjJPbXZwMmI5UGdhSW1LV2MzRGQ0M3Y4MUJDQXpYWllY?=
 =?utf-8?B?Z1RtZzNRYTdUZjdJdlhteXlyd3ZXRTU3Ulh1VFRlYWZUZGlMbkwrcFFrcytl?=
 =?utf-8?B?TG9kbllObjk0TXVTa2pPeXlGemxHbGNuSE9adGxZVGpPVFZ4VEI2NlRTbStF?=
 =?utf-8?B?OG9yK2F3bFQwUkVmWXY2RU8rWjBYZGlrTDJXa2lJMndVL0Zha3B0R0YrNm9o?=
 =?utf-8?B?d0xsb2h2cGRBL01rWHYrTVJISEhHdStFaFE0RUhnMkJDS3F1bmI2QmZlT1h5?=
 =?utf-8?B?OWhXdmM5QUxZM3Bzb3FBZDk4LzY1SUplU3haN3FOcXZnQzBtKy9pUlFNOW9w?=
 =?utf-8?B?QjZyamdGMjlLeHVCYUpaY3RJbElSaXoyelVUeWptaEM2cU5YT2dVZDlhcnlP?=
 =?utf-8?B?dWFCTGRIdTNsTm1JbmVWNWw2SWRudXMzNWJtTUVZL1dTbmtpSlhRSlMwb0Jt?=
 =?utf-8?B?LzltODVFRlhxSWhDbFVPRlNXUXlsbTVIeUJETXB4d2JJL2hpZDhHRW9ucDgr?=
 =?utf-8?B?YTZkUVJCNStYOWppbXJ1d3QrSWZNSExJVjl5VHBaNTliL01aTXRJZTdOZ2dD?=
 =?utf-8?B?cExqbmZ0SGpRc1g3SHBlZzNkU1o4L2RBV042Yk5SckhSbGVzSHJWUEM2SDQv?=
 =?utf-8?B?TTdBcGtKYkpuRXUxT2d0Ry9IOUplV3QzNUN6QXBJNU1oVWtsWDhqMWg2Y1I5?=
 =?utf-8?B?Q2p5N3Q1dzMzNGdiNUsrcGc3Z2JFOVNOUVpSdjNjQ0RCUSs0UlVZZkVtK3VU?=
 =?utf-8?B?aHFYMmJyUmlzSDBkQVBsVzVVSE1oWDNkeE9TNmd3TTJxdFp6YUNkYno5ZGh4?=
 =?utf-8?B?K1ZLMlhBOUVZMGI5NUpiVThRaVZWSWozRXhCT0tPaWRPZUVwZW0xYnlXS2ZI?=
 =?utf-8?Q?KP3TBPL7JKU=3D?=
X-Forefront-Antispam-Report: CIP:255.255.255.255;CTRY:;LANG:en;SCL:1;SRV:;IPV:NLI;SFV:NSPM;H:MW4PR11MB6739.namprd11.prod.outlook.com;PTR:;CAT:NONE;SFS:(13230040)(366016)(376014)(1800799024);DIR:OUT;SFP:1101;
X-MS-Exchange-AntiSpam-MessageData-ChunkCount: 1
X-MS-Exchange-AntiSpam-MessageData-0: =?utf-8?B?WjdkTUlnUENUY1pSdUlYb0Rla3JDc1R2cXJQUExNWUhyUG1WTHBtUk5DMms5?=
 =?utf-8?B?VXZwSjE4dldhb0U4ZHF2blhIUmdqdFg3SHZBb2pBUUt5N2dIbjJpd0VDUUwx?=
 =?utf-8?B?Y0orMU01aGJYY0oycTVtb3VWZUhkcjNPUlExM3NxK2t5am1tb2pjRUtQdnIz?=
 =?utf-8?B?L21sNmxQRENYb20rUWpRK3V5WkRSaVJkY3pvSGtaUFFyZlRIUHhtS2VHa3pG?=
 =?utf-8?B?Y1FTU0ZRcWhuUWJxeEsyVTNPRTJrUzFGcXlGNnFJdmFpdVNJM1pOV0F0L0du?=
 =?utf-8?B?eDhvZG8xVkl6WTJkTk9LdStaUFFmRzc1YVFGYXRjMVk1bUY0VktPZWxvVm1l?=
 =?utf-8?B?UzIwdXU4U0o4NCtSeWlUbGxzWjg2S3JYbm96WC8rL2xnQ3o2dGZ4TnFabnMy?=
 =?utf-8?B?RGhkRG1KZGs3V0FyQitZWk02TlBURHFMUS9MaUs2M3JOVUpVMXdobXJoM3V3?=
 =?utf-8?B?R2pjbVEyZmMwd2VLNTB1V1pPQWFycEtvS2ZKSlpPT05kQmw4RlROMytUb3dp?=
 =?utf-8?B?MVZRVVNWTXV0SkVrTDJFa0xIb2Jic1VFSEVjUWJwZTJQMjhyTm0yclRJV0hY?=
 =?utf-8?B?ZkduLzZEYk1Bb09jZHphT0NObUYyNVpoSlAvQldhZUFTc0Q1UWpQb2ZqQzlM?=
 =?utf-8?B?Y09DYmdzdTUvZ1IrekptK2QvQ251NEcvNFFsK2lxaVg3SDZoWGJsYjZZeGRR?=
 =?utf-8?B?akNnQ1dYd1dkVFU5VTY4UnVlL3JaVDdtTXJ5NDNVZHNvaEc0QzN2dERSandB?=
 =?utf-8?B?cVlvSmtrenJzSjhIUUZDSDNlc0pBNlF5THVIbnp4SFFTTnFLbUJldHZ6R2RH?=
 =?utf-8?B?NHdmSWJRYjBOYnhkQTRmZEwxbld6NlpHNGVMQm5NOGhZQU5Vb2E2Nno2VXNQ?=
 =?utf-8?B?RndaUlFzK09MN05IMVA4SXJFOS81MUN2T1cxU0w5T3BCZ2hUaTR3UEtCZGdY?=
 =?utf-8?B?alVjNHBlVm9GMkRWdnhBT3pGbCtUcWh2MWhScEROZ3U2YlRHaktKUTRPcDE1?=
 =?utf-8?B?bHQ3b25HUytNclV3YmszV2RXOE84Rmo2UVQ0YW91ZEZaOGloaGdkdjAvUFBu?=
 =?utf-8?B?WUxZUlVqTjBDTy9DUVZ0cEI2OFd2ekZldVpqenpoRitjblRheHQ1Q3V1Z3Zl?=
 =?utf-8?B?a3hGRkRCMlBOVVR4WFRYQzFCbGZGUjIxQUZaTlVjRnk3NEZqYmQxZCswWWRZ?=
 =?utf-8?B?alBOdEpKTWpLZFlXSXVNalIzRmxhMkhsb3MyTzJJRzhRTVR3aG5GNGxhcVV6?=
 =?utf-8?B?OFo3SHlldEtORmVMODZjV1Q2OXYzL0lES0wrazZobXFsY1NLTVJaaVFXeTdQ?=
 =?utf-8?B?cmszVmluekR2QzEvRmN5NUtuRko3d2Q4TmZzY0IwU2dMcHkreGJzTUJRTFZs?=
 =?utf-8?B?SDBnSEdTTVJ2T2xyZjg4bEsvUGV3bHFwMHkwaUdTSlg4WjQ2ZlBxZ2h2MjVt?=
 =?utf-8?B?RXFKMEtTL2FodU53NU9ZRkttS2RzRlQ1bk1tNTZ1RDBVdWd0TXNvQ25HSDc2?=
 =?utf-8?B?cENuTmtodDBzQ0tUbTRpVDl5UUwvM2pwQzY4NktDUVNVRWowYWE4Qkx0b3RR?=
 =?utf-8?B?clFUdzh3RWFRNXBmUHpibTdwekk4aG5ub0l3RVIzUU9tSTJBVGE5dk9ES2FO?=
 =?utf-8?B?NEVWNjJXNXZOZDdVMU5lN1MvRmVpMFhPZzhodXhOQWhINGFEQkp2TTZTeXgx?=
 =?utf-8?B?RksvbHkySTU2QUJOQk1tbjZsWmhiYnVaVWp4bjdYaFBpU1A3UG5vM1E0NzJV?=
 =?utf-8?B?UFUzYmtjUUxvajd3L0Fhb2o5SUhDdTg5cVBkQzBUaWcrNGsxZlY2anI1ck1i?=
 =?utf-8?B?UE5XdmRmTDdlTFZUYXRzeHBTeTJ6eVoxZ3NHeG55UmNXUmFSTXFCaUtiTlFC?=
 =?utf-8?B?UVVxWmhTVGJFekRtb2xjUzNQWDVNV1BOdGtzM2dHME1uemZlUWk1d1pVaVBB?=
 =?utf-8?B?TEhTRnFxWm50S05ycHVOMVp3c29mb2pjbzlmcndSbzdTVEZxc3gxTFRNM3VZ?=
 =?utf-8?B?c0s2Qnc2VmhJMW1GaFRCc0wwcW9RcEl6MzBpdFRWOXpOSGZvSDVEa3A4NzdS?=
 =?utf-8?B?TS82WGI1cDA3Lyt5Y2FXdHhpMFNjR2FlZmRwTU9NWGdGU2htTDUxRkZBeTM0?=
 =?utf-8?Q?C53JXlmkZoAn4Q6wTCtEkUI1/?=
X-MS-Exchange-CrossTenant-Network-Message-Id: 16ec98af-ac4b-466e-1458-08dd7addd553
X-MS-Exchange-CrossTenant-AuthSource: MW4PR11MB6739.namprd11.prod.outlook.com
X-MS-Exchange-CrossTenant-AuthAs: Internal
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 13 Apr 2025 22:52:14.4720
 (UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 46c98d88-e344-4ed4-8496-4ed7712e255d
X-MS-Exchange-CrossTenant-MailboxType: HOSTED
X-MS-Exchange-CrossTenant-UserPrincipalName: UQJ2ufx/jBtLpUYZpyf5DhFF3mlzBclywOH1z8Z+ZvdTxnZdYBphVW/3SBO+6yITUau93kvWIB3KrxJxq3vefQ==
X-MS-Exchange-Transport-CrossTenantHeadersStamped: PH7PR11MB7003
X-OriginatorOrg: intel.com
Status: RO
Content-Length: 23882
Lines: 873

cxl_test provides a good way to ensure quick smoke and regression
testing.  The complexity of Dynamic Capacity (DC) extent processing as
well as the complexity of the new sparse DAX regions can mostly be
tested through cxl_test.  This includes management of sparse regions and
DAX devices on those regions; the management of extent device lifetimes;
and the processing of DCD events.

The only missing functionality from this test is actual interrupt
processing.

Mock memory devices can easily mock DC information and manage fake
extent data.

Define mock_dc_partition information within the mock memory data.  Add
sysfs entries on the mock device to inject and delete extents.

The inject format is <start>:<length>:<tag>:<more_flag>
The delete format is <start>:<length>

Directly call the event irq callback to simulate irqs to process the
test extents.

Add DC mailbox commands to the CEL and implement those commands.

Reviewed-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
Reviewed-by: Dave Jiang <dave.jiang@intel.com>
Signed-off-by: Ira Weiny <ira.weiny@intel.com>

---
Changes:
[iweiny: rebase]
[djbw: s/region/partition/]
[iweiny: s/tag/uuid/]
---
 tools/testing/cxl/test/mem.c | 753 +++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 753 insertions(+)

diff --git a/tools/testing/cxl/test/mem.c b/tools/testing/cxl/test/mem.c
index a71a72966de1..a85a04168434 100644
--- a/tools/testing/cxl/test/mem.c
+++ b/tools/testing/cxl/test/mem.c
@@ -20,6 +20,7 @@
 #define FW_SLOTS 3
 #define DEV_SIZE SZ_2G
 #define EFFECT(x) (1U << x)
+#define BASE_DYNAMIC_CAP_DPA DEV_SIZE
 
 #define MOCK_INJECT_DEV_MAX 8
 #define MOCK_INJECT_TEST_MAX 128
@@ -113,6 +114,22 @@ static struct cxl_cel_entry mock_cel[] = {
 				      EFFECT(SECURITY_CHANGE_IMMEDIATE) |
 				      EFFECT(BACKGROUND_OP)),
 	},
+	{
+		.opcode = cpu_to_le16(CXL_MBOX_OP_GET_DC_CONFIG),
+		.effect = CXL_CMD_EFFECT_NONE,
+	},
+	{
+		.opcode = cpu_to_le16(CXL_MBOX_OP_GET_DC_EXTENT_LIST),
+		.effect = CXL_CMD_EFFECT_NONE,
+	},
+	{
+		.opcode = cpu_to_le16(CXL_MBOX_OP_ADD_DC_RESPONSE),
+		.effect = cpu_to_le16(EFFECT(CONF_CHANGE_IMMEDIATE)),
+	},
+	{
+		.opcode = cpu_to_le16(CXL_MBOX_OP_RELEASE_DC),
+		.effect = cpu_to_le16(EFFECT(CONF_CHANGE_IMMEDIATE)),
+	},
 };
 
 /* See CXL 2.0 Table 181 Get Health Info Output Payload */
@@ -173,6 +190,8 @@ struct vendor_test_feat {
 	__le32 data;
 } __packed;
 
+#define NUM_MOCK_DC_REGIONS 2
+
 struct cxl_mockmem_data {
 	void *lsa;
 	void *fw;
@@ -191,6 +210,20 @@ struct cxl_mockmem_data {
 	unsigned long sanitize_timeout;
 	struct vendor_test_feat test_feat;
 	u8 shutdown_state;
+
+	struct cxl_dc_partition dc_partitions[NUM_MOCK_DC_REGIONS];
+	u32 dc_ext_generation;
+	struct mutex ext_lock;
+
+	/*
+	 * Extents are in 1 of 3 states
+	 * FM (sysfs added but not sent to the host yet)
+	 * sent (sent to the host but not accepted)
+	 * accepted (by the host)
+	 */
+	struct xarray dc_fm_extents;
+	struct xarray dc_sent_extents;
+	struct xarray dc_accepted_exts;
 };
 
 static struct mock_event_log *event_find_log(struct device *dev, int log_type)
@@ -607,6 +640,251 @@ static void cxl_mock_event_trigger(struct device *dev)
 	cxl_mem_get_event_records(mdata->mds, mes->ev_status);
 }
 
+struct cxl_extent_data {
+	u64 dpa_start;
+	u64 length;
+	u8 uuid[UUID_SIZE];
+	bool shared;
+};
+
+static int __devm_add_extent(struct device *dev, struct xarray *array,
+			     u64 start, u64 length, const char *uuid,
+			     bool shared)
+{
+	struct cxl_extent_data *extent;
+
+	extent = devm_kzalloc(dev, sizeof(*extent), GFP_KERNEL);
+	if (!extent)
+		return -ENOMEM;
+
+	extent->dpa_start = start;
+	extent->length = length;
+	memcpy(extent->uuid, uuid, min(sizeof(extent->uuid), strlen(uuid)));
+	extent->shared = shared;
+
+	if (xa_insert(array, start, extent, GFP_KERNEL)) {
+		devm_kfree(dev, extent);
+		dev_err(dev, "Failed xarry insert %#llx\n", start);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int devm_add_fm_extent(struct device *dev, u64 start, u64 length,
+			      const char *uuid, bool shared)
+{
+	struct cxl_mockmem_data *mdata = dev_get_drvdata(dev);
+
+	guard(mutex)(&mdata->ext_lock);
+	return __devm_add_extent(dev, &mdata->dc_fm_extents, start, length,
+				 uuid, shared);
+}
+
+/* It is known that ext and the new range are not equal */
+static struct cxl_extent_data *
+split_ext(struct device *dev, struct xarray *array,
+	  struct cxl_extent_data *ext, u64 start, u64 length)
+{
+	u64 new_start, new_length;
+
+	if (ext->dpa_start == start) {
+		new_start = start + length;
+		new_length = (ext->dpa_start + ext->length) - new_start;
+
+		if (__devm_add_extent(dev, array, new_start, new_length,
+				      ext->uuid, false))
+			return NULL;
+
+		ext = xa_erase(array, ext->dpa_start);
+		if (__devm_add_extent(dev, array, start, length, ext->uuid,
+				      false))
+			return NULL;
+
+		return xa_load(array, start);
+	}
+
+	/* ext->dpa_start != start */
+
+	if (__devm_add_extent(dev, array, start, length, ext->uuid, false))
+		return NULL;
+
+	new_start = ext->dpa_start;
+	new_length = start - ext->dpa_start;
+
+	ext = xa_erase(array, ext->dpa_start);
+	if (__devm_add_extent(dev, array, new_start, new_length, ext->uuid,
+			      false))
+		return NULL;
+
+	return xa_load(array, start);
+}
+
+/*
+ * Do not handle extents which are not inside a single extent sent to
+ * the host.
+ */
+static struct cxl_extent_data *
+find_create_ext(struct device *dev, struct xarray *array, u64 start, u64 length)
+{
+	struct cxl_extent_data *ext;
+	unsigned long index;
+
+	xa_for_each(array, index, ext) {
+		u64 end = start + length;
+
+		/* start < [ext) <= start */
+		if (start < ext->dpa_start ||
+		    (ext->dpa_start + ext->length) <= start)
+			continue;
+
+		if (end <= ext->dpa_start ||
+		    (ext->dpa_start + ext->length) < end) {
+			dev_err(dev, "Invalid range %#llx-%#llx\n", start,
+				end);
+			return NULL;
+		}
+
+		break;
+	}
+
+	if (!ext)
+		return NULL;
+
+	if (start == ext->dpa_start && length == ext->length)
+		return ext;
+
+	return split_ext(dev, array, ext, start, length);
+}
+
+static int dc_accept_extent(struct device *dev, u64 start, u64 length)
+{
+	struct cxl_mockmem_data *mdata = dev_get_drvdata(dev);
+	struct cxl_extent_data *ext;
+
+	dev_dbg(dev, "Host accepting extent %#llx\n", start);
+	mdata->dc_ext_generation++;
+
+	lockdep_assert_held(&mdata->ext_lock);
+	ext = find_create_ext(dev, &mdata->dc_sent_extents, start, length);
+	if (!ext) {
+		dev_err(dev, "Extent %#llx-%#llx not found\n",
+			start, start + length);
+		return -ENOMEM;
+	}
+	ext = xa_erase(&mdata->dc_sent_extents, ext->dpa_start);
+	return xa_insert(&mdata->dc_accepted_exts, start, ext, GFP_KERNEL);
+}
+
+static void release_dc_ext(void *md)
+{
+	struct cxl_mockmem_data *mdata = md;
+
+	xa_destroy(&mdata->dc_fm_extents);
+	xa_destroy(&mdata->dc_sent_extents);
+	xa_destroy(&mdata->dc_accepted_exts);
+}
+
+/* Pretend to have some previous accepted extents */
+struct pre_ext_info {
+	u64 offset;
+	u64 length;
+} pre_ext_info[] = {
+	{
+		.offset = SZ_128M,
+		.length = SZ_64M,
+	},
+	{
+		.offset = SZ_256M,
+		.length = SZ_64M,
+	},
+};
+
+static int devm_add_sent_extent(struct device *dev, u64 start, u64 length,
+				const char *tag, bool shared)
+{
+	struct cxl_mockmem_data *mdata = dev_get_drvdata(dev);
+
+	lockdep_assert_held(&mdata->ext_lock);
+	return __devm_add_extent(dev, &mdata->dc_sent_extents, start, length,
+				 tag, shared);
+}
+
+static int inject_prev_extents(struct device *dev, u64 base_dpa)
+{
+	struct cxl_mockmem_data *mdata = dev_get_drvdata(dev);
+	int rc;
+
+	dev_dbg(dev, "Adding %ld pre-extents for testing\n",
+		ARRAY_SIZE(pre_ext_info));
+
+	guard(mutex)(&mdata->ext_lock);
+	for (int i = 0; i < ARRAY_SIZE(pre_ext_info); i++) {
+		u64 ext_dpa = base_dpa + pre_ext_info[i].offset;
+		u64 ext_len = pre_ext_info[i].length;
+
+		dev_dbg(dev, "Adding pre-extent DPA:%#llx LEN:%#llx\n",
+			ext_dpa, ext_len);
+
+		rc = devm_add_sent_extent(dev, ext_dpa, ext_len, "", false);
+		if (rc) {
+			dev_err(dev, "Failed to add pre-extent DPA:%#llx LEN:%#llx; %d\n",
+				ext_dpa, ext_len, rc);
+			return rc;
+		}
+
+		rc = dc_accept_extent(dev, ext_dpa, ext_len);
+		if (rc)
+			return rc;
+	}
+	return 0;
+}
+
+static int cxl_mock_dc_partition_setup(struct device *dev)
+{
+	struct cxl_mockmem_data *mdata = dev_get_drvdata(dev);
+	u64 base_dpa = BASE_DYNAMIC_CAP_DPA;
+	u32 dsmad_handle = 0xFADE;
+	u64 decode_length = SZ_512M;
+	u64 block_size = SZ_512;
+	u64 length = SZ_512M;
+	int rc;
+
+	mutex_init(&mdata->ext_lock);
+	xa_init(&mdata->dc_fm_extents);
+	xa_init(&mdata->dc_sent_extents);
+	xa_init(&mdata->dc_accepted_exts);
+
+	rc = devm_add_action_or_reset(dev, release_dc_ext, mdata);
+	if (rc)
+		return rc;
+
+	for (int i = 0; i < NUM_MOCK_DC_REGIONS; i++) {
+		struct cxl_dc_partition *part = &mdata->dc_partitions[i];
+
+		dev_dbg(dev, "Creating DC partition DC%d DPA:%#llx LEN:%#llx\n",
+			i, base_dpa, length);
+
+		part->base = cpu_to_le64(base_dpa);
+		part->decode_length = cpu_to_le64(decode_length /
+						  CXL_CAPACITY_MULTIPLIER);
+		part->length = cpu_to_le64(length);
+		part->block_size = cpu_to_le64(block_size);
+		part->dsmad_handle = cpu_to_le32(dsmad_handle);
+		dsmad_handle++;
+
+		rc = inject_prev_extents(dev, base_dpa);
+		if (rc) {
+			dev_err(dev, "Failed to add pre-extents for DC%d\n", i);
+			return rc;
+		}
+
+		base_dpa += decode_length;
+	}
+
+	return 0;
+}
+
 static int mock_gsl(struct cxl_mbox_cmd *cmd)
 {
 	if (cmd->size_out < sizeof(mock_gsl_payload))
@@ -1582,6 +1860,192 @@ static int mock_get_supported_features(struct cxl_mockmem_data *mdata,
 	return 0;
 }
 
+static int mock_get_dc_config(struct device *dev,
+			      struct cxl_mbox_cmd *cmd)
+{
+	struct cxl_mbox_get_dc_config_in *dc_config = cmd->payload_in;
+	struct cxl_mockmem_data *mdata = dev_get_drvdata(dev);
+	u8 partition_requested, partition_start_idx, partition_ret_cnt;
+	struct cxl_mbox_get_dc_config_out *resp;
+	int i;
+
+	partition_requested = min(dc_config->partition_count, NUM_MOCK_DC_REGIONS);
+
+	if (cmd->size_out < struct_size(resp, partition, partition_requested))
+		return -EINVAL;
+
+	memset(cmd->payload_out, 0, cmd->size_out);
+	resp = cmd->payload_out;
+
+	partition_start_idx = dc_config->start_partition_index;
+	partition_ret_cnt = 0;
+	for (i = 0; i < NUM_MOCK_DC_REGIONS; i++) {
+		if (i >= partition_start_idx) {
+			memcpy(&resp->partition[partition_ret_cnt],
+				&mdata->dc_partitions[i],
+				sizeof(resp->partition[partition_ret_cnt]));
+			partition_ret_cnt++;
+		}
+	}
+	resp->avail_partition_count = NUM_MOCK_DC_REGIONS;
+	resp->partitions_returned = i;
+
+	dev_dbg(dev, "Returning %d dc partitions\n", partition_ret_cnt);
+	return 0;
+}
+
+static int mock_get_dc_extent_list(struct device *dev,
+				   struct cxl_mbox_cmd *cmd)
+{
+	struct cxl_mbox_get_extent_out *resp = cmd->payload_out;
+	struct cxl_mockmem_data *mdata = dev_get_drvdata(dev);
+	struct cxl_mbox_get_extent_in *get = cmd->payload_in;
+	u32 total_avail = 0, total_ret = 0;
+	struct cxl_extent_data *ext;
+	u32 ext_count, start_idx;
+	unsigned long i;
+
+	ext_count = le32_to_cpu(get->extent_cnt);
+	start_idx = le32_to_cpu(get->start_extent_index);
+
+	memset(resp, 0, sizeof(*resp));
+
+	guard(mutex)(&mdata->ext_lock);
+	/*
+	 * Total available needs to be calculated and returned regardless of
+	 * how many can actually be returned.
+	 */
+	xa_for_each(&mdata->dc_accepted_exts, i, ext)
+		total_avail++;
+
+	if (start_idx > total_avail)
+		return -EINVAL;
+
+	xa_for_each(&mdata->dc_accepted_exts, i, ext) {
+		if (total_ret >= ext_count)
+			break;
+
+		if (total_ret >= start_idx) {
+			resp->extent[total_ret].start_dpa =
+						cpu_to_le64(ext->dpa_start);
+			resp->extent[total_ret].length =
+						cpu_to_le64(ext->length);
+			memcpy(&resp->extent[total_ret].uuid, ext->uuid,
+					sizeof(resp->extent[total_ret]));
+			total_ret++;
+		}
+	}
+
+	resp->returned_extent_count = cpu_to_le32(total_ret);
+	resp->total_extent_count = cpu_to_le32(total_avail);
+	resp->generation_num = cpu_to_le32(mdata->dc_ext_generation);
+
+	dev_dbg(dev, "Returning %d extents of %d total\n",
+		total_ret, total_avail);
+
+	return 0;
+}
+
+static void dc_clear_sent(struct device *dev)
+{
+	struct cxl_mockmem_data *mdata = dev_get_drvdata(dev);
+	struct cxl_extent_data *ext;
+	unsigned long index;
+
+	lockdep_assert_held(&mdata->ext_lock);
+
+	/* Any extents not accepted must be cleared */
+	xa_for_each(&mdata->dc_sent_extents, index, ext) {
+		dev_dbg(dev, "Host rejected extent %#llx\n", ext->dpa_start);
+		xa_erase(&mdata->dc_sent_extents, ext->dpa_start);
+	}
+}
+
+static int mock_add_dc_response(struct device *dev,
+				struct cxl_mbox_cmd *cmd)
+{
+	struct cxl_mockmem_data *mdata = dev_get_drvdata(dev);
+	struct cxl_mbox_dc_response *req = cmd->payload_in;
+	u32 list_size = le32_to_cpu(req->extent_list_size);
+
+	guard(mutex)(&mdata->ext_lock);
+	for (int i = 0; i < list_size; i++) {
+		u64 start = le64_to_cpu(req->extent_list[i].dpa_start);
+		u64 length = le64_to_cpu(req->extent_list[i].length);
+		int rc;
+
+		rc = dc_accept_extent(dev, start, length);
+		if (rc)
+			return rc;
+	}
+
+	dc_clear_sent(dev);
+	return 0;
+}
+
+static void dc_delete_extent(struct device *dev, unsigned long long start,
+			     unsigned long long length)
+{
+	struct cxl_mockmem_data *mdata = dev_get_drvdata(dev);
+	unsigned long long end = start + length;
+	struct cxl_extent_data *ext;
+	unsigned long index;
+
+	dev_dbg(dev, "Deleting extent at %#llx len:%#llx\n", start, length);
+
+	guard(mutex)(&mdata->ext_lock);
+	xa_for_each(&mdata->dc_fm_extents, index, ext) {
+		u64 extent_end = ext->dpa_start + ext->length;
+
+		/*
+		 * Any extent which 'touches' the released delete range will be
+		 * removed.
+		 */
+		if ((start <= ext->dpa_start && ext->dpa_start < end) ||
+		    (start <= extent_end && extent_end < end))
+			xa_erase(&mdata->dc_fm_extents, ext->dpa_start);
+	}
+
+	/*
+	 * If the extent was accepted let it be for the host to drop
+	 * later.
+	 */
+}
+
+static int release_accepted_extent(struct device *dev, u64 start, u64 length)
+{
+	struct cxl_mockmem_data *mdata = dev_get_drvdata(dev);
+	struct cxl_extent_data *ext;
+
+	guard(mutex)(&mdata->ext_lock);
+	ext = find_create_ext(dev, &mdata->dc_accepted_exts, start, length);
+	if (!ext) {
+		dev_err(dev, "Extent %#llx not in accepted state\n", start);
+		return -EINVAL;
+	}
+	xa_erase(&mdata->dc_accepted_exts, ext->dpa_start);
+	mdata->dc_ext_generation++;
+
+	return 0;
+}
+
+static int mock_dc_release(struct device *dev,
+			   struct cxl_mbox_cmd *cmd)
+{
+	struct cxl_mbox_dc_response *req = cmd->payload_in;
+	u32 list_size = le32_to_cpu(req->extent_list_size);
+
+	for (int i = 0; i < list_size; i++) {
+		u64 start = le64_to_cpu(req->extent_list[i].dpa_start);
+		u64 length = le64_to_cpu(req->extent_list[i].length);
+
+		dev_dbg(dev, "Extent %#llx released by host\n", start);
+		release_accepted_extent(dev, start, length);
+	}
+
+	return 0;
+}
+
 static int cxl_mock_mbox_send(struct cxl_mailbox *cxl_mbox,
 			      struct cxl_mbox_cmd *cmd)
 {
@@ -1673,6 +2137,18 @@ static int cxl_mock_mbox_send(struct cxl_mailbox *cxl_mbox,
 	case CXL_MBOX_OP_GET_SUPPORTED_FEATURES:
 		rc = mock_get_supported_features(mdata, cmd);
 		break;
+	case CXL_MBOX_OP_GET_DC_CONFIG:
+		rc = mock_get_dc_config(dev, cmd);
+		break;
+	case CXL_MBOX_OP_GET_DC_EXTENT_LIST:
+		rc = mock_get_dc_extent_list(dev, cmd);
+		break;
+	case CXL_MBOX_OP_ADD_DC_RESPONSE:
+		rc = mock_add_dc_response(dev, cmd);
+		break;
+	case CXL_MBOX_OP_RELEASE_DC:
+		rc = mock_dc_release(dev, cmd);
+		break;
 	case CXL_MBOX_OP_GET_FEATURE:
 		rc = mock_get_feature(mdata, cmd);
 		break;
@@ -1755,6 +2231,10 @@ static int cxl_mock_mem_probe(struct platform_device *pdev)
 		return -ENOMEM;
 	dev_set_drvdata(dev, mdata);
 
+	rc = cxl_mock_dc_partition_setup(dev);
+	if (rc)
+		return rc;
+
 	mdata->lsa = vmalloc(LSA_SIZE);
 	if (!mdata->lsa)
 		return -ENOMEM;
@@ -1812,6 +2292,9 @@ static int cxl_mock_mem_probe(struct platform_device *pdev)
 	if (rc)
 		return rc;
 
+	if (cxl_dcd_supported(mds))
+		cxl_configure_dcd(mds, &range_info);
+
 	rc = cxl_dpa_setup(cxlds, &range_info);
 	if (rc)
 		return rc;
@@ -1936,11 +2419,281 @@ static ssize_t sanitize_timeout_store(struct device *dev,
 
 static DEVICE_ATTR_RW(sanitize_timeout);
 
+/* Return if the proposed extent would break the test code */
+static bool new_extent_valid(struct device *dev, size_t new_start,
+			     size_t new_len)
+{
+	struct cxl_mockmem_data *mdata = dev_get_drvdata(dev);
+	struct cxl_extent_data *extent;
+	size_t new_end, i;
+
+	if (!new_len)
+		return false;
+
+	new_end = new_start + new_len;
+
+	dev_dbg(dev, "New extent %zx-%zx\n", new_start, new_end);
+
+	guard(mutex)(&mdata->ext_lock);
+	dev_dbg(dev, "Checking extents starts...\n");
+	xa_for_each(&mdata->dc_fm_extents, i, extent) {
+		if (extent->dpa_start == new_start)
+			return false;
+	}
+
+	dev_dbg(dev, "Checking sent extents starts...\n");
+	xa_for_each(&mdata->dc_sent_extents, i, extent) {
+		if (extent->dpa_start == new_start)
+			return false;
+	}
+
+	dev_dbg(dev, "Checking accepted extents starts...\n");
+	xa_for_each(&mdata->dc_accepted_exts, i, extent) {
+		if (extent->dpa_start == new_start)
+			return false;
+	}
+
+	return true;
+}
+
+struct cxl_test_dcd {
+	uuid_t id;
+	struct cxl_event_dcd rec;
+} __packed;
+
+struct cxl_test_dcd dcd_event_rec_template = {
+	.id = CXL_EVENT_DC_EVENT_UUID,
+	.rec = {
+		.hdr = {
+			.length = sizeof(struct cxl_test_dcd),
+		},
+	},
+};
+
+static int log_dc_event(struct cxl_mockmem_data *mdata, enum dc_event type,
+			u64 start, u64 length, const char *tag_str, bool more)
+{
+	struct device *dev = mdata->mds->cxlds.dev;
+	struct cxl_test_dcd *dcd_event;
+
+	dev_dbg(dev, "mock device log event %d\n", type);
+
+	dcd_event = devm_kmemdup(dev, &dcd_event_rec_template,
+				     sizeof(*dcd_event), GFP_KERNEL);
+	if (!dcd_event)
+		return -ENOMEM;
+
+	dcd_event->rec.flags = 0;
+	if (more)
+		dcd_event->rec.flags |= CXL_DCD_EVENT_MORE;
+	dcd_event->rec.event_type = type;
+	dcd_event->rec.extent.start_dpa = cpu_to_le64(start);
+	dcd_event->rec.extent.length = cpu_to_le64(length);
+	memcpy(dcd_event->rec.extent.uuid, tag_str,
+	       min(sizeof(dcd_event->rec.extent.uuid),
+		   strlen(tag_str)));
+
+	mes_add_event(mdata, CXL_EVENT_TYPE_DCD,
+		      (struct cxl_event_record_raw *)dcd_event);
+
+	/* Fake the irq */
+	cxl_mem_get_event_records(mdata->mds, CXLDEV_EVENT_STATUS_DCD);
+
+	return 0;
+}
+
+static void mark_extent_sent(struct device *dev, unsigned long long start)
+{
+	struct cxl_mockmem_data *mdata = dev_get_drvdata(dev);
+	struct cxl_extent_data *ext;
+
+	guard(mutex)(&mdata->ext_lock);
+	ext = xa_erase(&mdata->dc_fm_extents, start);
+	if (xa_insert(&mdata->dc_sent_extents, ext->dpa_start, ext, GFP_KERNEL))
+		dev_err(dev, "Failed to mark extent %#llx sent\n", ext->dpa_start);
+}
+
+/*
+ * Format <start>:<length>:<tag>:<more_flag>
+ *
+ * start and length must be a multiple of the configured partition block size.
+ * Tag can be any string up to 16 bytes.
+ *
+ * Extents must be exclusive of other extents
+ *
+ * If the more flag is specified it is expected that an additional extent will
+ * be specified without the more flag to complete the test transaction with the
+ * host.
+ */
+static ssize_t __dc_inject_extent_store(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t count,
+					bool shared)
+{
+	struct cxl_mockmem_data *mdata = dev_get_drvdata(dev);
+	unsigned long long start, length, more;
+	char *len_str, *uuid_str, *more_str;
+	size_t buf_len = count;
+	int rc;
+
+	char *start_str __free(kfree) = kstrdup(buf, GFP_KERNEL);
+	if (!start_str)
+		return -ENOMEM;
+
+	len_str = strnchr(start_str, buf_len, ':');
+	if (!len_str) {
+		dev_err(dev, "Extent failed to find len_str: %s\n", start_str);
+		return -EINVAL;
+	}
+
+	*len_str = '\0';
+	len_str += 1;
+	buf_len -= strlen(start_str);
+
+	uuid_str = strnchr(len_str, buf_len, ':');
+	if (!uuid_str) {
+		dev_err(dev, "Extent failed to find uuid_str: %s\n", len_str);
+		return -EINVAL;
+	}
+	*uuid_str = '\0';
+	uuid_str += 1;
+
+	more_str = strnchr(uuid_str, buf_len, ':');
+	if (!more_str) {
+		dev_err(dev, "Extent failed to find more_str: %s\n", uuid_str);
+		return -EINVAL;
+	}
+	*more_str = '\0';
+	more_str += 1;
+
+	if (kstrtoull(start_str, 0, &start)) {
+		dev_err(dev, "Extent failed to parse start: %s\n", start_str);
+		return -EINVAL;
+	}
+
+	if (kstrtoull(len_str, 0, &length)) {
+		dev_err(dev, "Extent failed to parse length: %s\n", len_str);
+		return -EINVAL;
+	}
+
+	if (kstrtoull(more_str, 0, &more)) {
+		dev_err(dev, "Extent failed to parse more: %s\n", more_str);
+		return -EINVAL;
+	}
+
+	if (!new_extent_valid(dev, start, length))
+		return -EINVAL;
+
+	rc = devm_add_fm_extent(dev, start, length, uuid_str, shared);
+	if (rc) {
+		dev_err(dev, "Failed to add extent DPA:%#llx LEN:%#llx; %d\n",
+			start, length, rc);
+		return rc;
+	}
+
+	mark_extent_sent(dev, start);
+	rc = log_dc_event(mdata, DCD_ADD_CAPACITY, start, length, uuid_str, more);
+	if (rc) {
+		dev_err(dev, "Failed to add event %d\n", rc);
+		return rc;
+	}
+
+	return count;
+}
+
+static ssize_t dc_inject_extent_store(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf, size_t count)
+{
+	return __dc_inject_extent_store(dev, attr, buf, count, false);
+}
+static DEVICE_ATTR_WO(dc_inject_extent);
+
+static ssize_t dc_inject_shared_extent_store(struct device *dev,
+					     struct device_attribute *attr,
+					     const char *buf, size_t count)
+{
+	return __dc_inject_extent_store(dev, attr, buf, count, true);
+}
+static DEVICE_ATTR_WO(dc_inject_shared_extent);
+
+static ssize_t __dc_del_extent_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count,
+				     enum dc_event type)
+{
+	struct cxl_mockmem_data *mdata = dev_get_drvdata(dev);
+	unsigned long long start, length;
+	char *len_str;
+	int rc;
+
+	char *start_str __free(kfree) = kstrdup(buf, GFP_KERNEL);
+	if (!start_str)
+		return -ENOMEM;
+
+	len_str = strnchr(start_str, count, ':');
+	if (!len_str) {
+		dev_err(dev, "Failed to find len_str: %s\n", start_str);
+		return -EINVAL;
+	}
+	*len_str = '\0';
+	len_str += 1;
+
+	if (kstrtoull(start_str, 0, &start)) {
+		dev_err(dev, "Failed to parse start: %s\n", start_str);
+		return -EINVAL;
+	}
+
+	if (kstrtoull(len_str, 0, &length)) {
+		dev_err(dev, "Failed to parse length: %s\n", len_str);
+		return -EINVAL;
+	}
+
+	dc_delete_extent(dev, start, length);
+
+	if (type == DCD_FORCED_CAPACITY_RELEASE)
+		dev_dbg(dev, "Forcing delete of extent %#llx len:%#llx\n",
+			start, length);
+
+	rc = log_dc_event(mdata, type, start, length, "", false);
+	if (rc) {
+		dev_err(dev, "Failed to add event %d\n", rc);
+		return rc;
+	}
+
+	return count;
+}
+
+/*
+ * Format <start>:<length>
+ */
+static ssize_t dc_del_extent_store(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t count)
+{
+	return __dc_del_extent_store(dev, attr, buf, count,
+				     DCD_RELEASE_CAPACITY);
+}
+static DEVICE_ATTR_WO(dc_del_extent);
+
+static ssize_t dc_force_del_extent_store(struct device *dev,
+					 struct device_attribute *attr,
+					 const char *buf, size_t count)
+{
+	return __dc_del_extent_store(dev, attr, buf, count,
+				     DCD_FORCED_CAPACITY_RELEASE);
+}
+static DEVICE_ATTR_WO(dc_force_del_extent);
+
 static struct attribute *cxl_mock_mem_attrs[] = {
 	&dev_attr_security_lock.attr,
 	&dev_attr_event_trigger.attr,
 	&dev_attr_fw_buf_checksum.attr,
 	&dev_attr_sanitize_timeout.attr,
+	&dev_attr_dc_inject_extent.attr,
+	&dev_attr_dc_inject_shared_extent.attr,
+	&dev_attr_dc_del_extent.attr,
+	&dev_attr_dc_force_del_extent.attr,
 	NULL
 };
 ATTRIBUTE_GROUPS(cxl_mock_mem);

-- 
2.49.0


